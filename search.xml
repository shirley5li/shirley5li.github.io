<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博文集锦]]></title>
    <url>%2F2017%2F12%2F27%2Fgood-blog-post%2F</url>
    <content type="text"><![CDATA[以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。 浏览器浏览器内部工作原理]]></content>
      <categories>
        <category>bolgPost</category>
      </categories>
      <tags>
        <tag>blogPost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程（3）学习笔记]]></title>
    <url>%2F2017%2F12%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[JavaScript学习笔记。 模仿块级作用域JS没有块级作用域，即在块语句中定义的变量，实际是在包含函数中创建的，而非在块语句中创建的。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 在Java、C++等语言中，for循环中定义的变量i只存在于for循环语句块中，循环一旦结束，变量i就会被销毁。而在JS中，变量i是定义在outputNumbers()这个包含函数的活动对象中的，因此从它被定义开始，就可以在函数内部随处访问它。 即使在一个函数中重新声明同一个变量，也不会改变它的值。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } var i; console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 JS不会提醒是否多次声明了同一个变量，在此情况下，它对后续重复的变量声明视而不见，但会执行后续声明中的变量初始化。可以通过匿名函数模仿块级作用域来避免多次声明同一个变量的问题。 用作块级作用域（私有作用域）的匿名函数语法如下： (function() { //这里为块级作用域 })(); 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。使用私有作用域如下： function outputNumbers(count) { (function() { for( var i = 0; i &lt; count; i++) { console.log(i); } })(); console.log(i);//导致一个错误！！！ } 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 私有变量严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的。但有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部无法访问这些变量，包括函数参数、局部变量、在函数中定义的其他函数。 把有权访问上述私有变量和私有函数的公有方法称为特权方法，有两种在对象上创建特权方法的方式。 第一种：在构造函数中定义特权方法，基本模式如下 function MyObject() { //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //特权方法 this.publicMethod = function() { privateVariable++; return privateFunction(); }; } 能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。 在创建构造函数实例后，除了使用特权方法，没有其他方式可以直接访问构造函数内部的私有变量和私有函数。 利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。 在构造函数中定义特权方法的缺点，就是必须使用构造函数模式来实现特权方法，而构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这一问题。 第二种：使用静态私有变量实现特权方法 通过在私有作用域中定义私有变量或函数，也可以创建特权方法。基本模式如下： (function() }{ //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //构造函数 MyObject = function() { }; //公有方法/特权方法 MyObject.prototype.publicMethod = function() { privateVariable++; return privateFunction(); }; })(); 公有方法是在构造函数原型上定义的，体现了典型的原型模式。注意：该模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，并不是我们想要的，因此也没有使用关键字var声明MyObject。初始化未经声明的变量，总会创建一个全局变量，因此MyObject就变成了一个全局变量，能够在私有作用域之外被访问到。但在严格模式下，给未经声明的变量赋值会导致错误。 该模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数由实例共享，在一个实例上调用公有方法，会影响所有实例。以该方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。因此选择使用实例变量，还是静态私有变量，视具体需求而定。 BOM-window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的global对象。 全局作用域所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例如： var age = 29; function sayAge() { alert(this.age); } alert(window.age); //29 sayAge(); //29 window.sayAge(); //29 全局变量会变为window对象的属性，定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记01]]></title>
    <url>%2F2017%2F12%2F08%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-ing%2F</url>
    <content type="text"><![CDATA[AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。 AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。Angular可以帮助你组织JavaScript代码，可以创建响应式网站（会对用户的请求产生快速的反应），Angular可以和JQuery很好的协调、方便测试（搭建可维护的应用）。 简单的解释Angular就是一个可以给HTML加上互动性的客户端JS框架。 关于传统网页请求和AngularJS网页请求之间的区别，参见博客AngularJS系列——简介。 AngularJS简介AngularJS 通过 ng-directives 扩展了 HTML。 ng-app 指令定义一个 AngularJS 应用程序。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序变量。 ng-bind 指令把应用程序数据绑定到 HTML 视图。 例如： &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;h1&gt;Hello {{name}}&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者”。ng-model 指令把输入域的值绑定到应用程序变量 name。ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。 AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素&quot;背后&quot;添加代码。 AngularJS 支持输入验证。 表达式AngularJS 使用表达式把数据绑定到 HTML。 AngularJS 表达式写在双大括号内：。AngularJS表达式很像JavaScript表达式：它们可以包含文字、运算符和变量。 &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;我的第一个表达式: {{ 5 + 5 }}&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： {{ quantity * cost }}&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： &lt;span ng-bind=&quot;quantity * cost&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS表达式与JavaScript表达式比较 类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。 指令AngularJS 通过指令新属性来扩展 HTML，指令带有前缀 ng-。 AngularJS 通过内置的指令来为应用添加功能，允许自定义指令。 ng-app 指令初始化一个 AngularJS 应用程序。 ng-init 指令初始化应用程序数据。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。 ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素 例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&apos;John&apos;&quot;&gt; &lt;p&gt;在输入框中尝试输入：&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt; &lt;p&gt;你输入的为： {{ firstName }}&lt;/p&gt; &lt;/div&gt; 使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive。 &lt;body ng-app=&quot;myApp&quot;&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; &lt;/body&gt; 你可以通过以下方式来调用指令：元素名、属性、类名、注释。 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; &lt;!-- directive: runoob-directive --&gt; AngularJS模型 ng-model指令ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript高级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F26%2FfreeCodeCamp-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS高级算法编程例题的学习总结。 Validate US Telephone Numbers题目：如果传入字符串是一个有效的美国电话号码，则返回 true. 用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法): 555-555-5555 (555)555-5555 (555) 555-5555 555 555 5555 5555555555 1 555 555 5555 在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false. tips:RegExp 实现 function telephoneCheck(str) { //^1?表示以1开头，1匹配0次或1次 //\s?表示空白字符匹配0次或1次 //\d{3}匹配一个0-9的数字三次 //\(\d{3}\)匹配（一个0-9的数字三次），比上面多一个括号，左右括号分别需要加上转义字符\ //[ -]?表示空格或者连字符-匹配0次或1次 //\d{4}$表示已4位数字结尾($) var re=/^1?\s?(\d{3}|\(\d{3}\))[ -]?\d{3}[ -]?\d{4}$/; return re.test(str); } telephoneCheck(&quot;1 555)555-5555&quot;);//返回false Symmetric Difference题目：创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组. 给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). tips:Array.reduce() 实现 function sym(args) { //将多个参数合并为一个数组arr var arr = []; for(var i = 0; i &lt; arguments.length; i++) { arr.push(arguments[i]); } //也可以使用Array.from()将输入参数合并为一个数组 //var arr = Array.from(arguments); //temp为所有项都没同时出现在两个相邻数组的数组，但temp内部可能有重复元素，因为单个数组内部可能元素重复 //pre是前一个数组，cur是当前数组 var temp = arr.reduce(function(prev, cur, index) { //a数组由prev数组在cur中没有出现过的元素组成 var a = prev.filter(function(item) { return cur.indexOf(item) &lt; 0; }); //b数组由cur数组在prev中没有出现过的元素组成 var b = cur.filter(function(item){ return prev.indexOf(item) &lt; 0; }); //合并a和b作为新的prev return a.concat(b); }); //对temp去重 return temp.filter(function(item, index, array){ return array.indexOf(item) == index; }); } sym([1, 2, 3], [5, 2, 1, 4]); Exact Change题目：设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数. cid 是一个二维数组，存着当前可用的找零. 当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”.否则, 返回应找回的零钱列表,且由大到小存在二维数组中. tips:Global Object 思路：输入为商品价格，实际付款，收银机零钱的余额。然后返回值有三种，如果找不开返回”Insufficient Funds”；如果正好找开，收银机余额空了，返回”Closed”；其余则返回找零的数组。 先将美元的各面额存入数组，对面额数组由大到小遍历，如果待找零钱大于该面额且该面额在收银机中存在的话，则进行该面额的找零操作，否则进入下一面额的找零操作。本面额的找零操作过程为：先根据待找零钱计算出该面额需要的张数，如果待找零钱&gt;=该面额的总值，则将该面额的钱全部给出，然后待找零钱更新，将该面额的找零结果输出；如果待找零钱小于该面额的总值，则从该面额总值中给出需要找出的那几张，然后更新待找零钱，输出该面额的找零结果。 实现 function checkCashRegister(price, cash, cid) { var change = cash - price;//待找零钱数目 var denominationArr = [0.01, 0.05, 0.1, 0.25, 1, 5, 10, 20, 100];//将不同面额存入数组，对应于cid[i][0] var total = 0;//用来记录收银机总共的零钱数 var money = change;//将待找零钱数change备份，因为下面找零过程中会更新change var resultArr = [];//用来输出找零列表 //从大面额到小面额遍历 for(var i = cid.length - 1; i &gt;= 0; i--) { total += cid[i][1];//记录收银机的总钱数 //如果待找零钱大于等于某个面额，并且该面额的钱数大于0，则需要给出该面额的零钱 if(change &gt; denominationArr[i] &amp;&amp; cid[i][1] &gt; 0) {//denominationArr[i] 表示第i种面额钱的面值，cid[i][1]表示收银机中该面额的总额 //num表示需要给出的该面额的数量 var num = parseInt(change / denominationArr[i]); //如果change需要的第i种面额的钱数大于等于收银机中该面额的实际钱数，则将收银机中该面额的钱全部给出,更新change和resultArr if(denominationArr[i] * num &gt;= cid[i][1]) { change -= cid[i][1]; resultArr.push(cid[i]); } else { //否则change需要的第i种面额的钱小于收银机中该面额的实际钱数，则找出change需要的该面额数目，更新change和resultArr change -= denominationArr[i] * num; resultArr.push([cid[i][0], denominationArr[i] * num]); } //操作过程中会使得change变为一个无限小数，因此使用.toFixed(2)方法保留两位小数 change = change.toFixed(2);//四舍五入保留两位小数 } } //如果收银机中的总钱数正好等于待找零钱数，返回&quot;Closed&quot; if(total=== money) { return &quot;Closed&quot;; } //如果收银机中的总钱数不够找，或者不能正好找整即change不能最后更新到0，则返回&quot;Insufficient Funds&quot; else if(total &lt; money || (change-0) !== 0) { //使用(cahnge-0)将0.00转化为0 return &quot;Insufficient Funds&quot;; } return resultArr; } checkCashRegister(3.26, 100.00, [[&quot;PENNY&quot;, 1.01], [&quot;NICKEL&quot;, 2.05], [&quot;DIME&quot;, 3.10], [&quot;QUARTER&quot;, 4.25], [&quot;ONE&quot;, 90.00], [&quot;FIVE&quot;, 55.00], [&quot;TEN&quot;, 20.00], [&quot;TWENTY&quot;, 60.00], [&quot;ONE HUNDRED&quot;, 100.00]]); //返回[[&quot;TWENTY&quot;, 60.00], [&quot;TEN&quot;, 20.00], [&quot;FIVE&quot;, 15], [&quot;ONE&quot;, 1], [&quot;QUARTER&quot;, 0.50], [&quot;DIME&quot;, 0.20], [&quot;PENNY&quot;, 0.04]] 注意： js计算浮点数精度不准确容易导致一些小问题，老是有几个测试例子通不过，使用.toFixed(2)方法四舍五入保留两位小数，但该方法也不严谨。具体见博客关于js浮点数计算精度不准确问题的解决办法。 另外由于change = change.toFixed(2)，使得找零完毕后change=&quot;0.00&quot;，因此使用(cahnge-0)将0.00转化为0，否则使用严格不等change！==0是错误的，因为0.00和0不完全相等。当然若不使用 (change-0) !== 0，也可以使用不严格不等change != 0。 Inventory Update题目：依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列. tips:Global Array Object 实现 function updateInventory(arr1, arr2) { //将现有库存的货物名称存入数组curGoodsArr var curGoodsArr = []; for(var i = 0; i &lt; arr1.length; i++) { curGoodsArr.push(arr1[i][1]); } for(var j = 0; j &lt; arr2.length; j++) { //若现有库存中没有新进货物类型，则将新货物名称和数量一并添加到库存数组，名称需按字母顺序排序 //将新货物名称追加到数组curGoodsArr,再对数组排序。sort()方法在原数组上排序，不生成副本 if(curGoodsArr.indexOf(arr2[j][1]) === -1) { //注意push()方法可向数组的末尾添加一个或多个元素，返回新的长度。注意是长度，不是返回新的数组！！！ curGoodsArr.push(arr2[j][1]); //给货物名称按字母排序 curGoodsArr.sort(); //找到该新货物名称在排序后出现在curGoodsArr数组中的索引，该索引值也是新货物应该出现在库存数组中的顺序 var indexNewGoods = curGoodsArr.indexOf(arr2[j][1]); //将新货物名称和数量一并插入到库存数组,使用.splice()方法,该方法会改变原始数组 arr1.splice(indexNewGoods, 0, [arr2[j][0], arr2[j][1]]); } //如果现有库存货物中已经新进货物的类型，则更新库存数量 else { //index为已有货物在库存货物名称数组中的索引，也即货物在库存数组中出现的顺序 var index = curGoodsArr.indexOf(arr2[j][1]); //更新库存数量，即等于原来的库存数量+新进的数量 arr1[index][0] =arr1[index][0] + arr2[j][0]; } } return arr1; } // 仓库库存示例 var curInv = [ [21, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [1, &quot;Hair Pin&quot;], [5, &quot;Microphone&quot;] ]; var newInv = [ [2, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [67, &quot;Bowling Ball&quot;], [7, &quot;Toothpaste&quot;] ]; updateInventory(curInv, newInv);//返回[[88, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [3, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [5, &quot;Microphone&quot;], [7, &quot;Toothpaste&quot;]] No repeats please题目：把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准。 例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a). 考察全排列 tips:Permutations RegExp 全排列算法原理和实现 实现 //求一个字符串的全排列字符串中，不含连续重复字符的字符串个数 function permAlone(str) { //将输入字符串转化为数组 strArr = str.split(&quot;&quot;); //求该字符串数组的全排列形式 permResultArr = []; perm(strArr, 0, strArr.length-1); //找出全排列后非连续重复的字符串个数 var count = 0; for(var i = 0; i &lt; permResultArr.length; i++) { if(conRepCharacter(permResultArr[i])) { count += 1; } } return count; } //判断一个字符串是否含连续重复的字符，若不包含连续重复字符，则返回true function conRepCharacter(str) { if(str.length === 1) { return true; } for(var i = 0; i &lt; str.length-1; i++) { if(str[i+1] === str[i]) { return false; } } return true; } //交换数组中两个字符的位置 function swapCharacter(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } //求给定字符串数组的全排列,其中strArr表示输入字符串转化成的数组，flag表示递归到哪一位，end表示递归结束的位即字符串长度减1 function perm(strArr, flag, end) { //递归结束输出结果 if(flag === end) { permResultArr.push(strArr.join(&quot;&quot;)); } for(var i = flag; i &lt;= end; i++) { //将字符串中的所有字母分别与第一个字母交换 strArr = swapCharacter(strArr, flag, i); //对交换后的字符串继续递归排列，由于第一个字母已经排列，因此从一个字母开始排列，即flag+1 perm(strArr, flag+1, end); //由于在进入到下一次循环时序列是被改变了，可如果要假定第一个字母的所有可能性的话，必须是建立在这些序列的初始状态一致的情况下 //因此通过再次交换恢复之前的排列顺序 strArr = swapCharacter(strArr, flag, i); } return permResultArr; } permAlone(&quot;abc&quot;);//返回6 Friendly Date Ranges题目：把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1). 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了；在这种情况下，如果月份开始和结束日期如果在同一个月，则结束日期月份也不用写了。另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。 例如:包含当前年份和相同月份的时候，makeFriendlyDates([“2017-01-02”, “2017-01-05”]) 应该返回 [“January 2nd”,”5th”]。不包含当前年份，makeFriendlyDates([“2003-08-15”, “2009-09-21”]) 应该返回 [“August 15th, 2003”, “September 21st, 2009”]。 考虑清楚所有可能出现的情况，包括传入的日期区间是否合理。对于不合理的日期区间，直接返回 undefined 即可。 tips:String.split() String.substr() parseInt() 实现 function makeFriendlyDates(arr) { var resultArr = []; //开始日期数组 var startArr = arr[0].split(&quot;-&quot;); //结束日期数组 var endArr = arr[1].split(&quot;-&quot;); //开始日期的年月日 var sYear = parseInt(startArr[0], 10); var sMonth = parseInt(startArr[1], 10); var sDay = parseInt(startArr[2], 10); //结束日期的年月日 var eYear = parseInt(endArr[0], 10); var eMonth = parseInt(endArr[1], 10); var eDay = parseInt(endArr[2], 10); //开始日期与结束日期之间相差的天数 var distDays = (eYear-sYear)*365 + (eMonth-sMonth)*30 + eDay-sDay; //获取当前日期的年份 var currDate = new Date(); var currYear = currDate.getFullYear(); //月份字符串数组 var monthsArr = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]; //日字符串数组 var daysArr = [&quot;1st&quot;,&quot;2nd&quot;,&quot;3rd&quot;,&quot;4th&quot;,&quot;5th&quot;,&quot;6th&quot;,&quot;7th&quot;,&quot;8th&quot;,&quot;9th&quot;,&quot;10th&quot;,&quot;11th&quot;,&quot;12th&quot;,&quot;13th&quot;,&quot;14th&quot;,&quot;15th&quot;,&quot;16th&quot;,&quot;17th&quot;,&quot;18th&quot;,&quot;19th&quot;,&quot;20th&quot;,&quot;21st&quot;,&quot;22nd&quot;,&quot;23rd&quot;,&quot;24th&quot;,&quot;25th&quot;,&quot;26th&quot;,&quot;27th&quot;,&quot;28th&quot;,&quot;29th&quot;,&quot;30th&quot;,&quot;31st&quot;]; //先判断日期区间是否合理,若不合理返回undefined if(distDays &lt; 0) { return &quot;undefined&quot;; } //如果开始日期和结束日期一样，则返回一个 if(sYear === eYear &amp;&amp; sMonth === eMonth &amp;&amp; sDay === eDay) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期如果在同一个月，则开始日期年份、结束日期年份和月份也不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot;+ daysArr[sDay-1], daysArr[eDay-1]]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则开始日期年份、结束日期年份不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth !== eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1], monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期在同一个月,则结束日期年份和月份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear === eYear &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则结束日期年份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear !== eYear &amp;&amp; distDays &gt; 30) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差大于等于一年 if(distDays &gt;= 365) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1] + &quot;, &quot; + eYear]; return resultArr; } } makeFriendlyDates([&quot;2001-12-20&quot;, &quot;2001-12-20&quot;]);//返回[&quot;December 20th, 2001&quot;] Make a Person题目：用下面给定的方法构造一个对象. 方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast). 所有有参数的方法只接受一个字符串参数.所有的方法只与实体对象交互. tips:Closures Details of the Object Model 实现 var Person = function(firstAndLast) { this.getFirstName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[0]; }; this.getLastName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[1]; }; this.getFullName = function() { return firstAndLast; }; this.setFirstName = function(first) { var arr = firstAndLast.split(&quot; &quot;); arr[0] = first; firstAndLast = arr.join(&quot; &quot;); }; this.setLastName = function(last) { var arr = firstAndLast.split(&quot; &quot;); arr[1] = last; firstAndLast = arr.join(&quot; &quot;); }; this.setFullName = function(firstAndLast2) { firstAndLast = firstAndLast2; }; }; var bob = new Person(&apos;Bob Ross&apos;); bob.getFirstName();//返回&quot;Bob&quot; Map the Debris题目：返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期.原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}. 求得的值应该是一个与其最接近的整数，轨道是以地球为基准的. 地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI tips:Math.pow() Math.round() 实现 function orbitalPeriod(arr) { var GM = 398600.4418; var earthRadius = 6367.4447; //轨道周期公式 T=2π√(a^3/GM) for(var i = 0; i &lt; arr.length; i++) { //a为轨道半径，等于地球半径加平均海拔 var a = earthRadius + arr[i].avgAlt; var T1 = Math.sqrt(4 * Math.pow(Math.PI, 2) * Math.pow(a, 3) / GM); //将求得的周期转化为整数 var T = Math.round(T1); //删除原有属性海拔 delete arr[i].avgAlt; //添加新的属性轨道周期 arr[i].orbitalPeriod = T; } return arr; } orbitalPeriod([{name : &quot;sputnik&quot;, avgAlt : 35873.5553}]);//返回[{name: &quot;sputnik&quot;, orbitalPeriod: 86400}] Pairwise题目：举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。 所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。 tips:Array.reduce()自己没有用上reduce()方法 实现 function pairwise(arr, arg) { var sumIndex = 0; for(var i = 0; i &lt; arr.length; i++) { //与当前元素应该配对的元素值 var pairVal = arg - arr[i]; //配对元素应有的索引值,配对元素不能为自己 var pairIndex = arr.indexOf(pairVal); //如果找到与当前元素配对的，则将这一对的索引值累加，并将当前元素和与之配对的元素值置为-1 if(pairIndex !== -1 &amp;&amp; pairIndex !== i) { arr[i] = -1; arr[pairIndex] = -1; sumIndex += i + pairIndex; } } return sumIndex; } pairwise([1, 3, 2, 4], 4);//返回1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-demos学习笔记]]></title>
    <url>%2F2017%2F11%2F20%2Freact-demos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[来自阮一峰的博客React 入门实例教程学习。 JSX语法简介React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 JSX 就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到 &lt;，JSX就当HTML解析，遇到 { 就当JavaScript解析。 JS语法 var child1 = React.createElement(&apos;li&apos;, null, &apos;First Text Content&apos;); var child2 = React.createElement(&apos;li&apos;, null, &apos;Second Text Content&apos;); var root = React.createElement(&apos;ul&apos;, { className: &apos;my-list&apos; }, child1, child2); JSX语法 var root =( &lt;ul className=&quot;my-list&quot;&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt; ); JSX将XML语法直接加入JS中,通过代码而非模板来高效的定义界面。之后JSX通过翻译器转换为纯JS再由浏览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。 另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。JSX只是创建虚拟DOM的一种语法格式而已,除了用JSX,我们也可以用JS代码来创建虚拟DOM. 一篇简要介绍JSX语法的文章深入浅出React（三）：理解JSX和组件。 HTML模板使用 React 的网页源码，结构大致如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // starts here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最后一个 标签的 type 属性为 text/babel ,因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”。 上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。 ReactDOM.render()React最基本的方法，用于将模板转为 HTML 语言，并插入到指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); 上面代码将一个 h1 标题，插入到 example 节点。代码执行结果如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;h1 data-reactroot=&quot;&quot;&gt;Hello, world!&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JSX语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。 &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function (name, index) { return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; JSX 的基本语法规则：遇到 HTML 标签（以 &lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。上述代码执行结果如下所示。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员。 var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, ]; ReactDOM.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById(&apos;example&apos;) ); 上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，结果如下。 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass() 方法就用于生成一个组件类。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; } }); ReactDOM.render( &lt;HelloMessage name=&quot;John&quot; /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，变量 HelloMessage 就是一个组件类。模板插入 时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。执行结果如下所示。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。即在组件类中通过js获取组件的class属性时，需要使用this.props.className。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt; Hello {this.props.name} &lt;/h1&gt;&lt;p&gt; //错误，包含了两个顶层标签，h1和p some text &lt;/p&gt;; } }); 上面代码会报错，因为HelloMessage组件包含了两个顶层标签：h1和p。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); } }); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body ); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。执行结果如下所示。 注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法。 PropTypes组件属性组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求。例如： var MyTitle = React.createClass({ propTypes: { title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); 上述代码中，Mytitle组件类有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。假如设置title属性的值是number类型就会报错，如下： var data = 123; ReactDOM.render( &lt;MyTitle title={data} /&gt;, document.body ); title属性就通不过验证了。控制台会显示一行警告信息，如下所示： getDefaultProps 方法可以用来设置组件属性的默认值. var MyTitle = React.createClass({ getDefaultProps : function () { return { title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 上面代码会输出”Hello World”。 获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 var MyComponent = React.createClass({ handleClick: function() { this.refs.myTextInput.focus(); }, render: function() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); } }); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，组件类 MyComponent 的子节点有一个文本输入框，用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为此，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 注意，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数 handleClick，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 。 var LikeButton = React.createClass({ getInitialState: function() { //初始状态 return {liked: false}; }, handleClick: function(event) { this.setState({liked: !this.state.liked}); }, render: function() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); } }); ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;) ); 上述组件类的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件， 调用Click 事件的回调函数 handleClick，导致状态变化。 this.setState 方法用于修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 var Input = React.createClass({ getInitialState: function() { return {value: &apos;Hello!&apos;}; }, handleChange: function(event) { this.setState({value: event.target.value}); }, render: function () { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); } }); ReactDOM.render(&lt;Input/&gt;, document.body); 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况。 组件的生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 栗子: var Hello = React.createClass({ getInitialState: function () { return { opacity: 1.0 }; }, componentDidMount: function () { this.timer = setInterval(function () { var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) { opacity = 1.0; } this.setState({ opacity: opacity }); }.bind(this), 100); }, render: function () { return ( &lt;div style={{opacity: this.state.opacity}}&gt; Hello {this.props.name} &lt;/div&gt; ); } }); ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.body ); 上述代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。执行结果如下所示： 注意：组件的style属性的设置方式也值得注意，不能写成 style=&quot;opacity:{this.state.opacity};&quot; 要写成 style={{opacity: this.state.opacity}} 这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。 var UserGist = React.createClass({ getInitialState: function() { return { username: &apos;&apos;, lastGistUrl: &apos;&apos; }; }, componentDidMount: function() { $.get(this.props.source, function(result) { var lastGist = result[0]; if (this.isMounted()) { this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); } }.bind(this)); }, render: function() { return ( &lt;div&gt; {this.state.username}&apos;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;. &lt;/div&gt; ); } }); ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;, document.body ); 上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。 我们甚至可以把一个promise对象传入组件。 ReactDOM.render( &lt;RepoList promise={$.getJSON(&apos;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&apos;)} /&gt;, document.body ); 上面代码从Github的API抓取数据，然后将promise对象作为属性，传给RepoList组件。 如果promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果promise对象报错（rejected状态），组件显示报错信息；如果promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 var RepoList = React.createClass({ getInitialState: function() { return { loading: true, error: null, data: null}; }, componentDidMount() { this.props.promise.then( value =&gt; this.setState({loading: false, data: value}), error =&gt; this.setState({loading: false, error: error})); }, render: function() { if (this.state.loading) { return &lt;span&gt;Loading...&lt;/span&gt;; } else if (this.state.error !== null) { return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;; } else { var repos = this.state.data.items; var repoList = repos.map(function (repo) { return ( &lt;li&gt; &lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description} &lt;/li&gt; ); }); return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;{repoList}&lt;/ol&gt; &lt;/main&gt; ); } } });]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript中级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F16%2FfreeCodeCamp-%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS中级算法编程例题的学习总结。 Sum All Numbers in a Range题目：传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。（最小的数字并非总在最前面。） tips: Math.max() &nbsp;Math.min()&nbsp;Array.reduce() 实现1 function sumAll(arr) { //获取两个数中的最小值 var min = Math.min(arr[0], arr[1]); //获取两个数中的最大值 var max = Math.max(arr[0], arr[1]); //将区间里的整数顺序添加到数组里 var array = []; for (i = min; i &lt; max + 1; i++) { array.push(i); } //利用.reduce()方法累加数组中的元素并返回 var total = array.reduce(function(sum,val) { return sum += val; }); return total; } sumAll([1, 4]); 实现2 function sumAll(arr) { var max = Math.max(arr[0],arr[1]); var min = Math.min(arr[0],arr[1]); var total = 0; //不使用.reduce()方法实现累加，直接使用for循环实现累加 for(var i = min; i &lt; max + 1; i++) { total += i; } return total; } Diff Two Arrays题目：比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。 tips：Comparison Operators &nbsp;Array.slice() &nbsp; Array.filter() &nbsp; Array.indexOf() &nbsp; Array.concat() 实现1 function diff(arr1, arr2) { var newArr = []; //比较两个数组大小，判断较长的数组中的每个元素是否在短数组中出现过，若没有出现过则.indexOf()方法返回-1 if (arr1.length &gt;= arr2.length) { for (i = 0; i &lt; arr1.length; i++) { if (arr2.indexOf(arr1[i]) === -1) { newArr.push(arr1[i]); } } } for (i = 0; i &lt; arr2.length; i++) { if (arr1.indexOf(arr2[i]) === -1) { newArr.push(arr2[i]); } } return newArr; } //测试，返回4 diff([1, 2, 3, 5], [1, 2, 3, 4, 5]); 实现2 function diff(arr1, arr2) { var newArr = []; var arr3 = []; for (var i=0;i&lt;arr1.length;i++) { if(arr2.indexOf(arr1[i]) === -1) arr3.push(arr1[i]); } var arr4 = []; for (var j=0;j&lt;arr2.length;j++) { if(arr1.indexOf(arr2[j]) === -1) arr4.push(arr2[j]); } newArr = arr3.concat(arr4); return newArr; } 实现1是自己的想法，只用一次for循环即可得到比较结果。实现2是看到部分博主用的方法。 Roman Numeral Converter题目：将给定的数字转换成罗马数字。 tips：Roman Numerals &nbsp; Array.splice() &nbsp; Array.indexOf() &nbsp; Array.join() 实现1 function convert(num) { //只转换小于4000的数字为罗马数字，大于4000的罗马数字上面要加横线，在此暂不考虑转换 if (num &gt;= 4000) { console.log(&quot;please convert a number less than 4000!&quot;); } //将num的各位提取出来，即num = thousands * 1000 + hundreds * 100 + tens * 10 + units; var thousands = Math.floor(num / 1000) ; var hundreds = Math.floor((num % 1000) / 100); var tens = Math.floor((num % 100) / 10); var units = num % 10; var roman = []; //当千位不为0时，将千位转化为罗马数字 while (thousands !== 0) { switch(thousands) { case 1: roman.splice(0, 0, &quot;M&quot;); break; case 2: roman.splice(0, 0, &quot;M&quot;,&quot;M&quot;); break; case 3: roman.splice(0, 0, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;); break; } thousands = 0; } // 当百位不为0时，将百位转化为罗马数字 while (hundreds !== 0) { // 记录最后一个千位罗马数字索引加一 var lastIdxT = roman.length; switch(hundreds) { case 1: roman.splice(lastIdxT, 0, &quot;C&quot;); break; case 2: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;); break; case 3: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 4: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;D&quot;); break; case 5: roman.splice(lastIdxT, 0, &quot;D&quot;); break; case 6: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;); break; case 7: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;); break; case 8: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 9: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;M&quot;); break; } hundreds = 0; } // 当十位不为0时，将十位转化为罗马数字 while(tens !== 0) { // 记录最后一个百位罗马数字索引加一 var lastIdxH = roman.length; switch(tens) { case 1: roman.splice(lastIdxH, 0, &quot;X&quot;); break; case 2: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;); break; case 3: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 4: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;L&quot;); break; case 5: roman.splice(lastIdxH, 0, &quot;L&quot;); break; case 6: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;); break; case 7: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;); break; case 8: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 9: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;C&quot;); break; } tens = 0; } // 记录最后一个十位罗马数字索引加一 var lastIdxTen = roman.length; switch(units) { case 1: roman.splice(lastIdxTen, 0, &quot;I&quot;); break; case 2: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;); break; case 3: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 4: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;V&quot;); break; case 5: roman.splice(lastIdxTen, 0, &quot;V&quot;); break; case 6: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;); break; case 7: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;); break; case 8: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 9: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;X&quot;); break; } return roman.join(&quot;&quot;); } convert(36); 实现2 function convert(num) { //将分割数和对应的罗马字符分别存入两个数组 var nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]; var romans =[&quot;m&quot;,&quot;cm&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;c&quot;,&quot;xc&quot;,&quot;l&quot;,&quot;xl&quot;,&quot;x&quot;,&quot;ix&quot;,&quot;v&quot;,&quot;iv&quot;,&quot;i&quot;]; var str = &quot;&quot;; nums.forEach(function(item,index,array){ while(num &gt;= item){ str += romans[index]; num -= item; } }); return str.toUpperCase(); } convert(36); 实现2是来自一位博主将给定的数字转换为罗马数字，代码精简易懂，自己的实现看起来冗长幼稚，需要学习的还很多哇！ Where art thou题目：写一个 function，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。 例如，如果第一个参数是 [{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]，第二个参数是 { last: &quot;Capulet&quot; }，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。 tips：Global Object&nbsp; Object.hasOwnProperty() &nbsp; Object.keys()&nbsp; Array.prototype.filter() 实现 function where(collection, source) { var arr = []; //获取source对象的所有属性名并保存在数组keys中 var keys = Object.keys(source); //filter() 方法创建一个新数组, 其包含通过所提供函数测试的所有元素,callback用来测试数组的每个元素，返回true则保留该元素 arr = collection.filter(function(element) { for(var i = 0; i &lt; keys.length; i++) { if(!element.hasOwnProperty(keys[i]) || element[keys[i]] !== source[keys[i]]) return false; } return true; }); return arr; } //返回 [{ first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }] where([{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }], { last: &quot;Capulet&quot; }); Search and Replace题目：使用给定的参数对句子执行一次查找和替换，然后返回新句子。 第一个参数是将要对其执行查找和替换的句子。 第二个参数是将被替换掉的单词（替换前的单词）。 第三个参数用于替换第二个参数（替换后的单词）。 注意：替换时保持原单词的大小写。例如，如果你想用单词 “dog” 替换单词 “Book” ，你应该替换成 “Dog”。 tips：Array.splice() String.replace() Array.join() 实现 function myReplace(str, before, after) { //获取需被替换的单词before的首字母的位置index，indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。 var index = str.indexOf(before); //判断before首字母是否为大写，若为大写，则让after首字母也大写 if(str[index]===str[index].toUpperCase()){ after = after[0].toUpperCase() + after.substring(1); //也可以用slice(1) } //替换，stringObject.replace(regexp/substr,replacement) return str.replace(before, after); } /*** 判断字母是否为大写 function isUpperCase(ch){ return ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;; } 判断字母是否为小写 function isLowerCase(ch){ return ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;; } 将单词的首字母大写 function firstUpperCase(str) { var afterStr = str.toLowerCase().replace(/^\w/g,function(s){return s.toUpperCase();}); return afterStr; } ***/ // charAt()方法可返回字符串指定位置的字符，stringObject.charAt(index) myReplace(&quot;A quick brown fox jumped over the lazy dog&quot;, &quot;jumped&quot;, &quot;leaped&quot;); Pig Latin题目：把指定的字符串翻译成 pig latin。 Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。 如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。 tips：Array.indexOf() Array.push() Array.join() String.substr() String.split() 实现1 function translate(str) { // 元音 var vowel = [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]; // 如果单词首字母以元音开头，直接在单词后面加&apos;way&apos; if(vowel.indexOf(str.substr(0,1)) !== -1) { return str + &quot;way&quot;; } /*** 只要单词是以辅音或辅音丛开始，将该辅音移到后面，最后加&apos;ay&apos;。 while循环每次都检查移动辅音后的单词，移动一个辅音字母后若还不是元音字母，继续移动，移完后再加&quot;ay&quot;***/ while(vowel.indexOf(str.substr(0,1)) == -1) { str = str.substr(1) + str.substr(0,1); } return str + &quot;ay&quot;; } translate(&quot;glove&quot;);//测试数据&quot;california&quot;，&quot;paragraphs&quot;，&quot;algorithm&quot;，&quot;eight&quot; 实现2 function translate(str) { var tempArr = []; var answer; tempArr = str.split(&apos;&apos;);//将str分解为单个字符存入数组 var i = 0; //如果首个字符不是元音则 i++，如果首个字符是元音则退出while循环 while (tempArr[i] != &apos;a&apos; &amp;&amp; tempArr[i] != &apos;o&apos; &amp;&amp; tempArr[i] != &apos;i&apos; &amp;&amp; tempArr[i] != &apos;e&apos; &amp;&amp; tempArr[i] != &apos;u&apos;) { i++; } answer = str.substr(i);//将str辅音或辅音丛后面的部分提取出来 answer += str.substr(0,i);//再将辅音或辅音丛部分追加在answer后 //i=0时，首字母为元音，在变换之后加&quot;way&quot; if(i === 0) { answer += &quot;way&quot;; } //i不为0时，首字母为辅音或辅音丛，在变换后加&quot;ay&quot; else { answer += &quot;ay&quot;; } return answer; } DNA Pairing题目：DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。 Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。 在每一个数组中将给定的字母作为第一个碱基返回。字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]] tips：Array.push() String.split() 实现1 function pair(str) { var inputArr = []; var resultArr = []; //将输入字符串按单个字母拆分为数组 inputArr = str.split(&apos;&apos;); //对输入数组的每一种情况配对，GC,CG,AT,TA inputArr.forEach(function(item, index) { switch(item) { case &quot;G&quot;: resultArr.push([&quot;G&quot;,&quot;C&quot;]); break; case &quot;C&quot;: resultArr.push([&quot;C&quot;,&quot;G&quot;]); break; case &quot;A&quot;: resultArr.push([&quot;A&quot;,&quot;T&quot;]); break; case &quot;T&quot;: resultArr.push([&quot;T&quot;,&quot;A&quot;]); break; } }); return resultArr; } pair(&quot;GCG&quot;);//返回 [[&quot;G&quot;, &quot;C&quot;], [&quot;C&quot;,&quot;G&quot;],[&quot;G&quot;, &quot;C&quot;]] 实现2和实现3来自博客。 实现2 解题思路：把字符串进行匹配和对应关系进行匹配，将匹配到的字符推入该数组。最后将所有的数组推入一个新的数组。 匹配方式：用对象存储对应关系。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; var arr = []; for(var i in str){ arr.push([str[i],obj[str[i]]]); } return arr; } pair(&quot;GCG&quot;); 实现3 用map函数来进行优化,其实就是简化了写法。map函数可以改变原有的数组，给予指定的方法就可以了。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; //ES6 的写法 return str.split(&apos;&apos;).map(e =&gt; [e,obj[e]]); } pair(&quot;GCG&quot;); ES5 的写法 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; return str.split(&apos;&apos;).map(function(e){ return [e,obj[e]]; }); } pair(&quot;GCG&quot;); Missing letters题目：从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。 tips：String.charCodeAt() String.fromCharCode() 实现 function fearNotLetter(str) { var resultStr = &quot;&quot;; //先判断所有字母是否都在序列中,若都在则返回undefined if((str.charCodeAt(0) + str.length - 1) === str.charCodeAt(str.length - 1) ) { return undefined; } else { //若不然，则根据str每个字母的编码是否连续来返回缺失字母 for (i = 0; i &lt; str.length - 1; i++) { var startCode = str.charCodeAt(i); var nextCode = str.charCodeAt(i + 1); //如果相邻两个字母之间的编码不连续，则将两个字母之间缺失的字母追加到resultStr中 while ( nextCode - startCode !== 1) { resultStr += String.fromCharCode(startCode + 1); startCode ++; } } } return resultStr; } fearNotLetter(&quot;abce&quot;);//返回&quot;d&quot; fearNotLetter(&quot;abch&quot;);//返回&quot;defg&quot; 关于此题目的回答，比较了一些博主的答案，他们的答案大多只满足两个输入相邻字母之间只缺少一个字母的情况，对于缺失多个字母的情况没有考虑。自己的回答考虑到了两个相邻字母之间缺失多个字母的情况。 Boo who题目：检查一个值是否是基本布尔类型，并返回 true 或 false。基本布尔类型即 true 和 false。 tips:Boolean Objects 补充：5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。 1种复杂数据类型Object（包括Function、Array、Date等）。 typeof操作符返回下列某个字符串： &quot;undefined&quot;---未定义 &quot;boolean&quot;---布尔值 &quot;string&quot;---字符串 &quot;number&quot;---数值 &quot;object&quot;---对象或null &quot;function&quot;---函数 实现 function boo(bool) { //使用typeof操作符检测数据类型 return typeof(bool) === &quot;boolean&quot; ? true : false;//可直接写为 return typeof bool===&apos;boolean&apos;; } boo(null);//返回false Sorted Union题目：写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的但不包含重复值的新数组。 换句话说，新数组中的所有值都应该以原始顺序被包含在内，但是不包含重复值。即非重复的数字应该以它们原始的顺序排序。例如unite([1, 3, 2], [5, 2, 1, 4], [2, 1]) 应该返回 [1, 3, 2, 5, 4]。unite([1, 3, 2], [1, [5]], [2, [4]]) 应该返回 [1, 3, 2, [5], [4]]。 tips:Arguments object Array.reduce() 实现1 function unite(arr1, arr2, arr3) { //unite函数的输入参数类对象数组arguments for(i = 1; i &lt; arguments.length; i ++) { for (j = 0; j &lt; arguments[i].length; j ++) { //若第i个输入数组的第j个数字在第一个数组中没出现过，则追加到第一个数组中，否则什么也不做 if (arr1.indexOf(arguments[i][j]) == -1) { arr1.push(arguments[i][j]); } } } return arr1; } unite([1, 3, 2], [5, 2, 1, 4], [2, 1]);//返回[1,3,2,5,4] 实现2 思路：先将多个输入参数（数组）合并，再去重。来源于简书。 function unite(arr1, arr2, arr3) { //Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例，即返回[arr1, arr2, arr3]的形式 var args = Array.from(arguments); //reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 var arr = args.reduce(function(accumulator,cur){ //将多个输入数组合并为一个数组arr,即返回[1,3,2,5,2,1,4,2,1]的形式 return accumulator.concat(cur); }); var resultArr = []; //对合并后的数组arr去重 return resultArr = arr.filter(function(item,index){ //返回true则filter到结果数组，indexOf()方法返回第一个匹配元素的index， //后面重复元素的indexOf返回值为该元素第一次出现时的index（比如对第二个2应用indexOf返回2） return arr.indexOf(item) === index; }); } Convert HTML Entities题目：将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。 tips:RegExp HTML Entities 实现 function convert(str) { //替换规则映射对象 var entityMap = { &apos;&amp;&apos; : &apos;&amp;amp;&apos;, &apos;&lt;&apos; : &apos;&amp;lt;&apos;, &apos;&gt;&apos; : &apos;&amp;gt;&apos;, &apos;\&quot;&apos; : &apos;&amp;quot;&apos;, &apos;\&apos;&apos; : &apos;&amp;apos;&apos; , }; //使用string的replace规则，将匹配到的字符根据替换规则替换掉 return str.replace(/[&amp;&lt;&gt;&quot;&apos;]/g, function(matched) { return entityMap[matched]; }); } convert(&quot;Dolce &amp; Gabbana&quot;);//输出结果&quot;Dolce &amp;amp; Gabbana&quot; Spinal Tap Case题目：将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。 tips:RegExp String.replace() 实现 function spinalCase(str) { //将str分为两类，一类是以空格、下划线、短横线连接的字符串；一类是驼峰形式的字符串 //驼峰形式的字符串 if(str.split(/\W|_/).length === 1) { for (i = 0; i &lt; str.length; i++) { //找到所有单词的首写大写字母，并用短横线和对应小写替换 if (str[i].toUpperCase() === str[i]) { str = str.replace(str[i], &quot;-&quot;+str[i].toLowerCase()); } } } //以空格、下划线、短横线连接的字符串，先转换为小写再替换 else { //注意匹配模式加上全局标志，否则只会找到第一个匹配 str = str.toLowerCase().replace(/\W|_/g, &quot;-&quot;); } return str; } spinalCase(&apos;This Is Spinal Tap&apos;);//返回 &quot;this-is-spinal-tap&quot; spinalCase(&quot;The_Andy_Griffith_Show&quot;);//返回 &quot;the-andy-griffith-show&quot; spinalCase(&quot;Teletubbies say Eh-oh&quot;);//返回 &quot;teletubbies-say-eh-oh&quot; spinalCase(&quot;thisIsSpinalTap&quot;);//返回 &quot;this-is-spinal-tap&quot; Sum All Odd Fibonacci Numbers题目：给一个正整数num，返回小于或等于num的斐波纳契奇数之和。 斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。 例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。 提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。 tips:Remainder) 参考文档 实现 function sumFibs(num) { //先找到所有小于num的斐波那契数，并存在数组fibsArr中 var fibsArr = [1, 1, 2]; for(i = 2; i &lt; num; i++) { if (fibsArr[i] + fibsArr[i-1] &lt;= num) { fibsArr.push(fibsArr[i] + fibsArr[i-1]); } } //筛选出fibsArr中的奇数并求和 var sum = fibsArr.filter(function(element, index) { //若为奇数则返回 return element % 2 !== 0; }).reduce(function(prev, curr) { return prev += curr; }); return sum; } sumFibs(1);//返回2 Sum All Primes题目：求小于等于给定数值的质数之和。 给定的数不一定是质数。 只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。 tips:For Loops Array.push() 实现 //判断一个数是不是素数 function isPrime(num) { //判断输入是否为number类型，是否为整数 if(typeof(num) !== &apos;number&apos; || !Number.isInteger(num)) { return false; } //num小于2时，不是素数 if(num &lt; 2) {return false;} //num等于2时，是素数 if(num === 2) {return true;} //num大于2时，如果num可以被2整除（即num为偶数），不是素数 else if(num % 2 === 0) {return false;} //num大于2时，依次判断num能否被奇数整除，最大循环为num的开方 var range = Math.ceil(Math.sqrt(num)); for(var i = 3; i &lt;= range; i+=2) { if(num % i === 0) {return false;} } return true; } //求小于等于给定数值的质数之和 function sumPrimes(num) { var sum = 0; for(var i = 0; i &lt;= num; i ++) { //对于小于num的每个数先判断是否为素数，若为素数则叠加 if(isPrime(i)) { sum += i; } } return sum; } sumPrimes(977);//返回73156 Smallest Common Multiple题目：找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。 范围是两个数字构成的数组，两个数字不一定按数字顺序排序。 例如对 1 和 3 —— 找出能被 1 和 3 和它们之间所有数字整除的最小公倍数。 tips:Smallest Common Multiple 辗转相除法 思路：最小公倍数 = 两个数的积 / 最大公约数 最大公约数用辗转相除法（欧几里得算法）求得，即当 a mod b=0时，gcd(a,b)=0,否则gcd(a,b)=gcd(b,a mod b)。 求连续几个数的最小公倍数，可以先求得边界两个数的最小公倍数，再用此最小公倍数依次和中间的数值求最小公倍数，从而得到所有数的最小公倍数。 实现 function smallestCommons(arr) { //首先对两个给定参数排序,按从小到大排序 arr.sort(function(a, b) { return a - b; }); //求a和b的最小公倍数 var a = arr[0]; var b = arr[1]; //flag表示边界两个数的最小公倍数 var flag = smallestCommonMultiple(a, b); //用flag依次和中间的数值求最小公倍数，即得最终的最小公倍数 for(var i = a +1; i &lt; b; i ++) { flag = smallestCommonMultiple(flag, i); } return flag; } //欧几里得算法求两个数的最大公约数,a&lt;=b function gcd (a, b) { //当除数为零时，最大公约数为被除数a if(!b) {return a;} //否则辗转相除 return gcd(b, a%b); } //求两个数的最小公倍数 function smallestCommonMultiple(a, b) { return a * b / gcd(a, b); } smallestCommons([1,5]);//返回60 Finders Keepers题目：写一个 function，它遍历数组 arr，并返回数组中第一个满足 func 返回值的元素。举个例子，如果 arr 为 [1, 2, 3]，func 为 function(num) {return num === 2; }，那么 find 的返回值应为 2。 tips:Array.filter() 实现 function find(arr, func) { var num = 0; //注意filter()方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 //而我们只需要返回第一个满足func的元素 num = arr.filter(func).length === 0 ? undefined : arr.filter(func)[0]; return num; } find([1, 2, 3, 4], function(num){ return num % 2 === 0; });//返回2 Drop it题目：丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。 第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。 最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。 tips:Arguments object Array.shift() Array.slice() 实现 function drop(arr, func) { //只要func返回false就左移抛出该元素，继续判断左移后的第一个元素是否满足条件 while(!func(arr[0])) { //shift() 方法从数组中删除第一个元素，并返回该元素的值。shift()方法会改变原数组 arr.shift(); } return arr; } drop([1, 2, 3], function(n) {return n &lt; 3; }); Steamroller题目：对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。 tips:Array.isArray() 实现 function steamroller(arr) { //扁平化处理后的数组 var afterArr = []; for(var i = 0; i &lt; arr.length; i ++) { //依次判断数组中元素类型是否为数组 //如果元素是数组类型，继续对该元素做数组扁平化处理 if(Array.isArray(arr[i])) { var midArr = steamroller(arr[i]); afterArr = afterArr.concat(midArr); //如果不是数组类型，则将该元素push进afterArr储存 }else { afterArr.push(arr[i]); } } return afterArr; } steamroller([1, [2], [3, [[4]]]]);//返回[1,2,3,4] Binary Agents题目：传入二进制字符串，翻译成英语句子并返回。二进制字符串是以空格分隔的。 tips:String.charCodeAt() String.fromCharCode() 实现 function binaryAgent(str) { var strToArr = []; var afterTrans = &quot;&quot;; //将二进制字符串按空格划分为字符串数组，并转化为number类型，十进制形式 str.split(&quot; &quot;).forEach(function(item,index) { //将二进制形式转化为十进制形式 strToArr.push(parseInt(item, 2)); }); afterTrans = strToArr.reduce(function(prev, curr) { //将数组中的十进制Unicode码通过String.fromCharCode()方法转换为字母，利用reduce()方法依次处理数组元素并拼接成字符串 return prev + String.fromCharCode(curr); },&quot;&quot;); return afterTrans; } binaryAgent(&quot;01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001&quot;);//返回&quot;I love FreeCodeCamp!&quot; Everything Be True题目：完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。 记住：你只能通过中括号来访问对象的变量属性(pre)。 tips:可以有多种实现方式，最简洁的方式莫过于Array.prototype.every() every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 实现 function every(collection, pre) { //使用every() 方法测试数组的所有元素是否都通过了指定函数的测试。 var flag = collection.every(function(item, index) { //如果对象不存在pre属性，则返回false if(!item.hasOwnProperty(pre)) {return false;} //测试pre属性的值是否为true if(!item[pre]) {return false;} return true; }); return flag; } every([{&quot;user&quot;: &quot;Tinky-Winky&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Dipsy&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Laa-Laa&quot;, &quot;sex&quot;: &quot;female&quot;}, {&quot;user&quot;: &quot;Po&quot;, &quot;sex&quot;: &quot;female&quot;}], &quot;sex&quot;);//返回true 换一种简洁的写法： function every(collection, pre) { return collection.every(function(elements){ return elements.hasOwnProperty(pre) &amp;&amp; Boolean(elements[pre]); }); } Arguments Optional题目：创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。 例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。调用这个有一个参数的返回的 function，返回求和的结果：var sumTwoAnd = add(2);sumTwoAnd(3) 返回 5。如果两个参数都不是有效的数字，则返回 undefined。 tips:Closures Arguments object 实现 function add() { //如果add有两个参数，则返回两个参数的和 if(arguments.length === 2 &amp;&amp; typeof arguments[0] === &quot;number&quot; &amp;&amp; typeof arguments[1] === &quot;number&quot;) { return arguments[0] + arguments[1]; } //如果add有一个参数，则通过闭包方式返回一个函数 if(arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;number&quot;) { var x = arguments[0]; //通过闭包方式返回只有一个参数的函数 return function(y) { if(typeof y === &quot;number&quot;) { return x + y;} return undefined; }; } return undefined; } add(2,3);//返回5 add(2)(3);//返回5 add(2)([3]);//返回undefined add(2, &quot;3&quot;);//返回undefined add(&quot;http://bit.ly/IqT6zt&quot;);//返回undefined]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP简要了解]]></title>
    <url>%2F2017%2F11%2F15%2FJSONP%E7%AE%80%E8%A6%81%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在freeCodeCamp上学习使用twith TV API获取频道信息时，在freeCodeCamp的指导中提到若使用$.getJSON(()方法会因为跨域资源共享(CORS)问题发生错误信息。 freeCodeCamp Challenge Guide: How to Use the TwitchTV API 中建议使用jQuery的JSONP方法来解决CORS问题。 JSONP的诞生传统ajax无法跨域，而标签的src属性是可以跨域的,可以通过把跨域服务器写成调用本地的函数 ，回调数据回来。 json刚好被js支持（object） 调用跨域服务器上动态生成的js格式文件（不管是什么类型的地址，最终生成的返回值都是一段js代码） 这种获取远程数据的方式看起来非常像ajax，但其实并不一样，便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。 传递一个callback参数给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。 例子（1）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js alert(&quot;我是远程文件&quot;); 本地 &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 在本地标签直接引入一个js文件，页面将会弹出警告框。 （2）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;}); 本地 &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data){ alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); }; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 该例子中在本地定义了一个函数localHandler，在本地通过标签的src属性引入了跨域服务器上的一个js文件remote.js，在引入的js文件里调用了本地定义的函数localHandler。 问题：如何让远程js文件知道它应该调用的本地函数的名字呢？毕竟jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同。 （3）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：flightResult.php flightHandler({ &quot;code&quot;:&quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 }); 本地 &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;跨域服务器/flightResult.php?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; 在该例中动态创建标签（动态创建脚本）； url中传递了一个code参数，服务器去做查询CA1998次航班的信息，callback参数告诉服务器，我的本地回调函数叫做flightHandler； 跨域服务端调用这个函数flightHandler，页面将会弹出一个提示窗体，显示出票价和余票。 JSONP方法中服务器做的事情// 数据 $data = [ &quot;name&quot;:&quot;anonymous66&quot;, &quot;age&quot;:&quot;18&quot;, &quot;like&quot;:&quot;jianshu&quot; ]; // 接收callback函数名称 $callback = $_GET[&apos;callback&apos;]; // 输出 echo $callback . &quot;(&quot; . json_encode($data) . &quot;)&quot;; 服务器端做的就是获取url中的callback参数，并将callback参数作为函数名来包裹json数据，动态生成js文件，再返回给客户端。 JSONP与AJAX的区别ajax的核心是通过XMLHttpRequest获取非本页内容。 jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 转自：segmentfault专栏JSONP是什么]]></content>
      <categories>
        <category>jsonp</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
        <tag>javascript</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax-imooc]]></title>
    <url>%2F2017%2F11%2F06%2Fajax-imooc%2F</url>
    <content type="text"><![CDATA[ajax,即异步JavaScript和XML，通过在后台和服务器少量的数据交换实现页面的异步局部加载更新。ajax中一个关键的对象 XMLHttpRequest对象，作为网页和服务器之间交换数据的桥梁，来实现网页的异步请求、局部刷新。 创建XMLHttpRequest对象在现代浏览器中创建XMLHttpRequest对象 var request = new XMLHttpRequest();//现代浏览器 若在早期老版本浏览器中，考虑兼容性，创建XMLHttpRequest对象方式如下： var request; if(window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6,IE5 } HTTP协议HTTP是一种无状态协议。一个HTTP请求包括以下7个步骤： 建立TCP连接 WEB浏览器向WEB服务器发送请求命令 WEB浏览器发送请求头信息 WEB服务器应答 WEB服务器发送应答头信息 WEB服务器向浏览器发送数据 WEB服务器关闭TCP连接 HTTP请求一个HTTP请求一般由四部分组成： HTTP请求的方法和动作，比如GET或POST请求 正在请求的URL 请求头，包含一些客户端环境信息、身份验证信息等 请求体，即请求正文，包含客户提交的查询字符串信息、表单信息等一般来说请求头和请求正文之间有一个空行，表示请求头结束。一篇关于GET、POST请求的博文详解GET:一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。(用于查询，一般不用于新建和修改。默认为GET提交)POST:一般用于修改服务器上的资源，对所发送信息的数量无限制。HTTP响应一个HTTP响应一般由三部分组成： 一个数字和文字组成的状态码，表示请求成功还是失败 响应头，包含服务器类型、日期时间、内容类型、长度等 响应体，即响应正文HTTP状态码的类型： XMLHttpRequest发送请求两个方法，open和send open(method, url, async) send(string)open方法用于设置请求，第一个参数method表示请求的类型，即GET或POST；第二个参数url即请求的地址，绝对地址或相对地址；第三个参数表示是否异步请求，默认为true。send方法用于发送请求，当使用get请求时，send可不给出参数，而使用post请求时必须有参数。例如： request.open(“POST”,”create.php”,true); request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息，一定要写在open()和send()之间 request.send(“name=xxxx&amp;sex=xxx”); XMLHttpRequest取得响应通过监听XMLHttpRequest对象readyState属性的变化，判断服务器的状态变化信息。通过.onreadystatechange()方法监听readyState属性的变化，当readyState为4（响应完成）并且status为200(请求成功)时，再对响应数据做处理： var request = new XMLHttpRequest(); request.open(&quot;POST&quot;,&quot;get.php&quot;,true); request.send(); request.onreadystatechange = function() { if(request.readyState == 4 &amp;&amp; request.status == 200) { //做一些处理，例如request.responseText } } PHP]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[planeGame-H5 Canvas小游戏未完成的问题]]></title>
    <url>%2F2017%2F10%2F30%2FplaneGameQuestion%2F</url>
    <content type="text"><![CDATA[H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。 未完成内容游戏设置部分音乐设置（HTML5 audio相关的学习，包括设置游戏背景音乐以及各种子弹、爆炸等声音，以及切换声音的开启和关闭） 背景设置（即切换背景图片） 战机设置（即切换战机plane的icon图片） 存在问题的地方点击“再玩一次”之后，敌机以及子弹的速度会越来越快，差不多第三次重玩就无法进行了。感觉是因为上一次游戏过程中的一些数据没有清除，怀疑过是不是setInterval()的原因，百度了查了好多，在end处添加了window.clearInterval()，但也是无济于事。特将此问题记录，以待后面将js学深了再来解决。 可以改进的地方游戏结束以后，除了“再玩一次”，再添加一个“退出游戏”功能，使页面切换到index状态。 适应手机端的，试了下在电脑上战机移动不了，应该是手指移动事件那里还未考虑鼠标移动来兼容电脑浏览器。 效果截图主页面如下： 游戏结束，“再玩一次”界面 github源码github仓库地址：demo-planegame 放在gh-pages上的样子，电脑端战机移动不了。demo展示]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(二)DOM操作--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js2%2F</url>
    <content type="text"><![CDATA[JS调用DOM接口修改样式。 DOM简介 上图是一张网页的生成过程，大致分为五步： （1）html代码转化为DOM树 （2）CSS代码转化成CSSOM（CSS Object Model） （3）结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） （4）生成布局（layout），即将所有渲染树的所有节点进行平面合成 （5）将布局绘制（paint）在屏幕上 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 其中，在html文档生成DOM树后，JS可以通过DOM提供的接口来添加、删除、修改元素和样式。 DOM查找查找API: document.getElementById()//通过元素id查找，查找一个元素 [document|Element].getElementsByClassName()//通过元素类名查找，查找一组元素，得到一个类数组(html collection) [document|Element].getElementsByTagName()//通过元素标签名查找,查找一组元素，得到一个类数组 [document|Element].querySelector()//通过CSS选择器查找，例如 var qId = document.querySelector(&apos;#id&apos;); [document|Element].querySelectorAll()//通过CSS选择器查找 后两者常用。 DOM新增和删除（1）新增节点新增一个元素时，包括插入和追加。前面插入用insertBefore()，后面追加用appendChild()。 parent.appendChild(element)//新增节点到父元素的末尾 parentElement.insertBefore(newElement, targetElement)//新增节点到targetElement元素的前面 注意：使用.insertBefore()方法时，不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它。所以可以通过targetElement.parentNode.insertBefore(newElement, targetElement)来插入。 新增多个元素时，可以利用上述两个方法结合循环实现，但循环会导致一个问题，因为直接操作DOM会导致浏览器反复渲染。利用DocumentFragment节点解决这个反复渲染问题。 DocumentFragment文档片段，可以理解为“轻量级”的节点。有两个属性，分别为：nodeType = 11, nodeName = #document-fragment。DocumentFragment作为仓库来使用，不在DOM树中，游离在DOM树之外。当增加多个节点时，可将这多个节点临时存放在DocumentFragment仓库中，最后再一次性插入DOM树中，就解决了浏览器反复渲染的问题。 （2）删除节点删除节点使用removeChild() （3）创建节点 此时创建出的节点即为DocumentFragment文档碎片，创建完以后再插入或者追加到DOM树中。 document.createElement(nodeName)//创建元素节点,nodeName即为h1,h2,li,p,.... document.creatTextNode(text)//创建文本节点 练习题 题目要求:现有 HTML 代码如下, &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;/body&gt; 在h1元素的后面新增一个ul元素，ul元素中有一百个li元素，li的内容就是 1-100 ，如下所示： &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; ...... &lt;li&gt;98&lt;/li&gt; &lt;li&gt;99&lt;/li&gt; &lt;li&gt;100&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; js代码如下： var len = 100; var ul = document.createElement(&apos;ul&apos;); var body = document.getElementsByTagName(&apos;body&apos;)[0]; for(var i = 0; i &lt; len; i++){ var li = document.createElement(&apos;li&apos;); var liText = document.createTextNode(i+1); li.appendChild(liText); ul.appendChild(li); } body.appendChild(ul); DOM修改样式两种方式修改元素样式：通过元素style属性修改；通过元素class属性修改。 （1）style属性 style属性包含着元素诸如颜色大小等样式，style属性是一个对象。如访问style对象的color属性：element.style.color。 注意：当引用一个中间带减号的CSS属性时，DOM要求用驼峰命名法。CSS属性font-family变为了DOM属性fontFamily：element.style.fontFamily。这是因为减号和加号之类的操作符是保留字，不允许用在函数或变量的名字里，意味着也不能用在方法和属性的名字里。 缺点：style属性只能返回内嵌样式。即只有把CSS style属性插入到标记里，才可以用DOM style属性去获取那些属性信息。DOM style属性不能用来检索外部CSS文件里声明的样式。 （2）class属性 利用DOM修改元素的class属性（比如新增一个class或者删除一个class），使得利用外部CSS文件中的设置的样式改变元素的样式，而不是用DOM直接操作style属性修改样式。 例如要给要给elem元素设置class属性为intro，方法如下： a.利用setAttribute()方法, elem.setAttribute(&quot;class&quot;,&quot;intro&quot;) b.通过更新className属性。className属性是一个可读可写的属性，凡是元素节点都有这个属性。可以用className属性获取一个元素的class属性，element.className。 用className属性和赋值操作符设置一个元素的class属性：element.className = value 该方法的不足，通过className属性设置某个元素的class属性时将替换该元素原有的属性（而不是追加）。 在需要给一个元素追加新的class时，可以按照以下思路： 检查className属性的是否为null； 如果是，把新的class设置值直接赋值给className属性； 若不是，把一个空格和新的class设置值追加到className属性上去。 把上述步骤封装为一个函数addClass,该函数有两个参数，第一个为需要添加的新class的元素，第二个是新的class设置值。 function addClass(element, value){ if(!element.className){ element.className = value; }else{ newClassName = element.className; newClassName+= &quot; &quot;; newClassName+=value; element.className = newClassName; } } 事件模型&lt;!DOCTTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;事件简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;button id=&quot;button&quot;&gt;点击切换背景颜色&lt;/button&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 针对上述代码，当点击了button后事件反应机制有两种(这两种是上古时代的做法 。 。) 第一种是点击button后，button将事件传递到section，再传递到body，再传递到html，再传递到document。该种方式即为事件冒泡机制。如下图所示： 第二种是点击button后，从document开始一层层捕获，即为事件捕获机制。如下图所示。 目前标准的DOM事件流做法分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获阶段的结束阶段为目标元素的父元素，然后是处于目标阶段，接下来是事件冒泡阶段。在实际开发过程中，由于浏览器兼容问题，事件捕获过程基本不用，会频繁使用目标和事件冒泡。流程如下所示。 事件处理程序添加事件处理程序： element.addEventListener(type, handle, false)//type表示事件类型，handle为事件处理函数，false表示采用冒泡机制 删除事件处理程序： element.removeEventListener(type, handle) 例如： h1.addEventListener(&apos;click&apos;, function(){ console.log(this);//this指向绑定事件处理函数的对象，即h1元素 }, false); 事件对象 事件对象包含着所有与事件相关的信息。 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { //event即为事件处理对象，包括了触发点击事件时鼠标的位置等等信息 console.log(&apos;event&apos;, event); //将event对象打印出来并查看event对象包含哪些信息 } h1.addEventListener(&apos;click&apos;, handle, false); 事件冒泡 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 虽然点击事件绑定在body上，但此时点击h1元素，仍会触发事件打印event对象。此为事件冒泡。 流程：当点击目标元素h1，先找h1上有没有点击事件，有则触发，没有则按照冒泡机制一层层往上找，看有没有点击事件，直到冒泡到document。 阻止事件冒泡： var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 h1.addEventListener(&apos;click&apos; function(event) { event.stopPropagation();//阻止事件冒泡，当点击h1元素时，不会触发点击事件 }, false);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(一)--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js%2F</url>
    <content type="text"><![CDATA[NEXT十天训练营有关JS学习的笔记。 认识JavaScriptJS是目前主流浏览器唯一支持的脚本语言，由以下三部分组成： （1）ECMAScript:语言基础（核心）。 ECMA-262标准规定了ECMAScript这门语言的组成部分，例如语法、类型、语句、关键字、保留字、操作符、对象。 Web浏览器只是ECMAScript实现可能的宿主环境之一，其他宿主环境还包括Node(一种服务端JavaScript平台)和Adobe Flash。 （2）DOM（Document Object Model,文档对象模型） 通过DOM可以操作HTML元素，包括删除、添加、替换、修改节点等。DOM将整个HTML文档映射为一个多层节点结构，即DOM树。 （3）BOM（Browser Object Model,浏览器对象模型） 通过BOM获取一些浏览器的信息，以及控制浏览器的一些行为。 引入JavaScript有三种方式可以在HTML文档里引入JavaScript。 （1）行内方式。即直接在HTML元素的属性上应用js代码。 例如以下代码中button元素的onclick属性，点击button就会弹出消息框并显示“hello”。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 但这种方式不建议使用。一是因为这种方式针对一些用户的事件触发js执行，局限性较大。二是html文档中掺杂js代码会显得文档很乱，背离了结构应与样式、行为相分离的原则。 （2）内嵌方式。即通过一对标签在html文档中插入js代码。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; &gt;点击弹出消息框&lt;/button&gt; &lt;sript&gt; var helloBtn = documnet.getElementById(&quot;helloBtn&quot;); helloBtn.onclick = function() { alert(&quot;hello&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此种方式也有缺点。例如在不同页面使用上述标签之间这段js代码时，即在不同页面使用同一段js代码会有冗余。根据场景判断是否使用该方式。 （3）外链方式。即将js代码从html文档中提取出来单独形成一个.js文件，并在html文档中引入这个.js文件。 例如将方法（2）中标签之间这段js代码提取出来，保存在一个hello.js文件中，并在html文件中引入。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 根据场景判断是否使用该方式。 变量（1）语法: var 变量名 变量名区分大小写，首字母必须是字母、下划线或者$，非关键字和保留字。例如，var name = &quot;bottle&quot;; （2）全局变量和局部变量： 使用var定义的变量可能是全局变量也可能是局部变量，取决于是否在一个function中。如在function中使用var定义一个变量message，此变量即为一个局部变量。局部变量在function外面访问不到。若在function内不使用var定义变量message，则在函数外可以访问到该变量。 使用var定义 function test() { var message = &quot;hi&quot;;//定义一个局部变量 } test(); alert(message);//错误，找不到变量message 不使用var定义 function test() { message = &quot;hi&quot;;//定义一个全局变量 } test(); alert(message);//hi 使用控制台console来调试js代码。alert()弹出一个提示框。console.log()打印。 利用sources里面的snippets来观察变量。如下所示。 局部变量测试结果如下所示。 全局变量测试结果如下所示。 数据类型1、基本数据类型 （1）字符串类型String （2）数字类型Number （3）布尔类型Boolean ,取值true或false （4）Null （5）Undefined 2、复杂数据类型/引用数据类型 Object 怎样判断数据类型 在浏览器控制台可使用type of 操作符来判断以下数据类型。 typeof 1//&quot;number&quot; typeof &apos;a&apos;//&quot;string&quot; typeof true//&quot;boolean&quot; typeof undefined//&quot;undefined&quot; typeof null//&quot;object&quot; (这个比较特殊) typeof {}//&quot;object&quot; typeof function(){};//&quot;function&quot; 判断数据类型的几个例子如下。 Object对象1、创建对象 （1）使用对象字面量{}创建杯子对象。（推荐，简洁明了） var bottle = { name: &quot;bottle&quot;, //key: value price: 49, isKeepWarm: true } 对象的每一个属性都可以用对应的键值对(key: value)来描述，其中key为任一合法字符，value为任意数据类型。如果属性名包含多个中间含空格的字符，要用引号包含起来。 （2）使用Object构造函数创建杯子对象。 var bottle = new Object(); bottle.name = &quot;bottle&quot;; bottle.price = 49; bottle.isKeepWarm = true; 2、对象属性读操作 （1）使用点操作符 console.log(bottle.name);//&quot;bottle&quot;（推荐） （2）使用中括号操作符 console.log(bottle[&quot;name&quot;]);//&quot;bottle&quot;（如果对象属性名即key包含空格时，必须使用中括号操作符） 函数1、函数的定义 （1）函数声明 function 函数名（参数1，参数2，...）{ 函数体 return ; } 函数声明的特点，在相同作用域下，不管在何处声明都可以调用的到。即使声明在调用之后。 （2）函数表达式 var 变量 = function(参数1，参数2，...){ 函数体 return ; } 函数表达式的调用必须在函数表达式声明之后。这是区别于函数声明的地方。 作用域 如上图所示，bottles是在函数之外声明的，是全局作用域的一个变量，所以在函数内部可以访问到bottles。而函数内部（函数作用域）声明的num为局部变量，只可以在函数内部被访问到，在函数外部无法获取。 流程控制（1）if语句 if(条件) { 执行语句1; } else{ 执行语句2; } （2）switch语句 swith(n){ case 0: 执行语句1； case 1: 执行语句2; ... } 字符串的有关操作分割字符串 splitsplit()方法可以把字符串分割为字符串数组。 &quot;2:3:4:5&quot;.split(&quot;:&quot;) // 将返回 [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] &quot;|a|b|c&quot;.split(&quot;|&quot;) // 将返回 [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 截取字符串 substringsubstring() 方法用于提取字符串中介于两个指定下标之间的字符。语法：str.substring(indexStart, [indexEnd]) var str = &apos;Hello World!&apos;; console.log(str.substring(3)); // 将返回 lo world! 字符串转换大写 toUpperCase()toUpperCase() 方法用于把字符串转换为大写。 var str = &apos;Hello World!&apos;; console.log(str.toUpperCase()); // 将返回 HELLO WORLD! 题目完善函数 convertToCamelCase 的功能。函数 convertToCamelCase 会转换传入的字符串参数 string 为驼峰格式，并返回转换后的字符串。具体要求如下： 参数 string 是以中划线（-）连接单词的字符串，需将第二个起的非空单词首字母转为大写，如 -webkit-border-radius 转换后的结果为 webkitBorderRadius。 返回转换后的字符串 解决方法： function convertToCamelCase(str){ var strSplit = str.split(&quot;-&quot;);//转换为字符串数组 if(strSplit[0] === &quot;&quot;){ //如果第一个字符串为空的话，左移删掉，否则的话不变 strSplit.shift(); } for(var i = 1; i &lt; strSplit.length; i++){ var letter = strSplit[i].charAt(0);//取得字符串数组中每个字符串的首字母 //使用replace方法将每个字符串的首写字母大写 strSplit[i] = strSplit[i].replace(letter, function replace(letter){ return letter.toUpperCase(); }); } return strSplit.join(&quot;&quot;);//join方法串接起字符串 } convertToCamelCase(&quot;-ni-hao-a&quot;); 还可以使用正则表达式的方法。 function convertToCamelCase(str) { return str.replace(/\-[a-z]/g , function(a, b){ return b == 0 ? a.replace(&apos;-&apos;,&apos;&apos;) : a.replace(&apos;-&apos;,&apos;&apos;).toUpperCase(); }); }]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS切图笔记from慕课网]]></title>
    <url>%2F2017%2F10%2F18%2FPS%E5%88%87%E5%9B%BE%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接前端工程师必备的PS技能——切图篇。 Photoshop界面设置使用的photoshop版本为photoshop cc 2015。 新建设置文件–&gt;新建–&gt;文档类型（自定）–&gt;宽度一般固定（1920像素）–&gt;高度一般不定(此时设为2000像素)–&gt;分辨率72像素/英寸–&gt;背景内容(透明)。 再点击“确定”即可生成一张新的界面。此时还可点击“存储预设为”将本次自定义设置预设，留作以后使用该设置参数时使用。参数设置即生成图片分别为下列两图所示。 不知道是不是我下载的破解版的原因，键盘在中文输入法状态下时，左侧导航栏的工具图标不显示提示名称，切换到英文输入状态时就会显示。。 移动工具设置第一个工具图标为：移动工具，快捷键V。 如下图所示。 选择移动工具–不勾选自动选择–选择图层–按住ctrl+鼠标左键可以自由选择想要的图层，会在右侧图层显示信息栏为你筛选出当前鼠标左键选择的图层。如下图所示。 视图设置勾选两个功能：（1）视图–&gt;显示–&gt;智能参考线 （2）视图–&gt;标尺可以在窗口–&gt;库，颜色，路径，通道， 把这几个功能关掉。 窗口–&gt;历史记录，信息，图层，三个功能模块打开。 最后在右侧区域一共用到四个功能，即信息，字符，图层，历史纪录。见下图。 信息面板设置如下： 在编辑–&gt;首选项–&gt;单位与标尺，将单位改为像素。 Photoshop基本操作]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有默认margin，padding值的html标签]]></title>
    <url>%2F2017%2F10%2F18%2F%E9%BB%98%E8%AE%A4margin%E5%80%BC%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。 h1~h6标签有默认margin（top,bottom且相同）值，没有默认padding值。 在chrome中：16,15,14,16,17,19; 在firefox中：16,15,14,16,17,20; 在safari中：16,15,14,16,17,19; 在opera中：16,15,14,14,17,21; 在maxthon中：16,14,14,15,16,18; 在IE6.0中：都是19； 在IE7.0中：都是19； 在IE8.0中：16,15,14,16,17,19; dl标签有默认margin（top,bottom且相同）值，没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; dd标签有默认margin-left：40px;(在所有上述浏览器中)。 ol,ul标签有默认margin-（top,bottom且相同）值，有默认padding-left值 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; 默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。 th,td标签th,td标签没有默认的margin值，有默认的padding值。 在Chrome,Firefox,Safari,Opera,Maxthon中：padding：1px; 在IE8.0中：padding：0px 1px 1px; 在IE7.0中：padding：0px 1px； 相同内容th的宽度要比td宽，因为th字体有加粗效果。 注意 ：table标签没有默认的margin,padding值。 form标签form标签在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中没有默认的margin,padding值，但在IE6.0,7.0中有默认的margin：19px 0px; p标签p标签有默认margin(top,bottom)值,没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; textarea标签textarea标签在上述所有浏览器中：margin:2px；padding:2px； select标签select标签在Chrome,Safari,Maxthon中有默认的margin：2px；在Opera,Firefox,IE6.0,7.0,8.0没有默认的margin值。 option标签option标签只有在firefox中有默认的padding-left：3px； CSS reset/*CSS style init*/ body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,option,textarea,form,th,td{margin: 0; padding: 0;} body{font:14px/1.5 &quot;宋体&quot;;} img{border:none;} li{list-style:none;} input,select,textarea{outline:none;border:none;background:none;} textarea{resize:none;} a{text-decoration:none;}]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS清除浮动的几种方法]]></title>
    <url>%2F2017%2F10%2F17%2Fclearfix%2F</url>
    <content type="text"><![CDATA[几种定位方式，以及CSS清除浮动的几种方法。 几种定位方式普通流定位 static普通流定位即文档流定位，是页面元素的默认定位方式。按照元素在文档流中的出现顺序以默认形式呈现元素。 页面中的块级元素：按照从上到下的方式逐个排列 。 页面中的行内元素：按照从左到右的方式逐个排列 。 此时考虑如何让多个块级元素显示在一行，就引出了浮动的概念。 浮动定位 floatfloat属性取值为 left/right。这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕。 相对定位 relative元素会相对于它原来的位置偏移某个距离。使元素偏离原来位置后，元素原本的空间依然会被保留。 语法 属性：position 取值：relative 再配合 偏移属性top/right/bottom/left实现位置改变 绝对定位 absolute若元素被设置为绝对定位，具备以下几个特征： 1、脱离文档流-不占据页面空间 2、通过偏移属性固定元素位置 3、相对于 最近的已定位的祖先元素实现位置固定 4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定 语法 属性：position 取值：absolute 再配合 偏移属性(top/right/bottom/left)实现位置的固定 固定定位 fixed将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动。 语法 属性：position 取值：fixed 配合着 偏移属性(top/right/bottom/left)实现位置的固定 浮动的效果1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位 2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动) 3、浮动元素依然位于父元素之内 4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 注意 1、一行内，显示不下所有的已浮动元素时，最后一个将换行 2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定) 3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大（块级元素：允许修改尺寸；行内元素：不允许修改尺寸 ） 4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素 浮动的影响：由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）。 清除浮动方法1直接设置父元素的高度。优势：极其简单；弊端：必须要知道父元素高度是多少 方法2在父元素中，追加空子元素，并设置其clear属性为both。clear是css中专用于清除浮动的属性。作用：清除当前元素前面的元素浮动所带来的影响 取值： 1、none 默认值，不做任何清除浮动的操作 2、left 清除前面元素左浮动带来的影响 3、right 清除前面元素右浮动带来的影响 4、both 清除前面元素所有浮动带来的影响 优势：代码量少 容易掌握 简单易懂弊端：会添加许多无意义的空标签，有违结构与表现的分离，不便于后期的维护 方法3设置父元素浮动。 优势：简单，代码量少，没有结构和语义化问题；弊端：对后续元素会有影响 方法4为父元素设置overflow属性。 取值：hidden 或 auto 优势：简单，代码量少弊端：如果有内容要溢出显示(弹出菜单)，也会被一同隐藏 方法5父元素设置display:table. 优势：不影响结构与表现的分离，语义化正确，代码量少；弊端：盒模型属性已经改变，会造成其他问题 方法6使用内容生成的方式清除浮动。 .clearfix:after { content:&quot;&quot;; display:block; clear:both; } :after 选择器向选定的元素之后插入内容 content:&quot;&quot;; 生成内容为空 display: block; 生成的元素以块级元素显示, clear:both; 清除前面元素浮动带来的影响 相对于空标签闭合浮动的方法，优势：不破坏文档结构，没有副作用；弊端：代码量多 方法7.cf:before,.cf:after { content:&quot;&quot;; display:table; } .cf:after { clear:both; } 优势：不破坏文档结构，没有副作用；弊端： 代码量多]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTFS文件系统介绍]]></title>
    <url>%2F2017%2F10%2F16%2FNTFS-file-system%2F</url>
    <content type="text"><![CDATA[【转】Windows文件系统FAT16、FAT32、NTFS的简单介绍。 什么是NTFS文件系统介绍NTFS之前，先来介绍一下FAT。 FAT(File Allocation Table)表示“文件分配表”，它的意义在于对硬盘分区的管理。FAT16、FAT32、NTFS是Windows系统最常见的三种文件系统。 FAT16：以前用的DOS、Windows95都使用FAT16文件系统，后来的Windows98/2000/XP等系统均支持FAT16文件系统。它最大可以管理大到2GB的分区，但每个分区最多只能有65525个簇（簇是磁盘空间的配置单位，即文件的存取的最小单位，一个簇包含若干扇区，而扇区是磁盘驱动器向磁盘读取和写入数据的最小单位）。随着硬盘或分区容量的增大，每个簇所占的空间将越来越大，从而导致硬盘空间的浪费。 更多关于硬盘的基本知识参见博客硬盘基本知识。 FAT32：随着大容量硬盘的出现，从Windows98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。 NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。从1993年开始，随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。 在NTFS文件系统中，文件存取是按簇进行分配，一个簇必需是物理扇区的整数倍，而且总是2的整数次方倍。NTFS文件系统并不去关心什么是扇区，也不会去关心扇区到底有多大（如是不是512字节）。簇大小在使用格式化程序时则会由格式化程序根据卷大小自动的进行分配。 文件通过主文件表（MFT）来确定其在磁盘上的存储位置。主文件表是一个对应的数据库，由一系列的文件记录组成。 卷中每一个文件都有一个文件记录（对于大型文件还可能有多个记录与之相对应）。主文件表本身也有它自己的文件记录。 NTFS卷上的每个文件都有一个64 bit称为文件引用号（File Reference Number，也称文件索引号）的唯一标识。文件引用号由两部分组成：一是文件号，二是文件顺序号。文件号为48位，对应于该文件在MFT中的位置。文件顺序号随着每次文件记录的重用而增加，这是为NTFS进行内部一致性检查而设计的。 NTFS使用逻辑簇号（Logical Cluster Number，LCN）和虚拟簇号（Virtual Cluster Number，VCN）来进行簇的定位。LCN是对整个卷中所有的簇从头到尾所进行的简单编号。卷因子乘以LCN，NTFS就能够得到卷上的物理字节偏移量，从而得到物理磁盘地址。VCN则是对属于特定文件的簇从头到尾进行编号，以便于引用文件中的数据。VCN可以映射成LCN，而不必要求在物理上连续。 NTFS的目录只是一个简单的文件名和文件引用号的索引，如果目录的属性列表小于一个记录的长度，那么该目录的所有信息都存储在主文件表的记录中，对于大于记录的目录则使用B+树进行管理。 主文件表中的基本文件记录中有一个指针指向一个存储非常驻索引缓冲–包括该目录下所有下一级子目录和文件的外部簇，而B+树结构便于大型目录中文件和子目录的快速查找。 在NTFS中，所有存储在卷上的数据都包含在文件中，包括用来定位和获取文件的数据结构，以及引导程序和记录这个卷的记录（NTFS元数据）的位图，这体现了NTFS的原则：磁盘上的任何事物都为文件。在文件中存储一切使得文件系统很容易定位和维护数据，而在NTFS中，卷中所有存放的数据均在一个叫做MFT的文件记录数组中，称为主文件表(Master File Table)，MFT是由高级格式化产生的。而MFT则由文件记录(File Record)数组构成。File Record的大小一般是固定的，不管簇的大小是多少，均为1KB，这个概念相当于Linux中的inode（i节点）。File Record在MFT文件记录数组中物理上是连续的，且从0开始编号。 MFT仅供系统本身组织、架构文件系统使用，这在NTFS中称为元数据(metadata)。其中最基本的前16个记录是操作系统使用的非常重要的元数据文件。这些NTFS主文件表的重要的元数据文件都是以$(美元符号)开始的名字，所以是隐藏文件，在Windows 2000中不能使用dir命令(甚至加上/ah参数)像普通文件一样列出这些元数据文件。实际上File System Driver(ntfs.sys)维护了一个系统变量NTFS Protect System Files用于隐藏这些元数据。但是微软公司也提供了一个OEM TOOL,叫做NFI.EXE,用此工具可以转储NTFS主文件表的重要的元数据文件（元数据：是存储在卷上支持文件系统格式管理的数据。它不能被应用程序来访问，它只能为系统提供服务）。这些元数据文件文件是系统驱动程序装配卷所必需的，WINDOWS 2000给每个分区赋予一个盘符并不表示该分区包含有WINDOWS 2000可以识别的文件系统格式，如果一旦主文件表损坏，那么该分区在WINDOWS 2000下是无法读取的。为了使该分区能够在WINDOWS 2000下能被识别，也就是必须首先建立WINDOWS 2000可以识别的文件系统格式即主文件表，这可通过高级格式化该分区来完成。众所周知，Windows以簇号来定位文件在磁盘存储的位置，在FAT格式的文件系统中有关簇号的指针是包含在FAT表中的，而在NTFS中有关簇号的指针是包含在$MFT及$MFTMirr文件中的。 NTFS元文件MFT中的第1个记录就是MFT自身。由于MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（＄MftMirr），也就是MFT中的第2个记录。 第3个记录是日志文件（＄LogFile）。该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，例如复制，从而在系统失败时能够恢复NTFS卷。 第4个记录是卷文件（＄Volume），它包含了卷名、被格式化的卷的NTFS版本和一个标明该磁盘是否损坏的标志位（NTFS系统以此决定是否需要调用Chkdsk程序来进行修复）。 第5个记录是属性定义表（＄AttrDef，attribute definition table），其中存放了卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。 第6个记录是根目录（\），其中保存了存放于该卷根目录下所有文件和目录的索引。在访问了一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接进行对该文件的访问。 第7个记录是位图文件（＄Bitmap）。NTFS卷的分配状态都存放在位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲的还是已被分配了的，由于该文件可以很容易的被扩大，所以NTFS的卷可以很方便的动态的扩大，而FAT格式的文件系统由于涉及到FAT表的变化，所以不能随意的对分区大小进行调整。 第8个记录是引导文件（＄Boot），它是另一个重要的系统文件，存放着Windows 2000/XP的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统。该文件是在Format程序运行时创建的，这正体现了NTFS把磁盘上的所有事物都看成是文件的原则。这也意味着虽然该文件享受NTFS系统的各种安全保护，但还是可以通过普通的文件I/O操作来修改。 第9个记录是坏簇文件（＄BadClus），它记录了磁盘上该卷中所有的损坏的簇号，防止系统对其进行分配使用。 第10个记录是安全文件（＄Secure），它存储了整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为了节省空间，NTFS将具有相同描述符的文件和目录存放在一个公共文件中。 第11个记录为大写文件（＄UpCase，upper case file），该文件包含一个大小写字符转换表。 第12个记录是扩展元数据目录（＄Extended metadata directory）。 第13个记录是重解析点文件（$Extend\$Reparse）。 第14个记录是变更日志文件（$Extend\$UsnJrnl）。 第15个记录是配额管理文件（$Extend\$Quota）。 第16个记录是对象ID文件（$Extend\$ObjId）。 第17～23记录是是系统保留记录，用于将来扩展。 MFT的前16个元数据文件是如此重要，为了防止数据的丢失，NTFS系统在该卷文件存储部分的正中央对它们进行了备份。 NTFS把磁盘分成了两大部分，其中大约12%分配给了MFT，以满足其不断增长的文件数量。为了保持MFT元文件的连续性，MFT对这12%的空间享有独占权。余下的88%的空间被分配用来存储文件。而剩余磁盘空间则包含了所有的物理剩余空间–MFT剩余空间也包含在里面。MFT空间的使用机制可以这样来描述：当文件耗尽了存储空间时，Windows操作系统会简单地减少MFT空间，并把它分配给文件存储。当有剩余空间时，这些空间又会重新被划分给MFT。虽然系统尽力保持MFT空间的专用性，但是有时不得不做出牺牲。尽管MFT碎片有时是无法忍受的，却无法阻止它的发生。 那么NTFS到底是怎么通过MFT来访问卷的呢？首先，当NTFS访问某个卷时，它必须”装载”该卷：NTFS会查看引导文件（在图中的＄Boot元数据文件定义的文件），找到MFT的物理磁盘地址。然后它就从文件记录的数据属性中获得VCN到LCN的映射信息，并存储在内存中。这个映射信息定位了MFT的运行（run或extent）在磁盘上的位置。接着，NTFS再打开几个元数据文件的MFT记录，并打开这些文件。如有必要NTFS开始执行它的文件系统恢复操作。在NTFS打开了剩余的元数据文件后，用户就可以开始访问该卷了。 文件和目录记录NTFS将文件作为属性/属性值的集合来处理，这一点与其他文件系统不一样。文件数据就是未命名属性的值，其他文件属性包括文件名、文件拥有者、文件时间标记等。 每个属性由单个的流（stream）组成，即简单的字符队列。严格地说，NTFS并不对文件进行操作，而只是对属性流进行读写。NTFS提供对属性流的各种操作：创建、删除、读取（字节范围）以及写入（字节范围）。读写操作一般是针对文件的未命名属性的，对于已命名的属性则可以通过已命名的数据流句法来进行操作。 一个文件通常占用一个文件记录。然而，当一个文件具有很多项属性值或很零碎的时候，就可能需要占用一个以上的文件记录。这种情况下，第一个文件记录是其基本的文件记录，存储有该文件需要的其它文件记录的位置。小文件和文件夹（典型的如1500字节或更少）将全部存储在文件的MFT记录里。 文件夹记录包括索引信息，小文件夹记录完全存储在MFT结构内，然而大的文件夹则被组织成B+树结构，用一个指针指向一个外部簇，该簇用来存储那些MFT内存储不了的文件夹的属性。 NTFS卷上文件的常用属性列出如下（并不是所有文件都有所有这些属性）： （1）常驻属性与非常驻属性 当一个文件很小时，其所有属性和属性值可存放在MFT的文件记录中。当属性值能直接存放在MFT中时，该属性就称为常驻属性（resident attribute）。有些属性总是常驻的，这样NTFS才可以确定其他非常驻属性。例如，标准信息属性和根索引就总是常驻属性。 每个属性都是以一个标准头开始的，在头中包含该属性的信息和NTFS通常用来管理属性的信息。该头总是常驻的，并记录着属性值是否常驻、对于常驻属性，头中还包含着属性值的偏侈量和属性值的长度。 如果属性值能直接存放在MFT中，那么NTFS对它的访问时间就将大大缩短。NTFS只需访问磁盘一次，就可立即获得数据；而不必像FAT文件系统那样，先在FAT表中查找文件，再读出连续分配的单元，最后找到文件的数据。小文件或小目录的所有属性，均可以在MFT中常驻。小文件的未命名属性可以包括所有文件数据。 大文件或大目录的所有属性，就不可能都常驻在MFT中。如果一个属性（如文件数据属性）太大而不能存放在只有1KB的MFT文件记录中，那么NTFS将从MFT之外分配区域。这些区域通常称为一个运行（run）或一个盘区（extent），它们可用来存储属性值，如文件数据。如果以后属性值又增加，那么NTFS将会再分配一个运行，以便用来存储额外的数据。值存储在运行中而不是在MFT文件记录中的属性称为非常驻属性（nonresident attribute）。NTFS决定了一个属性是常驻还是非常驻的；而属性值的位置对访问它的进程而言是透明的。当一个属性为非常驻时，如大文件的数据，它的头部包含了NTFS需要在磁盘上定位该属性值的有关信息。 在标准属性中，只有可以增长的属性才是非常驻的。对文件来说，可增长的属性有数据、属性列表等。标准信息和文件名属性总是常驻的。 （2）MFT文件记录结构分析 主文件表MFT的文件记录由记录头和属性列表组成，由”FF FF FF FF”结束，一般大小为1K，或一个簇大小（这样一般就更大），记录头包括以下一些域： 每次记录被修改都将导致日志文件序列号$LogFile Sequence Number（LSN）发生变化。序列号Sequence Number（SN）用于记录主文件表记录被重复使用的次数。硬连接数Hard Link Count记录硬连接的数目，只出现在基本文件记录中。文件记录的实际长度是文件记录在磁盘上实际占用的字节空间。基本文件记录中的文件索引号，对于基本文件记录，其值为0，如果不为0，则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号，在基本文件记录中包含有扩展文件记录的信息，存储在”属性列表ATTRIBUTE_LIST”属性中。属性列表是可变长度区，以”FF FF FF FF”结束，对于1K长度的MFT记录，属性列表的起始偏移为0x30。]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网七夕动画学习总结+github pages展示]]></title>
    <url>%2F2017%2F09%2F29%2Fdemo-qixi%2F</url>
    <content type="text"><![CDATA[这段时间照着慕课网上的一个动画案例-H5+JS+CSS3实现七夕言情学习，并将学习的各部分的代码进行整合，最后将代码托管到github上，并通过github pages展示这个动画demo。一些地方自己修改以后没有老师的效果好，但这是自己第一个敲出来的前端小demo，成就感满满，哈哈。。。 关于动画案例里面用到一些jQuery和ajax相关的知识，由于自己学习js不久，很多深一点的概念理解不到位，比如一开始代码的封装和流程的编写，都是照葫芦画瓢，不是很理解，但是慢慢的看得多了，这个过程也就熟悉起来了。 页面布局部分比较容易理解，但是三个主题页面滚动起来最开始对自己还是有点难度。该案例很多部分都利用了CSS3的transform属性和animation属性。而且这个案例的思想是，把实现特定动作或者动能的代码封装起来，暴露一个接口出来，增强了安全性简化了编程过程。 具体的学习过程和用到的知识点，大家可以跟着H5+JS+CSS3实现七夕言情学习，边看边学的效果比抱着书一直看的效果要好一些。但js高级教程的基础必须打牢，很多师兄师姐给的建议，也是网上一些大佬的建议。 关于画面自己做的一点小改动，button的样式做了修改，并增加了链接到github仓库的logo（shirly与猫）,嘤嘤嘤。如下，左下角和右下角辣么一点点。 关于将页面搭建在github pages上关于动画制作的学习过程如果说困难和迷惑的话，那这最后一步展示在github pages上的过程，就应该是差点死在最后的1%上。在网上看了很多博客和教程，总会遇到很多小问题，无法显示自己在本地的效果。最后看到了这篇博客，【 js 工具 】如何在Github Pages搭建自己写的页面？，这篇博客对于利用github pages搭建自己写的网页描述很详细，从在github上建仓库，到github pages的设置，再到利用git命令克隆github上的仓库到本地，最后push到远程master分支上。 更多关于github的使用可参考Github 简明教程,其中讲解的git维护的本地仓库的工作流很清晰，对于我这个初步使用git的菜鸟十分友好。而且关于branch和更新与合并功能也讲的比较清楚。 本地仓库由git维护的“三棵树”组成。第一个是工作目录，使用$ git status可以查看，列出了当前目录下所有还未被git管理的文件，以及被git管理了且被修改过但还未添加（add）的文件，也即所有改动文件，用红色字体标出。如下所示，当我在本地仓库demo-qixi用$ git status命令查看后，可以看到红色文件均为未提交的。 第二个是暂存区（Index），它类似一个缓存区，临时保存你的改动。通过$ git add .命令添加当前目录下的所有文件和子目录到暂存区。注意.表示当前目录下的所有文件和子目录。也可以指定文件添加到暂存区，使用$ git add &lt;filename&gt;。如下使用$ git add .添加文件到暂存区： 此时我们再使用$ git status命令查看下工作目录，你会发现所有的文件都变绿了，这就表示这些文件已被添加到暂存区准备好被提交（commit）了。 第三个是HEAD，它指向你最后一次提交的结果。使用$ git commit -m &quot;代码提交说明信息&quot;命令，将暂存区最后一次添加更改情况提交到HEAD。如下所示。 上述“三棵树”的工作流程如下所示。 此时改动虽然已经提交到了HEAD，但是还没到远端仓库。使用$ git push命令将这些改动提交到远端仓库的default master分支。也可以使用$ git push origin master命令，把改动提交到master分支。可以把master换成自己想要推送的任何分支。 动画demo展示demo网页展示链接慕课七夕主题网页展示。 该动画demo在github上的代码仓库demo-qixi。 tips:在打开demo页面展示链接时，浏览器链接窗口出现提示“此页面上部分内容不安全，例如图像”，并且网页内容不能完整显示，我使用的firefox浏览器。如下所示， 原因是我们用来展示demo的github pages站点是使用https协议的安全站点，而demo中的一些图片链接是使用的http协议，浏览器不会渲染混合内容（即来自安全站点的不安全数据）。如果我们浏览https网页，浏览器会拒绝加载不安全的内容（例如这里的demo-qixi中图片使用的http协议），浏览器将向用户发出“此页面上部分内容不安全”的警告。可以参考这篇讲web安全的文章，绕过混合内容警告 - 在安全的页面加载不安全的内容。 解决办法：我用的火狐浏览器，点浏览器链接窗口左侧的黄色警告三角形-&gt;点右侧箭头显示连接细节-&gt;点暂时解除保护，就可以看到完整的动画demo了。 然后点击 Go!开始动画啦。。。。。。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匆匆拉萨之行]]></title>
    <url>%2F2017%2F09%2F13%2Ftour-lahsa%2F</url>
    <content type="text"><![CDATA[第一次尝试写游记，嗯，是在周老师的文艺熏陶之下，试着记录一哈，但愿最后读起来不是一篇作文的感觉 T T ~~真的太久没动手写点儿文字了，想当年语文也是考过140分的人呐 = = 哈哈哈哈哈哈哈哈哈 嗯，这一定会是一本气质爆炸的流水账，如此鼓励自己，就像拉萨的阳光和色彩，希望经得起时间，淡化模糊了的时候再来强化一遍，反正又不是背英语词汇书，不用每次拾起都abandon 哈哈哈 在被林子放鸽子（为了她的大好前程，以及许诺将来可以赚很多钱养我的情况下，对于她的这种抛弃我的行为予以了包容，哈哈哈，我就是这么体贴大方聪明美丽可爱。。。。。。然而，在她晓得我自己去耍，她却在加班以后，果断从内疚的心态转为了说我抛弃了她==），又不想回家监督老弟学习，团队的小伙伴接连回家只剩我自己的情况下，突然萌生了想去远一点的地方这个想法，其实之前也有想过去趟拉萨，但是纠结于各种原因，一直没有付出行动。 从打算去拉萨，到最后决定并买票只花了一天时间，这是第一次去一个远一点的地方没有攻略过就这么仓促决定了。去的火车票没有，只好买机票，回程的也没有直达的火车票了，机票略贵不舍，只好坐着火车出拉萨到西宁再转车，真是一次相当难忘的硬座经历。虽然匆匆忙忙腿脚肿胀，但遇到些有趣的人始终是种新鲜。 Day 1 贡嘎机场外连绵的山，云彩触手可及的感觉，很凉爽，不过光秃秃的山还是有点荒凉，阳光很炫 停放机场大巴的车站，一出门就被这片云吸引到了，坐在旁边的叔叔说拉萨比这漂亮的云很多，这个太一般了，他们已经习惯了这片土地的蓝天和云，而我这个刚刚落地的游客真的十分激动哇，嘤嘤嘤，超爱高原上的感觉，怎么形容呢，就是会心情变得超级好，好心情养成地啊 来之前准备了红景天，由于时间仓促只提前喝了一天，然而下飞机之后感觉自己一点高原反应都没有，默默地瞎激动，以为自己会是逃脱高反的那个例外，就像当初觉得自己也是那个会逃过警告的人，but，瞎激动的幸运之后高反是说来就来的，晚上头疼的睡不着。 Day 2红景天真特么不管用，第二天头疼头晕还是躺了大半天，还不如连喝几壶热水管用，必须要赞一下的是，本来带的防感冒的药吃了一片居然有治头疼的奇效，在感冒药的助攻下，晕晕乎乎吃了一顿串串。夏天拉萨夜晚的街头很是凉快，于是决定去布宫广场转转。夜晚吃饱了坐在电瓶车上吹着凉风浪荡在一座陌生城市的感觉，贼爽。 傍晚酒店对面的拉萨河，高山和低垂的白云环抱一整座城市。 布宫广场上一对拍婚纱照的恋人。想起回程的火车上遇到的一个妹子，她说起登珠峰途中遇到的一对六十多岁的爷爷奶奶，爷爷说，只有去过珠峰的爱情才是真的爱情。这种高调的秀恩爱的方式，真的很动人。在高海拔缺氧的环境下，我与你一起经历头晕和窒息，一起经受岁月无情的摧残。 Day 3 从这顿早饭开始体验到拉萨的物价之高，这样的包子在我高反胃口不好的情况下，吃了六个还不饱，一块五一个。原来我也可以是一个早饭能吃十几块钱包子的人= = 去的时候正好赶上拉萨的雪顿节，雪顿节又叫酸奶节，他们告诉我说是专门喝酸奶的节日，我觉得是在糊弄我，但我对西藏节日文化也没甚了解，不甚感兴趣，也没去深究。但雪顿节的林卡气氛我是感受到了，比我们春节似乎还要热闹。整个就是全家集体公园春游的感觉。 罗布林卡草地上到处都是来过林卡的藏民，一家人围坐在坐席上，带上酸奶，带上酥油茶，带上不远赶来的美好愿景。 喜欢拉萨的色彩，尤其这种对比强烈的红色和黄色，蓝天，白云，一切都很美丽。 Day 4 波林卡路措姆凉粉店的菜单，排队的人超级多。字很秀气。 点了酸奶，土豆，凉粉。酸奶超级喜欢，加了一勺白砂糖，还有点酸。 布宫的一角，就像童话里的一座宫殿。能想象到历史上权利曾在此集中过。宫殿上方的阳光，明亮刺眼，你只能仰视它，它离你那么近那么远。 龙王潭公园的树荫下看到的布宫背面。布宫真的是360度无死角的美丽。不知道为什么，就是感觉阳光映照下，这片绿很可口的样子，看起来真的很好吃的样子啊。 阳光穿过树隙。这株柳树目测应该几百年历史了，在高原长这么粗壮，它一定经历和见证了很多。 Day 5布宫的门票真的太抢手，200块的门票听说被黄牛炒到了一千多，在一番折腾排队下，终于被放进这个大宫殿。不过在参观过程中，除了游客对各种精致奢华的惊叹，还有那些朝拜者的认真和虔诚。可以看到一家人把坐在轮椅上的老人从山脚下一级级石阶往上抬，也可以看到七旬的两个老奶奶大概是姐妹吧，相互搀扶一起双手合十，一起磕长头，一起留着长长的辫子。不羡慕这虔诚的信仰，但羡慕这种跨越时间温暖的陪伴。不管你去哪儿，都和你一起。 布宫的一角，红色的墙壁里面是一种高原上的草。惊叹于古人的建筑智慧和手艺。 进入主要的宫殿参观文物前最后能拍照的地方。 同行的一个小妹妹，红墙的映衬下，宛若一只仙女。 出布宫后在山上俯瞰整个拉萨，布宫就是整个拉萨的观景台。 格桑花盛开的山坡，此时山顶上的布宫十分安静。 大昭寺门前磕长头的朝拜者。我是看客，无法理解信仰的力量，但激动于世界上还有这样一群人。 八廓街的一角，蓝天，云朵，建筑，一切都温柔和谐。 八廓街上一家叫南卡的冷饮店。名字很美丽。 一对环绕大昭寺磕长头的姐妹，她们还很小，但我好像看到了在布宫那一对磕头相扶的老奶奶。 阴影里的长椅上坐了一排在转经的老爷爷。朋友调侃道，我那么帅你不拍我，去拍老头子。但是，一排老爷爷排排坐真的很可爱啊。 Day 6早晨七点就坐车去纳木错，七点的拉萨还有些黑，尽管穿了外套街头还是很冷。但天微微亮的时候，拉萨的街头十分美丽。 圣湖就是圣湖，远远的就被迷住了。蓝天，云彩，雪山，清水。天空就像是湖水的倒影。坐在湖边发呆，感觉都很美好。 阳光倾泻而下。此处该有个美丽的仙仙的背影= = 再来一张透明的湖水。 一个仙仙的小姐姐的背影，超美，嘤嘤嘤 湖边一个浅滩，云朵和人群的倒影。 海拔5190米，那拉根山口飘舞的经幡。途中总有那么一抹颜色吸引了你，总有那么一个人惊艳于你。 青藏线上的黄昏。安静，美丽。 The End]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>tour</tag>
        <tag>lahsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题配置---打赏功能+文章结束标志]]></title>
    <url>%2F2017%2F08%2F10%2Fblog-donate%2F</url>
    <content type="text"><![CDATA[这次介绍一下next主题下添加打赏功能，以及在每篇文章末尾统一添加“文章结束”标志 ~~~吼吼吼 打赏功能首先在主题配置文件即hexo/themes/next/_config.yml找到version字段，查看自己的next主题的版本，如下图所示，我用的next主题的版本为5.1.2 在网上查了一些添加打赏功能的方法，参照来做的时候，发现了一些问题，可能是由于next主题升级到version5后自身增加了些隐藏的新功能，所以在网上找到的别人的一些方法不太适用，下面的添加文章结束功能也是如此。因此自己尝试设置好后特来分享一哈~ 在主题配置文件找到Reward字段部分，如下图所示，其中reward_comment字段设置你的打赏介绍，wechatpay和alipay分别为你保存微信以及支付宝收款二维码的路径，可以是本地路径，也可以是用图床生成的链接地址。我是把图片放在本地的，即将两个二维码图片放在了next/source/images文件夹下。 此时默认的打赏按钮如下，略丑。。。然后作了小小改动，把打赏按钮变好看一点点 ~~~ 改动方法如下：在hexo\themes\next\layout_macro下找到reward.swig文件，这个文件是关于打赏功能样式设置的。用下面代码覆盖原文件中的代码即可。由于保存的自动生成的微信及支付宝二维码图片的大小不一，且原图略大，所以可以通过设置包裹两幅图片的div元素的宽度和高度（代码两处注解处）来限制图片的大小，使其更加美观。宽度和高度可以依据自己喜欢更改大小。当然也可以自己使用图片处理工具将 12345678910111213141516171819202122232425262728293031&lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt; &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt; &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; style=&quot;width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt; 打赏 &lt;/button&gt; &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt; &#123;% if theme.wechatpay %&#125; &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt; &lt;p&gt;WeChat Pay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.alipay %&#125; &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt; &lt;p&gt;Alipay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.bitcoin %&#125; &lt;div id=&quot;bitcoin&quot; style=&quot;display: inline-block&quot;&gt; &lt;img id=&quot;bitcoin_qr&quot; src=&quot;&#123;&#123; theme.bitcoin &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Bitcoin&quot;/&gt; &lt;p&gt;Bitcoin&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt; 调整后的效果见下图，是不是稍微不那么丑了一点点呢，红红火火恍恍惚惚~~~~ 文章结束标志本以为这是一个非常简单的小功能，其实的确是一个很简单的功能，但由于参考的人家的做法可能不适于我使用的版本，导致这个小小的问题又折腾了好久T T 在hexo\themes\next\layout_macro文件夹下新建passage-end-tag.swig文件，并添加代码如下： 1&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 其中的 &lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;为FontAwesome图标,可以在其中挑选自己喜欢的图标，我选了一个笑脸，嘻嘻(●’◡’●) 然后打开hexo\themes\next\layout_macro文件夹下的post.swig文件，在 END POST BODY这段注解后添加如下图框框中的代码： 具体代码如下： 12345&#123;% if theme.passage_end_tag.enabled and not is_index %&#125; &lt;div&gt; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 再然后，打开主题配置文件hexo/themes/next/_config.yml，在末尾添加如下代码： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 效果如下图所示： 最后，运行下hexo g -d 看下部署到github后的效果吧！ PS:比较坑的一点，我使用的markdownpad，使用Tab缩进打代码块时，在右侧预览区可以正常显示代码块文本，但是 hexo s 在本地浏览器预览后，代码块文本却没有正确完整的显示，有些html标签被解释掉了。好像是Tab缩进可以被markdownpad的解释器正确解释，但是hexo的解释器却没有将其正确解析。后面换了一种打代码块的方式，就可以在浏览器正确显示了，但在markdownpad的预览区却没得到正常显示。即在代码块的最前面和最后面单独一行使用三个反引号 ```。如下图所示。 效果显示如下：]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于hexo和github搭建个人博客概述]]></title>
    <url>%2F2017%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言：第一次写博客，小激动~~~分享总结下用hexo+github搭建个人博客的过程，以及过程中遇到的问题。（我用的win10 64位系统） 环境介绍 hexo 根据hexo官网的介绍，hexo是一个快速简洁且高效的博客框架。hexo利用markdown等渲染引擎解析文章，快速生成静态网页。 Hexo是基于node.js的, 在安装它之前需要用到npm安装工具, 这个工具是 node.js 安装包的工具, 所以需要先安装 node.js。 关于hexo搭建博客原理进一步了解-hexo原理浅析。 node.js node.js是运行在服务端的javascript，是一个允许开发人员使用javascript语言编写服务端代码的框架。 npm npm是随同node.js一起安装的包管理工具，能解决node.js代码部署上的很多问题。允许用户从npm服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 新版的node.js已经集成了npm，所以下载安装node.js也一并将npm安装好了。 git git是一种非常流行的分布式版本控制系统，它和其他版本控制系统的主要差别在于git只关心文件数据的整体是否发生变化，而大多数版本其他系统只关心文件内容的具体差异。 我们利用git将hexo生成的静态博客页面，部署到github pages上。关于git的更多了解。 github 随着git迅速成为最流行的分布式版本控制系统，github网站上线了。github是一个基于git的代码托管平台，它为开源项目免费提供git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。 搭建步骤1.环境准备（node.js，git，github相关设置） 2.hexo下载安装 3.hexo相关配置 4.hexo与github pages链接 5.发布第一篇博文 6.hexo主题介绍及配置 7.hexo第三方服务集成（disqus评论，百度分享，访客记录等） 环境准备node.js下载安装node.js下载 下载完成后一路默认next即可。利用win+R打开命令窗口，在命令窗口中输入以下命令，可以查看node和npm的版本信息。如果可以正确显示版本信息，说明安装正确，否则检查安装过程，重新安装。 node -v npm -v 结果如下图所示。 git下载安装git下载 下载完成后一路默认next即可。在命令窗口中输入以下命令，可以查看git的版本信息。 git --version 结果如下图所示。 github注册相关若没有注册过github账号，在github官网按照步骤注册成功就好。 注册登录后，在页面右上角+号选择New repository创建新的代码仓库。 在Create a new repository页面下，填写Repository name框框，框框中填写yourname.github.io，其中yourname为Owner框框中的那个名字。再勾选一下Initialize this repository with a README 。 正确创建代码仓库后，需要开启github pages功能。在刚刚新建的代码仓库界面点击Settings，就会打开这个库的设置页面，向下拖动，会看见GitHub Pages，点击Launch Automatic page generator，github 自动创建出一个github pages页面。然后你可以试着访问yourname.github.io这个网址。 hexo下载安装在合适的盘，例如以E盘为例，在E盘根目录下新建hexo文件夹，然后右键点击选中hexo,选择Git Bash Here,在git命令窗口中输入以下命令： $ npm install hexo-cli -g 然后输入 $ npm install hexo --save 建议将hexo以下插件一起安装了 $ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ npm install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 (或者可以执行 npm install命令，npm会自动安装部分组件，但自己试了下，用npm命令不能安装全组件，部分组件还需自己手动安装，比如最重要的用于部署功能的组件 hexo-deployer-git 用 npm install命令就没装上。可以在hexo/node_modules文件下查看已经安装了的组件。) 安装完成后可查看下所安装的hexo版本信息。在hexo文件夹下右键进入git bash,输入以下命令: $ hexo -v 若看到类似如图所示版本信息说明hexo安装成功。 hexo相关配置 hexo初始化 -&gt;在hexo文件夹下右键进入git bash,输入以下初始化命令： $ hexo init hexo生成 -&gt;输入以下命令生成静态页面: $ hexo g 本地服务 -&gt;输入以下命令建立本地hexo预览： $ hexo s(确保已经安装了hexo-server组件，否则该命令无效） 执行完 hexo s 命令后会提示 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开上述链接地址，会看到hexo默认的主题页面，至此hexo本地配置完成。 PS：注意！！！安装了福昕阅读器的朋友，福昕阅读器会占用4000端口，导致 hexo s 命令后出错提示4000端口被占用。你可以在hexo/_config.yml站点配置文件里修改端口号，换成自己想设置的端口即可，如下修改： server: port: 4001 compress: true header: true hexo与github pages链接 deployment配置 -&gt;在hexo/_config.yml站点配置文件里，修改下面的字段内容如下： deploy: type: git repo: https://github.com/yourname/yourname.github.com.git #yourname即为创建仓库时的那个yourname branch: master PS:注意.yml格式文件冒号后面有一个空格。 发布第一篇博文在hexo文件夹下右键进入git bash,输入以下命令即可生成一篇新文章： hexo new post &quot;post_title&quot; #其中post_title为你想新建文章的文件名 此时在 E:\hexo\source\ _posts 下生成一个 post_title.md 文件（此后你可以用markdown编辑器打开该.md文件就可以编辑文章了）。 然后运行下面两条命令即可将新建的文章生成-&gt;部署到github上。 hexo g #生成 hexo d #部署 部署完毕后，即可访问https://yourname.github.io看到刚刚生成部署到github的文章。 PS：以后每次用markdown编辑器修改post_title.md文件后，记得用 hexo g -d 命令来生成和部署。修改完配置后也要hexo g -d一下。 PPS:hexo常用命令 hexo new post &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo主题介绍及配置我选用的较为简洁大方的next主题。 next主题下载 -&gt;在hexo文件夹下右键进入git bash,输入以下命令： git clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题 -&gt;在hexo/_config.yml站点配置文件下，修改如下字段： theme: next 测试主题启用是否成功 -&gt;执行 hexo s命令，在浏览器访问 http://localhost:4000查看主题效果。 PS：主题的其他相关设置可以参考该博客，写的很详细手把手教你用Hexo+Github 搭建属于自己的博客。 hexo第三方服务集成添加disqus评论由于以前国内使用较多的多说评论下架了，所以选用了国外较为稳定的disqus，但使用该评论功能需要“科学上网”！ 注册disqus账号https://disqus.com 在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为https://yourname.github.io), 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。 打开hexo/themes/next/_config.yml主题配置文件，修改下面字段： #Disqus disqus: enable: true shortname: #shortname即为你上面填写的唯一disqus路径，填上就好 count: true 添加百度分享功能百度分享功能的添加可以参考下面这篇博客。Hexo+Github搭建个人博客(三)——百度分享集成 百度统计访客访问量功能其他酷炫小功能参考hexo的next主题个性化教程:打造炫酷网站。 参考博客手把手教你用Hexo+Github 搭建属于自己的博客 记录第一次搭建hexo 嘤嘤嘤~~~THE END!]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
