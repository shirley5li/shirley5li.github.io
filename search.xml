<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【interview questions about Web】]]></title>
    <url>%2F2018%2F03%2F04%2Finterview-questions-about-Web%2F</url>
    <content type="text"><![CDATA[Web方面的知识盲区补漏。 匹配URL的正则表达式URL由三部分组成：资源类型(协议)、存放资源的主机域名、资源文件名。URL的一般语法格式为(带方括号[ ]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment据说比较好用匹配较全面的是这个：(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]参考自博客正确匹配URL的正则表达式、匹配URL的正则表达式解析。 React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快将数据的变化实时反映到UI上，这时需要对DOM进行操作，但复杂或频繁的DOM操作(会造成重排、重绘)通常是性能瓶颈产生的原因，为此，React引入了虚拟DOM（Virtual DOM）的机制。 虚拟DOM? 在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，称之为virtual DOM。(是不是跟文档片段有异曲同工之妙？dom中的文档碎片) 虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法 (深入浅出React（四）：虚拟DOM Diff算法解析)。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。 虚拟DOM对比原生操作DOM原生操作DOM方式，使用 innerHTML。在一个大型列表所有数据都变了的情况下，还算是合理，但当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。innerHTML: render html string + 重新创建所有 DOM 元素Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。 存疑React虚拟DOM的工作机制还不太理解，深入学习以后需要再回顾。React虚拟DOM浅析React 的 diff 算法为什么 React 的 virtual DOM 比原生的DOM 渲染性能更好？ RESTfulREST(Representational State Transfer)，“表述性状态转移”，是一种网络应用架构规范，目标是构建可扩展的web service。REST规范可以提高架构的性能和可维护性。REST是一种更简单的SOAP协议及以WSDL为基础的web service的替代。(SOAP暴露接口，REST暴露资源)参考博客WebService两种发布协议–SOAP和REST的区别。RESTful（采用REST架构规范的）系统通常是通过HTTP协议，并且使用HTTP的GET,POST,PUT,DELETE等动词来收发数据。W3C TAG开发了REST架构，基于HTTP 1.0。万维网代表了最大的REST架构实现，你可以认为所有的网页服务器都是采用REST架构的RESTful系统。目前在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。常见的三种Web服务架构。 WebView相关先了解什么是Hybrid APP。所谓Hybrid,即混合开发,意味着半原生半Web,其实在H5兴盛之前,Hybrid模式就已经比较成熟了,但是一直不愠不火(因为系统的一些现在以及html本身功能的限制)。怎么样的开发模式才算是Hybrid模式呢： Hybrid是半Native半web开发模式Hybrid模式中,底层功能API均由原生容器通过某种方式提供,然后业务逻辑由H5页面完成,最终原生容器加载H5页面,完成整个App 成熟的Hybrid模式意味着业务逻辑均由H5实现一款成熟的Hybrid框架,意味着各种类型的api都很完善,那么这时候几乎所有与业务相关的逻辑都是放在H5页面中的,原生只作为容器存在 成熟的Hybrid模式可复用性非常高,可以跨平台开发成熟的Hybrid框架,那么原生只会提供底层API,也就是说所有的业务是H5完成,不管是什么项目,业务只由H5实现,这时候就可以发现,业务代码是可以跨平台的,也就是说,开发一次,就可以和各自原生容器结合,组成两种原生安装包了,达到了跨平台开发效果 APP三种开发模式–之–HybridApp解决方案 原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。在Html5没有兴盛之前,加载的Html往往只能用来做一些简单的静态资源显示,但是H5大行其道以后,Html5中有很多新增的功能,炫酷的效果,特别是iOS中H5支持一直都很良好,Android 4.4以上支持也足够,所以这时候发现可以将一些主要的逻辑都用H5页面来编写,然后原生直接用webview加载显示,这样大大提高了开发效率,而且体验也很不错。webview用来展示网页的view组件，该组件是你运行自己的浏览器或者在你的线程中展示线上内容的基础。使用webkit渲染引擎来展示，并且支持前进后退等基于浏览历史，放大缩小，等更多功能。简单来说WebView是手机中内置了一款高性能 webkit 内核浏览器,在 SDK 中封装的一个组件。不给过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。参考文章前端解读Webview、WebView JavascriptBridge机制解析、JS交互与WebView的工作原理浅析。]]></content>
      <categories>
        <category>interview questions</category>
      </categories>
      <tags>
        <tag>interview questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about JS】 from牛客网]]></title>
    <url>%2F2018%2F02%2F27%2Finterview-questions-about-JS%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试经典题目合集 篇学习总结。 Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。优点：1) 数据持久性。2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。4) 简单性。 基于文本的轻量结构。5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。缺点：1) Cookie 数量和长度的限制 。数量：每个域的 cookie 总数有限。 a) IE6 或更低版本最多 20 个 cookie b) IE7 和之后的版本最后可以有 50 个 cookie c) Firefox 最多 50 个 cookie d) chrome 和 Safari 没有做硬性限制 长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。2) 潜在的安全风险。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能暴露所有的 session 信息。3)额外开销。 cookie 在每次发起 HTTP 请求的时候都会被发送给服务器，一些不需要的信息也有可能会被发送，会增加开销。4) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。5) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储1)Cookie ：广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。优点：容量适中，基本上不存在兼容性问题缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）（实际测试 2000(IE5.5)、 XP(IE6 、 IE7)， Vista(IE7)下都是可正常使用。）5)indexedDB : indexedDB是适合在本地存储大量非关系型数据（NOSQL），采取的是事件+异步回调进行操作。6)Web Storage在较高版本的浏览器中， JS 提供了 sessionStorage 和 globalStorage 。在 HTML5 中提供了 sessionStorage 和 localStorage 。sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上，即要求同源，不能跨域。 优点：容量大、易用、强大、原生支持缺点： a) 兼容性差（ Chrome,Safari,Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）b) 安全性差（所以请勿使用 localStorage 保存敏感信息）c)跨域限制用途：localStorage 可以利用持久化数据本地存储的特点来做网站优化，把一些静态资源，存储在本地，但是这个意义对PC端可能相对小一些，PC端的网速一般比较理想，读取本地localStorage的消耗 和读取服务器的消耗优化不了多少，而且存在本地localstorage的维护成本，总体性价比一般，移动端是可以利用这一点做一些优化，移动端的网络环境还是没达到理想，所以读取localstorage的代价应该小于服务器加载。 Web Storage 与 Cookie 的区别1 、 Web Storage 中的数据仅在存在本地，不与服务器发生交互。Cookie 中的数据会在浏览器和服务器中来回传递。2 、 Web Storage 存储空间更大，可以达到 5M。Cookie 数据大小不超过 4KB 。3 、 Web Storage 提供更多丰富易用的接口，如 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。Cookie 需要自己封装方法。4 、 cookie 需要指定作用域，不可以跨域调用，同样Web Storage 也存在跨域问题。5、 cookie 中的数据在过期时间之前均有效， Web Storage 则不同， sessionStorage 中的数据在当前浏览器窗口关闭后自动删除， localStorage持久存储数据，除非主动删除数据。 注： 但 Cookie 是不可以或缺的，Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地 “ 存储 ” 数据而生。 position的absolute与fixed共同点与不同点共同点：1.改变行内元素的呈现方式，display被置为inline-block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上 不同点：absolute的“根元素”是可以设置的，在父元素上设定定位relative；而fixed的“根元素”固定为浏览器窗口。当滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 CSS 哪些属性可以继承? CSS3新增伪类?可继承的样式：1.font-size2.font-family3.color4.text-indent不可继承的样式：1.border2.padding3.margin4.width5.heightCSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 CSS3的新特性答题套路：在我们的项目中经常用CSS3中的XX属性来实现XX特效。 CSS3实现圆角（border-radius），阴影（box-shadow） 对文字加特效（text-shadow、），线性渐变（gradient） transform变换: rotate(9deg); scale(0.85,0.90); translate(0px,-30px); skew(-9deg,0deg) // 旋转,缩放,定位,倾斜 动画animation 增加了更多的CSS选择器 多背景 rgba() 在CSS3中唯一引入的伪类是 ::selection. 媒体查询，多栏布局 border-image CSS sprites 的理解及使用CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”background-image”，”background-repeat”，”background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。 HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。 所以客户端只需要一个连接就能加载一个页面。参见博客HTTP1.0、HTTP1.1和HTTP2.0的区别。 Doctype文档类型 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML之间的区别1、XHTML 元素必须被正确地嵌套，不正确嵌套会报错。错误：&lt;p&gt;&lt;span&gt;this is example.&lt;/p&gt;&lt;/span&gt;正确：&lt;p&gt;&lt;span&gt;this is example.&lt;/span&gt;&lt;/p&gt;而html不被正确嵌套也不会报错。2、 XHTML 元素必须被关闭，即使是空标签&lt;/br&gt;，否则报错。而html可以写成&lt;br&gt;而不报错。3、 XHTML 标签名必须用小写字母。html可以大写。4、 XHTML 文档必须拥有根元素html，所有的 XHTML 元素必须被嵌套于 根元素中。而html不是必须的。 DOM操作——怎样添加、移除、移动、复制、创建和查找节点1、 创建新节点 createDocumentFragment() // 创建一个DOM片段 createElement() // 创建一个具体的元素 createTextNode() // 创建一个文本节点 2、 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() // 在已有的子节点前插入一个新的子节点 3、查找 getElementsByTagName() // 通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) document.getElementById() // 通过元素Id，唯一性 getElementsByClassName() //通过类名 queryselector() querySeletorAll() // (IE67 不支持) html5 的新特性以及新标签的浏览器兼容问题新特性：HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。1、拖拽释放(Drag and drop) API2、语义化更好的内容标签（header,nav,footer,aside,article,section）3、 音频、视频API(audio,video)4、 画布(Canvas) API5、 地理(Geolocation) API6、 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；7、 sessionStorage 的数据在浏览器关闭后自动删除8、 表单控件，calendar、date、time、email、url、search9、 新的技术webworker, websocket, Geolocation移除的元素：1、 纯表现的元素：basefont，big，center，font, s，strike，tt，u；2、 对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签： IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）： &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 如何区分：DOCTYPE声明新增的结构元素、功能元素 iframe的优缺点优点：1、 解决加载缓慢的第三方内容如图标和广告等的加载问题2、 Security sandbox3、 并行加载脚本4、 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)5、 方便制作导航栏缺点：1、 iframe会阻塞主页面的Onload事件2、 即时内容为空，加载也需要时间3、 没有语意4、 会产生很多页面，不容易管理5、 不容易打印6、 浏览器的后退按钮无效7、 代码复杂,无法被一些搜索引擎索引到8、 多数小型的移动设备（PDA 手机）无法完全显示框架9、 多框架的页面会增加服务器的http请求10、 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃 webSocket 如何兼容低浏览器Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 线程与进程的区别进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位。1、 一个程序至少有一个进程,一个进程至少有一个线程2、 线程的划分尺度小于进程，使得多线程程序的并发性高3、 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率4、 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制5、 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别 如何对网站的文件和资源进行优化1、 文件合并2、 文件最小化/文件压缩3、 使用 CDN 托管4、 缓存的使用（多个域名来提供缓存）雅虎军规：1、尽可能减少http请求次数，将css, js, 图片各自合并2、使用CDN，降低通信距离3、添加Expire/Cache-Control头4、启用Gzip压缩文件5、将css放在页面最上面6、将script放在页面最下面7、避免在css中使用表达式8、将css, js都放在外部文件中9、减少DNS查询10、最小化css, js，减小文件体积11、避免重定向12、移除重复脚本13、配置实体标签ETag14、使用AJAX缓存，让网站内容分批加载，局部更新 三种减少页面加载时间的方法1、 优化图片2、 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）3、 优化CSS（压缩合并css，如 margin-top, margin-left…)4、 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）5、 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）6、 减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面 测试JS代码性能的工具如何测试javascript代码的性能？—知乎1、 浏览器debug中现在都有原生的profile功能，可定位那个函数调用得多，用的时间多，这个可以比较精确定位耗时的函数。2、JSPerf 使用Benchmark.js和jsPerf分析代码性能3、 Dromaeo 前端性能测试：Page Speed OnlineGoogle Page Speed 是当下很流行的在线测试网站性能工具，基于Google的一套最佳的前端性能的规则，你可以很方便得到大量的性能信息，甚至还提供了移动设备的最佳实践报告WebPagetestWebPagetest 是性能测试的黄金标准，它提供了多方面的量化指标用于性能测试，比如有一个基本的评分，用于评价当前页面优化的水平；有一个截图，显示页面加载后的视觉效果；还有一个浏览器加载资源的瀑布流…根据用户浏览器真实的连接速度，在全球范围内进行网页速度测试，并提供详细的优化建议。前端性能测试必备工具清单前端性能优化和测试工具总结推荐10个免费在线测试网页性能工具 什么是 FOUC？ 如何来避免 FOUC？FOUC - Flash Of Unstyled Content 文档样式闪烁使用&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; @import导入外部样式文件时，IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决办法：将@import换成link，link是顺序加载，这样页面就会等css下载完之后再下载html文件，这样就先布好了局，所以就不会出现focus闪烁问题。 null和undefined的区别null是一个表示”无”的对象，转为数值时为0undefined是一个表示”无”的原始值，转为数值时为NaN 当声明的变量还未被初始化时，变量的默认值为undefinednull用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：1、 变量被声明了，但没有赋值时，就等于 undefined2、 调用函数时，应该提供的参数没有提供，该参数等于 undefined3、 对象没有赋值的属性，该属性的值为 undefined4、 函数没有返回值时，默认返回 undefined null表示“没有对象”，即该处不应该有值。典型用法是：1、 作为函数的参数，表示该函数的参数不是对象2、 作为对象原型链的终点 new操作符具体干了什么1、 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型2、 属性和方法被加入到 this 引用的对象中3、 新创建的对象由 this 所引用，并且最后隐式的返回 this //var obj = new Base(); var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); JSONJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;} json.stringify({a:10,b:20}); //json对象转换成字符串 json.parse(&apos;{&quot;a&quot;:10,&quot;b&quot;:20}&apos;) //字符串转换成json对象 博客—对json的理解 js延迟加载的方式JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。JS延迟加载有助于提高页面加载速度。 defer 属性 async 属性 动态创建DOM方式 使用jQuery的getScript方法 使用setTimeout延迟方法 让JS最后加载 1、 deferHTML 4.01 为 &lt;script&gt;标签定义了 defer属性。用途：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕之后再执行。defer属性只适用于外部脚本文件。支持 HTML5 的实现会忽略嵌入脚本设置的 defer属性。2、 asyncHTML5 为 &lt;script&gt;标签定义了 async属性。与defer属性类似，都用于改变处理脚本的行为。同样，只适用于外部脚本文件。目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。异步脚本一定会在页面 load 事件前执行。不能保证脚本会按顺序执行。3、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）4、 按需异步载入js(可以将js文件加载绑定到一个事件上，这样当事件发生时，才会加载相应的js文件)JS延迟加载的几种方式 解决跨域问题1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 前端常见跨域解决方案（全）关于跨域的简单demo集合–github documen.write和 innerHTML 的区别document.write 只能同步执行，如果在window.onload之前执行则在文档流中绘制内容，如果在window.onload之后则会重绘整个页面（之前内容被冲刷掉）innerHTML 则是绘制某个元素内的内容，没有这个限制 .call() 和 .apply() 的作用改变上下文，即this的指向。apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)方法能接收两个参数obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function（args–&gt;arguments） call:和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表 哪些操作会造成内存泄漏内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 全局变量引起的内存泄漏 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） dom清空或删除时，事件未清除导致的内存泄漏，脱离 DOM 的引用JavaScript内存泄露的4种方式及如何避免JavaScript常见的内存泄漏原因JavaScript 内存泄漏教程—阮一峰 如何判断当前脚本运行在浏览器还是node环境中通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境。 exports = typeof window === &apos;undefined&apos; ? global : window ; //获取全局对象的方式 //同理可得，typeof window可以用来判断是不是在浏览器环境中 Node.js的优缺点优点： 1、 高并发。采用事件驱动，异步编程，为网络服务而设计。NodeJS能支持比Java、PHP程序更高的并发量，虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上还是会力不从心。 2、 适合I/O密集型应用。 node.js非阻塞模式的IO处理给node.js带来在相对较低的资源耗用下的高性能与出众的负载能力,适合处理并发请求。 3、 node.js轻量高效，可以认为是数据密集型实时应用系统的完美解决方案。 4、 js语言适合前端工程师上手。 5、 社区活跃发展速度快缺点： 1、 单线程，单进程，只支持单核CPU，不能充分的利用多核CPU服务器。 2、 对程序员要求高一旦进程崩溃，那么整个web服务器就崩溃了。 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；（2）开多个进程监听同一个端口，使用cluster模块； 3、 不适合做复杂性很高的计算。 4、 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起； 5、 开源组件库质量参差不齐，更新快，向下不兼容 6、 Debug不方便，错误没有stack traceNodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。NodeJS优缺点及适用场景讨论 前端界面工程师 理解及前景 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。1、 实现界面交互2、 提升用户体验3、 有了Node.js，前端可以实现服务端的一些事情4、 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好5、 参与项目，快速高质量完成实现效果图，精确到1px；6、 与团队成员，UI设计，产品经理的沟通；7、 做好的页面结构，页面重构和用户体验；8、 处理hack，兼容、写出优美的代码格式；9、 针对服务器的优化、拥抱最新前端技术。 http状态码1xx: 信息性状态码，表示服务器接收到请求正在处理。2xx: 成功状态码，表示服务器正确处理完请求。3xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。301永久重定向，302临时重定向。4xx: 客户端错误状态码，服务器无法处理该请求。 404 not found5xx: 服务器错误状态码，服务器处理请求出错。 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置302 Found 临时性重定向303 See Other 临时性重定向，且总是使用 GET 请求新的 URI304 Not Modified 自从上次请求后，请求的网页未修改过400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求401 Unauthorized 请求未授权403 Forbidden 禁止访问404 Not Found 找不到如何与 URI 相匹配的资源500 Internal Server Error 最常见的服务器端错误503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） 页面加载过程1、 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。(DNS查询方式：浏览器缓存-&gt;系统缓存-&gt;路由器缓存)2、 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。3、 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。4、 此时，Web 服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM 如何管理项目1、 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等2、 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）3、 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）4、 页面进行标注（例如 页面 模块 开始和结束）5、 CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）6、 JS 分文件夹存放 命名以该 JS 功能为准的英文翻译7、 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 javascript对象的几种创建方式1、工厂模式2、构造函数模式3、原型模式 javascript继承的 6 种方法1、 原型链继承2、 借用构造函数继承3、 组合继承(原型+借用构造)4、 原型式继承5、 寄生式继承6、 寄生组合式继承JS继承的实现方式 ajax 的过程1、 创建XMLHttpRequest对象,也就是创建一个异步调用对象var xhr = new XMLHttpRequest()2、 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息xhr.open(url,&quot;get&quot;,false);3、 设置响应HTTP请求状态变化的函数onreadyState监听4、 发送HTTP请求如果是post必须发送xhr.send(null);(null不能为空)5、 获取异步调用返回的数据6、 使用JavaScript和DOM实现局部刷新 var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function(){ if(xhr.readyState===4){ if(xhr.status===200){ doResponse(xhr.responseText); } } } xhr.open(&apos;GET&apos;,&apos;URL&apos;,true); xhr.send(null); xhr.open(&apos;POST&apos;,&apos;URL&apos;,true); setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(&apos;k=v&amp;k=v&apos;); 异步加载和延迟加载把script标签放在head之间，意味着必须等到全部js代码都被下载，解析，执行完成之后，才开始呈现页面的内容。浏览器在遇到body标签时才开始呈现内容 1、&lt;script&gt;标签定义了defer属性，这个属性的用途表明脚本在执行的时候不会影响页面结构，相当于告诉浏览器立即下载，但延迟执行。注意defer属性只使用于外部脚本文件，支持html5的实现会忽略给嵌入脚本设置的defer属性。因此把延迟脚本放在页面的底部仍是最佳的选择&lt;script type = &quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;.js&quot;&gt;2、异步脚本async只使用于外部脚本文件，并告诉浏览器立即下载文件，但与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。&lt;script type = &quot;text/javascript&quot; async src=&quot;.js&quot;&gt; 前端的安全问题1、XSS指cross-site-scripting, 跨站脚本攻击，恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 浅谈XSS攻击的那些事（附常用绕过姿势）2、SQL注入，指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。SQL注入攻击原理以及基本方法3、OS命令注入攻击，指的是通过web应用，执行非法的操作系统命令达到非法攻击的目的。4、HTTP首部注入攻击，指攻击者通过在相应首部字段内插入换行，然后添加任意响应首部过主体的攻击。 邮件首部注入攻击，指攻击者通过向邮件首部to或subject内任意添加非法内容引起的攻击。攻击服务端(4)-HTTP参数注入攻击5、会话劫持，指攻击者通过某种手段拿到了用户的会话id，并非法使用此会话id伪装成用户达到攻击的目的。 6、还有DoS DDoS，一种让运行中的服务成停止状态的攻击。7、CSRF，跨站点请求伪造攻击，指的是攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等 CSRF攻击与防御 ie 各版本和 chrome 可以并行下载多少个资源1、 IE6 2 个并发2、 iE7 升级之后的 6 个并发，之后版本也是 6 个3、 Firefox，chrome 也是6个 js继承怎么实现，如何避免原型链上面的对象共享1、 原型链继承2、 借用构造函数继承3、 组合继承(原型+借用构造)4、 原型式继承5、 寄生式继承6、 寄生组合式继承利用空对象作为中介。Javascript面向对象编程（二）：构造函数的继承 —阮一峰 代码压缩工具及使用方法1、Google Closure Compile2、Yahoo Yui Compresso3、UglifyJSGCC压缩混淆的最彻底，但是破坏原有代码，并且不可压缩CSS文件，运行在java环境下，危险，要严格注意书写规范。Yui可以压缩CSS文件，安全，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，运行在java环境下。UglifyJs不可以压缩混淆CSS文件，运行在NodeJs环境下，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，安全JS代码压缩混淆工具使用说明 Flash、Ajax各自的优缺点，在使用中如何取舍Flash：1、 Flash适合处理多媒体、矢量图形、访问机器2、 对CSS、处理文本上不足，不容易被搜索Ajax：1、 Ajax对CSS、文本支持很好，支持搜索2、 多媒体、矢量图形、机器访问不足共同点：1、 与服务器的无刷新传递消息2、 可以检测用户离线和在线状态3、 操作DOM JavaScript 的同源策略概念：同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。同源策略是浏览器为了保护用户的个人信息以及企业数据的安全而设置的一种策略，不同源的客户端脚本是不能在对方未允许的情况下访问或索取对方的数据信息。 为什么要有同源限制：我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 什么是 “use strict” ? 使用它的好处和坏处ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。设立”严格模式”的目的，主要有以下几个：1、 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;2、 消除代码运行的一些不安全之处，保证代码运行的安全；3、 提高编译器效率，增加运行速度；4、 为未来新版本的Javascript做好铺垫。注：经过测试 IE6,7,8,9 均不支持严格模式。缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制 GET方式需要使用 Request.QueryString 来取得变量的值POST方式通过 Request.Form 来获取变量的值也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。 在以下情况中，请使用 POST 请求：1、 无法使用缓存文件（更新服务器上的文件或数据库）2、 向服务器发送大量数据（POST 没有数据量限制）3、 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 HTTP方法 是根据意图区分的，HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。表面区别：(1)传参方式1、 GET可以通过URL直接传参2、 两者都可以通过body传参(2)长度1、 header和body都没有对长度的限制2、 URL的长度受到部分早期浏览器的限制3、 URL的长度还可能受到服务器的限制，由于URL的实际超长或者设定其Content-Length较大值会引起服务器最大并发数下降或者资源空耗4、 2和3间接限定了URL方式发起GET方法的长度(3)安全性1、 GET不会修改服务端数据，POST可以修改数据2、 URL方式发起GET请求，参数会明文暴露3、 使用GET提交数据还可能会造成Cross-site request forgery攻击4、 本质上安全性无区别 css阻塞，js阻塞js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。 嵌入JS应该放在什么位置？1、 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。2、 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。3、 使用 defer（只支持IE）4、 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用 Javascript无阻塞加载具体方式：1、 将脚本放在底部。&lt;link&gt;还是放在head中，用以保证在js加载前，能加载出正常显示的页面。&lt;script&gt;标签放在&lt;/body&gt;前。2、 阻塞脚本：由于每个&lt;script&gt;标签下载时阻塞页面解析过程，所以限制页面的&lt;script&gt;总数也可以改善性能。适用于内联脚本和外部脚本。3、 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。4、 defer属性：支持IE4和fierfox3.5更高版本浏览器5、 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下： &lt;script&gt; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; script.src=&quot;file.js&quot;; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script); &lt;/script&gt; 此技术的重点在于：无论在何处启动下载，文件下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）关于CSS加载造成阻塞问题css并不会阻塞DOM树的解析，但会阻塞DOM树渲染。css加载会阻塞后面js语句的执行。为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)css加载会造成阻塞吗 eval()1、 它的功能是把对应的字符串解析成JS代码并运行2、 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 一个通用的事件侦听器函数// event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos; + type, function() { handler.call(element); }); } else { element[&apos;on&apos; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEnentListener) { element.removeEnentListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&apos;on&apos; + type, handler); } else { element[&apos;on&apos; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; Node.js 的适用场景1、 高并发2、 聊天3、 实时消息推送 1 Web开发：Express + EJS + Mongoose/MySQLexpress 是轻量灵活的Nodejs Web应用框架，它可以快速地搭建网站。Express框架建立在Nodejs内置的Http模块上，并对Http模块再包装，从而实际Web请求处理的功能。ejs是一个嵌入的Javascript模板引擎，通过编译生成HTML的代码。mongoose 是MongoDB的对象模型工具，通过Mongoose框架，可以进行访问MongoDB的操作。mysql 是连接MySQL数据库的通信API，可以进行访问MySQL的操作。通常用Nodejs做Web开发，需要3个框架配合使用，就像Java中的SSH。2 REST开发：Restifyrestify 是一个基于Nodejs的REST应用框架，支持服务器端和客户端。restify比起express更专注于REST服务，去掉了express中的 template, render等功能，同时强化了REST协议使用，版本化支持，HTTP的异常处理。3 Web聊天室(IM)：Express + Socket.iosocket.io一个是基于Nodejs架构体系的，支持websocket的协议用于时时通信的一个软件包。socket.io 给跨浏览器构建实时应用提供了完整的封装，socket.io完全由javascript实现。4 Web爬虫：Cheerio/Requestcheerio 是一个为服务器特别定制的，快速、灵活、封装jQuery核心功能工具包。Cheerio包括了 jQuery核心的子集，从jQuery库中去除了所有DOM不一致性和浏览器不兼容的部分，揭示了它真正优雅的API。Cheerio工作在一个非常简 单，一致的DOM模型之上，解析、操作、渲染都变得难以置信的高效。基础的端到端的基准测试显示Cheerio大约比JSDOM快八倍(8x)。 Cheerio封装了@FB55兼容的htmlparser，几乎能够解析任何的 HTML 和 XML document。5 Web博客：HexoHexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。发布时，Hexo可以部署在自己的Node服务器上面，也可以部署github上面。对于个人用户来说，部署在github上好处颇多，不仅可以省 去服务器的成本，还可以减少各种系统运维的麻烦事(系统管理、备份、网络)。所以，基于github的个人站点，正在开始流行起来….6 Web论坛: nodeclubNode Club 是用 Node.js 和 MongoDB 开发的新型社区软件，界面优雅，功能丰富，小巧迅速， 已在Node.js 中文技术社区 CNode 得到应用，但你完全可以用它搭建自己的社区。7 Web幻灯片：CleaverCleaver 可以生成基于Markdown的演示文稿。如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。8 前端包管理平台: bower.jsBower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。9 OAuth认证：PassportPassport项 目是一个基于Nodejs的认证中间件。Passport目的只是为了“登陆认证”，因此，代码干净，易维护，可以方便地集成到其他的应用中。Web应用 一般有2种登陆认证的形式：用户名和密码认证登陆,OAuth认证登陆。Passport可以根据应用程序的特点，配置不同的认证机制。本文将介绍，用户 名和密码的认证登陆。10 定时任务工具: laterLater 是一个基于Nodejs的工具库，用最简单的方式执行定时任务。Later可以运行在Node和浏览器中。11 浏览器环境工具: browserifyBrowserify 的出现可以让Nodejs模块跑在浏览器中，用require()的语法格式来组织前端的代码，加载npm的模块。在浏览器中，调用browserify编译后的代码， JavaScript 原型，原型链 ? 有什么特点？1.什么是原型，原型有什么特点：JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。使用原型的好处是：原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计），也就是说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。每一个构造函数都有一个prototype（原型）属性，这个属性就是使用构造函数创建出来的实例对象的原型对象。2.什么是原型链，原型链有什么特点对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。“原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 怎么重构页面页面重构是一种思想，是页面的二次构造（在实现层次）：包括设计稿的重构、过时页面的重构、功能不全页面的重构、代码重构。设计稿的重构：设计师的设计稿可能不是特别符合页面效果，当拿到设计稿时需要通过二次重构和修改达到预期效果。功能不全页面的重构：页面功能不符合用户体验、用户交互。过时页面的重构：使用的是过时的代码和标签，跟不上时代的发展。代码重构：代码质量、SEO优化、页面性能、更好的语义化、浏览器兼容、CSS优化。 WEB应用从服务器主动推送Data到客户端的方式1、AJAX轮询利用XHR，通过setInterval定时发送请求，但会造成数据同步不及时及无效的请求，增加后端处理压力2、基于 AJAX 的长轮询（long-polling）方式在Ajax轮询基础上做的一些改进，在没有更新的时候不再返回空响应，而且把连接保持到有更新的时候，客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求，通常把这种实现也叫做comet。3、Server-sent-events(SSE)让服务端可以向客户端流式发送文本消息，在实现上，客户端浏览器中增加EventSource对象，使其能通过事件的方式接收到服务器推送的消息，在服务端，使用长连接的事件流协议，即请求响应时增加新数据流数据格式。适应于后端数据更新频繁且对实时性要求较高而又不需要客户端向服务端通信的场景下。缺点： 只能单向通信，服务器端向客户端推送事件；事件流协议只能传输UTF-8数据，不支持二进制流。4、HTTP Streaming通过iframe和&lt;script&gt;标签完成数据的传输5、TCP 长连接6、HTML5 WebSocket可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应服务端是如何主动推送信息到客户端的？几种web服务器端推送技术的简单介绍HTML5服务器推送消息的各种解决办法 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？1、 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为2、 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件3、 ev.stopPropagation();注意旧ie的方法：ev.cancelBubble = true; Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？AJAX 的全称是异步的 Javascript 和 XML ，是一种创建快速动态网页的技术，通过在后台与服务器进行少量数据交互，实现网页的异步更新，在不重新加载整个界面的情况下，做到网页的部分刷新；AJAX 的交互模型（ AJAX 的过程）：用户发出异步请求；创建 XMLHttpRequest 对象；告诉 XMLHttpRequest 对象，哪个函数会处理 XMLHttpRequest 对象状态的改变，为此要把对象的 onReadyStateChange 属性设置为响应该事件的 JavaScript 函数的引用；创建请求，用 open 方法指定是 get 还是 post ，是否异步， url 地址；发送请求， send 方法；接收结果并分析；实现刷新同步异步的区别:同步：脚本会停留并等待服务器发送回复然后再继续异步：脚本允许页面继续其进程，服务器返回结果时再作处理跨域问题的解决1、 使用 document.domain+iframe 解决跨子域问题2、 使用 window.name3、 使用 flash4、 使用 iframe+location.hash5、 使用 html5 的 postMessage ；6、 使用 jsonp （创建动态 script ） js对象的深度克隆代码实现function clone(obj){ if(!obj || typeof(obj) != &apos;object&apos;) return obj; var r = Array.prototype.splice === obj.splice ? []:{}; for(var i in obj){ if(obj.hasOwnProperty(i)){ r[i] = clone(obj[i]); } } return r ; } //数组、对象都可以for in,同时针对对象必须需要判断hasOwnProperty属性，以防克隆原型链上的属性 javascript中对象的深度克隆 网站重构网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。对于传统的网站来说重构通常是：1、 表格(table)布局改为 DIV + CSS2、 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)3、 对于移动平台的优化4、 针对于 SEO 进行优化5、 深层次的网站重构应该考虑的方面6、 减少代码间的耦合7、 让代码保持弹性8、 严格按规范编写代码9、 设计可扩展的API10、 代替旧有的框架、语言(如VB)11、 增强用户体验12、 通常来说对于速度的优化也包含在重构中13、 压缩JS、CSS、image等前端资源(通常是由服务器来解决)14、 程序的性能优化(如数据读写)15、 采用CDN来加速资源加载16、 对于JS DOM的优化17、 HTTP服务器的文件缓存 如何获取UA浏览器标识（UA,User Agent）可以使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件，从而判断用户是使用电脑浏览还是手机浏览，让网页作出自动的适应。使用navigator对象:1、Navigator.appCodeName,浏览器代码名的字符表示2、appName，浏览器的名称3、appVersion 返回broswer平台和版本信息4、platform，返回运行浏览器的操作系统平台5、userAgent，返回客户机发送给服务器的useragent头部的值 &lt;script&gt; function whatBrowser() { document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; } &lt;/script&gt; js 数组去重1、 function uniqArray(arr) { //利用es6 新的数据类型，Set() 集合来做，集合不的每个元素是不允许重复的 return [... new Set(arr)]; //return Array.from(new Set(arr)); } 2、 Array.prototype.filterOverlap = function(){ var temp = []; if(!this.length){ return []; } for(var i=0,len = this.length;i&lt;len;i++){ if(temp.indexOf(this[i])&lt;0){ temp.push(this[i]); } } return temp; } 网页缓存 cache-control1、http响应头信息，可以用来设置缓存，优化页面的性能。服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。2、添加在HTTP响应头中3、no-store：禁止缓存对响应进行复制no-cache：在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用max-age: 从服务器将文档传来之时，可以认为此文档处于新鲜状态的秒数max-age=0;将最大使用时间设置为零，从而在每次访问的时候都进行刷新Expires响应首部：实际的过期时间而不是秒数 (GMT格式) Http头介绍:Expires,Cache-Control,Last-Modified,ETag浅谈前端性能优化（一）——Expires和Cache-Control js 操作获取和设置 cookie// 创建cookie function setCookie(name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) { cookieText += &apos;; expires=&apos; + expires; } if (path) { cookieText += &quot;; path=&quot; + path } if (domain) { cookieText += &apos;; domain=&apos; + domain; } if (secure) { cookieText += &apos;; secure&apos;; } document.cookie = cookieText; } // 获取cookie function getCookie(name) { var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) { var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); } return cookieValue; } // 删除cookie function unsetCookie(name) { document.cookie = name + &quot;= ; expires=&quot; + new Date(0); } 前端开发中通过js设置/获取cookie的一组方法]]></content>
      <categories>
        <category>interview questions</category>
      </categories>
      <tags>
        <tag>interview questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试常见算法题总结]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[十道前端面试常见算法题。 判断一个单词是否是回文思路：将字符串转换为数组，利用数组方法reverse()比较翻转后的字符串是否与源字符串一致。 实现： function checkPalindrome(str) { return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;); } 去掉一组整型数组重复的值function uniqueArr(arr) { var result = []; for(var i = 0; i &lt; arr.length; i++) { if(arr.indexOf(arr[i]) === i) { result.push(arr[i]); } } return result; } uniqueArr([1,13,24,11,11,14,1,2]);//返回 [1, 13, 24, 11, 14, 2] 统计一个字符串出现最多的字母function maxDuplicateLetter(str) { //如果字符串仅有一个字符，即为该字符 if(str.length === 1) { return str; } var letterObj = {}; for(var i = 0; i &lt; str.length; i++) { if(!letterObj[str[i]]) {//存放字母的对象中还未记录过该字母出现的次数 letterObj[str[i]] = 1; } letterObj[str[i]] += 1; } //接下来寻找存放字母的对象中最大的value所对应的key var maxValue = 1; var maxKey = &apos;&apos;; for(var key in letterObj) { if(letterObj[key] &gt; maxValue) { maxValue = letterObj[key]; maxKey = key; } } return maxKey; } maxDuplicateLetter(&quot;abcdddbb&quot;);//返回 &quot;a&quot; 排序算法（1）冒泡排序依次比较相邻两个数的大小，进行位置上的交换，若按由小到大排序，第一轮可以将最大的排在最右边。平均时间复杂度：O(n^2) &nbsp;&nbsp;最好情况：O(n) &nbsp;&nbsp; 最坏情况：O(n^2)空间复杂度：O(1)排序方式:In-place稳定性:稳定 function bubbleSort(arr) { for(var i = 0; i &lt; arr.length; i++) { for(var j = 0; j &lt; arr.length - i -1; j ++) { // 由小到大排序 if(arr[j] &gt; arr[j + 1]){ var swap = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = swap; } } } return arr; } bubbleSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7] (2)快速排序参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组。平均时间复杂度: O(n log n) &nbsp;&nbsp;最好情况：O(n log n) &nbsp;&nbsp; 最坏情况：O(n^2)空间复杂度：O(1)排序方式:In-place稳定性:不稳定 function quickSort(arr) { if(arr.length &lt;= 1) { return arr; } var referValue = arr[0]; var leftArr = []; var rightArr = []; // 由小到大排序 for(var i = 1; i &lt; arr.length; i++) { if(arr[i] &lt; referValue) { leftArr.push(arr[i]); } else { rightArr.push(arr[i]); } } return quickSort(leftArr).concat([referValue], quickSort(rightArr)); } quickSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7] 另外还有 选择排序、插入排序、希尔排序、归并排序、堆排序、计数排序、桶排序等，见博客js十大排序算法。 不借助临时变量，进行两个整数的交换利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b; function swap([a, b]) { var b = b - a; var a = a + b; var b = a - b; return [a, b]; } swap([2, 5]);//返回 [5, 2] 使用canvas 绘制一个有限度的斐波那契数列的曲线数列长度限定在9时的图像。斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……fibo[i] = fibo[i-1]+fibo[i-2];即生成斐波那契数列，然后再将该数列值作为半径，利用canvas arc方法绘制曲线。 function generateFibo(n) { var fiboArr = []; var i = 0; while(i &lt; n) { if (i &lt;= 1) { fiboArr.push(i); } else { fiboArr[i] = fiboArr[i - 1] + fiboArr[i - 2]; } i++; } return fiboArr; } generateFibo(6);//返回 [0, 1, 1, 2, 3, 5] 找出正数组的最大差值相当于找到一个数组中的最大值与最小值，最大差值即为两者之差。 function maxDifference(arr) { var minValue = arr[0]; var maxDiffer = 0; for(var i = 0; i &lt; arr.length; i++) { minValue = Math.min(minValue, arr[i]); currentDiffer = arr[i] - minValue; maxDiffer = Math.max(maxDiffer, currentDiffer); } return maxDiffer; } maxDifference([10,5,11,7,8,9]);//返回 6 随机生成指定长度的字符串function randomString(n) { var rangeStr = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;; var l = rangeStr.length; var randomStr = &apos;&apos;; for(var i = 0; i &lt; n; i++) { randomStr += rangeStr.charAt(Math.floor(Math.random() * l)); } return randomStr; } randomString(10);//返回 &quot;itfjah8rte&quot; 实现类似getElementsByClassName 的功能查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName、 querySelectorAll 等原生提供DOM查找的函数。 function queryClassName(node, name) { var starts = &apos;(^|[ \n\r\t\f])&apos;, ends = &apos;([ \n\r\t\f]|$)&apos;; var resultArr = [], reg = new RegExp(starts + name + ends), elements = node.getElementsByTagName(&quot;*&quot;); length = elements.length, i = 0; while(i &lt; length) { var element = elements[i]; if(reg.test(element.className)) { resultArr.push(element); } i++; } return resultArr; } // 方法2 function queryClassName2(node, name) { var elements = node.getElementsByTagName(&quot;*&quot;), length = elements.length, resultArr = []; for(var i = 0; i &lt; length; i ++) { if(elements[i].className) { var classNames = elements[i].className.split(&quot; &quot;);/*这里其实还要考虑类名间隔大于一个空格的情况*/ if(classNames.indexOf(name) !== -1) { resultArr.push(elements[i]); } } } return resultArr; } //HTML结构 &lt;ul id=&quot;ull&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li class=&apos;box box2&apos;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li class=&apos;box1&apos;&gt;3&lt;/li&gt; &lt;li class=&apos;box1&apos;&gt;4&lt;/li&gt; &lt;li class=&apos;box box1&apos;&gt;5&lt;/li&gt; &lt;/ul&gt; //测试结果 window.onload = function() { node = document.getElementById(&quot;ull&quot;); queryClassName(node, &quot;box&quot;);//返回 (2) [li.box.box2, li.box.box1] queryClassName2(node, &quot;box&quot;);// 返回 (2) [li.box.box2, li.box.box1] }; JS 实现二叉查找树(Binary Search Tree)在实际使用时会根据链表和有序数组等数据结构的不同优势进行选择。有序数组的优势在于二分查找，链表的优势在于数据项的插入和数据项的删除。但是在有序数组中插入数据就会很慢，同样在链表中查找数据项效率就很低。综合以上情况，二叉树可以利用链表和有序数组的优势，同时可以合并有序数组和链表的优势，二叉树也是一种常用的数据结构。二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树： 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 二叉树相关概念：凡是每个节点都最多有两个叉的树，都叫二叉树。查找树和排序树是一个东西。特点是中序遍历一遍的结果是单调的。这种树建出来可以用来做二分搜索。平衡树一般是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。二叉树由节点（node）和边组成。节点分为根节点、父节点、子节点。如下图所示： 红色是根节点（root）。蓝色是子节点也是父节点，绿色的是子节点。其余的线是边。节点和链表中的节点一样都可以存放数据信息。树中的边可以用自引用表示，这种引用就是C/C++里面的指针。通常来说树是顶部小，底部大，且树呈分层结构。root节点时第0层，以此类推。二叉树最多有两个节点。二叉树搜索： 二叉树一个节点左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。创建一个树节点。BST创建过程：(1)创建一个树节点包括左节点引用和右节点引用。(2)创建一个树结构。 创建一个树结构首先是向一个树种插入数据节点。当一棵树为null时，数据项是从树的root节点处开始插入，之后的插入顺序是根据搜索节点顺序规则进行插入。具体规则是：如果数据项比父节点的数据项要小，则插在父节点的左节点（leftNode），如果比父节点的数据项要大，则将新的node插入在父节点的右节点处（rightNode）。插入数据节点过程如下所示：插入节点的过程中其实也就是对tree遍历的过程，最终根据条件遍历到左右节点为null时进行添加新的节点。查找关键字查找关键字是数据结构一项重要操作项，在有序数组中通过二分排序效率非常高。在二叉树中的查找效率也比较高。因为二叉树的添加node的过程就是根据数据项的大小进行有序添加的，并不是毫无秩序的插入数据项。在有序的基础上进行查找关键字效率就会快很多。树的最值查找在树中查找是比较容易的，因为从root开始查找，最小值只会出现所有父节点的左节点处，同样最大值只会出现在所有父节点的沿着右节点搜索的最底层右节点处。参考自博客。删除节点给出如下二叉查找树 删除节点3之后，可以返回 或者 思路:若要删除一个BST的一个结点，需要考虑如下三种情况： 需要删除的节点下并没有其他子节点 需要删除的节点下有一个子节点（左或右） 需要删除的节点下有两个子节点（既左右节点都存在） 对这三种情况分别采取的措施是： 直接删除此结点 删除此结点，将此结点父节点连接到此结点左（右）子树 找出此结点右子树中的最小结点，用以代替要删除的结点，然后删除此最小结点 设定每个节点的数据结构： class Node { constructor(data, left, right) { this.data = data; this.left = left; this.right = right; } } 树由节点构成，由根节点逐渐延生到各个子节点，因此它基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法。 // 构建BST，具备一个根节点、以及添加、查找、删除节点的方法 class BinarySearchTree { constructor() { this.root = null; } // 插入节点的方法 insert(data) { let n = new Node(data, null, null); if (!this.root) { //如果此二叉树为空，则数据项从树的root节点处开始插入 return this.root = n; } let currentNode = this.root; let parent = null; while (true) { parent = currentNode; //保存当current变为null之前的那一个父节点 if (data &lt; currentNode.data) { //插在父节点的左节点 currentNode = currentNode.left; if (currentNode === null) { //不断向左node寻找是否为null parent.left = n; break; } } else { //插在父节点的右节点 currentNode = currentNode.right; if (currentNode === null) { parent.right = n; break; } } } } // 删除数据项 remove(data) { this.root = this.removeNode(this.root, data); } // 删除节点 // 删除树中与给定值相同的节点，如果树中没有相同值的节点，则不做处理，应该保证处理之后的树仍是二叉查找树。 removeNode(node, data) { if (node === null) { // 如果根节点为空 return null; } if (data === node.data) { // 没有子节点，即node为叶子节点 if (node.left === null &amp;&amp; node.right === null) { return null; } // 要删除的节点下只有右节点 if (node.left === null) { return node.right; } // 要删除的节点下只有左节点 if (node.right === null) { return node.left; } // 要删除的节点下有两个子节点的情况 // getSmallest用于找到该节点右子树中的最小节点，用以替代要删除的节点，然后删除此最小节点 let getSmallest = function (node) { if (node.left === null &amp;&amp; node.right === null) { return node; } if (node.left !== null) { return node.left; } if (node.right !== null) { return getSmallest(node.right); } } let temNode = getSmallest(node.right); node.data = temNode.data; node.right = this.removeNode(temNode.right, temNode.data); return node; } else if (data &lt; node.data) { node.left = this.removeNode(node.left, data); return node; } else { node.right = this.removeNode(node.right, data); return node; } } // 查找方法 find(data) { let currentNode = this.root; while (currentNode !== null) { if (data === currentNode.data) { return true; } if (data &lt; currentNode.data) { if (currentNode.left !== null) { currentNode = currentNode.left; } else { return false; } } else {// data &gt; currentNode.data if (currentNode.right !== null) { currentNode = currentNode.right; } else { return false; } } } } } 有关数组的一些操作见博客后半部分前端面试中的常见的算法问题。 下面是一篇总结常见数据结构的javascript实现的文章：常见数据结构的javascript实现。]]></content>
      <categories>
        <category>js算法题</category>
      </categories>
      <tags>
        <tag>js算法题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键]]></title>
    <url>%2F2018%2F02%2F26%2FvscodeKeyboardShortcuts%2F</url>
    <content type="text"><![CDATA[vscode中常用的快捷键功能。 文本编辑alt+up/down 向上/下移动单行 shift+alt+up/down 向上/下复制单行 shift+alt+f 格式化文本 command + +/- 增大/减小文本字体 Ctrl+Enter 在当前行下边插入一行 Ctrl+Shift+Enter 在当前行上方插入一行 代码行缩进： 向左缩进 Ctrl+[ &nbsp;&nbsp; 向右缩进 Ctrl+] 光标相关移动到行首：Home 移动到行尾：End 移动到文件结尾：Ctrl+End 移动到文件开头：Ctrl+Home 移动到后半个括号： Ctrl+Shift+] 选中当前行 Ctrl+i 选择从光标到行尾 Shift+End 选择从行首到光标处 Shift+Home 删除光标右侧的所有字： Ctrl+Delete 删除光标所在行: Ctrl+Shift+K 扩展/缩小选取范围： Shift+Alt+Left/Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L 回退上一个光标操作： Ctrl+U 重构代码移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 列出所有引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 左侧边栏及显示相关打开资源 ctrl+shift+E 打开搜索 ctrl+shift+F 打开git ctrl+shift+G 打开调试 ctrl+shift+D 打开扩展 ctrl+shift+X 全屏：F11 侧边栏显/隐：Ctrl+B 输出Show Output： Ctrl+Shift+U 预览markdown： Ctrl+Shift+V 编辑器与窗口管理打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 新建文件： Ctrl+N 文件之间切换： Ctrl+Tab 切出一个新的编辑器： Ctrl+\ (也可以按住 Ctrl 鼠标点击 Explorer 里的文件名。左中右 3 个编辑器的快捷键分别为 Ctrl+1 Ctrl+2 Ctrl+3)]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 calc()的使用]]></title>
    <url>%2F2018%2F01%2F23%2FCSS3-calc-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考转自博客CSS3的calc()使用。 为什么使用calc()平时在制作页面的时候，总会碰到有的元素是100%的宽度。众所周知，如果元素宽度(这里的宽度是盒模型content的宽度)为100%时，其自身不带其他盒模型属性设置还好，要是有别的（比如添加了padding和border），那将导致盒子撑破。 比如说，有一个边框，或者说有margin和padding，这些都会让你的盒子撑破。我们换句话来说，如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。这样一来就会相当的麻烦，平时我们碰到这样的现象时，也是相当的谨慎，有时甚至无法解决，只能通过改变结构来实现。就算你通过繁琐的方法实现了，但有于浏览器的兼容性而导致最终效果不一致。虽然前面介绍的CSS3属性中的box-sizing在一定程度上解决这样的问题，其实今天的calc()函数功能实现上面的效果来得更简单。 什么是calc()calc()是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽度。 calc() 能做什么calc()能让你给元素的做计算，你可以给一个div元素，使用百分比、em、px和rem单位值计算出其宽度或者高度，比如说 width: calc(50% + 2em);，这样一来你就不用考虑元素DIV的宽度值到底是多少，而把这个烦人的任务交由浏览器去计算。 calc()语法.element { width: calc(expression); } 其中”expression”是一个表达式，用来计算长度的表达式。 calc()运算规则calc()使用通用的数学运算规则，但是也提供更智能的功能： 使用“+”、“-”、“*” 和 “/”四则运算； 可以使用百分比、px、em、rem等单位； 可以混合使用各种单位进行计算； 表达式中有“+”和“-”时，其前后必须要有空格，如widht: calc(12%+5em);这种没有空格的写法是错误的； 表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。 浏览器兼容性浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持，同样需要在其前面加上各浏览器厂商的识别符，不过可惜的是，移动端的浏览器还没仅有“firefox for android 14.0”支持，其他的全军覆没。大家在实际使用时，同样需要添加浏览器的前缀 .element { /*Firefox*/ -moz-calc(expression); /*chrome safari*/ -webkit-calc(expression); /*Standard */ calc(); } 通过上面的了解，大家对calc()不在那么陌生，但对于实际的运用可能还是不太了解，那么大家就接下来跟我一起动手，通过实例来了解他吧。首先我们来看一个最常用的实例： &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; 上面的结构很简单，就是一个div.demo的元素中包含了一个div.box的元素，接下来我们一步一步来看其中的变化。第一步：添加普通样式： .demo { width: 300px; background: #60f; } .box { width: 100%; background: #f60; height: 50px; } 此时的效果很简单，就是div.box完全遮盖了div.demo，如下图所示： 第二步，在div.box上添加border和padding 这一步很棘手的事情来了，在div.box上添加10px的内距padding，同时添加5px的border： .demo { width: 300px; background: #60f; } .box { width: 100%; background: #f60; height: 50px; padding: 10px; border: 5px solid green; } 为了更好的说明问题，我在div.demo上添加了一个 padding：3px 0; .demo { width: 300px; background: #60f; padding: 3px 0; } .box { width: 100%; background: #f60; height: 50px; padding: 10px; border: 5px solid green; } 这个时候大家不知道能否想到问题会发生在哪？其实很简单，这个时候div.box的宽度大于了其容器div.demo的总宽度，从而撑破容器伸出来了，如图所示： 第三步，calc()的运用 为了解决撑破容器的问题，以前我们只能去计算div.box的宽度，用容器宽度减去padding和border的值，但有时候，我们苦于不知道元素的总宽度，比如说是自适应的布局，只知道一个百分值，但其他的值又是px之类的值，这就是难点，死卡住了。随着CSS3的出现，其中利用box-sizing来改变元素的盒模型类型实使实现效果，但今天我们学习的calc()方法更是方便。 知道总宽度是100%，在这个基础上减去boder的宽度（5px 2 = 10px）,在减去padding的宽度（10px 2 = 20px），即”100% - (10px + 5px) * 2 = 30px” ，最终得到的值就是div.box的width值： .demo { width: 300px; background: #60f; padding: 3px 0; } .box { background: #f60; height: 50px; padding: 10px; border: 5px solid green; width: 90%;/*写给不支持calc()的浏览器*/ width:-moz-calc(100% - (10px + 5px) * 2); width:-webkit-calc(100% - (10px + 5px) * 2); width: calc(100% - (10px + 5px) * 2); } 这样一来，通过calc()计算后，div.box不在会超出其容器div.demo的宽度，如图所示： 采用calc()方法的自适应布局demo在这个布局中，采用了自适应布局。整个布局包含了“头部”、“主内容”、“边栏”和“脚部”，并且“主内容”居左，“边栏”靠右。html结构如下： &lt;!-- 头部 --&gt; &lt;div id=&quot;header&quot;&gt;我是头部&lt;/div&gt; &lt;!-- 内容区容器 --&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;!-- 主内容 --&gt; &lt;div id=&quot;main&quot;&gt;我是主内容区&lt;/div&gt; &lt;!-- 右边栏 --&gt; &lt;div id=&quot;accessory&quot;&gt;我是右边栏&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚部 --&gt; &lt;div id=&quot;footer&quot;&gt;我是脚部&lt;/div&gt; 1、在body中设置一个内距，并附上一些基本的样式 body { background: #E8EADD; color: #3C323A; padding: 20px; } 2、设置主容器“wrapper”的样式 主容器的宽度是“100% - 20px * 2”,并且水平居中： .wrapper { width: 1024px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); margin: auto; } 给不支持calc()的浏览器设置了一个固定宽度值“1024px”。 3、给header和footer设置样式 这个例子中的header和footer很简单，给他们添加了一个内距为20px，其他就是一些基本的样式设置，那么其对应的宽度应该是100% - 20px * 2 #header { background: #f60; padding: 20px; width: 984px;/*Fallback for browsers that don&apos;t support the calc() function*/ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); } #footer { clear:both; background: #000; padding: 20px; color: #fff; width: 984px;/* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); } 4、给主内容设置样式 给主内容设置了一个8px的边框，20px的内距，并且向左浮动，同时设置了一个向右的外边距“20”px，关键之处，我们主内容占容器宽度的75%，这样一来，主内容的宽度应该是75% - 8px * 2 - 20px * 2 #main { border: 8px solid #B8C172; float: left; margin-bottom: 20px; margin-right: 20px; padding: 20px; width: 704px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(75% - 20px * 2 - 8px * 2); width: -webkit-calc(75% - 20px * 2 - 8px * 2); width: calc(75% - 20px * 2 - 8px * 2); } 5、设置右边栏样式 给边栏设置了一个25%的宽度，其除了包含8px的边框，10px的内距外，还有主内容外距20px也要去掉，不然整个宽度与容器会相差20px,换句话说就会撑破容器掉下来。因此边栏的实际宽度应该是25% - 10px * 2 - 8px * 2 -20px #accessory { border: 8px solid #B8C172; float: right; padding: 10px; width: 208px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(25% - 10px * 2 - 8px * 2 - 20px); width: -webkit-calc(25% - 10px * 2 - 8px * 2 - 20px); width: calc(25% - 10px * 2 - 8px * 2 - 20px); } 完整代码见github。 另附一篇移动端页面布局，讲得比较好。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about CSS】 from牛客网]]></title>
    <url>%2F2018%2F01%2F13%2Finterview-questions-about-CSS%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试常考知识点 HTML+CSS 篇学习总结。 CSS 盒子模型CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。CSS盒子模型有两种，分别是标准 W3C 盒子模型和 IE 盒子模型。W3C标准盒子模型:标准W3C 盒子模型的范围包括 margin、border、padding、content， content 部分不包含其他部分。width(content) = content盒子模型占据的宽度= width + padding + border + margin盒子的实际宽度大小= width + padding + borderIE盒子模型:IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。width(content) = content + padding-left + padding-right + border-left + border-right盒子模型占据的宽度= width + margin盒子的实际宽度大小= width参考标准盒子模型和IE盒子模型。 CSS选择器的类型类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素。参考CSS选择器笔记-阮一峰。 CSS优先级、计算特殊值优先级(1) 同类型，同级别的样式后者先于前者(2) ID选择器(#example) &gt; 类选择器(.example)|属性选择器([type=”radio”])|伪类(:hover) &gt; 标签选择器(h1)|伪元素(::before)(3) 内联 &gt; ID选择器 &gt; 类|伪类|属性 &gt; 标签|伪元素 &gt; 继承 &gt; 通用选择器()(4) 具体 &gt; 泛化的，特殊性即css优先级(5) 近的 &gt; 远的 (内联样式 &gt; 内部样式表 &gt; 外部样式表) 内联样式：内嵌在元素中，&lt;span style=&quot;color:red&quot;&gt;span&lt;/span&gt; 内部样式表：在页面中的样式，写在&lt;style&gt;&lt;/style&gt;中的样式 外部样式表：单独存在一个css文件中，通过link引入或import导入的样式有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。(6) !important 权重最高，比 inline style 还要高*选择器的优先权-计算特殊性值 内联样式表的权值最高 1000； ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1CSS 优先级法则：A 选择器都有一个权值，权值越大越优先；B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；D 继承的CSS 样式不如后来指定的CSS 样式；E 在同一组属性设置中标有“!important”规则的优先级最大 动态改变层中内容的方法通过innerHTML()，innerText()方法动态添加内容和文本。 常见浏览器兼容性问题与解决方案(1)一：不同浏览器的标签默认的margin和padding不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。碰到频率:100%解决方案：CSS样式初始化，即将使用到的有默认margin,padding值的标签的默认值置为0；或者用 *{margin:0;padding:0;}。但第二种方式不推荐，全局重置浏览器的默认样式，是一种粗暴的方式，会降低效率，使用第一种方式重置部分样式就可以了。(2)二：块属性标签float后，又有横向的margin情况下，在IE6显示margin比设置的大问题症状:常见症状是IE6中后面的一块被顶到下一行碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。(3)三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度碰到频率：60%解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。(4)四：行内属性标签，设置display:block后采用float布局，又有横向的margin的情况，IE6间距bug问题症状：IE6里的间距比超过设置的间距碰到几率：20%解决方案 ： 在display:block;后面加入display:inline;display:table;备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。(5)五：图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。碰到几率：20%解决方案：使用float属性为img布局备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以不建议使用）(6)六：标签最低高度设置min-height不兼容问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容碰到几率：5%解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时，容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。(7)七：透明度的兼容CSS设置一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容。 列出display的值并说明作用display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间inline： 指定对象为内联元素。block： 指定对象为块元素。list-item： 指定对象为列表项目。inline-block： 指定对象为内联块元素。(CSS2)table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;(CSS2)inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;(CSS2)table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;(CSS2)table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;(CSS2)table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;(CSS2)table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;(CSS2)table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;(CSS2)table-column-group：指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;(CSS2)table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;(CSS2)table-footer-group：指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;(CSS2)run-in： 根据上下文决定对象是内联对象还是块级对象。(CSS3)box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)参考display的32种写法。 居中div，居中一个浮动元素(1)非浮动元素居中：div为块级元素，居中块级元素首先要设置宽度,然后margin:0 auto;就居中了；还可以通过定位 方式；父级元素设置text-align:center;的方式等等。参考CSS居中完整指南。(2)、浮动元素居中:方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-width/2 px;其中的left是宽度的一半。方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。方法三:position定位等等。例如： &lt;style&gt; .box{ position: relative; left:50%; float:left; } .item{ position: relative; left:-50%; float:left; background: red; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt; &lt;/div&gt; 注：left:50%;这个left按照百分比来设置left值实际移动是按父容器的宽度来算，可以先看成box容器为body宽度为也就是浏览器宽度，left:50%;就是向右移动到中间，现在还要向左移动浮动元素item一半的距离，box的float是为了让box自身收缩，这样item的父容器的宽度就是本身的宽度了，再设置为left:-50%;也就是向左移动自身宽度的一半。 几种清除浮动的方法两种思路，五种方法。 思路1：父级定义；思路2：结尾定义。(1)、父级div定义 height原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。优点：简单、代码少、容易掌握缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题建议：不推荐使用，只建议高度固定的布局时使用(2)、结尾处加空div标签 clear:both原理：在父元素中，追加空子元，即添加一个空div，并利用css提供的clear:both清除浮动，让父级div能自动获取到高度优点：简单、代码少、浏览器支持好、不容易出现怪问题缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法(3)、父级div定义 伪类:after 和 zoom原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6,ie7浮动问题优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。建议：推荐使用，建议定义公共类，以减少CSS代码。(4)、父级div定义 overflow:hidden原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。(5)、父级div定义 overflow:auto原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。(6)、使用内容生成的方式清除浮动 .clearfix:after { content:&quot;&quot;; display: block; clear:both; } :after 选择器向选定的元素之后插入内容content:””; 生成内容为空display: block; 生成的元素以块级元素显示,clear:both; 清除前面元素浮动带来的影响相对于空标签闭合浮动的方法优势：不破坏文档结构，没有副作用弊端：代码量多参考 详解 清除浮动 的多种方式（clearfix）、 解读浮动闭合最佳方案：clearfix。 block，inline和inlinke-block细节对比 display:blocka、block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。b、block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。c、block元素可以设置margin和padding属性。 display:inlinea、inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。b、inline元素设置width,height属性无效。c、inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-blocka、简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个链接（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。补充说明a、一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。b、IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 优雅降级和渐进增强的含义优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 浮动元素引起的问题及相应解决办法浮动的工作原理： 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。问题：（1）父元素的高度无法被撑开，影响与父元素同级的元素（2）与浮动元素同级的非浮动元素会跟随其后（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法：使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式： .clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { display: inline-block; /* for IE/Mac */ }清除浮动的几种方法：(1)、额外标签法(使用空标签清除浮动)&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：会增加额外的标签，使HTML结构看起来不够简洁。）(2)、使用after伪类 #parent:after{ content:” “; height:0; visibility:hidden; display:block; clear:both; }(3)、浮动外部元素(4)、设置overflow为hidden或者auto 性能优化的方法总结一：（1）、减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2）、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4）、当需要设置的样式很多时设置className而不是直接操作style。（5）、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6）、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7）、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。回答二：(1)、减少HTTP请求次数(2)、使用CDN(3)、避免空的src和href(4)、为文件头指定Expires(5)、使用gzip压缩内容(6)、把CSS放到顶部(7)、把JS放到底部(8)、避 免使用CSS表达式(9)、将CSS和JS放到外部文件中(10)、避免跳转(11)、可缓存的AJAX(12)、使用GET来完成AJAX请求 初始化CSS样式的意义因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的(比如标签默认的margin、padding值不同等情况)，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，力求影响最小的情况下初始化。最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议） CSS中的刻度在CSS中刻度是用于设置元素尺寸的单位。a、特殊值0可以省略单位。例如：margin:0px;可以写成margin:0;b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。c、长度单位包括：相对单位和绝对单位。相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin绝对长度单位有： cm, mm, q, in, pt, pc, px绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px文本相对长度单位：em相对长度单位是相对于当前对象内文本的字体尺寸，如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数) body { font-size: 14px; } h1 { font-size: 16px; } .size1 p { font-size: 1em; } .size2 p { font-size: 2em; } .size3 p { font-size: 3em; }文本相对长度单位：remrem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数。只相对于根元素(html元素)的大小。浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法。em与rem的重要区别：它们计算的规则一个是依赖父元素另一个是依赖根元素计算。 box-sizing属性的用法a、box-sizing:content-boxpadding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin )。此属性表现为标准模式下的盒模型。b、box-sizing:border-boxpadding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )。 此属性表现为怪异模式下的盒模型。 浏览器标准模式和怪异模式之间的区别所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型(标准模式解析)，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。 怪异Quirks模式是什么，它和标准Standards模式有什么区别从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别：总体会有布局、样式解析和脚本执行三个方面的区别。盒模型： 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks模式下，IE的宽度和高度还包含了padding和border。设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的。用margin:0 auto设置水平居中：使用margin:0 auto;在standards模式下可以使元素水平居中，但在quirks模式下却会失效。（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。） 边距折叠外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin）相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系垂直方向外边距合并计算:a、参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。b、参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。c、参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 隐藏元素的方式a、使用CSS的display:none，不会占有原来的位置b、使用CSS的visibility:hidden，会占有原来的位置c、使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 为什么重置浏览器默认样式，如何重置默浏览器认样式每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。a、最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。b、使用CSSReset可以将所有浏览器默认样式设置成一样。c、normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。天猫 使用的css reset重置浏览器默认样式： body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td {margin: 0;padding: 0} body, button, input, select, textarea {font: 12px “microsoft yahei”;line-height: 1.5;-ms-overflow-style: scrollbar} h1, h2, h3, h4, h5, h6 {font-size: 100%} ul, ol {list-style: none}a {text-decoration: none;cursor:pointer} a:hover {text-decoration: underline} img {border: 0} button, input, select, textarea {font-size: 100%} table {border-collapse: collapse;border-spacing: 0} .clear {clear:both} .fr {float:right} .fl {float:left} .block {display:block;text-indent:-999em} 对BFC与IFC的理解？(是什么，如何产生，作用)(1)、什么是BFC与IFCa、BFC（Block Formatting Context）即”块级格式化上下文”， IFC（Inline Formatting Context）即”行内格式化上下文”。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。b、BFC是W3C CSS 2.1规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。c、在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。(2)、如何产生BFC当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：a、float的值不为noneb、overflow的值不为visiblec、display的值为table-cell, table-caption, inline-block中的任何一个d、position的值不为relative和staticCSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。 (3)、BFC的作用与特点a、不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖。如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。 对页面中使用定位(position)的理解osition：static | relative | absolute | fixed | center | page | sticky默认值：static，center、page、sticky是CSS3中新增加的值。(1)、static可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。(2)、relative相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。(3)、absolutea、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。b、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。(4)、fixed固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。(5)、center与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）(6)、page与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）(7)、sticky对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3） 如何解决多个元素重叠问题使用z-index属性可以设置元素的层叠顺序。z-index属性语法：z-index: auto | &lt;integer&gt;默认值：auto适用于：定位元素。即定义了position为非static的元素取值：auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。整数： 用整数值来定义堆叠级别。可以为负值。 说明：检索或设置对象的层叠顺序。z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。当多个元素层叠在一起时，数字大者将显示在上面。 页面布局的方式页面布局方式。 overflow :hidden是否形成新的块级格式化上下文会形成，触发BFC的条件有：float的值不为none。overflow的值不为visible。display的值为table-cell, table-caption, inline-block 中的任何一个。position的值不为relative 和static。]]></content>
      <categories>
        <category>interview questions</category>
      </categories>
      <tags>
        <tag>interview questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[introduction about HTTP]]></title>
    <url>%2F2018%2F01%2F09%2Fintroduction-about-HTTP%2F</url>
    <content type="text"><![CDATA[关于HTTP协议相关知识的学习总结。 简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP基于TCP/IP通信协议来传递数据。 HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 （2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 （3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 通信流程 消息结构HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息：请求行、请求头部、空行和请求数据。 GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi服务端响应消息：状态行、消息报头、空行和响应正文。 HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: “34aa387-d-1568eb00” Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 请求方法​ GET 请求指定的页面信息，并返回实体主体。 ​ HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 ​ POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 POST请求可能会导致新的资源的建立和/或已有资源的修改。 ​ PUT 从客户端向服务器传送的数据取代指定的文档的内容。 ​ DELETE 请求服务器删除指定的页面。 ​ CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 ​ OPTIONS 允许客户端查看服务器的性能。 ​ TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码HTTP状态码分类​ 1xx 信息，服务器收到请求，需要请求者继续执行操作​ 2xx 成功，操作被成功接收并处理​ 3xx 重定向，需要进一步的操作以完成请求​ 4xx 客户端错误，请求包含语法错误或无法完成请求​ 5xx 服务器错误，服务器在处理请求的过程中发生了错 HTTP状态码列表​ 100 Continue 继续。客户端应继续其请求 ​ 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 ​ 200 OK 请求成功。一般用于GET与POST请求 ​ 201 Created 已创建。成功请求并创建了新的资源 ​ 202 Accepted 已接受。已经接受请求，但未处理完成 ​ 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 ​ 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 ​ 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 ​ 206 Partial Content 部分内容。服务器成功处理了部分GET请求 ​ 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 ​ 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 ​ 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI ​ 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 ​ 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 ​ 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 ​ 306 Unused 已经被废弃的HTTP状态码 ​ 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 ​ 400 Bad Request 客户端请求的语法错误，服务器无法理解 ​ 401 Unauthorized 请求要求用户的身份认证 ​ 402 Payment Required 保留，将来使用 ​ 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 ​ 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 ​ 405 Method Not Allowed 客户端请求中的方法被禁止 ​ 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 ​ 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 ​ 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 ​ 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 ​ 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 ​ 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 ​ 412 Precondition Failed 客户端请求信息的先决条件错误 ​ 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 ​ 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 ​ 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 ​ 416 Requested range not satisfiable 客户端请求的范围无效 ​ 417 Expectation Failed 服务器无法满足Expect的请求头信息 ​ 500 Internal Server Error 服务器内部错误，无法完成请求 ​ 501 Not Implemented 服务器不支持请求的功能，无法完成请求 ​ 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 ​ 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 ​ 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 ​ 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about HTML】 from牛客网]]></title>
    <url>%2F2018%2F01%2F08%2Finterview-questions-about-HTML%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试常考知识点 HTML+CSS 篇学习总结。 浏览器页面有哪三层构成浏览器页面有哪三层构成，分别是什么，作用是什么?浏览器页面有结构层、表示层、行为层，三层构成，分别是HTML、CSS、JavaScript，作用是HTML实现页面结构(骨架)，CSS完成页面的表现与风格(肌肤)，JavaScript实现一些客户端的功能与业务(动作)，对用户事件作出反应。不过，在这三种技术之间存在着一些潜在的重叠区域，如DOM技术可以用来改变网页的结构；CSS诸如:hover和:focus之类的class伪类，使我们可以根据用户触发事件来改变呈现效果。改变元素的呈现效果当然是表示层的“势力范围”，但对用户触发事件做出反应却是行为层的领地。表示层和行为层的这种重叠形成了一个灰色地带。class伪类是 CSS 正在深入DOM领地证据，但 DOM在这方面也不是毫无作为，完全可以利用 DOM 技术把样式信息施加在HTML元素身上。分离的效果要做到即使去掉表示层和行为层，文档的内容也依然可以访问，因为“内容才是一切”。而且网页的行为层(javascript)与其结构(HTML)是彼此互不干扰的，不能混杂在一起。还要给行为层“预留退路”，要考虑到如果你的用户禁用了Javascript会怎样？网页是否还可以正常运作。做到平稳退化，渐进增强。 HTML5的优点与缺点HTML5是什么: HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ，RIA），例如：AdobeFlash 、Microsoft Silverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 HTML 最新版本，2014 年10月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。为什么有HTML5的出现： HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了 Web应用对插件的依赖，让用户体验更好，让开发更加方便，另外W3C 从推出 HTML4.0到5.0之间共经历了17年，HTML的变化很小，这并不符合一个好产品的演进规则。优点： 网络标准统一HTML5本身是由W3C推荐出来的，它的开发是通过谷歌、苹果，诺基亚、中国移动等几百家公司一起酝酿的技术，这个技术最大的好处在于它是一个公开的技术。换句话说，每一个公开的标准都可以根据W3C的资料库找寻根源。另一方面，W3C通过的HTML5标准也就意味着每一个浏览器或每一个平台都会去实现。 多设备跨平台，可移植性好HTML5的优点主要在于，这个技术可以进行跨平台的使用。比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台,甚至可以通过封装的技术发放到AppStore或GooglePlay上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。 自适应网页设计即“一次设计，普遍适用”，让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局(layout)。 即时更新游戏客户端每次都要更新，很麻烦。可是更新HTML5游戏就好像更新页面一样，是马上的、即时的更新。 提高可用性和改进用户的友好体验 增加几个新的标签，这将有助于开发人员定义重要的内容 可以给站点带来更多的多媒体元素(视频和音频) 可以很好的替代FLASH和SilverlightSilverlight是一个跨浏览器、跨平台的插件，为网络带来下一代基于.NET媒体体验，和丰富的交互式应用程序。 当涉及到网站的抓取和索引的时候，对于SEO很友好SEO，即搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。 将被大量应用于移动应用程序和游戏缺点： 安全方面像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket这样的功能很容易被黑客利用，来盗取用户的信息和资料。 完善性方面许多特性各浏览器的支持程度也不一样。 技术门槛方面HTML5技术开发者工作的同时，有许多新的属性和API需要开发者学习，像web worker、web socket、web storage等新特性，甚至后台及浏览器原理的知识。这是机遇的同时也是巨大的挑战。 性能方面某些平台上的引擎问题导致HTML5性能低下. 浏览器兼容性方面IE9以下浏览器几乎不支持。 Doctype作用Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?告诉浏览器应该用什么文档类型规范来解析这个文档。doctype不存在或格式不正确会导致文档以混杂模式呈现。严格模式的排版和js运作模式是以浏览器最高标准运行。混杂模式， 页面以宽松的向后兼容的形式展示。参考博客DOCTYPE声明。 HTML5有哪些新特性、移除了哪些元素HTML5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性元素、级块性元素、行内语义性元素和交互性元素4大类。结构性元素主要负责web上下文结构的定义：section：在 web 页面应用中，该元素也可以用于区域的章节描述。header：页面主体上的头部， header 元素往往在一对 body 元素中。footer：页面的底部（页脚），通常会标出网站的相关信息。nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割。aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。code：表示一段代码块。dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。 行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。meter：表示特定范围内的数值，可用于工资、数量、百分比等。time：表示时间值。progress：用来表示进度条，可通过对其 max 、min 、step 等属性进行控制，完成对进度的表示和监事。video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。 交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。command：用来处理命令按钮。 移除的元素纯表现的元素：&lt;basefont&gt; 默认字体，不设置字体，以此渲染; &lt;font&gt; 字体标签; &lt;center&gt;水平居中; &lt;u&gt;下划线; &lt;big&gt; 大字体; &lt;strike&gt;中横线; &lt;tt&gt;文本等宽;框架集：&lt;frameset&gt; &lt;noframes&gt; &lt;frame&gt; HTML5行内元素、块级元素、空元素行内元素a - 锚点abbr - 缩写br - 换行em - 强调strong - 粗体强调i - 斜体cite - 引用code - 计算机代码 ( 在引用源码的时候需要 )img - 图片span - 常用内联容器，定义文本内区块input - 输入框textarea - 多行文本输入框label - 表格标签块级元素div - 常用块级容易，也是 css layout 的主要标签p - 段落h1~h6 - 大标题form - 交互表单table - 表格ol - 排序表单ul - 非排序列表address - 地址blockquote - 块引用空元素&lt;br/&gt; //换行&lt;hr&gt; //分隔线&lt;input&gt; //文本框等&lt;img&gt; &lt;link&gt; &lt;meta&gt; 浏览器的内核分类IE: Trident 内核Firefox： Gecko 内核(开源)Safari: Webkit 内核(开源)Chrome: WebkitOpera: 以前是Presto内核，现已改用Blink内核(基于Webkit, Google与Opera Software共同开发) 对WEB标准以及W3C的理解与认识WEB标准 不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由 万维网联盟 （W3C）起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。标签闭合、标签小写、不乱嵌套—》XHTML；提高搜索机器人搜索几率–》DOM；使用外 链css和 js 脚本—》结构行为表现的分离；文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问；容易维护、改版方便；提高网站易用性。 什么是WebGL,它有什么优点WebGL(Web Graphics Library) 是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：第一，它通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持;第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。通俗的说WebGL是canvas绘图中的3D版本。因为原生的WebGL很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。 cookie，sessionStorage 和 localStorage 的区别共同点：都是保存在浏览器端，且同源的。 区别： cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同。cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同。sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同。sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的。cookies 会发送到服务器端。其余两个不会。Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ）；所有域名的存储量有限制（各浏览器不同，大致 4K ）； 有个数限制（各浏览器不同）；会随请求发送到服务器。LocalStorage 永久存储；单个域名存储量比较大（推荐 5MB ，各浏览器不同）；总体数量无限制。SessionStorage 只在 Session 内有效；存储量更大（推荐没有限制，但是实际上各浏览器也不同）。 对HTML语义化的理解 什么是 HTML 语义化&lt;基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 &gt;根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 语义化标签&lt;header&gt;&lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;section&gt;&lt;/section&gt;&lt;article&gt;&lt;/article&gt; 用来在页面中表示一套结构完整且独立的内容部分&lt;aside&gt;&lt;/aside&gt; 主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了&lt;figure&gt;&lt;/figure&gt; 媒体元素，比如一些视频，图片等等&lt;datalist&gt;&lt;/datalist&gt; 选项列表，与 input 元素配合使用，来定义 input 可能的值&lt;details&gt;&lt;/details&gt; 用于描述文档或者文档某个部分的细节 link和@import的区别HTML代码link:&lt;link rel=&#39;stylesheet&#39; rev=&#39;stylesheet&#39; href=&#39;CSS文件 &#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt; HTML代码@import: &lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt; @import url(&apos;CSS文件 &apos;); &lt;/style&gt; 首先link和import语法结构不同，前者是html标签，只能放入html源代码中使用，后者可看作为css样式，作用是引入css样式功能。 import在html使用时候需要&lt;style type=&quot;text/css&quot;&gt;标签，同时可以直接@import url(CSS文件路径地址)放入css文件或css代码里引入其它css文件。 本质上两者使用选择区别不大，但为了软件中编辑布局网页html代码，一般使用link较多，也推荐使用link。 两者都是外部引用CSS的方式，但是存在一定的区别：区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。区别5： link方式的样式权重 高于 @import的权重。 对SVG的理解SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是 W3C 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。特点： (1)任意放缩：用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 (2)文本独立：SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 (3)较小文件： 总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 (4)超强显示效果：SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 (5)超级颜色控制：SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 (6)交互 X 和智能化：SVG面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。 Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的 HTML全局属性(global attribute)有哪些参考HTML 全局属性。例如class, id, style, title, lang等等。 超链接target属性的取值和作用target属性指定所链接的页面在浏览器窗口中的打开方式。参数值主要有：_blank ：浏览器总在一个新打开、未命名的窗口中载入目标文档。_parent ：在父框架集中打开被链接文档。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。_self ：默认。在相同的框架中打开被链接文档。_top ： 在整个窗口中打开被链接文档。这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。framename：在指定的框架中打开被链接文档。 data- 属性的作用data- 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。data- 属性用于存储页面或应用程序的私有自定义数据。存储的（自定义）数据能够被页面的 JavaScript利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。 data-为HTML5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 方法获取：需要注意的是：data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 所有主流浏览器都支持 data-* 属性。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 浏览器内核主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎： 解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 iframe的缺点 iframe会阻塞主页面的 Onload 事件 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。现在，应该使用 iframe 的例子如： 沙箱隔离。参考 写js沙箱原来如此简单 引用第三方内容。 独立的带有交互的内容，比如幻灯片。 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。 使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。比较早期的网站使用iframe，主要是用于导航栏（navigator）。因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的URL不会随着页面的变化而变化。这就意味着一旦刷新，网站可能又回到首页。那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。所以从兼容性上来说，iframe 是没问题的。那么现在什么时候会用到 iframe 呢？因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 contentEditable。 label标签的作用对鼠标用户而言增进了可用性。label标签用来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=&apos;Name&apos;&gt;Number:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot;/&gt; 注意:label的for属性值要与后面对应的input标签id属性值相同。 浏览器内多个标签页之间的通信调用localstorge、cookies等本地存储方式。方法一：localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。例如标签页1： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); localStorage.setItem(&quot;name&quot;, name); }); }); &lt;/script&gt; 标签页2： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); localStorage.setItem(&quot;name&quot;, name); }); }); &lt;/script&gt; 方法二：使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。标签页1： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); document.cookie=&quot;name=&quot;+name; }); }); &lt;/script&gt; 标签页2： &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ function getCookie(key) { return JSON.parse(&quot;{\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;}&quot;)[key]; } setInterval(function(){ console.log(&quot;name=&quot; + getCookie(&quot;name&quot;)); }, 10000); }); &lt;/script&gt; 在页面上实现一个圆形的可点击区域第一种 使用image map &lt;img id=&quot;blue&quot; class=&quot;click-area&quot; src=&quot;blue.gif&quot; usemap=&quot;#Map&quot; /&gt; &lt;map name=&quot;Map&quot; id=&quot;Map&quot; class=&quot;click-area&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;50,50,50&quot;/&gt; &lt;/map&gt; #blue{ cursor:pointer; width:100px; height:100px; }第二种 使用CSS border-radius &lt;div id=&quot;red&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt; #red{ cursor:pointer; background:red; width:100px; height:100px; border-radius:50%; } 第三种 使用js检测鼠标位置,获取鼠标点击位置坐标，判断其到圆点的距离是否不大于圆的半径，来判断点击位置是否在圆内。 &lt;div id=&quot;yellow&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt; $(&quot;#yellow&quot;).on(&apos;click&apos;,function(e) { var r = 50; var x1 = $(this).offset().left+$(this).width()/2; var y1 = $(this).offset().top+$(this).height()/2; var x2= e.clientX; var y2= e.clientY; var distance = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))); if (distance &lt;= 50) alert(&quot;Yes!&quot;); }); title与h3、b与strong、及i与em的区别&lt;strong&gt; 表示html页面上的强调（emphasized text）， &lt;em&gt; 表示句子中的强调（即强调语义）1.b和strong的区别盲人朋友使用阅读设备阅读网络时：&lt;strong&gt;会重读，&lt;b&gt;不会。两者虽然在网页中显示效果一样，但实际目的不同。&lt;b&gt;这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；&lt;strong&gt;这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；总结：&lt;b&gt;为了加粗而加粗，&lt;strong&gt;为了标明重点而加粗，也可以用其它方式来强调，比如下划线，比如字体加大，比如红色，等等，可以通过css来改变strong的具体表现。2.i和em的区别同样，I是Italic(斜体)，而em是emphasize(强调)。3.title与h1的联系与区别：从网站角度看，title更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。从文章角度看，h1则是用于概括文章主题。用户进入内容页，想看到的当然就是文章的内容，h1文章标题就是最重要的。文章标题最好只有一个，多个h1会导致搜索引擎不知道这个页面哪个标题内容最重要，导致淡化这个页面的标题和关键词，起不到突出主题的效果。区别：h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。 不使用border画出1px高的线，考虑兼容性实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？ &lt;div style=&quot;width:100%;height:1px;background-color:black&quot;&gt;&lt;/div&gt; src属性与href属性的区别src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。&lt;script src =&#39;js.js&#39;&gt;&lt;/script&gt;，当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，如果我们在文档中添加&lt;link href=&#39;common.css&#39; rel=&#39;stylesheet&#39;/&gt;，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 对canvas的理解canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。canvas标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。 WebSocket与消息推送B/S架构的系统多使用HTTP协议。HTTP协议的特点： 1 无状态协议； 2 用于通过 Internet 发送请求消息和响应消息； 3 使用端口接收和发送消息，默认为80端口； 4 底层通信还是使用SocketHTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法实现 双向通信与消息推送 ：轮询： 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用长轮询： 客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，实例：WebQQ、 Hi 网页版、 Facebook IM长连接： 在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天Flash Socket： 在页面中内嵌入一个使用了 Socket 类的 Flash 程序， JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。实例：网络互动游戏。Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点:事件驱动；异步；使用 ws 或者 wss 协议的客户端 socket；能够实现真正意义上的推送功能缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别参考文章：WebSocket 教程-阮一峰html5-websocket初探 img的title和alt的区别alt 是给搜索引擎识别，在图像无法显示时的替代文本； alt属性有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。title 是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。参考文章：img图片标签alt和title属性的区别 表单的基本组成组成：表单标签、表单域、表单按钮。 a、表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;个人基本信息&lt;/legend&gt; &lt;div&gt; &lt;label for=&quot;userName&quot;&gt;名称：&lt;/label&gt; &lt;input id=&quot;useName&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passWord&quot;&gt;密码：&lt;/label&gt; &lt;input id=&quot;passWord&quot; type=&quot;password&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;msg&quot;&gt;详细信息：&lt;/label&gt; &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; form标签： &lt;form action=&quot;表单提交的地址&quot; method=&quot;表单提交的方法&quot; id=&quot;&quot; class=&quot;&quot;&gt;fieldset标签：作用是将表单内相关元素分组；将表单内容的一部分打包，生成一组表单的字段;在一个form表单中，可以有一个或者多个fielset标签。legend标签： 作用是为fieldset标签定义标题。label标签： 该标签在页面中使用不会为用户呈现任何特殊效果，但是却可以很好地为鼠标用户改进了可用性。其作用是为input元素定义标注，要注意的是label中的for属性应与input中的id属性一致，如上述代码所示。input标签： 输入框，其中可以根据type的属性值改变输入框的作用。例如：&lt;input type=&quot;text&quot;/&gt; 是文本框，还可以是密码输入框、复选框、单选框等等。 表单提交中Get和Post方式的区别原理性区别： Http 定义的与服务器交互的四种基本方法，增删改查（ put delete post get ）；从定义而言 get 用于信息获取（状态不做迁移），而且是安全幂等的（不修改信息、同一 url 多次请求结果一致），但有时候并不严格遵循规定，比如腾讯新闻的刷新操作，因为从 server端来讲，数据状态并没有发生任何改变 ，所以也可以算成是幂等； post 可以修改服务器上的资源请求（资源的状态迁移），比如新闻评论的提交，提交前后资源被修改了。 关于幂等与否只是 http 的规定，实际中要看服务器端怎么写。表象上的区别： 提交的安全性不同： Get 将表单中的数据按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用”? “连接，而各个变量之间使用”&amp;”连接（明文提交）； Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL （依照表单提交）。 Get 传输的数据量小（ 1024 字节），这主要是因为受 URL 长度限制； URL 长度在 http 协议中没有限制，只是 IE 对 URL 有长度限制，其他浏览器取决于操作系统，理论上没有限制。 Post 可以传输大量的数据（ 2M ），理论上 http 没有限制数据量长度，服务器处理程序的处理能力限制了表单域长度，而有限制 Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。 传输信息所在 http 中的位置不同： Post 的信息作为 http 请求的内容，而 Get 是在 Http 头部传输的， get 请求可以有 body 但大多数服务器不会解析 get 请求的 body 。 (1)、 get 是从服务器上获取数据， post 是向服务器传送数据。(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。(3)、对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。(5)、 get 安全性低， post 安全性较高。 关于HTML5标签的几个知识点HTML5新增的表单元素：datalist 元素：datalist 元素规定输入域的选项列表；列表是通过 datalist 内的 option 元素创建的,option 元素永远都要设置 value 属性；如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id。keygen 元素:keygen 元素的作用是提供一种验证用户的可靠方法;keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。output 元素:output 元素用于不同类型的输出，比如计算或脚本输出。HTML5废弃的标签：第一类：表现性元素basefont big center font s strike tt u等。建议用语义正确的元素代替他们，并使用CSS来确保渲染后的效果第二类：框架类元素因框架有很多可用性及可访问性问题，HTML5规范将以下元素移除:frame frameset noframes但html5支持iframe。第三类：属性类很多表现性的属性也被新规范移除，如下：alignbody标签上的link、vlink、alink、text属性bgcolorheight和widthiframe元素上的scrolling属性valignhspace和vspacetable标签上的cellpadding、cellspacing和border属性header标签上的profile属性img和iframe元素的longdesc属性第四类：其他abbr取代acronym（用于表示缩写）object取代了appletul取代了dirHTML5 标准提供的新APIMedia API：例如video audio,Using the Camera APIText Track API: textTracks属性;返回代表可用文本字幕的TextTrackList对象Application Cache API： 应用程序缓存User Interaction ：新增的语义化元素，output元素等Data Transfer API ：webSocketCommand APIConstraint Validation APIHistory API : session localStorage cookieHTML5 存储类型有什么区别HTML5 能够本地存储数据，在之前都是使用 cookie。 HTML5 提供了下面两种本地存储方案：localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，因此它不是一种持久化的本地存储，仅仅是会话级别的存储 cookies,seesionStorage,localStorage区别：共同点：都是保存到浏览器端，都是同源。区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大。seesionStroage,在窗口关闭前有效，不在不同浏览器窗口共享。 localStroage,始终有效，永久数据，所有同源窗口共享。 cookie:在过期前有效，所有同源窗口共享 。HTML5 应用程序缓存和浏览器缓存的区别使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势：离线浏览 - 用户可在应用离线时使用它们；速度 - 已缓存资源加载得更快；减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下： &lt;!doctype html&gt; &lt;html manifest=”example.appcache”&gt; ….. &lt;/html&gt; 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。除了 audio 和 video，HTML5 还有哪些媒体标签&lt;embed&gt; 标签，定义嵌入的内容，比如插件。 &lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt; &lt;source&gt; 标签，对于定义多个数据源很有用。 &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;/video&gt; &lt;track&gt;标签，为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt; &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt; &lt;/video&gt; HTML5 中如何嵌入视频和音频类似，HTML5 支持 MP4 、WebM 和 Ogg 格式的视频，通过video标签嵌入视频，下面是简单示例： &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; Your browser does’ nt support video embedding feature. &lt;/video&gt; HTML5 中如何嵌入音频HTML5 支持 MP3 、Wav 和 Ogg 格式的音频，通过audio标签嵌入音频，示例如下： &lt;audio controls&gt; &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt; Your browser does’ nt support audio embedding feature. &lt;/audio&gt; 新的 HTML5 文档类型和字符集是什么HTML5 文档类型：&lt;!doctype html&gt;HTML5 使用 UTF-8 编码: &lt;meta charset=&quot;UTF-8&quot; &gt;]]></content>
      <categories>
        <category>interview questions</category>
      </categories>
      <tags>
        <tag>interview questions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在两台电脑上更新维护github pages + hexo博客]]></title>
    <url>%2F2018%2F01%2F07%2Fmaintain%20github%20blog%20on%20two%20computer%2F</url>
    <content type="text"><![CDATA[之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。 实现思路主要思路利用git分支实现。利用Hexo框架生成的静态博客文件默认放在博客repo的master分支，即台式机上初次搭建好的本地博客环境Hexo文件夹下的public文件夹的内容对应github上博客repo的master分支内容。现在我们需要在博客repo新建一个hexo分支，用来放Hexo源文件，即放台式机上Hexo文件夹下的全部文件，而不只是public文件夹（public用来存放静态网站文件）。 现在我们的博客repo即xxxx.github.io这个仓库有了两个分支，一个master分支用来放Hexo生成的静态网站，一个hexo分支放Hexo的源文件。相当于用hexo分支备份了之前台式机上本地的Hexo环境，在笔记本上将hexo分支clone下来，然后写文章、更新博客到hexo分支（git push到hexo分支，使得备份源文件最新），保证hexo分支的内容最新，然后执行hexo g -d命令，生成的静态文件会被默认push到master分支，更新博客站点内容。 下面来叙述一下具体的操作步骤。 原来台式机上的操作 在Github的xxx.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo（之前的默认分支是master），save保存。 然后将该仓库克隆到本地，进入该xxx.github.io文件目录。在当前目录使用Git Bash，执行git branch命令查看当前文件夹下内容所在的分支，查询结果应为新建的分支hexo。 接下来，将本地博客的部署文件（Hexo目录下的全部文件，即Hexo源文件）全部拷贝进xxx.github.io文件目录中去。最后将xxx.github.io目录下的全部文件push到hexo分支，即完成了Hexo源文件的备份过程。 注意：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可。 上面的注意点中的情形我没有遇到，直接把本地Hexo文件夹下的全部内容复制到新clone下来的xxx.github.io文件夹下，然后通过git命令push到博客repo的hexo分支。 push到hexo分支的git命令介绍:git status可以查看当前目录下哪些文件被改动过了，被改动过但还未被git管理的显示红色，被改动过但已经add添加到暂存区的显示绿色；git add .可以将当前目录下的全部改动文件添加到暂存区，以待被提交；git commit -m &quot;back up hexo files&quot;将暂存区的内容提交至HEAD，以待被push到远端；git push将HEAD内容push到远端github博客仓库的hexo分支。至此完成了台式机本地Hexo源文件备份到xxx.github.io仓库的hexo分支。 新的笔记本上的操作由于上面过程已经完成了原来电脑上本地Hexo源文件的备份，所以博客现在可以在其他电脑上维护和更新了。 由于笔记本上没有安装node.js、git等，所以需要像初次搭建博客那样，先安装配置好环境。参考之前的文章基于hexo和github搭建个人博客概述，先下载安装node.js，下载安装git。（如果电脑有这两个工具可以忽略这一步） 将新电脑即笔记本生成的ssh key添加到GitHub账户上（因为通过SSH url方式，使用git客户端第一次git clone github.com代码需要验证ssh key），具体的添加SSH key方法参考github设置添加SSH。 在笔记本上克隆xxx.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支，使用git branch命令查看。 切换到xxx.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)。 另外可以看到仓库hexo分支themes/next主题文件夹是空的，所以clone到本地的next主题文件夹也是空的（原因还没搞清楚，为什么备份的时候单单next主题文件夹push不上去），所以只好将台式机上的next主题文件夹拷贝一份到笔记本上，替换clone下来的空next主题文件夹。这个地方算是遇到的一个坑，因为本地测试的时候提示无法渲染index.html，搜索了原因有人回答是不是主题文件没有，这才发现next文件夹是空的。 还有就是，由于还需要Hexo框架帮我们生成静态网站并push到master分支，而此时你有没有发现我们还忘记装Hexo了，没装Hexo我们怎么能用hexo g -d这样的命令呢。所以最后一步，把Hexo装上。Hexo的下载安装同样参考之前的博客基于hexo和github搭建个人博客概述。之前我以为备份好Hexo源文件，再clone下来就自带Hexo环境，可以执行hexo g这样命令，我参考的那篇博文也没重装Hexo这一步，但当我试着写了文章执行本地hexo s测试时，提示找不到hexo这样的命令，然后我照初次搭建博客那样$ npm install hexo --save，又装了一下Hexo，就可以执行hexo s命令了，并测试了一下正确。 至此就可以在笔记本上写博客了。 在xxx.github.io目录下，执行hexo new post &quot;the first post on laptop&quot;，可以新建一篇文章，然后编辑撰写，或者改动以前的文章。 然后用执行git status可以查看当前目录下哪些文件被改动过了，即新写的文章、添加的文件、修改的文件等；执行git add .将当前目录下的全部改动文件添加到暂存区，以待被提交；执行git commit -m &quot;back up hexo files&quot;将暂存区的内容提交至HEAD，以待被push到远端；执行git push将HEAD内容push到远端github博客仓库的hexo分支。至此完成了笔记本本地Hexo源文件备份到xxx.github.io仓库的hexo分支的过程，即不管是在台式机操作还是在笔记本操作，都要保证hexo分支的内容是最新的。 最后执行hexo g -d命令，即将本地编辑好的.md形式的文件生成静态博客文件并push到博客repo的master分支，这一步完成了博客站点的更新。 再回到台式机上更新博客时的操作注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行git pull hexo命令，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。 另外看到一篇讲解Hexo的版本控制与持续集成的文章，将本地push到hexo分支和利用hexo部署博客静态文件到master分支的两个步骤合二为一，使用GitHub进行版本控制，又能做到一键发布。即用到了持续集成，也就是用CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo。自己还没有实际操作过，等操作过后再作总结。 reference利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>github pages</category>
      </categories>
      <tags>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画简介]]></title>
    <url>%2F2018%2F01%2F03%2FCSS%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[来自于NEXT十天训练营CSS篇关于动画的笔记。 CSS动画分类CSS动画主要有两类，即补间动画和帧动画。 补间动画只需定义一个开始状态和结束状态，其余中间状态由浏览器自动填充，使用transition属性实现。 帧动画不只要定义开始和结束状态，还需要定义中间过程的帧，使用animation属性实现。 transition动画transition动画只需定义动画的开始和结束状态，其余过渡状态由浏览器自动补全。示例代码如下： HTML结构： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS样式： .box { width: 600px; height: 200px; border: 1px solid #ccc; background-color: #fff; margin: 200px auto; } .circle { width: 50px; height: 50px; /*定义开始状态小球的颜色和位置*/ background-color: blue; border-radius: 50%; margin: 75px 0; /*注意transition有多个属性，此处为简写新形式，包括了两个属性*/ /*即transition-property: all; transition-duration: 2s;*/ /*transition-property设置过渡效果的CSS属性的名称*/ /*transtion-property的值为all，表示background-color和transform都是过渡渐变属性，*/ /*若此处transtion-property值为background-color，而transform不变，则只过渡渐变颜色，位置瞬移*/ transition: all 2s; } /*定义结束状态小球的位置和颜色*/ .box:hover .circle { background-color: red; transform: translate(550px, 0); } 实例效果见codepen。transition共有如下四个属性。 另外transition-property不支持动画的一些属性如下： 不支持将a图片过渡渐变为b图片；不支持float属性（即float属性从无到有）；不支持将width/height属性从无渐变为某个值，但支持从一个长度渐变为另一个长度；不支持display属性从无到有；不支持visibility属性；不支持poisition属性。 animation动画animation动画通过关键帧来定义动画的变化状态。示例代码如下： HTML结构： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS样式： .circle { width: 50px; height: 50px; background-color: blue; border-radius: 50%; margin: 75px 0; /*animation: circleRun 2s ease infinite;*/ /*animation也是一个简写属性，即上一句包括如下属性*/ animation-name: circleRun; animation-duration: 2s; animation-timing-function: ease; animation-iteration-count: infinite; /*此外animation还有如下几个属性*/ animation-delay: 2s; animation-direction: normal; animation-fill-mode: none; animation-play-state: running; } /*定义中间状态小球的关键帧*/ @keyframes circleRun { from { transform: translate(0, 75px); } 33% { transform: translate(150px, 75px); } 66% { transform: translate(400px, -75px); } to { transform: translate(550px, 0); background-color: red; } } 实例效果见codepen。 使用animation实现页面正在loading的效果见codepen demo-animationLoading]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS几种布局方式的学习总结]]></title>
    <url>%2F2018%2F01%2F02%2FCSS-layout%2F</url>
    <content type="text"><![CDATA[学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自CSS 常见布局方式 。CSS几种常见的布局方式如下图总结。 传统盒模型布局方式传统布局方式就是通过盒模型，使用 display属性（文档流布局） + position属性（定位布局） + float属性（浮动布局）。 文档流布局最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行。 定位布局通过 position属性来进行定位。该属性有四种不同类型的定位，分别为static（默认定位）、relative（相对定位）、absolute（绝对定位）和fixed（固定定位）。 static：若某元素的position属性的是默认static，那这个元素就在文档流中。 relative：设置为相对定位的元素不脱离文档流，参考自身的位置通过top、bottom、left和right进行定位，让这个元素以自身原来的位置为基准进行移动，元素仍然保持其未定位前的形状，它原本所占的空间仍然保留（因为它没有脱离文档流）。因此，采用相对定位的元素有可能覆盖了其他元素，因为它其实占据了两个位置，一个是移动前的位置，一个是移动后的位置，若移动后的位置和别的元素冲突，就把别的元素覆盖了。 与relative（相对定位）不同，设置为absolute（绝对定位）和fixed（固定定位）的元素脱离了文档流，元素原先在正常文档流中所占的空间会关闭，就像该元素不存在一样。 absolute: absolute（绝对定位）元素的位置相对于最近的已定位的祖先元素，若该元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 fixed: fixed（固定定位）是相对于浏览器窗口的，即将设置为fixed（固定位置）的元素固定在浏览器的某个位置上，即使拖动浏览器的滚动条，该元素的位置也不会改变。 浮动布局使用 float属性，使元素脱离文档流，浮动起来。 在CSS中使用float属性用于改变块元素对象的默认显示方式。当块元素对象设置了float属性后，它将不再独占一行，而是可以浮动到左侧或右侧，直到浮动的框外缘碰到包含框或另一个浮动框的边框为止。 注意：浮动框也不在文档流中，因此对文档流的中块框来说，浮动框就像不存在一样。这一点和absolute（绝对定位）属性类型有类似之处，但float和absolute还有以下不同： (1)absolute元素的位置相对于离它最近的已定位的祖先元素，它可以以父元素框的4个顶点为基准进行定位。而float属性定位时则是根据left或right属性值，以父元素的左上或右上为基准进行定位。 (2)采用absolute属性定位的元素不能被文本所包围，而采用float属性定位的元素可以被文本包围（float最初设计的用意就是这个，用以取代HTML中的align属性）。 (3)float的影响可控，absolute的影响不可控。设置float和absolute属性的元素都脱离了文档流，因此它们都会影响到其下方的元素。但是，absolute是布局属性，使用它时没有一种有效的方法使之与其下方的元素不重合在一起。相反，若一个元素指定了float属性，当我们向其下方（或后面）的元素的应用了clear属性后（clear:left；clear:right；clear:both），其后的元素就不再受影响了。所以一般在网页布局时，更多的使用float属性。 flex布局flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 flex是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果。但是要注意其浏览器的兼容性，flex 只支持 ie 10+，所以还是要根据项目情况使用。 使用flex布局只需要将其display属性设置为 flex 即可，也可以设置行内的 flex。 Webkit内核的浏览器，必须加上 -webkit 前缀。注意：设为flex布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 Flexible Box模型如下： 在flex中，最核心的概念就是容器和轴，所有的属性都是围绕容器和轴设置的。其中，容器分为父容器和子容器。轴分为主轴（main axis）和交叉轴（cross axis）（主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90°）。 在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。 在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 父容器属性父容器上有六个属性：flex-direction：主轴的方向。 flex-wrap：超出父容器子容器的排列样式。 flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。 justify-content：子容器在主轴的排列方向。 align-items：子容器在交叉轴的排列方向。 align-content：多根轴线的对齐方式。 flex-direction 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。 flex-wrap 属性决定子容器如果在一条轴线排不下时，如何换行。 flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 justify-content 属性定义了子容器在主轴上的对齐方式。 align-items 属性定义子容器在交叉轴上如何对齐,具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 子容器属性子容器也有 6 个属性：order：子容器的排列顺序。 flex-grow：子容器剩余空间的拉伸比例。 flex-shrink：子容器超出空间的压缩比例。 flex-basis：子容器在不伸缩情况下的原始尺寸。 子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写。 align-self属性。 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。 flex-shrink 属性定义了子容器弹性收缩的比例。例如，超出的部分按 1:2 的比例从给定子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap。 flex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写，默认值为 0 1auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父容器align-items 属性。默认值为 auto，表示继承父元素的 align-items属性，如果没有父元素，则等同于 stretch。 grid网格布局flex 布局虽然强大，但是只能是一维布局，如果要进行二维布局，还需要使用 grid。 grid 布局又称为“网格布局”，可以实现二维布局方式，和之前的 表格table布局差不多，然而，这是使用 CSS 控制的，不是使用 HTML 控制的，同时还可以依赖于媒体查询根据不同的上下文得新定义布局。 网格布局还可以让我们摆脱现在布局中存在的文档流限制，换句话说，你的结构不需要根据设计稿从上往下布置了。这也意味着您可以自由地更改页面元素位置。这最适合你在不同的断点位置实现你最需要的布局，而不再需要为响应你的设计而担心HTML结构的问题。和 table 布局不同的是，grid 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。 没有 HTML 结构的网格布局有助于使用流体、调整顺序等技术管理或更改布局。通过结合 CSS 的媒体查询属性，可以控制网格布局容器和他们的子元素，使用页面的布局根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容。 grid 网格布局中的基本概念网格线(Grid Lines) 组成了网格，他是网格的水平和垂直的分界线。一个网格线存在行或列的两侧。我们可以引用它的数目或者定义的网格线名称。 网格轨道(Grid Track)是就是相邻两条网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。 网格单元格(Grid Cell) 是指四条网格线之间的空间。所以它是最小的单位，就像表格中的单元格。 网格区域(Grid Area) 是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。 使用grid布局使用 grid 布局很简单，通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小） 就可以了。 网格容器中的所有子元素就会自动变成网格项目（grid item），然后设置列（grid-template-columns）和 行（grid-template-rows）的大小，设置 grid-template-columns 有多少个参数，生成的 grid 列表就有多少 列。 注：当元素设置了网格布局，column、float、clear、vertical-align属性无效。 referenceCSS定位——position、float小结]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages自定义域名及DNS相关介绍]]></title>
    <url>%2F2017%2F12%2F29%2Fgithub-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！ 域名相关知识域名是什么根据百度百科，域名（Domain Name），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称。用于在数据传输时标识计算机的电子方位。 对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。域名同时也仅限于ASCII字符的一个子集，这使得很多其他语言无法正确表示他们的名字和单词。 在域名中大小写是没有区分的。域名一般不能超过5级，从左到右域的级别变高，高的级域包含低的级域。域名在整个Internet中是唯一的，当高级子域名相同时，低级子域名不允许重复。一台服务器只能有一个IP地址，但是却可以有多个域名。 任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。这是基于13个全球范围的“根服务器”，其维护组织除了当中的3个以外，其他都位于美国。从这13个根服务器开始，余下的Internet DNS命名空间被委托给其他的DNS服务器， 这些服务器提供DNS名称空间中的特定部分。 域名级别整个DNS系统是由许多域所组成，每个域下又细分更多的域，DNS域构成了层次树状结构，自上而下分别是根域、顶级域名、二级域名…，最后是主机名。 顶级域名（一级域名）——如：.com、.net、.edu、.gov、.cn等。二级域名我们常常能够申请到的域名，在顶级域名的左侧加上的一个自定义的文字段，例如shirley5li.me，通常所说申请的域名，往往指的是这个二级域名。 以www.sina.com.cn为例，该域名是三级域名，其中sina.com.cn为新浪Web服务器的【域名】，www不是域名的组成部分而是URL的组成部分。所以该例中， 一级域名.cn、二级域名.com.cn、三级域名.sina.com.cn。主机名www（表示该主机所提供的服务为www服务，即Web服务器。 URL的构成——http://主机名 . 域名（端口号、参数、查询等可选。 域名(Domain Name)可由若干部份组成,各部份之间用圆点分开，域名前加上【主机类型信息】（如：www、ftp）和【传输协议信息】就构成了网址（URL）http://www.xxxx.cn。 子域名(sbudomain name) 相对于上文所提到的“我们通常所说的域名”（二级域名）的基础上，又加入了子域名的概念，就是在一个域名的前面，加上新的字段，代表这个域名下的某个特定的主机或者协议。最常用的就是WWW协议，所以，我的子域名www.shirley5li.me就是shirley5li.me的WWW子域名。 DNS相关知识网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。 例如，www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。 域名服务器分不同的组来负责各子系统的名字。系统中的每一层叫做一个域，每个域用一个点分开。所谓域名服务器（即Domain Name Server，简称Name Server、DNS）实际上就是装有域名系统的主机。它是一种分层结构数据库，能够执行名字解析（name resolution）。 DNS服务器上都存了些啥？最主要的就是能够完成域名解析的一些记录 A记录（A record)A记录在DNS中的意义就是，域名到ip地址的转换。所以，当我们在DNS服务器中添加一个A记录时，是告诉服务器，将某个特定的域名映射到一个ip地址。 CNAME记录（CNAME record)CNAME的意义，简单说就是别名，即将一个域名射到另一个域名（区别于A记录的ip）。所以，CNAME通常有两种用法: (1)不同顶级域名之间的跳转。例如：我的域名是 shirley5li.me(顶级域名为me)。如果希望当访问这个域名的时候，实际上是访问的shirley5li.github.io（顶级域名为io）的主页时，虽然他们在不同的顶级域名，但是可以用CNAME记录映射。 (2)将一个子域名映射到域名。例如：你想当访问者输入www.shirley5li.me（一个WWW子域名）的时候，仍旧访问shirley5li.me这个域名所指向的内容时，可以将www.shirley5li.me利用CNAME记录映射到shirley5li.me。 NS记录（Name Server）指定了负责解析我这个域名的服务器的地址。这条记录赋予我们一个特殊的能力，就是，我可以让自己指定的一个DNS解析服务器，而不一定是域名提供商自带的域名解析服务器。简单来说，就是在godaddy买的域名，默认是使用godaddy的域名服务器来进行域名解析的，但是如果我想让别的server解析（例如NDSPod），而不受godaddy服务器的限制呢？那就是更改这个NS记录的内容。一般来讲，是两条记录，一条主服务器，一条副服务器。 因此很多人推荐Godaddy注册购买域名，DNSpod负责解析，即修改NS记录。 域名服务器哪家强域名通过向域名注册商购买获得，如今有很多域名注册商，比如国内的万网以及国外的GoDaddy。考虑各种因素，在GoDaddy上购买域名相比万网的好处是不需要各种审核，很多人推荐使用godaddy，Godaddy注册购买域名，DNSpod解析。雅蠛蝶，那我也用狗爹了~2017年Godaddy域名注册教程 先来狗爹注册个账号，然后搜索想要的域名购买。这里又在选择什么样的域名后缀纠结半天，什么.me .cc .org .com，最后选择了shirley5li.me，因为价格最低。。。然后支付宝付款就好了。 github pages绑定域名详细步骤既然域名已经买完了，直接是没法用的，因为没有进行DNS解析，别人是没法正常通过域名访问你的界面的，这里使用DNS进行解析。 域名绑定的含义就是当你访问你的域名时，浏览器会自动跳转到刚才创建的 Github Pages(username.github.io)。实现绑定的关键在于设置 DNS 解析。在 GoDaddy 注册的域名，由于 GFW 的存在，需要使用第三方 DNS 服务来解析域名。推荐使用鹅厂的 DNSPOD。鹅厂的服务可靠性高同时也不会被墙。 域名购买完成后，回到Github项目上，即搭建博客那个项目，点击设置Settings，找到Custom domain，填入申请的域名，并保存。 这个操作等同于在项目根目录下创建一个名为CNAME的文件，文件内容为上述填写的域名。 回到GoDaddy的主页上，点击个人用户–&gt;管理域名。 再点击那三个点点（真的对用户超不友好，找半天！！！），选择管理DNS。 默认的DNS记录如下所示： 关于A记录的修改，在名称@这条记录中，将值改为Github博客的IP地址（由ping得到，即151.101.77.147。操作如下： 关于CNAME记录的修改，在名称www这条记录中，将值改为github博客默认的域名，即shirley5li.github.io。 该阶段修改后修的DNS管理记录如下： 上图中两条NS记录的值为狗爹默认的域名服务器的地址，为防止背墙以及速度等原因，采用第三方国内域名服务器NDSPod来解析我们在狗爹申请的域名。 接下来我们到NDSPod来注册账号，注册完账号后，在DNSPOD首页–&gt;管理控制台–&gt;域名解析–&gt;添加域名，将在狗爹申请的域名填入，点确定。如下所示。 然后点击刚刚添加的域名，来管理DNS记录。DNS记录各参数含义：(1)主机记录， @：不通过任何前缀访问域名 ， www：通过www前缀访问域名。(2)记录类型， A：在记录值处写主机IP地址，NS：记录值是DNSPOD提供的Name Server地址，CNAME：记录值是域名的别名。 添加一条A记录，主机类型是@，记录值填ping Github博客得到的ip地址。再将狗爹上的两条CNAME记录添加上。最后DNSPOD上的DNS各条记录如下所示: 然后将上图中的两条NS记录值（DNSPOD默认的域名服务器地址），填入Godaddy的自定义域名服务器。即： 狗爹更改后，再刷新一下，域名服务器如下： 等待一段时间就可以成功用DNSPod解析域名到Github博客，在浏览器地址栏输入shirley5li.me，可以看到如下github pages博客主页： 至此大功告成。 PS:参考一些博客，他们在域名注册成功后，在github博客本地目录source下创建CNAME文件，里面填入自己申请的域名即shirley5li.me，保存后hexo g -d上传至Github Repo中。此步骤相当于在搭建博客那个项目，点击设置Settings，在Custom domain，填入申请的域名的过程，因为上面已经操作了Custom domain填入申请域名的过程，所以没有此步骤也可以正常解析shirley5li.me，但再添加也无妨。 reference域名–wikipedia 怎么区分域名级别，举例说明更易懂 从DNS到github pages自定义域名 – 漫谈域名那些事 老左所理解的建站域名的选择以及域名投资的一些看法 想注册一个作个人博客用的域名，应该使用哪个域名注册提供商？ 使用 Hexo + Github Pages 搭建独立博客 Blog绑定域名——Godaddy + DNSPod]]></content>
      <categories>
        <category>github pages</category>
      </categories>
      <tags>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文集锦]]></title>
    <url>%2F2017%2F12%2F27%2Fgood-blog-post%2F</url>
    <content type="text"><![CDATA[以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。 浏览器浏览器内部工作原理 当在浏览器地址栏输入一个网址的时候，究竟发生了什么? html5-websocket初探 移动端页面布局]]></content>
      <categories>
        <category>bolgPost</category>
      </categories>
      <tags>
        <tag>blogPost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程（3）学习笔记]]></title>
    <url>%2F2017%2F12%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[JavaScript学习笔记。 模仿块级作用域JS没有块级作用域，即在块语句中定义的变量，实际是在包含函数中创建的，而非在块语句中创建的。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 在Java、C++等语言中，for循环中定义的变量i只存在于for循环语句块中，循环一旦结束，变量i就会被销毁。而在JS中，变量i是定义在outputNumbers()这个包含函数的活动对象中的，因此从它被定义开始，就可以在函数内部随处访问它。 即使在一个函数中重新声明同一个变量，也不会改变它的值。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } var i; console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 JS不会提醒是否多次声明了同一个变量，在此情况下，它对后续重复的变量声明视而不见，但会执行后续声明中的变量初始化。可以通过匿名函数模仿块级作用域来避免多次声明同一个变量的问题。 用作块级作用域（私有作用域）的匿名函数语法如下： (function() { //这里为块级作用域 })(); 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。使用私有作用域如下： function outputNumbers(count) { (function() { for( var i = 0; i &lt; count; i++) { console.log(i); } })(); console.log(i);//导致一个错误！！！ } 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 私有变量严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的。但有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部无法访问这些变量，包括函数参数、局部变量、在函数中定义的其他函数。 把有权访问上述私有变量和私有函数的公有方法称为特权方法，有两种在对象上创建特权方法的方式。 第一种：在构造函数中定义特权方法，基本模式如下 function MyObject() { //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //特权方法 this.publicMethod = function() { privateVariable++; return privateFunction(); }; } 能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。 在创建构造函数实例后，除了使用特权方法，没有其他方式可以直接访问构造函数内部的私有变量和私有函数。 利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。 在构造函数中定义特权方法的缺点，就是必须使用构造函数模式来实现特权方法，而构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这一问题。 第二种：使用静态私有变量实现特权方法 通过在私有作用域中定义私有变量或函数，也可以创建特权方法。基本模式如下： (function() }{ //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //构造函数 MyObject = function() { }; //公有方法/特权方法 MyObject.prototype.publicMethod = function() { privateVariable++; return privateFunction(); }; })(); 公有方法是在构造函数原型上定义的，体现了典型的原型模式。注意：该模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，并不是我们想要的，因此也没有使用关键字var声明MyObject。初始化未经声明的变量，总会创建一个全局变量，因此MyObject就变成了一个全局变量，能够在私有作用域之外被访问到。但在严格模式下，给未经声明的变量赋值会导致错误。 该模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数由实例共享，在一个实例上调用公有方法，会影响所有实例。以该方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。因此选择使用实例变量，还是静态私有变量，视具体需求而定。 BOM-window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的global对象。 全局作用域所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例如： var age = 29; function sayAge() { alert(this.age); } alert(window.age); //29 sayAge(); //29 window.sayAge(); //29 全局变量会变为window对象的属性，定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记01]]></title>
    <url>%2F2017%2F12%2F08%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-ing%2F</url>
    <content type="text"><![CDATA[AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。 AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。Angular可以帮助你组织JavaScript代码，可以创建响应式网站（会对用户的请求产生快速的反应），Angular可以和JQuery很好的协调、方便测试（搭建可维护的应用）。 简单的解释Angular就是一个可以给HTML加上互动性的客户端JS框架。 关于传统网页请求和AngularJS网页请求之间的区别，参见博客AngularJS系列——简介。 AngularJS简介AngularJS 通过 ng-directives 扩展了 HTML。 ng-app 指令定义一个 AngularJS 应用程序。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序变量。 ng-bind 指令把应用程序数据绑定到 HTML 视图。 例如： &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;h1&gt;Hello {{name}}&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者”。ng-model 指令把输入域的值绑定到应用程序变量 name。ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。 AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素&quot;背后&quot;添加代码。 AngularJS 支持输入验证。 表达式AngularJS 使用表达式把数据绑定到 HTML。 AngularJS 表达式写在双大括号内：。AngularJS表达式很像JavaScript表达式：它们可以包含文字、运算符和变量。 &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;我的第一个表达式: {{ 5 + 5 }}&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： {{ quantity * cost }}&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： &lt;span ng-bind=&quot;quantity * cost&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS表达式与JavaScript表达式比较 类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。 指令AngularJS 通过指令新属性来扩展 HTML，指令带有前缀 ng-。 AngularJS 通过内置的指令来为应用添加功能，允许自定义指令。 ng-app 指令初始化一个 AngularJS 应用程序。 ng-init 指令初始化应用程序数据。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。 ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素 例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&apos;John&apos;&quot;&gt; &lt;p&gt;在输入框中尝试输入：&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt; &lt;p&gt;你输入的为： {{ firstName }}&lt;/p&gt; &lt;/div&gt; 使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive。 &lt;body ng-app=&quot;myApp&quot;&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; &lt;/body&gt; 你可以通过以下方式来调用指令：元素名、属性、类名、注释。 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; &lt;!-- directive: runoob-directive --&gt; AngularJS模型 ng-model指令ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript高级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F26%2FfreeCodeCamp-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS高级算法编程例题的学习总结。 Validate US Telephone Numbers题目：如果传入字符串是一个有效的美国电话号码，则返回 true. 用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法): 555-555-5555 (555)555-5555 (555) 555-5555 555 555 5555 5555555555 1 555 555 5555 在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false. tips:RegExp 实现 function telephoneCheck(str) { //^1?表示以1开头，1匹配0次或1次 //\s?表示空白字符匹配0次或1次 //\d{3}匹配一个0-9的数字三次 //\(\d{3}\)匹配（一个0-9的数字三次），比上面多一个括号，左右括号分别需要加上转义字符\ //[ -]?表示空格或者连字符-匹配0次或1次 //\d{4}$表示已4位数字结尾($) var re=/^1?\s?(\d{3}|\(\d{3}\))[ -]?\d{3}[ -]?\d{4}$/; return re.test(str); } telephoneCheck(&quot;1 555)555-5555&quot;);//返回false Symmetric Difference题目：创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组. 给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). tips:Array.reduce() 实现 function sym(args) { //将多个参数合并为一个数组arr var arr = []; for(var i = 0; i &lt; arguments.length; i++) { arr.push(arguments[i]); } //也可以使用Array.from()将输入参数合并为一个数组 //var arr = Array.from(arguments); //temp为所有项都没同时出现在两个相邻数组的数组，但temp内部可能有重复元素，因为单个数组内部可能元素重复 //pre是前一个数组，cur是当前数组 var temp = arr.reduce(function(prev, cur, index) { //a数组由prev数组在cur中没有出现过的元素组成 var a = prev.filter(function(item) { return cur.indexOf(item) &lt; 0; }); //b数组由cur数组在prev中没有出现过的元素组成 var b = cur.filter(function(item){ return prev.indexOf(item) &lt; 0; }); //合并a和b作为新的prev return a.concat(b); }); //对temp去重 return temp.filter(function(item, index, array){ return array.indexOf(item) == index; }); } sym([1, 2, 3], [5, 2, 1, 4]); Exact Change题目：设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数. cid 是一个二维数组，存着当前可用的找零. 当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”.否则, 返回应找回的零钱列表,且由大到小存在二维数组中. tips:Global Object 思路：输入为商品价格，实际付款，收银机零钱的余额。然后返回值有三种，如果找不开返回”Insufficient Funds”；如果正好找开，收银机余额空了，返回”Closed”；其余则返回找零的数组。 先将美元的各面额存入数组，对面额数组由大到小遍历，如果待找零钱大于该面额且该面额在收银机中存在的话，则进行该面额的找零操作，否则进入下一面额的找零操作。本面额的找零操作过程为：先根据待找零钱计算出该面额需要的张数，如果待找零钱&gt;=该面额的总值，则将该面额的钱全部给出，然后待找零钱更新，将该面额的找零结果输出；如果待找零钱小于该面额的总值，则从该面额总值中给出需要找出的那几张，然后更新待找零钱，输出该面额的找零结果。 实现 function checkCashRegister(price, cash, cid) { var change = cash - price;//待找零钱数目 var denominationArr = [0.01, 0.05, 0.1, 0.25, 1, 5, 10, 20, 100];//将不同面额存入数组，对应于cid[i][0] var total = 0;//用来记录收银机总共的零钱数 var money = change;//将待找零钱数change备份，因为下面找零过程中会更新change var resultArr = [];//用来输出找零列表 //从大面额到小面额遍历 for(var i = cid.length - 1; i &gt;= 0; i--) { total += cid[i][1];//记录收银机的总钱数 //如果待找零钱大于等于某个面额，并且该面额的钱数大于0，则需要给出该面额的零钱 if(change &gt; denominationArr[i] &amp;&amp; cid[i][1] &gt; 0) {//denominationArr[i] 表示第i种面额钱的面值，cid[i][1]表示收银机中该面额的总额 //num表示需要给出的该面额的数量 var num = parseInt(change / denominationArr[i]); //如果change需要的第i种面额的钱数大于等于收银机中该面额的实际钱数，则将收银机中该面额的钱全部给出,更新change和resultArr if(denominationArr[i] * num &gt;= cid[i][1]) { change -= cid[i][1]; resultArr.push(cid[i]); } else { //否则change需要的第i种面额的钱小于收银机中该面额的实际钱数，则找出change需要的该面额数目，更新change和resultArr change -= denominationArr[i] * num; resultArr.push([cid[i][0], denominationArr[i] * num]); } //操作过程中会使得change变为一个无限小数，因此使用.toFixed(2)方法保留两位小数 change = change.toFixed(2);//四舍五入保留两位小数 } } //如果收银机中的总钱数正好等于待找零钱数，返回&quot;Closed&quot; if(total=== money) { return &quot;Closed&quot;; } //如果收银机中的总钱数不够找，或者不能正好找整即change不能最后更新到0，则返回&quot;Insufficient Funds&quot; else if(total &lt; money || (change-0) !== 0) { //使用(cahnge-0)将0.00转化为0 return &quot;Insufficient Funds&quot;; } return resultArr; } checkCashRegister(3.26, 100.00, [[&quot;PENNY&quot;, 1.01], [&quot;NICKEL&quot;, 2.05], [&quot;DIME&quot;, 3.10], [&quot;QUARTER&quot;, 4.25], [&quot;ONE&quot;, 90.00], [&quot;FIVE&quot;, 55.00], [&quot;TEN&quot;, 20.00], [&quot;TWENTY&quot;, 60.00], [&quot;ONE HUNDRED&quot;, 100.00]]); //返回[[&quot;TWENTY&quot;, 60.00], [&quot;TEN&quot;, 20.00], [&quot;FIVE&quot;, 15], [&quot;ONE&quot;, 1], [&quot;QUARTER&quot;, 0.50], [&quot;DIME&quot;, 0.20], [&quot;PENNY&quot;, 0.04]] 注意： js计算浮点数精度不准确容易导致一些小问题，老是有几个测试例子通不过，使用.toFixed(2)方法四舍五入保留两位小数，但该方法也不严谨。具体见博客关于js浮点数计算精度不准确问题的解决办法。 另外由于change = change.toFixed(2)，使得找零完毕后change=&quot;0.00&quot;，因此使用(cahnge-0)将0.00转化为0，否则使用严格不等change！==0是错误的，因为0.00和0不完全相等。当然若不使用 (change-0) !== 0，也可以使用不严格不等change != 0。 Inventory Update题目：依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列. tips:Global Array Object 实现 function updateInventory(arr1, arr2) { //将现有库存的货物名称存入数组curGoodsArr var curGoodsArr = []; for(var i = 0; i &lt; arr1.length; i++) { curGoodsArr.push(arr1[i][1]); } for(var j = 0; j &lt; arr2.length; j++) { //若现有库存中没有新进货物类型，则将新货物名称和数量一并添加到库存数组，名称需按字母顺序排序 //将新货物名称追加到数组curGoodsArr,再对数组排序。sort()方法在原数组上排序，不生成副本 if(curGoodsArr.indexOf(arr2[j][1]) === -1) { //注意push()方法可向数组的末尾添加一个或多个元素，返回新的长度。注意是长度，不是返回新的数组！！！ curGoodsArr.push(arr2[j][1]); //给货物名称按字母排序 curGoodsArr.sort(); //找到该新货物名称在排序后出现在curGoodsArr数组中的索引，该索引值也是新货物应该出现在库存数组中的顺序 var indexNewGoods = curGoodsArr.indexOf(arr2[j][1]); //将新货物名称和数量一并插入到库存数组,使用.splice()方法,该方法会改变原始数组 arr1.splice(indexNewGoods, 0, [arr2[j][0], arr2[j][1]]); } //如果现有库存货物中已经新进货物的类型，则更新库存数量 else { //index为已有货物在库存货物名称数组中的索引，也即货物在库存数组中出现的顺序 var index = curGoodsArr.indexOf(arr2[j][1]); //更新库存数量，即等于原来的库存数量+新进的数量 arr1[index][0] =arr1[index][0] + arr2[j][0]; } } return arr1; } // 仓库库存示例 var curInv = [ [21, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [1, &quot;Hair Pin&quot;], [5, &quot;Microphone&quot;] ]; var newInv = [ [2, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [67, &quot;Bowling Ball&quot;], [7, &quot;Toothpaste&quot;] ]; updateInventory(curInv, newInv);//返回[[88, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [3, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [5, &quot;Microphone&quot;], [7, &quot;Toothpaste&quot;]] No repeats please题目：把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准。 例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a). 考察全排列 tips:Permutations RegExp 全排列算法原理和实现 实现 //求一个字符串的全排列字符串中，不含连续重复字符的字符串个数 function permAlone(str) { //将输入字符串转化为数组 strArr = str.split(&quot;&quot;); //求该字符串数组的全排列形式 permResultArr = []; perm(strArr, 0, strArr.length-1); //找出全排列后非连续重复的字符串个数 var count = 0; for(var i = 0; i &lt; permResultArr.length; i++) { if(conRepCharacter(permResultArr[i])) { count += 1; } } return count; } //判断一个字符串是否含连续重复的字符，若不包含连续重复字符，则返回true function conRepCharacter(str) { if(str.length === 1) { return true; } for(var i = 0; i &lt; str.length-1; i++) { if(str[i+1] === str[i]) { return false; } } return true; } //交换数组中两个字符的位置 function swapCharacter(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } //求给定字符串数组的全排列,其中strArr表示输入字符串转化成的数组，flag表示递归到哪一位，end表示递归结束的位即字符串长度减1 function perm(strArr, flag, end) { //递归结束输出结果 if(flag === end) { permResultArr.push(strArr.join(&quot;&quot;)); } for(var i = flag; i &lt;= end; i++) { //将字符串中的所有字母分别与第一个字母交换 strArr = swapCharacter(strArr, flag, i); //对交换后的字符串继续递归排列，由于第一个字母已经排列，因此从一个字母开始排列，即flag+1 perm(strArr, flag+1, end); //由于在进入到下一次循环时序列是被改变了，可如果要假定第一个字母的所有可能性的话，必须是建立在这些序列的初始状态一致的情况下 //因此通过再次交换恢复之前的排列顺序 strArr = swapCharacter(strArr, flag, i); } return permResultArr; } permAlone(&quot;abc&quot;);//返回6 Friendly Date Ranges题目：把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1). 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了；在这种情况下，如果月份开始和结束日期如果在同一个月，则结束日期月份也不用写了。另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。 例如:包含当前年份和相同月份的时候，makeFriendlyDates([“2017-01-02”, “2017-01-05”]) 应该返回 [“January 2nd”,”5th”]。不包含当前年份，makeFriendlyDates([“2003-08-15”, “2009-09-21”]) 应该返回 [“August 15th, 2003”, “September 21st, 2009”]。 考虑清楚所有可能出现的情况，包括传入的日期区间是否合理。对于不合理的日期区间，直接返回 undefined 即可。 tips:String.split() String.substr() parseInt() 实现 function makeFriendlyDates(arr) { var resultArr = []; //开始日期数组 var startArr = arr[0].split(&quot;-&quot;); //结束日期数组 var endArr = arr[1].split(&quot;-&quot;); //开始日期的年月日 var sYear = parseInt(startArr[0], 10); var sMonth = parseInt(startArr[1], 10); var sDay = parseInt(startArr[2], 10); //结束日期的年月日 var eYear = parseInt(endArr[0], 10); var eMonth = parseInt(endArr[1], 10); var eDay = parseInt(endArr[2], 10); //开始日期与结束日期之间相差的天数 var distDays = (eYear-sYear)*365 + (eMonth-sMonth)*30 + eDay-sDay; //获取当前日期的年份 var currDate = new Date(); var currYear = currDate.getFullYear(); //月份字符串数组 var monthsArr = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]; //日字符串数组 var daysArr = [&quot;1st&quot;,&quot;2nd&quot;,&quot;3rd&quot;,&quot;4th&quot;,&quot;5th&quot;,&quot;6th&quot;,&quot;7th&quot;,&quot;8th&quot;,&quot;9th&quot;,&quot;10th&quot;,&quot;11th&quot;,&quot;12th&quot;,&quot;13th&quot;,&quot;14th&quot;,&quot;15th&quot;,&quot;16th&quot;,&quot;17th&quot;,&quot;18th&quot;,&quot;19th&quot;,&quot;20th&quot;,&quot;21st&quot;,&quot;22nd&quot;,&quot;23rd&quot;,&quot;24th&quot;,&quot;25th&quot;,&quot;26th&quot;,&quot;27th&quot;,&quot;28th&quot;,&quot;29th&quot;,&quot;30th&quot;,&quot;31st&quot;]; //先判断日期区间是否合理,若不合理返回undefined if(distDays &lt; 0) { return &quot;undefined&quot;; } //如果开始日期和结束日期一样，则返回一个 if(sYear === eYear &amp;&amp; sMonth === eMonth &amp;&amp; sDay === eDay) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期如果在同一个月，则开始日期年份、结束日期年份和月份也不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot;+ daysArr[sDay-1], daysArr[eDay-1]]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则开始日期年份、结束日期年份不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth !== eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1], monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期在同一个月,则结束日期年份和月份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear === eYear &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则结束日期年份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear !== eYear &amp;&amp; distDays &gt; 30) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差大于等于一年 if(distDays &gt;= 365) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1] + &quot;, &quot; + eYear]; return resultArr; } } makeFriendlyDates([&quot;2001-12-20&quot;, &quot;2001-12-20&quot;]);//返回[&quot;December 20th, 2001&quot;] Make a Person题目：用下面给定的方法构造一个对象. 方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast). 所有有参数的方法只接受一个字符串参数.所有的方法只与实体对象交互. tips:Closures Details of the Object Model 实现 var Person = function(firstAndLast) { this.getFirstName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[0]; }; this.getLastName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[1]; }; this.getFullName = function() { return firstAndLast; }; this.setFirstName = function(first) { var arr = firstAndLast.split(&quot; &quot;); arr[0] = first; firstAndLast = arr.join(&quot; &quot;); }; this.setLastName = function(last) { var arr = firstAndLast.split(&quot; &quot;); arr[1] = last; firstAndLast = arr.join(&quot; &quot;); }; this.setFullName = function(firstAndLast2) { firstAndLast = firstAndLast2; }; }; var bob = new Person(&apos;Bob Ross&apos;); bob.getFirstName();//返回&quot;Bob&quot; Map the Debris题目：返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期.原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}. 求得的值应该是一个与其最接近的整数，轨道是以地球为基准的. 地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI tips:Math.pow() Math.round() 实现 function orbitalPeriod(arr) { var GM = 398600.4418; var earthRadius = 6367.4447; //轨道周期公式 T=2π√(a^3/GM) for(var i = 0; i &lt; arr.length; i++) { //a为轨道半径，等于地球半径加平均海拔 var a = earthRadius + arr[i].avgAlt; var T1 = Math.sqrt(4 * Math.pow(Math.PI, 2) * Math.pow(a, 3) / GM); //将求得的周期转化为整数 var T = Math.round(T1); //删除原有属性海拔 delete arr[i].avgAlt; //添加新的属性轨道周期 arr[i].orbitalPeriod = T; } return arr; } orbitalPeriod([{name : &quot;sputnik&quot;, avgAlt : 35873.5553}]);//返回[{name: &quot;sputnik&quot;, orbitalPeriod: 86400}] Pairwise题目：举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。 所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。 tips:Array.reduce()自己没有用上reduce()方法 实现 function pairwise(arr, arg) { var sumIndex = 0; for(var i = 0; i &lt; arr.length; i++) { //与当前元素应该配对的元素值 var pairVal = arg - arr[i]; //配对元素应有的索引值,配对元素不能为自己 var pairIndex = arr.indexOf(pairVal); //如果找到与当前元素配对的，则将这一对的索引值累加，并将当前元素和与之配对的元素值置为-1 if(pairIndex !== -1 &amp;&amp; pairIndex !== i) { arr[i] = -1; arr[pairIndex] = -1; sumIndex += i + pairIndex; } } return sumIndex; } pairwise([1, 3, 2, 4], 4);//返回1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-demos学习笔记]]></title>
    <url>%2F2017%2F11%2F20%2Freact-demos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[来自阮一峰的博客React 入门实例教程学习。 JSX语法简介React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 JSX 就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到 &lt;，JSX就当HTML解析，遇到 { 就当JavaScript解析。 JS语法 var child1 = React.createElement(&apos;li&apos;, null, &apos;First Text Content&apos;); var child2 = React.createElement(&apos;li&apos;, null, &apos;Second Text Content&apos;); var root = React.createElement(&apos;ul&apos;, { className: &apos;my-list&apos; }, child1, child2); JSX语法 var root =( &lt;ul className=&quot;my-list&quot;&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt; ); JSX将XML语法直接加入JS中,通过代码而非模板来高效的定义界面。之后JSX通过翻译器转换为纯JS再由浏览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。 另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。JSX只是创建虚拟DOM的一种语法格式而已,除了用JSX,我们也可以用JS代码来创建虚拟DOM. 一篇简要介绍JSX语法的文章深入浅出React（三）：理解JSX和组件。 HTML模板使用 React 的网页源码，结构大致如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // starts here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最后一个 标签的 type 属性为 text/babel ,因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”。 上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。 ReactDOM.render()React最基本的方法，用于将模板转为 HTML 语言，并插入到指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); 上面代码将一个 h1 标题，插入到 example 节点。代码执行结果如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;h1 data-reactroot=&quot;&quot;&gt;Hello, world!&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JSX语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。 &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function (name, index) { return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; JSX 的基本语法规则：遇到 HTML 标签（以 &lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。上述代码执行结果如下所示。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员。 var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, ]; ReactDOM.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById(&apos;example&apos;) ); 上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，结果如下。 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass() 方法就用于生成一个组件类。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; } }); ReactDOM.render( &lt;HelloMessage name=&quot;John&quot; /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，变量 HelloMessage 就是一个组件类。模板插入 时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。执行结果如下所示。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。即在组件类中通过js获取组件的class属性时，需要使用this.props.className。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt; Hello {this.props.name} &lt;/h1&gt;&lt;p&gt; //错误，包含了两个顶层标签，h1和p some text &lt;/p&gt;; } }); 上面代码会报错，因为HelloMessage组件包含了两个顶层标签：h1和p。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); } }); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body ); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。执行结果如下所示。 注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法。 PropTypes组件属性组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求。例如： var MyTitle = React.createClass({ propTypes: { title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); 上述代码中，Mytitle组件类有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。假如设置title属性的值是number类型就会报错，如下： var data = 123; ReactDOM.render( &lt;MyTitle title={data} /&gt;, document.body ); title属性就通不过验证了。控制台会显示一行警告信息，如下所示： getDefaultProps 方法可以用来设置组件属性的默认值. var MyTitle = React.createClass({ getDefaultProps : function () { return { title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 上面代码会输出”Hello World”。 获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 var MyComponent = React.createClass({ handleClick: function() { this.refs.myTextInput.focus(); }, render: function() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); } }); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，组件类 MyComponent 的子节点有一个文本输入框，用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为此，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 注意，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数 handleClick，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 。 var LikeButton = React.createClass({ getInitialState: function() { //初始状态 return {liked: false}; }, handleClick: function(event) { this.setState({liked: !this.state.liked}); }, render: function() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); } }); ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;) ); 上述组件类的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件， 调用Click 事件的回调函数 handleClick，导致状态变化。 this.setState 方法用于修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 var Input = React.createClass({ getInitialState: function() { return {value: &apos;Hello!&apos;}; }, handleChange: function(event) { this.setState({value: event.target.value}); }, render: function () { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); } }); ReactDOM.render(&lt;Input/&gt;, document.body); 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况。 组件的生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 栗子: var Hello = React.createClass({ getInitialState: function () { return { opacity: 1.0 }; }, componentDidMount: function () { this.timer = setInterval(function () { var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) { opacity = 1.0; } this.setState({ opacity: opacity }); }.bind(this), 100); }, render: function () { return ( &lt;div style={{opacity: this.state.opacity}}&gt; Hello {this.props.name} &lt;/div&gt; ); } }); ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.body ); 上述代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。执行结果如下所示： 注意：组件的style属性的设置方式也值得注意，不能写成 style=&quot;opacity:{this.state.opacity};&quot; 要写成 style={{opacity: this.state.opacity}} 这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。 var UserGist = React.createClass({ getInitialState: function() { return { username: &apos;&apos;, lastGistUrl: &apos;&apos; }; }, componentDidMount: function() { $.get(this.props.source, function(result) { var lastGist = result[0]; if (this.isMounted()) { this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); } }.bind(this)); }, render: function() { return ( &lt;div&gt; {this.state.username}&apos;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;. &lt;/div&gt; ); } }); ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;, document.body ); 上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。 我们甚至可以把一个promise对象传入组件。 ReactDOM.render( &lt;RepoList promise={$.getJSON(&apos;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&apos;)} /&gt;, document.body ); 上面代码从Github的API抓取数据，然后将promise对象作为属性，传给RepoList组件。 如果promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果promise对象报错（rejected状态），组件显示报错信息；如果promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 var RepoList = React.createClass({ getInitialState: function() { return { loading: true, error: null, data: null}; }, componentDidMount() { this.props.promise.then( value =&gt; this.setState({loading: false, data: value}), error =&gt; this.setState({loading: false, error: error})); }, render: function() { if (this.state.loading) { return &lt;span&gt;Loading...&lt;/span&gt;; } else if (this.state.error !== null) { return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;; } else { var repos = this.state.data.items; var repoList = repos.map(function (repo) { return ( &lt;li&gt; &lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description} &lt;/li&gt; ); }); return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;{repoList}&lt;/ol&gt; &lt;/main&gt; ); } } });]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript中级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F16%2FfreeCodeCamp-%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS中级算法编程例题的学习总结。 Sum All Numbers in a Range题目：传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。（最小的数字并非总在最前面。） tips: Math.max() &nbsp;Math.min()&nbsp;Array.reduce() 实现1 function sumAll(arr) { //获取两个数中的最小值 var min = Math.min(arr[0], arr[1]); //获取两个数中的最大值 var max = Math.max(arr[0], arr[1]); //将区间里的整数顺序添加到数组里 var array = []; for (i = min; i &lt; max + 1; i++) { array.push(i); } //利用.reduce()方法累加数组中的元素并返回 var total = array.reduce(function(sum,val) { return sum += val; }); return total; } sumAll([1, 4]); 实现2 function sumAll(arr) { var max = Math.max(arr[0],arr[1]); var min = Math.min(arr[0],arr[1]); var total = 0; //不使用.reduce()方法实现累加，直接使用for循环实现累加 for(var i = min; i &lt; max + 1; i++) { total += i; } return total; } Diff Two Arrays题目：比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。 tips：Comparison Operators &nbsp;Array.slice() &nbsp; Array.filter() &nbsp; Array.indexOf() &nbsp; Array.concat() 实现1 function diff(arr1, arr2) { var newArr = []; //比较两个数组大小，判断较长的数组中的每个元素是否在短数组中出现过，若没有出现过则.indexOf()方法返回-1 if (arr1.length &gt;= arr2.length) { for (i = 0; i &lt; arr1.length; i++) { if (arr2.indexOf(arr1[i]) === -1) { newArr.push(arr1[i]); } } } for (i = 0; i &lt; arr2.length; i++) { if (arr1.indexOf(arr2[i]) === -1) { newArr.push(arr2[i]); } } return newArr; } //测试，返回4 diff([1, 2, 3, 5], [1, 2, 3, 4, 5]); 实现2 function diff(arr1, arr2) { var newArr = []; var arr3 = []; for (var i=0;i&lt;arr1.length;i++) { if(arr2.indexOf(arr1[i]) === -1) arr3.push(arr1[i]); } var arr4 = []; for (var j=0;j&lt;arr2.length;j++) { if(arr1.indexOf(arr2[j]) === -1) arr4.push(arr2[j]); } newArr = arr3.concat(arr4); return newArr; } 实现1是自己的想法，只用一次for循环即可得到比较结果。实现2是看到部分博主用的方法。 Roman Numeral Converter题目：将给定的数字转换成罗马数字。 tips：Roman Numerals &nbsp; Array.splice() &nbsp; Array.indexOf() &nbsp; Array.join() 实现1 function convert(num) { //只转换小于4000的数字为罗马数字，大于4000的罗马数字上面要加横线，在此暂不考虑转换 if (num &gt;= 4000) { console.log(&quot;please convert a number less than 4000!&quot;); } //将num的各位提取出来，即num = thousands * 1000 + hundreds * 100 + tens * 10 + units; var thousands = Math.floor(num / 1000) ; var hundreds = Math.floor((num % 1000) / 100); var tens = Math.floor((num % 100) / 10); var units = num % 10; var roman = []; //当千位不为0时，将千位转化为罗马数字 while (thousands !== 0) { switch(thousands) { case 1: roman.splice(0, 0, &quot;M&quot;); break; case 2: roman.splice(0, 0, &quot;M&quot;,&quot;M&quot;); break; case 3: roman.splice(0, 0, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;); break; } thousands = 0; } // 当百位不为0时，将百位转化为罗马数字 while (hundreds !== 0) { // 记录最后一个千位罗马数字索引加一 var lastIdxT = roman.length; switch(hundreds) { case 1: roman.splice(lastIdxT, 0, &quot;C&quot;); break; case 2: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;); break; case 3: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 4: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;D&quot;); break; case 5: roman.splice(lastIdxT, 0, &quot;D&quot;); break; case 6: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;); break; case 7: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;); break; case 8: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 9: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;M&quot;); break; } hundreds = 0; } // 当十位不为0时，将十位转化为罗马数字 while(tens !== 0) { // 记录最后一个百位罗马数字索引加一 var lastIdxH = roman.length; switch(tens) { case 1: roman.splice(lastIdxH, 0, &quot;X&quot;); break; case 2: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;); break; case 3: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 4: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;L&quot;); break; case 5: roman.splice(lastIdxH, 0, &quot;L&quot;); break; case 6: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;); break; case 7: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;); break; case 8: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 9: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;C&quot;); break; } tens = 0; } // 记录最后一个十位罗马数字索引加一 var lastIdxTen = roman.length; switch(units) { case 1: roman.splice(lastIdxTen, 0, &quot;I&quot;); break; case 2: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;); break; case 3: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 4: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;V&quot;); break; case 5: roman.splice(lastIdxTen, 0, &quot;V&quot;); break; case 6: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;); break; case 7: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;); break; case 8: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 9: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;X&quot;); break; } return roman.join(&quot;&quot;); } convert(36); 实现2 function convert(num) { //将分割数和对应的罗马字符分别存入两个数组 var nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]; var romans =[&quot;m&quot;,&quot;cm&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;c&quot;,&quot;xc&quot;,&quot;l&quot;,&quot;xl&quot;,&quot;x&quot;,&quot;ix&quot;,&quot;v&quot;,&quot;iv&quot;,&quot;i&quot;]; var str = &quot;&quot;; nums.forEach(function(item,index,array){ while(num &gt;= item){ str += romans[index]; num -= item; } }); return str.toUpperCase(); } convert(36); 实现2是来自一位博主将给定的数字转换为罗马数字，代码精简易懂，自己的实现看起来冗长幼稚，需要学习的还很多哇！ Where art thou题目：写一个 function，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。 例如，如果第一个参数是 [{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]，第二个参数是 { last: &quot;Capulet&quot; }，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。 tips：Global Object&nbsp; Object.hasOwnProperty() &nbsp; Object.keys()&nbsp; Array.prototype.filter() 实现 function where(collection, source) { var arr = []; //获取source对象的所有属性名并保存在数组keys中 var keys = Object.keys(source); //filter() 方法创建一个新数组, 其包含通过所提供函数测试的所有元素,callback用来测试数组的每个元素，返回true则保留该元素 arr = collection.filter(function(element) { for(var i = 0; i &lt; keys.length; i++) { if(!element.hasOwnProperty(keys[i]) || element[keys[i]] !== source[keys[i]]) return false; } return true; }); return arr; } //返回 [{ first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }] where([{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }], { last: &quot;Capulet&quot; }); Search and Replace题目：使用给定的参数对句子执行一次查找和替换，然后返回新句子。 第一个参数是将要对其执行查找和替换的句子。 第二个参数是将被替换掉的单词（替换前的单词）。 第三个参数用于替换第二个参数（替换后的单词）。 注意：替换时保持原单词的大小写。例如，如果你想用单词 “dog” 替换单词 “Book” ，你应该替换成 “Dog”。 tips：Array.splice() String.replace() Array.join() 实现 function myReplace(str, before, after) { //获取需被替换的单词before的首字母的位置index，indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。 var index = str.indexOf(before); //判断before首字母是否为大写，若为大写，则让after首字母也大写 if(str[index]===str[index].toUpperCase()){ after = after[0].toUpperCase() + after.substring(1); //也可以用slice(1) } //替换，stringObject.replace(regexp/substr,replacement) return str.replace(before, after); } /*** 判断字母是否为大写 function isUpperCase(ch){ return ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;; } 判断字母是否为小写 function isLowerCase(ch){ return ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;; } 将单词的首字母大写 function firstUpperCase(str) { var afterStr = str.toLowerCase().replace(/^\w/g,function(s){return s.toUpperCase();}); return afterStr; } ***/ // charAt()方法可返回字符串指定位置的字符，stringObject.charAt(index) myReplace(&quot;A quick brown fox jumped over the lazy dog&quot;, &quot;jumped&quot;, &quot;leaped&quot;); Pig Latin题目：把指定的字符串翻译成 pig latin。 Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。 如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。 tips：Array.indexOf() Array.push() Array.join() String.substr() String.split() 实现1 function translate(str) { // 元音 var vowel = [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]; // 如果单词首字母以元音开头，直接在单词后面加&apos;way&apos; if(vowel.indexOf(str.substr(0,1)) !== -1) { return str + &quot;way&quot;; } /*** 只要单词是以辅音或辅音丛开始，将该辅音移到后面，最后加&apos;ay&apos;。 while循环每次都检查移动辅音后的单词，移动一个辅音字母后若还不是元音字母，继续移动，移完后再加&quot;ay&quot;***/ while(vowel.indexOf(str.substr(0,1)) == -1) { str = str.substr(1) + str.substr(0,1); } return str + &quot;ay&quot;; } translate(&quot;glove&quot;);//测试数据&quot;california&quot;，&quot;paragraphs&quot;，&quot;algorithm&quot;，&quot;eight&quot; 实现2 function translate(str) { var tempArr = []; var answer; tempArr = str.split(&apos;&apos;);//将str分解为单个字符存入数组 var i = 0; //如果首个字符不是元音则 i++，如果首个字符是元音则退出while循环 while (tempArr[i] != &apos;a&apos; &amp;&amp; tempArr[i] != &apos;o&apos; &amp;&amp; tempArr[i] != &apos;i&apos; &amp;&amp; tempArr[i] != &apos;e&apos; &amp;&amp; tempArr[i] != &apos;u&apos;) { i++; } answer = str.substr(i);//将str辅音或辅音丛后面的部分提取出来 answer += str.substr(0,i);//再将辅音或辅音丛部分追加在answer后 //i=0时，首字母为元音，在变换之后加&quot;way&quot; if(i === 0) { answer += &quot;way&quot;; } //i不为0时，首字母为辅音或辅音丛，在变换后加&quot;ay&quot; else { answer += &quot;ay&quot;; } return answer; } DNA Pairing题目：DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。 Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。 在每一个数组中将给定的字母作为第一个碱基返回。字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]] tips：Array.push() String.split() 实现1 function pair(str) { var inputArr = []; var resultArr = []; //将输入字符串按单个字母拆分为数组 inputArr = str.split(&apos;&apos;); //对输入数组的每一种情况配对，GC,CG,AT,TA inputArr.forEach(function(item, index) { switch(item) { case &quot;G&quot;: resultArr.push([&quot;G&quot;,&quot;C&quot;]); break; case &quot;C&quot;: resultArr.push([&quot;C&quot;,&quot;G&quot;]); break; case &quot;A&quot;: resultArr.push([&quot;A&quot;,&quot;T&quot;]); break; case &quot;T&quot;: resultArr.push([&quot;T&quot;,&quot;A&quot;]); break; } }); return resultArr; } pair(&quot;GCG&quot;);//返回 [[&quot;G&quot;, &quot;C&quot;], [&quot;C&quot;,&quot;G&quot;],[&quot;G&quot;, &quot;C&quot;]] 实现2和实现3来自博客。 实现2 解题思路：把字符串进行匹配和对应关系进行匹配，将匹配到的字符推入该数组。最后将所有的数组推入一个新的数组。 匹配方式：用对象存储对应关系。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; var arr = []; for(var i in str){ arr.push([str[i],obj[str[i]]]); } return arr; } pair(&quot;GCG&quot;); 实现3 用map函数来进行优化,其实就是简化了写法。map函数可以改变原有的数组，给予指定的方法就可以了。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; //ES6 的写法 return str.split(&apos;&apos;).map(e =&gt; [e,obj[e]]); } pair(&quot;GCG&quot;); ES5 的写法 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; return str.split(&apos;&apos;).map(function(e){ return [e,obj[e]]; }); } pair(&quot;GCG&quot;); Missing letters题目：从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。 tips：String.charCodeAt() String.fromCharCode() 实现 function fearNotLetter(str) { var resultStr = &quot;&quot;; //先判断所有字母是否都在序列中,若都在则返回undefined if((str.charCodeAt(0) + str.length - 1) === str.charCodeAt(str.length - 1) ) { return undefined; } else { //若不然，则根据str每个字母的编码是否连续来返回缺失字母 for (i = 0; i &lt; str.length - 1; i++) { var startCode = str.charCodeAt(i); var nextCode = str.charCodeAt(i + 1); //如果相邻两个字母之间的编码不连续，则将两个字母之间缺失的字母追加到resultStr中 while ( nextCode - startCode !== 1) { resultStr += String.fromCharCode(startCode + 1); startCode ++; } } } return resultStr; } fearNotLetter(&quot;abce&quot;);//返回&quot;d&quot; fearNotLetter(&quot;abch&quot;);//返回&quot;defg&quot; 关于此题目的回答，比较了一些博主的答案，他们的答案大多只满足两个输入相邻字母之间只缺少一个字母的情况，对于缺失多个字母的情况没有考虑。自己的回答考虑到了两个相邻字母之间缺失多个字母的情况。 Boo who题目：检查一个值是否是基本布尔类型，并返回 true 或 false。基本布尔类型即 true 和 false。 tips:Boolean Objects 补充：5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。 1种复杂数据类型Object（包括Function、Array、Date等）。 typeof操作符返回下列某个字符串： &quot;undefined&quot;---未定义 &quot;boolean&quot;---布尔值 &quot;string&quot;---字符串 &quot;number&quot;---数值 &quot;object&quot;---对象或null &quot;function&quot;---函数 实现 function boo(bool) { //使用typeof操作符检测数据类型 return typeof(bool) === &quot;boolean&quot; ? true : false;//可直接写为 return typeof bool===&apos;boolean&apos;; } boo(null);//返回false Sorted Union题目：写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的但不包含重复值的新数组。 换句话说，新数组中的所有值都应该以原始顺序被包含在内，但是不包含重复值。即非重复的数字应该以它们原始的顺序排序。例如unite([1, 3, 2], [5, 2, 1, 4], [2, 1]) 应该返回 [1, 3, 2, 5, 4]。unite([1, 3, 2], [1, [5]], [2, [4]]) 应该返回 [1, 3, 2, [5], [4]]。 tips:Arguments object Array.reduce() 实现1 function unite(arr1, arr2, arr3) { //unite函数的输入参数类对象数组arguments for(i = 1; i &lt; arguments.length; i ++) { for (j = 0; j &lt; arguments[i].length; j ++) { //若第i个输入数组的第j个数字在第一个数组中没出现过，则追加到第一个数组中，否则什么也不做 if (arr1.indexOf(arguments[i][j]) == -1) { arr1.push(arguments[i][j]); } } } return arr1; } unite([1, 3, 2], [5, 2, 1, 4], [2, 1]);//返回[1,3,2,5,4] 实现2 思路：先将多个输入参数（数组）合并，再去重。来源于简书。 function unite(arr1, arr2, arr3) { //Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例，即返回[arr1, arr2, arr3]的形式 var args = Array.from(arguments); //reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 var arr = args.reduce(function(accumulator,cur){ //将多个输入数组合并为一个数组arr,即返回[1,3,2,5,2,1,4,2,1]的形式 return accumulator.concat(cur); }); var resultArr = []; //对合并后的数组arr去重 return resultArr = arr.filter(function(item,index){ //返回true则filter到结果数组，indexOf()方法返回第一个匹配元素的index， //后面重复元素的indexOf返回值为该元素第一次出现时的index（比如对第二个2应用indexOf返回2） return arr.indexOf(item) === index; }); } Convert HTML Entities题目：将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。 tips:RegExp HTML Entities 实现 function convert(str) { //替换规则映射对象 var entityMap = { &apos;&amp;&apos; : &apos;&amp;amp;&apos;, &apos;&lt;&apos; : &apos;&amp;lt;&apos;, &apos;&gt;&apos; : &apos;&amp;gt;&apos;, &apos;\&quot;&apos; : &apos;&amp;quot;&apos;, &apos;\&apos;&apos; : &apos;&amp;apos;&apos; , }; //使用string的replace规则，将匹配到的字符根据替换规则替换掉 return str.replace(/[&amp;&lt;&gt;&quot;&apos;]/g, function(matched) { return entityMap[matched]; }); } convert(&quot;Dolce &amp; Gabbana&quot;);//输出结果&quot;Dolce &amp;amp; Gabbana&quot; Spinal Tap Case题目：将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。 tips:RegExp String.replace() 实现 function spinalCase(str) { //将str分为两类，一类是以空格、下划线、短横线连接的字符串；一类是驼峰形式的字符串 //驼峰形式的字符串 if(str.split(/\W|_/).length === 1) { for (i = 0; i &lt; str.length; i++) { //找到所有单词的首写大写字母，并用短横线和对应小写替换 if (str[i].toUpperCase() === str[i]) { str = str.replace(str[i], &quot;-&quot;+str[i].toLowerCase()); } } } //以空格、下划线、短横线连接的字符串，先转换为小写再替换 else { //注意匹配模式加上全局标志，否则只会找到第一个匹配 str = str.toLowerCase().replace(/\W|_/g, &quot;-&quot;); } return str; } spinalCase(&apos;This Is Spinal Tap&apos;);//返回 &quot;this-is-spinal-tap&quot; spinalCase(&quot;The_Andy_Griffith_Show&quot;);//返回 &quot;the-andy-griffith-show&quot; spinalCase(&quot;Teletubbies say Eh-oh&quot;);//返回 &quot;teletubbies-say-eh-oh&quot; spinalCase(&quot;thisIsSpinalTap&quot;);//返回 &quot;this-is-spinal-tap&quot; Sum All Odd Fibonacci Numbers题目：给一个正整数num，返回小于或等于num的斐波纳契奇数之和。 斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。 例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。 提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。 tips:Remainder) 参考文档 实现 function sumFibs(num) { //先找到所有小于num的斐波那契数，并存在数组fibsArr中 var fibsArr = [1, 1, 2]; for(i = 2; i &lt; num; i++) { if (fibsArr[i] + fibsArr[i-1] &lt;= num) { fibsArr.push(fibsArr[i] + fibsArr[i-1]); } } //筛选出fibsArr中的奇数并求和 var sum = fibsArr.filter(function(element, index) { //若为奇数则返回 return element % 2 !== 0; }).reduce(function(prev, curr) { return prev += curr; }); return sum; } sumFibs(1);//返回2 Sum All Primes题目：求小于等于给定数值的质数之和。 给定的数不一定是质数。 只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。 tips:For Loops Array.push() 实现 //判断一个数是不是素数 function isPrime(num) { //判断输入是否为number类型，是否为整数 if(typeof(num) !== &apos;number&apos; || !Number.isInteger(num)) { return false; } //num小于2时，不是素数 if(num &lt; 2) {return false;} //num等于2时，是素数 if(num === 2) {return true;} //num大于2时，如果num可以被2整除（即num为偶数），不是素数 else if(num % 2 === 0) {return false;} //num大于2时，依次判断num能否被奇数整除，最大循环为num的开方 var range = Math.ceil(Math.sqrt(num)); for(var i = 3; i &lt;= range; i+=2) { if(num % i === 0) {return false;} } return true; } //求小于等于给定数值的质数之和 function sumPrimes(num) { var sum = 0; for(var i = 0; i &lt;= num; i ++) { //对于小于num的每个数先判断是否为素数，若为素数则叠加 if(isPrime(i)) { sum += i; } } return sum; } sumPrimes(977);//返回73156 Smallest Common Multiple题目：找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。 范围是两个数字构成的数组，两个数字不一定按数字顺序排序。 例如对 1 和 3 —— 找出能被 1 和 3 和它们之间所有数字整除的最小公倍数。 tips:Smallest Common Multiple 辗转相除法 思路：最小公倍数 = 两个数的积 / 最大公约数 最大公约数用辗转相除法（欧几里得算法）求得，即当 a mod b=0时，gcd(a,b)=0,否则gcd(a,b)=gcd(b,a mod b)。 求连续几个数的最小公倍数，可以先求得边界两个数的最小公倍数，再用此最小公倍数依次和中间的数值求最小公倍数，从而得到所有数的最小公倍数。 实现 function smallestCommons(arr) { //首先对两个给定参数排序,按从小到大排序 arr.sort(function(a, b) { return a - b; }); //求a和b的最小公倍数 var a = arr[0]; var b = arr[1]; //flag表示边界两个数的最小公倍数 var flag = smallestCommonMultiple(a, b); //用flag依次和中间的数值求最小公倍数，即得最终的最小公倍数 for(var i = a +1; i &lt; b; i ++) { flag = smallestCommonMultiple(flag, i); } return flag; } //欧几里得算法求两个数的最大公约数,a&lt;=b function gcd (a, b) { //当除数为零时，最大公约数为被除数a if(!b) {return a;} //否则辗转相除 return gcd(b, a%b); } //求两个数的最小公倍数 function smallestCommonMultiple(a, b) { return a * b / gcd(a, b); } smallestCommons([1,5]);//返回60 Finders Keepers题目：写一个 function，它遍历数组 arr，并返回数组中第一个满足 func 返回值的元素。举个例子，如果 arr 为 [1, 2, 3]，func 为 function(num) {return num === 2; }，那么 find 的返回值应为 2。 tips:Array.filter() 实现 function find(arr, func) { var num = 0; //注意filter()方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 //而我们只需要返回第一个满足func的元素 num = arr.filter(func).length === 0 ? undefined : arr.filter(func)[0]; return num; } find([1, 2, 3, 4], function(num){ return num % 2 === 0; });//返回2 Drop it题目：丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。 第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。 最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。 tips:Arguments object Array.shift() Array.slice() 实现 function drop(arr, func) { //只要func返回false就左移抛出该元素，继续判断左移后的第一个元素是否满足条件 while(!func(arr[0])) { //shift() 方法从数组中删除第一个元素，并返回该元素的值。shift()方法会改变原数组 arr.shift(); } return arr; } drop([1, 2, 3], function(n) {return n &lt; 3; }); Steamroller题目：对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。 tips:Array.isArray() 实现 function steamroller(arr) { //扁平化处理后的数组 var afterArr = []; for(var i = 0; i &lt; arr.length; i ++) { //依次判断数组中元素类型是否为数组 //如果元素是数组类型，继续对该元素做数组扁平化处理 if(Array.isArray(arr[i])) { var midArr = steamroller(arr[i]); afterArr = afterArr.concat(midArr); //如果不是数组类型，则将该元素push进afterArr储存 }else { afterArr.push(arr[i]); } } return afterArr; } steamroller([1, [2], [3, [[4]]]]);//返回[1,2,3,4] Binary Agents题目：传入二进制字符串，翻译成英语句子并返回。二进制字符串是以空格分隔的。 tips:String.charCodeAt() String.fromCharCode() 实现 function binaryAgent(str) { var strToArr = []; var afterTrans = &quot;&quot;; //将二进制字符串按空格划分为字符串数组，并转化为number类型，十进制形式 str.split(&quot; &quot;).forEach(function(item,index) { //将二进制形式转化为十进制形式 strToArr.push(parseInt(item, 2)); }); afterTrans = strToArr.reduce(function(prev, curr) { //将数组中的十进制Unicode码通过String.fromCharCode()方法转换为字母，利用reduce()方法依次处理数组元素并拼接成字符串 return prev + String.fromCharCode(curr); },&quot;&quot;); return afterTrans; } binaryAgent(&quot;01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001&quot;);//返回&quot;I love FreeCodeCamp!&quot; Everything Be True题目：完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。 记住：你只能通过中括号来访问对象的变量属性(pre)。 tips:可以有多种实现方式，最简洁的方式莫过于Array.prototype.every() every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 实现 function every(collection, pre) { //使用every() 方法测试数组的所有元素是否都通过了指定函数的测试。 var flag = collection.every(function(item, index) { //如果对象不存在pre属性，则返回false if(!item.hasOwnProperty(pre)) {return false;} //测试pre属性的值是否为true if(!item[pre]) {return false;} return true; }); return flag; } every([{&quot;user&quot;: &quot;Tinky-Winky&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Dipsy&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Laa-Laa&quot;, &quot;sex&quot;: &quot;female&quot;}, {&quot;user&quot;: &quot;Po&quot;, &quot;sex&quot;: &quot;female&quot;}], &quot;sex&quot;);//返回true 换一种简洁的写法： function every(collection, pre) { return collection.every(function(elements){ return elements.hasOwnProperty(pre) &amp;&amp; Boolean(elements[pre]); }); } Arguments Optional题目：创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。 例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。调用这个有一个参数的返回的 function，返回求和的结果：var sumTwoAnd = add(2);sumTwoAnd(3) 返回 5。如果两个参数都不是有效的数字，则返回 undefined。 tips:Closures Arguments object 实现 function add() { //如果add有两个参数，则返回两个参数的和 if(arguments.length === 2 &amp;&amp; typeof arguments[0] === &quot;number&quot; &amp;&amp; typeof arguments[1] === &quot;number&quot;) { return arguments[0] + arguments[1]; } //如果add有一个参数，则通过闭包方式返回一个函数 if(arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;number&quot;) { var x = arguments[0]; //通过闭包方式返回只有一个参数的函数 return function(y) { if(typeof y === &quot;number&quot;) { return x + y;} return undefined; }; } return undefined; } add(2,3);//返回5 add(2)(3);//返回5 add(2)([3]);//返回undefined add(2, &quot;3&quot;);//返回undefined add(&quot;http://bit.ly/IqT6zt&quot;);//返回undefined]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP简要了解]]></title>
    <url>%2F2017%2F11%2F15%2FJSONP%E7%AE%80%E8%A6%81%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在freeCodeCamp上学习使用twith TV API获取频道信息时，在freeCodeCamp的指导中提到若使用$.getJSON(()方法会因为跨域资源共享(CORS)问题发生错误信息。 freeCodeCamp Challenge Guide: How to Use the TwitchTV API 中建议使用jQuery的JSONP方法来解决CORS问题。 JSONP的诞生传统ajax无法跨域，而标签的src属性是可以跨域的,可以通过把跨域服务器写成调用本地的函数 ，回调数据回来。 json刚好被js支持（object） 调用跨域服务器上动态生成的js格式文件（不管是什么类型的地址，最终生成的返回值都是一段js代码） 这种获取远程数据的方式看起来非常像ajax，但其实并不一样，便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。 传递一个callback参数给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。 例子（1）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js alert(&quot;我是远程文件&quot;); 本地 &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 在本地标签直接引入一个js文件，页面将会弹出警告框。 （2）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;}); 本地 &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data){ alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); }; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 该例子中在本地定义了一个函数localHandler，在本地通过标签的src属性引入了跨域服务器上的一个js文件remote.js，在引入的js文件里调用了本地定义的函数localHandler。 问题：如何让远程js文件知道它应该调用的本地函数的名字呢？毕竟jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同。 （3）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：flightResult.php flightHandler({ &quot;code&quot;:&quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 }); 本地 &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;跨域服务器/flightResult.php?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; 在该例中动态创建标签（动态创建脚本）； url中传递了一个code参数，服务器去做查询CA1998次航班的信息，callback参数告诉服务器，我的本地回调函数叫做flightHandler； 跨域服务端调用这个函数flightHandler，页面将会弹出一个提示窗体，显示出票价和余票。 JSONP方法中服务器做的事情// 数据 $data = [ &quot;name&quot;:&quot;anonymous66&quot;, &quot;age&quot;:&quot;18&quot;, &quot;like&quot;:&quot;jianshu&quot; ]; // 接收callback函数名称 $callback = $_GET[&apos;callback&apos;]; // 输出 echo $callback . &quot;(&quot; . json_encode($data) . &quot;)&quot;; 服务器端做的就是获取url中的callback参数，并将callback参数作为函数名来包裹json数据，动态生成js文件，再返回给客户端。 JSONP与AJAX的区别ajax的核心是通过XMLHttpRequest获取非本页内容。 jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 JSONP优缺点优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都 可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。JSONP是一种脚本注入(Script Injection)行为，所以有一定的安全隐患。 转自：segmentfault专栏JSONP是什么 参考：JSONP原理优缺点(只能GET不支持POST)]]></content>
      <categories>
        <category>jsonp</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
        <tag>javascript</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax-imooc]]></title>
    <url>%2F2017%2F11%2F06%2Fajax-imooc%2F</url>
    <content type="text"><![CDATA[ajax,即异步JavaScript和XML，通过在后台和服务器少量的数据交换实现页面的异步局部加载更新。ajax中一个关键的对象 XMLHttpRequest对象，作为网页和服务器之间交换数据的桥梁，来实现网页的异步请求、局部刷新。 创建XMLHttpRequest对象在现代浏览器中创建XMLHttpRequest对象 var request = new XMLHttpRequest();//现代浏览器 若在早期老版本浏览器中，考虑兼容性，创建XMLHttpRequest对象方式如下： var request; if(window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6,IE5 } HTTP协议HTTP是一种无状态协议。一个HTTP请求包括以下7个步骤： 建立TCP连接 WEB浏览器向WEB服务器发送请求命令 WEB浏览器发送请求头信息 WEB服务器应答 WEB服务器发送应答头信息 WEB服务器向浏览器发送数据 WEB服务器关闭TCP连接 HTTP请求一个HTTP请求一般由四部分组成： HTTP请求的方法和动作，比如GET或POST请求 正在请求的URL 请求头，包含一些客户端环境信息、身份验证信息等 请求体，即请求正文，包含客户提交的查询字符串信息、表单信息等一般来说请求头和请求正文之间有一个空行，表示请求头结束。一篇关于GET、POST请求的博文详解GET:一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。(用于查询，一般不用于新建和修改。默认为GET提交)POST:一般用于修改服务器上的资源，对所发送信息的数量无限制。HTTP响应一个HTTP响应一般由三部分组成： 一个数字和文字组成的状态码，表示请求成功还是失败 响应头，包含服务器类型、日期时间、内容类型、长度等 响应体，即响应正文HTTP状态码的类型： XMLHttpRequest发送请求两个方法，open和send open(method, url, async) send(string)open方法用于设置请求，第一个参数method表示请求的类型，即GET或POST；第二个参数url即请求的地址，绝对地址或相对地址；第三个参数表示是否异步请求，默认为true。send方法用于发送请求，当使用get请求时，send可不给出参数，而使用post请求时必须有参数。例如： request.open(“POST”,”create.php”,true); request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息，一定要写在open()和send()之间 request.send(“name=xxxx&amp;sex=xxx”); XMLHttpRequest取得响应通过监听XMLHttpRequest对象readyState属性的变化，判断服务器的状态变化信息。通过.onreadystatechange()方法监听readyState属性的变化，当readyState为4（响应完成）并且status为200(请求成功)时，再对响应数据做处理： var request = new XMLHttpRequest(); request.open(&quot;POST&quot;,&quot;get.php&quot;,true); request.send(); request.onreadystatechange = function() { if(request.readyState == 4 &amp;&amp; request.status == 200) { //做一些处理，例如request.responseText } } PHP]]></content>
      <categories>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[planeGame-H5 Canvas小游戏未完成的问题]]></title>
    <url>%2F2017%2F10%2F30%2FplaneGameQuestion%2F</url>
    <content type="text"><![CDATA[H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。 未完成内容游戏设置部分音乐设置（HTML5 audio相关的学习，包括设置游戏背景音乐以及各种子弹、爆炸等声音，以及切换声音的开启和关闭） 背景设置（即切换背景图片） 战机设置（即切换战机plane的icon图片） 存在问题的地方点击“再玩一次”之后，敌机以及子弹的速度会越来越快，差不多第三次重玩就无法进行了。感觉是因为上一次游戏过程中的一些数据没有清除，怀疑过是不是setInterval()的原因，百度了查了好多，在end处添加了window.clearInterval()，但也是无济于事。特将此问题记录，以待后面将js学深了再来解决。 可以改进的地方游戏结束以后，除了“再玩一次”，再添加一个“退出游戏”功能，使页面切换到index状态。 适应手机端的，试了下在电脑上战机移动不了，应该是手指移动事件那里还未考虑鼠标移动来兼容电脑浏览器。 效果截图主页面如下： 游戏结束，“再玩一次”界面 github源码github仓库地址：demo-planegame 放在gh-pages上的样子，电脑端战机移动不了。demo展示]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(二)DOM操作--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js2%2F</url>
    <content type="text"><![CDATA[JS调用DOM接口修改样式。 DOM简介 上图是一张网页的生成过程，大致分为五步： （1）html代码转化为DOM树 （2）CSS代码转化成CSSOM（CSS Object Model） （3）结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） （4）生成布局（layout），即将所有渲染树的所有节点进行平面合成 （5）将布局绘制（paint）在屏幕上 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 其中，在html文档生成DOM树后，JS可以通过DOM提供的接口来添加、删除、修改元素和样式。 DOM查找查找API: document.getElementById()//通过元素id查找，查找一个元素 [document|Element].getElementsByClassName()//通过元素类名查找，查找一组元素，得到一个类数组(html collection) [document|Element].getElementsByTagName()//通过元素标签名查找,查找一组元素，得到一个类数组 [document|Element].querySelector()//通过CSS选择器查找，例如 var qId = document.querySelector(&apos;#id&apos;); [document|Element].querySelectorAll()//通过CSS选择器查找 后两者常用。 DOM新增和删除（1）新增节点新增一个元素时，包括插入和追加。前面插入用insertBefore()，后面追加用appendChild()。 parent.appendChild(element)//新增节点到父元素的末尾 parentElement.insertBefore(newElement, targetElement)//新增节点到targetElement元素的前面 注意：使用.insertBefore()方法时，不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它。所以可以通过targetElement.parentNode.insertBefore(newElement, targetElement)来插入。 新增多个元素时，可以利用上述两个方法结合循环实现，但循环会导致一个问题，因为直接操作DOM会导致浏览器反复渲染。利用DocumentFragment节点解决这个反复渲染问题。 DocumentFragment文档片段，可以理解为“轻量级”的节点。有两个属性，分别为：nodeType = 11, nodeName = #document-fragment。DocumentFragment作为仓库来使用，不在DOM树中，游离在DOM树之外。当增加多个节点时，可将这多个节点临时存放在DocumentFragment仓库中，最后再一次性插入DOM树中，就解决了浏览器反复渲染的问题。 （2）删除节点删除节点使用removeChild() （3）创建节点 此时创建出的节点即为DocumentFragment文档碎片，创建完以后再插入或者追加到DOM树中。 document.createElement(nodeName)//创建元素节点,nodeName即为h1,h2,li,p,.... document.creatTextNode(text)//创建文本节点 练习题 题目要求:现有 HTML 代码如下, &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;/body&gt; 在h1元素的后面新增一个ul元素，ul元素中有一百个li元素，li的内容就是 1-100 ，如下所示： &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; ...... &lt;li&gt;98&lt;/li&gt; &lt;li&gt;99&lt;/li&gt; &lt;li&gt;100&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; js代码如下： var len = 100; var ul = document.createElement(&apos;ul&apos;); var body = document.getElementsByTagName(&apos;body&apos;)[0]; for(var i = 0; i &lt; len; i++){ var li = document.createElement(&apos;li&apos;); var liText = document.createTextNode(i+1); li.appendChild(liText); ul.appendChild(li); } body.appendChild(ul); DOM修改样式两种方式修改元素样式：通过元素style属性修改；通过元素class属性修改。 （1）style属性 style属性包含着元素诸如颜色大小等样式，style属性是一个对象。如访问style对象的color属性：element.style.color。 注意：当引用一个中间带减号的CSS属性时，DOM要求用驼峰命名法。CSS属性font-family变为了DOM属性fontFamily：element.style.fontFamily。这是因为减号和加号之类的操作符是保留字，不允许用在函数或变量的名字里，意味着也不能用在方法和属性的名字里。 缺点：style属性只能返回内嵌样式。即只有把CSS style属性插入到标记里，才可以用DOM style属性去获取那些属性信息。DOM style属性不能用来检索外部CSS文件里声明的样式。 （2）class属性 利用DOM修改元素的class属性（比如新增一个class或者删除一个class），使得利用外部CSS文件中的设置的样式改变元素的样式，而不是用DOM直接操作style属性修改样式。 例如要给要给elem元素设置class属性为intro，方法如下： a.利用setAttribute()方法, elem.setAttribute(&quot;class&quot;,&quot;intro&quot;) b.通过更新className属性。className属性是一个可读可写的属性，凡是元素节点都有这个属性。可以用className属性获取一个元素的class属性，element.className。 用className属性和赋值操作符设置一个元素的class属性：element.className = value 该方法的不足，通过className属性设置某个元素的class属性时将替换该元素原有的属性（而不是追加）。 在需要给一个元素追加新的class时，可以按照以下思路： 检查className属性的是否为null； 如果是，把新的class设置值直接赋值给className属性； 若不是，把一个空格和新的class设置值追加到className属性上去。 把上述步骤封装为一个函数addClass,该函数有两个参数，第一个为需要添加的新class的元素，第二个是新的class设置值。 function addClass(element, value){ if(!element.className){ element.className = value; }else{ newClassName = element.className; newClassName+= &quot; &quot;; newClassName+=value; element.className = newClassName; } } 事件模型&lt;!DOCTTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;事件简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;button id=&quot;button&quot;&gt;点击切换背景颜色&lt;/button&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 针对上述代码，当点击了button后事件反应机制有两种(这两种是上古时代的做法 。 。) 第一种是点击button后，button将事件传递到section，再传递到body，再传递到html，再传递到document。该种方式即为事件冒泡机制。如下图所示： 第二种是点击button后，从document开始一层层捕获，即为事件捕获机制。如下图所示。 目前标准的DOM事件流做法分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获阶段的结束阶段为目标元素的父元素，然后是处于目标阶段，接下来是事件冒泡阶段。在实际开发过程中，由于浏览器兼容问题，事件捕获过程基本不用，会频繁使用目标和事件冒泡。流程如下所示。 事件处理程序添加事件处理程序： element.addEventListener(type, handle, false)//type表示事件类型，handle为事件处理函数，false表示采用冒泡机制 删除事件处理程序： element.removeEventListener(type, handle) 例如： h1.addEventListener(&apos;click&apos;, function(){ console.log(this);//this指向绑定事件处理函数的对象，即h1元素 }, false); 事件对象 事件对象包含着所有与事件相关的信息。 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { //event即为事件处理对象，包括了触发点击事件时鼠标的位置等等信息 console.log(&apos;event&apos;, event); //将event对象打印出来并查看event对象包含哪些信息 } h1.addEventListener(&apos;click&apos;, handle, false); 事件冒泡 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 虽然点击事件绑定在body上，但此时点击h1元素，仍会触发事件打印event对象。此为事件冒泡。 流程：当点击目标元素h1，先找h1上有没有点击事件，有则触发，没有则按照冒泡机制一层层往上找，看有没有点击事件，直到冒泡到document。 阻止事件冒泡： var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 h1.addEventListener(&apos;click&apos; function(event) { event.stopPropagation();//阻止事件冒泡，当点击h1元素时，不会触发点击事件 }, false);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(一)--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js%2F</url>
    <content type="text"><![CDATA[NEXT十天训练营有关JS学习的笔记。 认识JavaScriptJS是目前主流浏览器唯一支持的脚本语言，由以下三部分组成： （1）ECMAScript:语言基础（核心）。 ECMA-262标准规定了ECMAScript这门语言的组成部分，例如语法、类型、语句、关键字、保留字、操作符、对象。 Web浏览器只是ECMAScript实现可能的宿主环境之一，其他宿主环境还包括Node(一种服务端JavaScript平台)和Adobe Flash。 （2）DOM（Document Object Model,文档对象模型） 通过DOM可以操作HTML元素，包括删除、添加、替换、修改节点等。DOM将整个HTML文档映射为一个多层节点结构，即DOM树。 （3）BOM（Browser Object Model,浏览器对象模型） 通过BOM获取一些浏览器的信息，以及控制浏览器的一些行为。 引入JavaScript有三种方式可以在HTML文档里引入JavaScript。 （1）行内方式。即直接在HTML元素的属性上应用js代码。 例如以下代码中button元素的onclick属性，点击button就会弹出消息框并显示“hello”。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 但这种方式不建议使用。一是因为这种方式针对一些用户的事件触发js执行，局限性较大。二是html文档中掺杂js代码会显得文档很乱，背离了结构应与样式、行为相分离的原则。 （2）内嵌方式。即通过一对标签在html文档中插入js代码。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; &gt;点击弹出消息框&lt;/button&gt; &lt;sript&gt; var helloBtn = documnet.getElementById(&quot;helloBtn&quot;); helloBtn.onclick = function() { alert(&quot;hello&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此种方式也有缺点。例如在不同页面使用上述标签之间这段js代码时，即在不同页面使用同一段js代码会有冗余。根据场景判断是否使用该方式。 （3）外链方式。即将js代码从html文档中提取出来单独形成一个.js文件，并在html文档中引入这个.js文件。 例如将方法（2）中标签之间这段js代码提取出来，保存在一个hello.js文件中，并在html文件中引入。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 根据场景判断是否使用该方式。 变量（1）语法: var 变量名 变量名区分大小写，首字母必须是字母、下划线或者$，非关键字和保留字。例如，var name = &quot;bottle&quot;; （2）全局变量和局部变量： 使用var定义的变量可能是全局变量也可能是局部变量，取决于是否在一个function中。如在function中使用var定义一个变量message，此变量即为一个局部变量。局部变量在function外面访问不到。若在function内不使用var定义变量message，则在函数外可以访问到该变量。 使用var定义 function test() { var message = &quot;hi&quot;;//定义一个局部变量 } test(); alert(message);//错误，找不到变量message 不使用var定义 function test() { message = &quot;hi&quot;;//定义一个全局变量 } test(); alert(message);//hi 使用控制台console来调试js代码。alert()弹出一个提示框。console.log()打印。 利用sources里面的snippets来观察变量。如下所示。 局部变量测试结果如下所示。 全局变量测试结果如下所示。 数据类型1、基本数据类型 （1）字符串类型String （2）数字类型Number （3）布尔类型Boolean ,取值true或false （4）Null （5）Undefined 2、复杂数据类型/引用数据类型 Object 怎样判断数据类型 在浏览器控制台可使用type of 操作符来判断以下数据类型。 typeof 1//&quot;number&quot; typeof &apos;a&apos;//&quot;string&quot; typeof true//&quot;boolean&quot; typeof undefined//&quot;undefined&quot; typeof null//&quot;object&quot; (这个比较特殊) typeof {}//&quot;object&quot; typeof function(){};//&quot;function&quot; 判断数据类型的几个例子如下。 Object对象1、创建对象 （1）使用对象字面量{}创建杯子对象。（推荐，简洁明了） var bottle = { name: &quot;bottle&quot;, //key: value price: 49, isKeepWarm: true } 对象的每一个属性都可以用对应的键值对(key: value)来描述，其中key为任一合法字符，value为任意数据类型。如果属性名包含多个中间含空格的字符，要用引号包含起来。 （2）使用Object构造函数创建杯子对象。 var bottle = new Object(); bottle.name = &quot;bottle&quot;; bottle.price = 49; bottle.isKeepWarm = true; 2、对象属性读操作 （1）使用点操作符 console.log(bottle.name);//&quot;bottle&quot;（推荐） （2）使用中括号操作符 console.log(bottle[&quot;name&quot;]);//&quot;bottle&quot;（如果对象属性名即key包含空格时，必须使用中括号操作符） 函数1、函数的定义 （1）函数声明 function 函数名（参数1，参数2，...）{ 函数体 return ; } 函数声明的特点，在相同作用域下，不管在何处声明都可以调用的到。即使声明在调用之后。 （2）函数表达式 var 变量 = function(参数1，参数2，...){ 函数体 return ; } 函数表达式的调用必须在函数表达式声明之后。这是区别于函数声明的地方。 作用域 如上图所示，bottles是在函数之外声明的，是全局作用域的一个变量，所以在函数内部可以访问到bottles。而函数内部（函数作用域）声明的num为局部变量，只可以在函数内部被访问到，在函数外部无法获取。 流程控制（1）if语句 if(条件) { 执行语句1; } else{ 执行语句2; } （2）switch语句 swith(n){ case 0: 执行语句1； case 1: 执行语句2; ... } 字符串的有关操作分割字符串 splitsplit()方法可以把字符串分割为字符串数组。 &quot;2:3:4:5&quot;.split(&quot;:&quot;) // 将返回 [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] &quot;|a|b|c&quot;.split(&quot;|&quot;) // 将返回 [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 截取字符串 substringsubstring() 方法用于提取字符串中介于两个指定下标之间的字符。语法：str.substring(indexStart, [indexEnd]) var str = &apos;Hello World!&apos;; console.log(str.substring(3)); // 将返回 lo world! 字符串转换大写 toUpperCase()toUpperCase() 方法用于把字符串转换为大写。 var str = &apos;Hello World!&apos;; console.log(str.toUpperCase()); // 将返回 HELLO WORLD! 题目完善函数 convertToCamelCase 的功能。函数 convertToCamelCase 会转换传入的字符串参数 string 为驼峰格式，并返回转换后的字符串。具体要求如下： 参数 string 是以中划线（-）连接单词的字符串，需将第二个起的非空单词首字母转为大写，如 -webkit-border-radius 转换后的结果为 webkitBorderRadius。 返回转换后的字符串 解决方法： function convertToCamelCase(str){ var strSplit = str.split(&quot;-&quot;);//转换为字符串数组 if(strSplit[0] === &quot;&quot;){ //如果第一个字符串为空的话，左移删掉，否则的话不变 strSplit.shift(); } for(var i = 1; i &lt; strSplit.length; i++){ var letter = strSplit[i].charAt(0);//取得字符串数组中每个字符串的首字母 //使用replace方法将每个字符串的首写字母大写 strSplit[i] = strSplit[i].replace(letter, function replace(letter){ return letter.toUpperCase(); }); } return strSplit.join(&quot;&quot;);//join方法串接起字符串 } convertToCamelCase(&quot;-ni-hao-a&quot;); 还可以使用正则表达式的方法。 function convertToCamelCase(str) { return str.replace(/\-[a-z]/g , function(a, b){ return b == 0 ? a.replace(&apos;-&apos;,&apos;&apos;) : a.replace(&apos;-&apos;,&apos;&apos;).toUpperCase(); }); }]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS切图笔记from慕课网]]></title>
    <url>%2F2017%2F10%2F18%2FPS%E5%88%87%E5%9B%BE%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接前端工程师必备的PS技能——切图篇。 Photoshop界面设置使用的photoshop版本为photoshop cc 2015。 新建设置文件–&gt;新建–&gt;文档类型（自定）–&gt;宽度一般固定（1920像素）–&gt;高度一般不定(此时设为2000像素)–&gt;分辨率72像素/英寸–&gt;背景内容(透明)。 再点击“确定”即可生成一张新的界面。此时还可点击“存储预设为”将本次自定义设置预设，留作以后使用该设置参数时使用。参数设置即生成图片分别为下列两图所示。 不知道是不是我下载的破解版的原因，键盘在中文输入法状态下时，左侧导航栏的工具图标不显示提示名称，切换到英文输入状态时就会显示。。 移动工具设置第一个工具图标为：移动工具，快捷键V。 如下图所示。 选择移动工具–不勾选自动选择–选择图层–按住ctrl+鼠标左键可以自由选择想要的图层，会在右侧图层显示信息栏为你筛选出当前鼠标左键选择的图层。如下图所示。 视图设置勾选两个功能：（1）视图–&gt;显示–&gt;智能参考线 （2）视图–&gt;标尺可以在窗口–&gt;库，颜色，路径，通道， 把这几个功能关掉。 窗口–&gt;历史记录，信息，图层，三个功能模块打开。 最后在右侧区域一共用到四个功能，即信息，字符，图层，历史纪录。见下图。 信息面板设置如下： 在编辑–&gt;首选项–&gt;单位与标尺，将单位改为像素。 Photoshop基本操作]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有默认margin，padding值的html标签]]></title>
    <url>%2F2017%2F10%2F18%2F%E9%BB%98%E8%AE%A4margin%E5%80%BC%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。 h1~h6标签有默认margin（top,bottom且相同）值，没有默认padding值。 在chrome中：16,15,14,16,17,19; 在firefox中：16,15,14,16,17,20; 在safari中：16,15,14,16,17,19; 在opera中：16,15,14,14,17,21; 在maxthon中：16,14,14,15,16,18; 在IE6.0中：都是19； 在IE7.0中：都是19； 在IE8.0中：16,15,14,16,17,19; dl标签有默认margin（top,bottom且相同）值，没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; dd标签有默认margin-left：40px;(在所有上述浏览器中)。 ol,ul标签有默认margin-（top,bottom且相同）值，有默认padding-left值 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; 默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。 th,td标签th,td标签没有默认的margin值，有默认的padding值。 在Chrome,Firefox,Safari,Opera,Maxthon中：padding：1px; 在IE8.0中：padding：0px 1px 1px; 在IE7.0中：padding：0px 1px； 相同内容th的宽度要比td宽，因为th字体有加粗效果。 注意 ：table标签没有默认的margin,padding值。 form标签form标签在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中没有默认的margin,padding值，但在IE6.0,7.0中有默认的margin：19px 0px; p标签p标签有默认margin(top,bottom)值,没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; textarea标签textarea标签在上述所有浏览器中：margin:2px；padding:2px； select标签select标签在Chrome,Safari,Maxthon中有默认的margin：2px；在Opera,Firefox,IE6.0,7.0,8.0没有默认的margin值。 option标签option标签只有在firefox中有默认的padding-left：3px； CSS reset/*CSS style init*/ body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,option,textarea,form,th,td{margin: 0; padding: 0;} body{font:14px/1.5 &quot;宋体&quot;;} img{border:none;} li{list-style:none;} input,select,textarea{outline:none;border:none;background:none;} textarea{resize:none;} a{text-decoration:none;}]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS清除浮动的几种方法]]></title>
    <url>%2F2017%2F10%2F17%2Fclearfix%2F</url>
    <content type="text"><![CDATA[几种定位方式，以及CSS清除浮动的几种方法。 几种定位方式普通流定位 static普通流定位即文档流定位，是页面元素的默认定位方式。按照元素在文档流中的出现顺序以默认形式呈现元素。 页面中的块级元素：按照从上到下的方式逐个排列 。 页面中的行内元素：按照从左到右的方式逐个排列 。 此时考虑如何让多个块级元素显示在一行，就引出了浮动的概念。 浮动定位 floatfloat属性取值为 left/right。这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕。 相对定位 relative元素会相对于它原来的位置偏移某个距离。使元素偏离原来位置后，元素原本的空间依然会被保留。 语法 属性：position 取值：relative 再配合 偏移属性top/right/bottom/left实现位置改变 绝对定位 absolute若元素被设置为绝对定位，具备以下几个特征： 1、脱离文档流-不占据页面空间 2、通过偏移属性固定元素位置 3、相对于 最近的已定位的祖先元素实现位置固定 4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定 语法 属性：position 取值：absolute 再配合 偏移属性(top/right/bottom/left)实现位置的固定 固定定位 fixed将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动。 语法 属性：position 取值：fixed 配合着 偏移属性(top/right/bottom/left)实现位置的固定 浮动的效果1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位 2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动) 3、浮动元素依然位于父元素之内 4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 注意 1、一行内，显示不下所有的已浮动元素时，最后一个将换行 2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定) 3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大（块级元素：允许修改尺寸；行内元素：不允许修改尺寸 ） 4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素 浮动的影响：由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）。 清除浮动方法1直接设置父元素的高度。优势：极其简单；弊端：必须要知道父元素高度是多少 方法2在父元素中，追加空子元素，并设置其clear属性为both。clear是css中专用于清除浮动的属性。作用：清除当前元素前面的元素浮动所带来的影响 取值： 1、none 默认值，不做任何清除浮动的操作 2、left 清除前面元素左浮动带来的影响 3、right 清除前面元素右浮动带来的影响 4、both 清除前面元素所有浮动带来的影响 优势：代码量少 容易掌握 简单易懂弊端：会添加许多无意义的空标签，有违结构与表现的分离，不便于后期的维护 方法3设置父元素浮动。 优势：简单，代码量少，没有结构和语义化问题；弊端：对后续元素会有影响 方法4为父元素设置overflow属性。 取值：hidden 或 auto 优势：简单，代码量少弊端：如果有内容要溢出显示(弹出菜单)，也会被一同隐藏 方法5父元素设置display:table. 优势：不影响结构与表现的分离，语义化正确，代码量少；弊端：盒模型属性已经改变，会造成其他问题 方法6使用内容生成的方式清除浮动。 .clearfix:after { content:&quot;&quot;; display:block; clear:both; } :after 选择器向选定的元素之后插入内容 content:&quot;&quot;; 生成内容为空 display: block; 生成的元素以块级元素显示, clear:both; 清除前面元素浮动带来的影响 相对于空标签闭合浮动的方法，优势：不破坏文档结构，没有副作用；弊端：代码量多 方法7.cf:before,.cf:after { content:&quot;&quot;; display:table; } .cf:after { clear:both; } 优势：不破坏文档结构，没有副作用；弊端： 代码量多]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTFS文件系统介绍]]></title>
    <url>%2F2017%2F10%2F16%2FNTFS-file-system%2F</url>
    <content type="text"><![CDATA[【转】Windows文件系统FAT16、FAT32、NTFS的简单介绍。 什么是NTFS文件系统介绍NTFS之前，先来介绍一下FAT。 FAT(File Allocation Table)表示“文件分配表”，它的意义在于对硬盘分区的管理。FAT16、FAT32、NTFS是Windows系统最常见的三种文件系统。 FAT16：以前用的DOS、Windows95都使用FAT16文件系统，后来的Windows98/2000/XP等系统均支持FAT16文件系统。它最大可以管理大到2GB的分区，但每个分区最多只能有65525个簇（簇是磁盘空间的配置单位，即文件的存取的最小单位，一个簇包含若干扇区，而扇区是磁盘驱动器向磁盘读取和写入数据的最小单位）。随着硬盘或分区容量的增大，每个簇所占的空间将越来越大，从而导致硬盘空间的浪费。 更多关于硬盘的基本知识参见博客硬盘基本知识。 FAT32：随着大容量硬盘的出现，从Windows98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。 NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。从1993年开始，随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。 在NTFS文件系统中，文件存取是按簇进行分配，一个簇必需是物理扇区的整数倍，而且总是2的整数次方倍。NTFS文件系统并不去关心什么是扇区，也不会去关心扇区到底有多大（如是不是512字节）。簇大小在使用格式化程序时则会由格式化程序根据卷大小自动的进行分配。 文件通过主文件表（MFT）来确定其在磁盘上的存储位置。主文件表是一个对应的数据库，由一系列的文件记录组成。 卷中每一个文件都有一个文件记录（对于大型文件还可能有多个记录与之相对应）。主文件表本身也有它自己的文件记录。 NTFS卷上的每个文件都有一个64 bit称为文件引用号（File Reference Number，也称文件索引号）的唯一标识。文件引用号由两部分组成：一是文件号，二是文件顺序号。文件号为48位，对应于该文件在MFT中的位置。文件顺序号随着每次文件记录的重用而增加，这是为NTFS进行内部一致性检查而设计的。 NTFS使用逻辑簇号（Logical Cluster Number，LCN）和虚拟簇号（Virtual Cluster Number，VCN）来进行簇的定位。LCN是对整个卷中所有的簇从头到尾所进行的简单编号。卷因子乘以LCN，NTFS就能够得到卷上的物理字节偏移量，从而得到物理磁盘地址。VCN则是对属于特定文件的簇从头到尾进行编号，以便于引用文件中的数据。VCN可以映射成LCN，而不必要求在物理上连续。 NTFS的目录只是一个简单的文件名和文件引用号的索引，如果目录的属性列表小于一个记录的长度，那么该目录的所有信息都存储在主文件表的记录中，对于大于记录的目录则使用B+树进行管理。 主文件表中的基本文件记录中有一个指针指向一个存储非常驻索引缓冲–包括该目录下所有下一级子目录和文件的外部簇，而B+树结构便于大型目录中文件和子目录的快速查找。 在NTFS中，所有存储在卷上的数据都包含在文件中，包括用来定位和获取文件的数据结构，以及引导程序和记录这个卷的记录（NTFS元数据）的位图，这体现了NTFS的原则：磁盘上的任何事物都为文件。在文件中存储一切使得文件系统很容易定位和维护数据，而在NTFS中，卷中所有存放的数据均在一个叫做MFT的文件记录数组中，称为主文件表(Master File Table)，MFT是由高级格式化产生的。而MFT则由文件记录(File Record)数组构成。File Record的大小一般是固定的，不管簇的大小是多少，均为1KB，这个概念相当于Linux中的inode（i节点）。File Record在MFT文件记录数组中物理上是连续的，且从0开始编号。 MFT仅供系统本身组织、架构文件系统使用，这在NTFS中称为元数据(metadata)。其中最基本的前16个记录是操作系统使用的非常重要的元数据文件。这些NTFS主文件表的重要的元数据文件都是以$(美元符号)开始的名字，所以是隐藏文件，在Windows 2000中不能使用dir命令(甚至加上/ah参数)像普通文件一样列出这些元数据文件。实际上File System Driver(ntfs.sys)维护了一个系统变量NTFS Protect System Files用于隐藏这些元数据。但是微软公司也提供了一个OEM TOOL,叫做NFI.EXE,用此工具可以转储NTFS主文件表的重要的元数据文件（元数据：是存储在卷上支持文件系统格式管理的数据。它不能被应用程序来访问，它只能为系统提供服务）。这些元数据文件文件是系统驱动程序装配卷所必需的，WINDOWS 2000给每个分区赋予一个盘符并不表示该分区包含有WINDOWS 2000可以识别的文件系统格式，如果一旦主文件表损坏，那么该分区在WINDOWS 2000下是无法读取的。为了使该分区能够在WINDOWS 2000下能被识别，也就是必须首先建立WINDOWS 2000可以识别的文件系统格式即主文件表，这可通过高级格式化该分区来完成。众所周知，Windows以簇号来定位文件在磁盘存储的位置，在FAT格式的文件系统中有关簇号的指针是包含在FAT表中的，而在NTFS中有关簇号的指针是包含在$MFT及$MFTMirr文件中的。 NTFS元文件MFT中的第1个记录就是MFT自身。由于MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（＄MftMirr），也就是MFT中的第2个记录。 第3个记录是日志文件（＄LogFile）。该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，例如复制，从而在系统失败时能够恢复NTFS卷。 第4个记录是卷文件（＄Volume），它包含了卷名、被格式化的卷的NTFS版本和一个标明该磁盘是否损坏的标志位（NTFS系统以此决定是否需要调用Chkdsk程序来进行修复）。 第5个记录是属性定义表（＄AttrDef，attribute definition table），其中存放了卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。 第6个记录是根目录（\），其中保存了存放于该卷根目录下所有文件和目录的索引。在访问了一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接进行对该文件的访问。 第7个记录是位图文件（＄Bitmap）。NTFS卷的分配状态都存放在位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲的还是已被分配了的，由于该文件可以很容易的被扩大，所以NTFS的卷可以很方便的动态的扩大，而FAT格式的文件系统由于涉及到FAT表的变化，所以不能随意的对分区大小进行调整。 第8个记录是引导文件（＄Boot），它是另一个重要的系统文件，存放着Windows 2000/XP的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统。该文件是在Format程序运行时创建的，这正体现了NTFS把磁盘上的所有事物都看成是文件的原则。这也意味着虽然该文件享受NTFS系统的各种安全保护，但还是可以通过普通的文件I/O操作来修改。 第9个记录是坏簇文件（＄BadClus），它记录了磁盘上该卷中所有的损坏的簇号，防止系统对其进行分配使用。 第10个记录是安全文件（＄Secure），它存储了整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为了节省空间，NTFS将具有相同描述符的文件和目录存放在一个公共文件中。 第11个记录为大写文件（＄UpCase，upper case file），该文件包含一个大小写字符转换表。 第12个记录是扩展元数据目录（＄Extended metadata directory）。 第13个记录是重解析点文件（$Extend\$Reparse）。 第14个记录是变更日志文件（$Extend\$UsnJrnl）。 第15个记录是配额管理文件（$Extend\$Quota）。 第16个记录是对象ID文件（$Extend\$ObjId）。 第17～23记录是是系统保留记录，用于将来扩展。 MFT的前16个元数据文件是如此重要，为了防止数据的丢失，NTFS系统在该卷文件存储部分的正中央对它们进行了备份。 NTFS把磁盘分成了两大部分，其中大约12%分配给了MFT，以满足其不断增长的文件数量。为了保持MFT元文件的连续性，MFT对这12%的空间享有独占权。余下的88%的空间被分配用来存储文件。而剩余磁盘空间则包含了所有的物理剩余空间–MFT剩余空间也包含在里面。MFT空间的使用机制可以这样来描述：当文件耗尽了存储空间时，Windows操作系统会简单地减少MFT空间，并把它分配给文件存储。当有剩余空间时，这些空间又会重新被划分给MFT。虽然系统尽力保持MFT空间的专用性，但是有时不得不做出牺牲。尽管MFT碎片有时是无法忍受的，却无法阻止它的发生。 那么NTFS到底是怎么通过MFT来访问卷的呢？首先，当NTFS访问某个卷时，它必须”装载”该卷：NTFS会查看引导文件（在图中的＄Boot元数据文件定义的文件），找到MFT的物理磁盘地址。然后它就从文件记录的数据属性中获得VCN到LCN的映射信息，并存储在内存中。这个映射信息定位了MFT的运行（run或extent）在磁盘上的位置。接着，NTFS再打开几个元数据文件的MFT记录，并打开这些文件。如有必要NTFS开始执行它的文件系统恢复操作。在NTFS打开了剩余的元数据文件后，用户就可以开始访问该卷了。 文件和目录记录NTFS将文件作为属性/属性值的集合来处理，这一点与其他文件系统不一样。文件数据就是未命名属性的值，其他文件属性包括文件名、文件拥有者、文件时间标记等。 每个属性由单个的流（stream）组成，即简单的字符队列。严格地说，NTFS并不对文件进行操作，而只是对属性流进行读写。NTFS提供对属性流的各种操作：创建、删除、读取（字节范围）以及写入（字节范围）。读写操作一般是针对文件的未命名属性的，对于已命名的属性则可以通过已命名的数据流句法来进行操作。 一个文件通常占用一个文件记录。然而，当一个文件具有很多项属性值或很零碎的时候，就可能需要占用一个以上的文件记录。这种情况下，第一个文件记录是其基本的文件记录，存储有该文件需要的其它文件记录的位置。小文件和文件夹（典型的如1500字节或更少）将全部存储在文件的MFT记录里。 文件夹记录包括索引信息，小文件夹记录完全存储在MFT结构内，然而大的文件夹则被组织成B+树结构，用一个指针指向一个外部簇，该簇用来存储那些MFT内存储不了的文件夹的属性。 NTFS卷上文件的常用属性列出如下（并不是所有文件都有所有这些属性）： （1）常驻属性与非常驻属性 当一个文件很小时，其所有属性和属性值可存放在MFT的文件记录中。当属性值能直接存放在MFT中时，该属性就称为常驻属性（resident attribute）。有些属性总是常驻的，这样NTFS才可以确定其他非常驻属性。例如，标准信息属性和根索引就总是常驻属性。 每个属性都是以一个标准头开始的，在头中包含该属性的信息和NTFS通常用来管理属性的信息。该头总是常驻的，并记录着属性值是否常驻、对于常驻属性，头中还包含着属性值的偏侈量和属性值的长度。 如果属性值能直接存放在MFT中，那么NTFS对它的访问时间就将大大缩短。NTFS只需访问磁盘一次，就可立即获得数据；而不必像FAT文件系统那样，先在FAT表中查找文件，再读出连续分配的单元，最后找到文件的数据。小文件或小目录的所有属性，均可以在MFT中常驻。小文件的未命名属性可以包括所有文件数据。 大文件或大目录的所有属性，就不可能都常驻在MFT中。如果一个属性（如文件数据属性）太大而不能存放在只有1KB的MFT文件记录中，那么NTFS将从MFT之外分配区域。这些区域通常称为一个运行（run）或一个盘区（extent），它们可用来存储属性值，如文件数据。如果以后属性值又增加，那么NTFS将会再分配一个运行，以便用来存储额外的数据。值存储在运行中而不是在MFT文件记录中的属性称为非常驻属性（nonresident attribute）。NTFS决定了一个属性是常驻还是非常驻的；而属性值的位置对访问它的进程而言是透明的。当一个属性为非常驻时，如大文件的数据，它的头部包含了NTFS需要在磁盘上定位该属性值的有关信息。 在标准属性中，只有可以增长的属性才是非常驻的。对文件来说，可增长的属性有数据、属性列表等。标准信息和文件名属性总是常驻的。 （2）MFT文件记录结构分析 主文件表MFT的文件记录由记录头和属性列表组成，由”FF FF FF FF”结束，一般大小为1K，或一个簇大小（这样一般就更大），记录头包括以下一些域： 每次记录被修改都将导致日志文件序列号$LogFile Sequence Number（LSN）发生变化。序列号Sequence Number（SN）用于记录主文件表记录被重复使用的次数。硬连接数Hard Link Count记录硬连接的数目，只出现在基本文件记录中。文件记录的实际长度是文件记录在磁盘上实际占用的字节空间。基本文件记录中的文件索引号，对于基本文件记录，其值为0，如果不为0，则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号，在基本文件记录中包含有扩展文件记录的信息，存储在”属性列表ATTRIBUTE_LIST”属性中。属性列表是可变长度区，以”FF FF FF FF”结束，对于1K长度的MFT记录，属性列表的起始偏移为0x30。]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网七夕动画学习总结+github pages展示]]></title>
    <url>%2F2017%2F09%2F29%2Fdemo-qixi%2F</url>
    <content type="text"><![CDATA[这段时间照着慕课网上的一个动画案例-H5+JS+CSS3实现七夕言情学习，并将学习的各部分的代码进行整合，最后将代码托管到github上，并通过github pages展示这个动画demo。一些地方自己修改以后没有老师的效果好，但这是自己第一个敲出来的前端小demo，成就感满满，哈哈。。。 关于动画案例里面用到一些jQuery和ajax相关的知识，由于自己学习js不久，很多深一点的概念理解不到位，比如一开始代码的封装和流程的编写，都是照葫芦画瓢，不是很理解，但是慢慢的看得多了，这个过程也就熟悉起来了。 页面布局部分比较容易理解，但是三个主题页面滚动起来最开始对自己还是有点难度。该案例很多部分都利用了CSS3的transform属性和animation属性。而且这个案例的思想是，把实现特定动作或者动能的代码封装起来，暴露一个接口出来，增强了安全性简化了编程过程。 具体的学习过程和用到的知识点，大家可以跟着H5+JS+CSS3实现七夕言情学习，边看边学的效果比抱着书一直看的效果要好一些。但js高级教程的基础必须打牢，很多师兄师姐给的建议，也是网上一些大佬的建议。 关于画面自己做的一点小改动，button的样式做了修改，并增加了链接到github仓库的logo（shirly与猫）,嘤嘤嘤。如下，左下角和右下角辣么一点点。 关于将页面搭建在github pages上关于动画制作的学习过程如果说困难和迷惑的话，那这最后一步展示在github pages上的过程，就应该是差点死在最后的1%上。在网上看了很多博客和教程，总会遇到很多小问题，无法显示自己在本地的效果。最后看到了这篇博客，【 js 工具 】如何在Github Pages搭建自己写的页面？，这篇博客对于利用github pages搭建自己写的网页描述很详细，从在github上建仓库，到github pages的设置，再到利用git命令克隆github上的仓库到本地，最后push到远程master分支上。 更多关于github的使用可参考Github 简明教程,其中讲解的git维护的本地仓库的工作流很清晰，对于我这个初步使用git的菜鸟十分友好。而且关于branch和更新与合并功能也讲的比较清楚。 本地仓库由git维护的“三棵树”组成。第一个是工作目录，使用$ git status可以查看，列出了当前目录下所有还未被git管理的文件，以及被git管理了且被修改过但还未添加（add）的文件，也即所有改动文件，用红色字体标出。如下所示，当我在本地仓库demo-qixi用$ git status命令查看后，可以看到红色文件均为未提交的。 第二个是暂存区（Index），它类似一个缓存区，临时保存你的改动。通过$ git add .命令添加当前目录下的所有文件和子目录到暂存区。注意.表示当前目录下的所有文件和子目录。也可以指定文件添加到暂存区，使用$ git add &lt;filename&gt;。如下使用$ git add .添加文件到暂存区： 此时我们再使用$ git status命令查看下工作目录，你会发现所有的文件都变绿了，这就表示这些文件已被添加到暂存区准备好被提交（commit）了。 第三个是HEAD，它指向你最后一次提交的结果。使用$ git commit -m &quot;代码提交说明信息&quot;命令，将暂存区最后一次添加更改情况提交到HEAD。如下所示。 上述“三棵树”的工作流程如下所示。 此时改动虽然已经提交到了HEAD，但是还没到远端仓库。使用$ git push命令将这些改动提交到远端仓库的default master分支。也可以使用$ git push origin master命令，把改动提交到master分支。可以把master换成自己想要推送的任何分支。 动画demo展示demo网页展示链接慕课七夕主题网页展示。 该动画demo在github上的代码仓库demo-qixi。 tips:在打开demo页面展示链接时，浏览器链接窗口出现提示“此页面上部分内容不安全，例如图像”，并且网页内容不能完整显示，我使用的firefox浏览器。如下所示， 原因是我们用来展示demo的github pages站点是使用https协议的安全站点，而demo中的一些图片链接是使用的http协议，浏览器不会渲染混合内容（即来自安全站点的不安全数据）。如果我们浏览https网页，浏览器会拒绝加载不安全的内容（例如这里的demo-qixi中图片使用的http协议），浏览器将向用户发出“此页面上部分内容不安全”的警告。可以参考这篇讲web安全的文章，绕过混合内容警告 - 在安全的页面加载不安全的内容。 解决办法：我用的火狐浏览器，点浏览器链接窗口左侧的黄色警告三角形-&gt;点右侧箭头显示连接细节-&gt;点暂时解除保护，就可以看到完整的动画demo了。 然后点击 Go!开始动画啦。。。。。。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>animation</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匆匆拉萨之行]]></title>
    <url>%2F2017%2F09%2F13%2Ftour-lahsa%2F</url>
    <content type="text"><![CDATA[第一次尝试写游记，嗯，是在周老师的文艺熏陶之下，试着记录一哈，但愿最后读起来不是一篇作文的感觉 T T ~~真的太久没动手写点儿文字了，想当年语文也是考过140分的人呐 = = 哈哈哈哈哈哈哈哈哈 嗯，这一定会是一本气质爆炸的流水账，如此鼓励自己，就像拉萨的阳光和色彩，希望经得起时间，淡化模糊了的时候再来强化一遍，反正又不是背英语词汇书，不用每次拾起都abandon 哈哈哈 在被林子放鸽子（为了她的大好前程，以及许诺将来可以赚很多钱养我的情况下，对于她的这种抛弃我的行为予以了包容，哈哈哈，我就是这么体贴大方聪明美丽可爱。。。。。。然而，在她晓得我自己去耍，她却在加班以后，果断从内疚的心态转为了说我抛弃了她==），又不想回家监督老弟学习，团队的小伙伴接连回家只剩我自己的情况下，突然萌生了想去远一点的地方这个想法，其实之前也有想过去趟拉萨，但是纠结于各种原因，一直没有付出行动。 从打算去拉萨，到最后决定并买票只花了一天时间，这是第一次去一个远一点的地方没有攻略过就这么仓促决定了。去的火车票没有，只好买机票，回程的也没有直达的火车票了，机票略贵不舍，只好坐着火车出拉萨到西宁再转车，真是一次相当难忘的硬座经历。虽然匆匆忙忙腿脚肿胀，但遇到些有趣的人始终是种新鲜。 Day 1 贡嘎机场外连绵的山，云彩触手可及的感觉，很凉爽，不过光秃秃的山还是有点荒凉，阳光很炫 停放机场大巴的车站，一出门就被这片云吸引到了，坐在旁边的叔叔说拉萨比这漂亮的云很多，这个太一般了，他们已经习惯了这片土地的蓝天和云，而我这个刚刚落地的游客真的十分激动哇，嘤嘤嘤，超爱高原上的感觉，怎么形容呢，就是会心情变得超级好，好心情养成地啊 来之前准备了红景天，由于时间仓促只提前喝了一天，然而下飞机之后感觉自己一点高原反应都没有，默默地瞎激动，以为自己会是逃脱高反的那个例外，就像当初觉得自己也是那个会逃过警告的人，but，瞎激动的幸运之后高反是说来就来的，晚上头疼的睡不着。 Day 2红景天真特么不管用，第二天头疼头晕还是躺了大半天，还不如连喝几壶热水管用，必须要赞一下的是，本来带的防感冒的药吃了一片居然有治头疼的奇效，在感冒药的助攻下，晕晕乎乎吃了一顿串串。夏天拉萨夜晚的街头很是凉快，于是决定去布宫广场转转。夜晚吃饱了坐在电瓶车上吹着凉风浪荡在一座陌生城市的感觉，贼爽。 傍晚酒店对面的拉萨河，高山和低垂的白云环抱一整座城市。 布宫广场上一对拍婚纱照的恋人。想起回程的火车上遇到的一个妹子，她说起登珠峰途中遇到的一对六十多岁的爷爷奶奶，爷爷说，只有去过珠峰的爱情才是真的爱情。这种高调的秀恩爱的方式，真的很动人。在高海拔缺氧的环境下，我与你一起经历头晕和窒息，一起经受岁月无情的摧残。 Day 3 从这顿早饭开始体验到拉萨的物价之高，这样的包子在我高反胃口不好的情况下，吃了六个还不饱，一块五一个。原来我也可以是一个早饭能吃十几块钱包子的人= = 去的时候正好赶上拉萨的雪顿节，雪顿节又叫酸奶节，他们告诉我说是专门喝酸奶的节日，我觉得是在糊弄我，但我对西藏节日文化也没甚了解，不甚感兴趣，也没去深究。但雪顿节的林卡气氛我是感受到了，比我们春节似乎还要热闹。整个就是全家集体公园春游的感觉。 罗布林卡草地上到处都是来过林卡的藏民，一家人围坐在坐席上，带上酸奶，带上酥油茶，带上不远赶来的美好愿景。 喜欢拉萨的色彩，尤其这种对比强烈的红色和黄色，蓝天，白云，一切都很美丽。 Day 4 波林卡路措姆凉粉店的菜单，排队的人超级多。字很秀气。 点了酸奶，土豆，凉粉。酸奶超级喜欢，加了一勺白砂糖，还有点酸。 布宫的一角，就像童话里的一座宫殿。能想象到历史上权利曾在此集中过。宫殿上方的阳光，明亮刺眼，你只能仰视它，它离你那么近那么远。 龙王潭公园的树荫下看到的布宫背面。布宫真的是360度无死角的美丽。不知道为什么，就是感觉阳光映照下，这片绿很可口的样子，看起来真的很好吃的样子啊。 阳光穿过树隙。这株柳树目测应该几百年历史了，在高原长这么粗壮，它一定经历和见证了很多。 Day 5布宫的门票真的太抢手，200块的门票听说被黄牛炒到了一千多，在一番折腾排队下，终于被放进这个大宫殿。不过在参观过程中，除了游客对各种精致奢华的惊叹，还有那些朝拜者的认真和虔诚。可以看到一家人把坐在轮椅上的老人从山脚下一级级石阶往上抬，也可以看到七旬的两个老奶奶大概是姐妹吧，相互搀扶一起双手合十，一起磕长头，一起留着长长的辫子。不羡慕这虔诚的信仰，但羡慕这种跨越时间温暖的陪伴。不管你去哪儿，都和你一起。 布宫的一角，红色的墙壁里面是一种高原上的草。惊叹于古人的建筑智慧和手艺。 进入主要的宫殿参观文物前最后能拍照的地方。 同行的一个小妹妹，红墙的映衬下，宛若一只仙女。 出布宫后在山上俯瞰整个拉萨，布宫就是整个拉萨的观景台。 格桑花盛开的山坡，此时山顶上的布宫十分安静。 大昭寺门前磕长头的朝拜者。我是看客，无法理解信仰的力量，但激动于世界上还有这样一群人。 八廓街的一角，蓝天，云朵，建筑，一切都温柔和谐。 八廓街上一家叫南卡的冷饮店。名字很美丽。 一对环绕大昭寺磕长头的姐妹，她们还很小，但我好像看到了在布宫那一对磕头相扶的老奶奶。 阴影里的长椅上坐了一排在转经的老爷爷。朋友调侃道，我那么帅你不拍我，去拍老头子。但是，一排老爷爷排排坐真的很可爱啊。 Day 6早晨七点就坐车去纳木错，七点的拉萨还有些黑，尽管穿了外套街头还是很冷。但天微微亮的时候，拉萨的街头十分美丽。 圣湖就是圣湖，远远的就被迷住了。蓝天，云彩，雪山，清水。天空就像是湖水的倒影。坐在湖边发呆，感觉都很美好。 阳光倾泻而下。此处该有个美丽的仙仙的背影= = 再来一张透明的湖水。 一个仙仙的小姐姐的背影，超美，嘤嘤嘤 湖边一个浅滩，云朵和人群的倒影。 海拔5190米，那拉根山口飘舞的经幡。途中总有那么一抹颜色吸引了你，总有那么一个人惊艳于你。 青藏线上的黄昏。安静，美丽。 The End]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>tour</tag>
        <tag>lahsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题配置---打赏功能+文章结束标志]]></title>
    <url>%2F2017%2F08%2F10%2Fblog-donate%2F</url>
    <content type="text"><![CDATA[这次介绍一下next主题下添加打赏功能，以及在每篇文章末尾统一添加“文章结束”标志 ~~~吼吼吼 打赏功能首先在主题配置文件即hexo/themes/next/_config.yml找到version字段，查看自己的next主题的版本，如下图所示，我用的next主题的版本为5.1.2 在网上查了一些添加打赏功能的方法，参照来做的时候，发现了一些问题，可能是由于next主题升级到version5后自身增加了些隐藏的新功能，所以在网上找到的别人的一些方法不太适用，下面的添加文章结束功能也是如此。因此自己尝试设置好后特来分享一哈~ 在主题配置文件找到Reward字段部分，如下图所示，其中reward_comment字段设置你的打赏介绍，wechatpay和alipay分别为你保存微信以及支付宝收款二维码的路径，可以是本地路径，也可以是用图床生成的链接地址。我是把图片放在本地的，即将两个二维码图片放在了next/source/images文件夹下。 此时默认的打赏按钮如下，略丑。。。然后作了小小改动，把打赏按钮变好看一点点 ~~~ 改动方法如下：在hexo\themes\next\layout_macro下找到reward.swig文件，这个文件是关于打赏功能样式设置的。用下面代码覆盖原文件中的代码即可。由于保存的自动生成的微信及支付宝二维码图片的大小不一，且原图略大，所以可以通过设置包裹两幅图片的div元素的宽度和高度（代码两处注解处）来限制图片的大小，使其更加美观。宽度和高度可以依据自己喜欢更改大小。当然也可以自己使用图片处理工具将 12345678910111213141516171819202122232425262728293031&lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt; &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt; &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; style=&quot;width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt; 打赏 &lt;/button&gt; &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt; &#123;% if theme.wechatpay %&#125; &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt; &lt;p&gt;WeChat Pay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.alipay %&#125; &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt; &lt;p&gt;Alipay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.bitcoin %&#125; &lt;div id=&quot;bitcoin&quot; style=&quot;display: inline-block&quot;&gt; &lt;img id=&quot;bitcoin_qr&quot; src=&quot;&#123;&#123; theme.bitcoin &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Bitcoin&quot;/&gt; &lt;p&gt;Bitcoin&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt; 调整后的效果见下图，是不是稍微不那么丑了一点点呢，红红火火恍恍惚惚~~~~ 文章结束标志本以为这是一个非常简单的小功能，其实的确是一个很简单的功能，但由于参考的人家的做法可能不适于我使用的版本，导致这个小小的问题又折腾了好久T T 在hexo\themes\next\layout_macro文件夹下新建passage-end-tag.swig文件，并添加代码如下： 1&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 其中的 &lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;为FontAwesome图标,可以在其中挑选自己喜欢的图标，我选了一个笑脸，嘻嘻(●’◡’●) 然后打开hexo\themes\next\layout_macro文件夹下的post.swig文件，在 END POST BODY这段注解后添加如下图框框中的代码： 具体代码如下： 12345&#123;% if theme.passage_end_tag.enabled and not is_index %&#125; &lt;div&gt; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 再然后，打开主题配置文件hexo/themes/next/_config.yml，在末尾添加如下代码： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 效果如下图所示： 最后，运行下hexo g -d 看下部署到github后的效果吧！ PS:比较坑的一点，我使用的markdownpad，使用Tab缩进打代码块时，在右侧预览区可以正常显示代码块文本，但是 hexo s 在本地浏览器预览后，代码块文本却没有正确完整的显示，有些html标签被解释掉了。好像是Tab缩进可以被markdownpad的解释器正确解释，但是hexo的解释器却没有将其正确解析。后面换了一种打代码块的方式，就可以在浏览器正确显示了，但在markdownpad的预览区却没得到正常显示。即在代码块的最前面和最后面单独一行使用三个反引号 ```。如下图所示。 效果显示如下：]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>next</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于hexo和github搭建个人博客概述]]></title>
    <url>%2F2017%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言：第一次写博客，小激动~~~分享总结下用hexo+github搭建个人博客的过程，以及过程中遇到的问题。（我用的win10 64位系统） 环境介绍 hexo 根据hexo官网的介绍，hexo是一个快速简洁且高效的博客框架。hexo利用markdown等渲染引擎解析文章，快速生成静态网页。 Hexo是基于node.js的, 在安装它之前需要用到npm安装工具, 这个工具是 node.js 安装包的工具, 所以需要先安装 node.js。 关于hexo搭建博客原理进一步了解-hexo原理浅析。 node.js node.js是运行在服务端的javascript，是一个允许开发人员使用javascript语言编写服务端代码的框架。 npm npm是随同node.js一起安装的包管理工具，能解决node.js代码部署上的很多问题。允许用户从npm服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 新版的node.js已经集成了npm，所以下载安装node.js也一并将npm安装好了。 git git是一种非常流行的分布式版本控制系统，它和其他版本控制系统的主要差别在于git只关心文件数据的整体是否发生变化，而大多数版本其他系统只关心文件内容的具体差异。 我们利用git将hexo生成的静态博客页面，部署到github pages上。关于git的更多了解。 github 随着git迅速成为最流行的分布式版本控制系统，github网站上线了。github是一个基于git的代码托管平台，它为开源项目免费提供git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。 搭建步骤1.环境准备（node.js，git，github相关设置） 2.hexo下载安装 3.hexo相关配置 4.hexo与github pages链接 5.发布第一篇博文 6.hexo主题介绍及配置 7.hexo第三方服务集成（disqus评论，百度分享，访客记录等） 环境准备node.js下载安装node.js下载 下载完成后一路默认next即可。利用win+R打开命令窗口，在命令窗口中输入以下命令，可以查看node和npm的版本信息。如果可以正确显示版本信息，说明安装正确，否则检查安装过程，重新安装。 node -v npm -v 结果如下图所示。 git下载安装git下载 下载完成后一路默认next即可。在命令窗口中输入以下命令，可以查看git的版本信息。 git --version 结果如下图所示。 github注册相关若没有注册过github账号，在github官网按照步骤注册成功就好。 注册登录后，在页面右上角+号选择New repository创建新的代码仓库。 在Create a new repository页面下，填写Repository name框框，框框中填写yourname.github.io，其中yourname为Owner框框中的那个名字。再勾选一下Initialize this repository with a README 。 正确创建代码仓库后，需要开启github pages功能。在刚刚新建的代码仓库界面点击Settings，就会打开这个库的设置页面，向下拖动，会看见GitHub Pages，点击Launch Automatic page generator，github 自动创建出一个github pages页面。然后你可以试着访问yourname.github.io这个网址。 hexo下载安装在合适的盘，例如以E盘为例，在E盘根目录下新建hexo文件夹，然后右键点击选中hexo,选择Git Bash Here,在git命令窗口中输入以下命令： $ npm install hexo-cli -g 然后输入 $ npm install hexo --save 建议将hexo以下插件一起安装了 $ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ npm install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 (或者可以执行 npm install命令，npm会自动安装部分组件，但自己试了下，用npm命令不能安装全组件，部分组件还需自己手动安装，比如最重要的用于部署功能的组件 hexo-deployer-git 用 npm install命令就没装上。可以在hexo/node_modules文件下查看已经安装了的组件。) 安装完成后可查看下所安装的hexo版本信息。在hexo文件夹下右键进入git bash,输入以下命令: $ hexo -v 若看到类似如图所示版本信息说明hexo安装成功。 hexo相关配置 hexo初始化 -&gt;在hexo文件夹下右键进入git bash,输入以下初始化命令： $ hexo init hexo生成 -&gt;输入以下命令生成静态页面: $ hexo g 本地服务 -&gt;输入以下命令建立本地hexo预览： $ hexo s(确保已经安装了hexo-server组件，否则该命令无效） 执行完 hexo s 命令后会提示 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开上述链接地址，会看到hexo默认的主题页面，至此hexo本地配置完成。 PS：注意！！！安装了福昕阅读器的朋友，福昕阅读器会占用4000端口，导致 hexo s 命令后出错提示4000端口被占用。你可以在hexo/_config.yml站点配置文件里修改端口号，换成自己想设置的端口即可，如下修改： server: port: 4001 compress: true header: true hexo与github pages链接 deployment配置 -&gt;在hexo/_config.yml站点配置文件里，修改下面的字段内容如下： deploy: type: git repo: https://github.com/yourname/yourname.github.com.git #yourname即为创建仓库时的那个yourname branch: master PS:注意.yml格式文件冒号后面有一个空格。 发布第一篇博文在hexo文件夹下右键进入git bash,输入以下命令即可生成一篇新文章： hexo new post &quot;post_title&quot; #其中post_title为你想新建文章的文件名 此时在 E:\hexo\source\ _posts 下生成一个 post_title.md 文件（此后你可以用markdown编辑器打开该.md文件就可以编辑文章了）。 然后运行下面两条命令即可将新建的文章生成-&gt;部署到github上。 hexo g #生成 hexo d #部署 部署完毕后，即可访问https://yourname.github.io看到刚刚生成部署到github的文章。 PS：以后每次用markdown编辑器修改post_title.md文件后，记得用 hexo g -d 命令来生成和部署。修改完配置后也要hexo g -d一下。 PPS:hexo常用命令 hexo new post &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo主题介绍及配置我选用的较为简洁大方的next主题。 next主题下载 -&gt;在hexo文件夹下右键进入git bash,输入以下命令： git clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题 -&gt;在hexo/_config.yml站点配置文件下，修改如下字段： theme: next 测试主题启用是否成功 -&gt;执行 hexo s命令，在浏览器访问 http://localhost:4000查看主题效果。 PS：主题的其他相关设置可以参考该博客，写的很详细手把手教你用Hexo+Github 搭建属于自己的博客。 hexo第三方服务集成添加disqus评论由于以前国内使用较多的多说评论下架了，所以选用了国外较为稳定的disqus，但使用该评论功能需要“科学上网”！ 注册disqus账号https://disqus.com 在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为https://yourname.github.io), 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。 打开hexo/themes/next/_config.yml主题配置文件，修改下面字段： #Disqus disqus: enable: true shortname: #shortname即为你上面填写的唯一disqus路径，填上就好 count: true 添加百度分享功能百度分享功能的添加可以参考下面这篇博客。Hexo+Github搭建个人博客(三)——百度分享集成 百度统计访客访问量功能其他酷炫小功能参考hexo的next主题个性化教程:打造炫酷网站。 参考博客手把手教你用Hexo+Github 搭建属于自己的博客 记录第一次搭建hexo 嘤嘤嘤~~~THE END!]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node.js</tag>
        <tag>npm</tag>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
