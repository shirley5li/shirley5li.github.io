<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirley</title>
  <subtitle>一只自学成菜的仙女!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-30T09:32:22.906Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShirleyLi</name>
    <email>1363814017@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>planeGame-H5 Canvas小游戏未完成的问题</title>
    <link href="http://yoursite.com/2017/10/30/planeGameQuestion/"/>
    <id>http://yoursite.com/2017/10/30/planeGameQuestion/</id>
    <published>2017-10-30T08:31:25.000Z</published>
    <updated>2017-10-30T09:32:22.906Z</updated>
    
    <content type="html"><![CDATA[<p>H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。<br><a id="more"></a></p>
<h2 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h2><h3 id="游戏设置部分"><a href="#游戏设置部分" class="headerlink" title="游戏设置部分"></a>游戏设置部分</h3><p>音乐设置（HTML5 audio相关的学习，包括设置游戏背景音乐以及各种子弹、爆炸等声音，以及切换声音的开启和关闭）</p>
<p>背景设置（即切换背景图片）</p>
<p>战机设置（即切换战机plane的icon图片）</p>
<h3 id="存在问题的地方"><a href="#存在问题的地方" class="headerlink" title="存在问题的地方"></a>存在问题的地方</h3><p>点击“再玩一次”之后，敌机以及子弹的速度会越来越快，差不多第三次重玩就无法进行了。感觉是因为上一次游戏过程中的一些数据没有清除，怀疑过是不是setInterval()的原因，百度了查了好多，在end处添加了window.clearInterval()，但也是无济于事。特将此问题记录，以待后面将js学深了再来解决。</p>
<h3 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h3><p>游戏结束以后，除了“再玩一次”，再添加一个“退出游戏”功能，使页面切换到index状态。</p>
<p>适应手机端的，试了下在电脑上战机移动不了，应该是手指移动事件那里还未考虑鼠标移动来兼容电脑浏览器。</p>
<h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p>主页面如下：</p>
<p><img src="/images/planeGameQuestion/1.png" alt="1"></p>
<p>游戏结束，“再玩一次”界面</p>
<p><img src="/images/planeGameQuestion/2.png" alt="2"></p>
<h2 id="github源码"><a href="#github源码" class="headerlink" title="github源码"></a>github源码</h2><p>github仓库地址：<a href="https://github.com/shirley5li/demo-planegame" target="_blank" rel="external">demo-planegame</a></p>
<p>放在gh-pages上的样子，电脑端战机移动不了。。。。<a href="https://shirley5li.github.io/demo-planegame/" target="_blank" rel="external">demo展示</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。&lt;br&gt;
    
    </summary>
    
      <category term="HTML5 Canvas" scheme="http://yoursite.com/categories/HTML5-Canvas/"/>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>JS笔记(二)DOM操作--from next十天训练营</title>
    <link href="http://yoursite.com/2017/10/20/next-js2/"/>
    <id>http://yoursite.com/2017/10/20/next-js2/</id>
    <published>2017-10-20T12:21:29.000Z</published>
    <updated>2017-10-21T05:57:32.996Z</updated>
    
    <content type="html"><![CDATA[<p>JS调用DOM接口修改样式。<br><a id="more"></a></p>
<h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><p><img src="/images/next-js2/1.png" alt="1"></p>
<p>上图是一张网页的生成过程，大致分为五步：</p>
<p>（1）html代码转化为DOM树</p>
<p>（2）CSS代码转化成CSSOM（CSS Object Model）</p>
<p>（3）结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）</p>
<p>（4）生成布局（layout），即将所有渲染树的所有节点进行平面合成</p>
<p>（5）将布局绘制（paint）在屏幕上</p>
<p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。</p>
<p>其中，在html文档生成DOM树后，JS可以通过DOM提供的接口来添加、删除、修改元素和样式。</p>
<h2 id="DOM查找"><a href="#DOM查找" class="headerlink" title="DOM查找"></a>DOM查找</h2><p>查找API:</p>
<pre><code>document.getElementById()//通过元素id查找，查找一个元素

[document|Element].getElementsByClassName()//通过元素类名查找，查找一组元素，得到一个类数组(html collection)

[document|Element].getElementsByTagName()//通过元素标签名查找,查找一组元素，得到一个类数组

[document|Element].querySelector()//通过CSS选择器查找，例如 var qId = document.querySelector(&apos;#id&apos;);

[document|Element].querySelectorAll()//通过CSS选择器查找
</code></pre><p>后两者常用。</p>
<h2 id="DOM新增和删除"><a href="#DOM新增和删除" class="headerlink" title="DOM新增和删除"></a>DOM新增和删除</h2><p>（1）新增节点<br>新增一个元素时，包括插入和追加。前面插入用insertBefore()，后面追加用appendChild()。</p>
<pre><code>parent.appendChild(element)//新增节点到父元素的末尾

parentElement.insertBefore(newElement, targetElement)//新增节点到targetElement元素的前面
</code></pre><p>注意：使用.insertBefore()方法时，不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它。所以可以通过<code>targetElement.parentNode.insertBefore(newElement, targetElement)</code>来插入。</p>
<p>新增多个元素时，可以利用上述两个方法结合循环实现，但循环会导致一个问题，因为直接操作DOM会导致浏览器反复渲染。利用DocumentFragment节点解决这个反复渲染问题。</p>
<p><strong>DocumentFragment</strong>文档片段，可以理解为“轻量级”的节点。有两个属性，分别为：nodeType = 11, nodeName = #document-fragment。<br>DocumentFragment作为仓库来使用，不在DOM树中，游离在DOM树之外。当增加多个节点时，可将这多个节点临时存放在DocumentFragment仓库中，最后再一次性插入DOM树中，就解决了浏览器反复渲染的问题。</p>
<p>（2）删除节点<br>删除节点使用removeChild()</p>
<p>（3）创建节点</p>
<p>此时创建出的节点即为DocumentFragment文档碎片，创建完以后再插入或者追加到DOM树中。</p>
<pre><code>document.createElement(nodeName)//创建元素节点,nodeName即为h1,h2,li,p,....

document.creatTextNode(text)//创建文本节点
</code></pre><p><strong>练习题</strong></p>
<p>题目要求:现有 HTML 代码如下,</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;按要求新增元素&lt;/h1&gt;
&lt;/body&gt;
</code></pre><p>在h1元素的后面新增一个ul元素，ul元素中有一百个li元素，li的内容就是 1-100 ，如下所示：</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;按要求新增元素&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        ......
        &lt;li&gt;98&lt;/li&gt;
        &lt;li&gt;99&lt;/li&gt;
        &lt;li&gt;100&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre><p>js代码如下：</p>
<pre><code>var len = 100;
var ul = document.createElement(&apos;ul&apos;);
var body = document.getElementsByTagName(&apos;body&apos;)[0];
for(var i = 0; i &lt; len; i++){
    var li = document.createElement(&apos;li&apos;);
    var liText = document.createTextNode(i+1);
    li.appendChild(liText);
    ul.appendChild(li);

} 
body.appendChild(ul);
</code></pre><h2 id="DOM修改样式"><a href="#DOM修改样式" class="headerlink" title="DOM修改样式"></a>DOM修改样式</h2><p>两种方式修改元素样式：通过元素style属性修改；通过元素class属性修改。</p>
<p>（1）style属性</p>
<p>style属性包含着元素诸如颜色大小等样式，style属性是一个对象。如访问style对象的color属性：<code>element.style.color</code>。</p>
<p>注意：当引用一个中间带减号的CSS属性时，DOM要求用驼峰命名法。CSS属性font-family变为了DOM属性fontFamily：<code>element.style.fontFamily</code>。这是因为减号和加号之类的操作符是保留字，不允许用在函数或变量的名字里，意味着也不能用在方法和属性的名字里。</p>
<p>缺点：style属性只能返回内嵌样式。即只有把CSS style属性插入到标记里，才可以用DOM style属性去获取那些属性信息。DOM style属性不能用来检索外部CSS文件里声明的样式。</p>
<p>（2）class属性</p>
<p>利用DOM修改元素的class属性（比如新增一个class或者删除一个class），使得利用外部CSS文件中的设置的样式改变元素的样式，而不是用DOM直接操作style属性修改样式。</p>
<p>例如要给要给elem元素设置class属性为intro，方法如下：</p>
<p><strong>a.</strong>利用setAttribute()方法, <code>elem.setAttribute(&quot;class&quot;,&quot;intro&quot;)</code></p>
<p><strong>b.</strong>通过更新className属性。className属性是一个可读可写的属性，凡是元素节点都有这个属性。可以用className属性获取一个元素的class属性，<code>element.className</code>。</p>
<p>用className属性和赋值操作符设置一个元素的class属性：<code>element.className = value</code></p>
<p>该方法的<strong>不足</strong>，通过className属性设置某个元素的class属性时将替换该元素原有的属性（而不是追加）。</p>
<p><strong>在需要给一个元素追加新的class时，可以按照以下思路：</strong></p>
<p>检查className属性的是否为null；</p>
<p>如果是，把新的class设置值直接赋值给className属性；</p>
<p>若不是，把一个空格和新的class设置值追加到className属性上去。</p>
<p>把上述步骤封装为一个函数addClass,该函数有两个参数，第一个为需要添加的新class的元素，第二个是新的class设置值。</p>
<pre><code>function addClass(element, value){
    if(!element.className){
        element.className = value;
    }else{
        newClassName = element.className;
        newClassName+= &quot; &quot;;
        newClassName+=value;
        element.className = newClassName;
    }
}
</code></pre><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><pre><code>&lt;!DOCTTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;事件简介&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;section&gt;
        &lt;button id=&quot;button&quot;&gt;点击切换背景颜色&lt;/button&gt;
    &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>针对上述代码，当点击了button后事件反应机制有两种(这两种是上古时代的做法 。 。)</p>
<p>第一种是点击button后，button将事件传递到section，再传递到body，再传递到html，再传递到document。该种方式即为事件冒泡机制。<br>如下图所示：</p>
<p><img src="/images/next-js2/2.png" alt="2"></p>
<p>第二种是点击button后，从document开始一层层捕获，即为事件捕获机制。如下图所示。</p>
<p><img src="/images/next-js2/3.png" alt="3"></p>
<p>目前<strong>标准的DOM事件流</strong>做法分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<p>事件捕获阶段的结束阶段为目标元素的父元素，然后是处于目标阶段，接下来是事件冒泡阶段。在实际开发过程中，由于浏览器兼容问题，事件捕获过程基本不用，会频繁使用目标和事件冒泡。流程如下所示。</p>
<p><img src="/images/next-js2/4.png" alt="4"></p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p><strong>添加</strong>事件处理程序：</p>
<pre><code>element.addEventListener(type, handle, false)//type表示事件类型，handle为事件处理函数，false表示采用冒泡机制
</code></pre><p><strong>删除</strong>事件处理程序：</p>
<pre><code>element.removeEventListener(type, handle)
</code></pre><p>例如：</p>
<pre><code>h1.addEventListener(&apos;click&apos;, function(){
    console.log(this);//this指向绑定事件处理函数的对象，即h1元素
}, false);
</code></pre><p><strong>事件对象</strong></p>
<p>事件对象包含着所有与事件相关的信息。</p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   //event即为事件处理对象，包括了触发点击事件时鼠标的位置等等信息
    console.log(&apos;event&apos;, event);  //将event对象打印出来并查看event对象包含哪些信息
}
h1.addEventListener(&apos;click&apos;, handle, false);
</code></pre><p><strong>事件冒泡</strong></p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   
    console.log(&apos;event&apos;, event);  
}
document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上
</code></pre><p>虽然点击事件绑定在body上，但此时点击h1元素，仍会触发事件打印event对象。此为事件冒泡。</p>
<p>流程：当点击目标元素h1，先找h1上有没有点击事件，有则触发，没有则按照冒泡机制一层层往上找，看有没有点击事件，直到冒泡到document。</p>
<p>阻止事件冒泡：</p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   
    console.log(&apos;event&apos;, event);  
}
document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上
h1.addEventListener(&apos;click&apos; function(event) {
event.stopPropagation();//阻止事件冒泡，当点击h1元素时，不会触发点击事件
}, false);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS调用DOM接口修改样式。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS笔记(一)--from next十天训练营</title>
    <link href="http://yoursite.com/2017/10/20/next-js/"/>
    <id>http://yoursite.com/2017/10/20/next-js/</id>
    <published>2017-10-20T01:21:29.000Z</published>
    <updated>2017-10-20T12:27:04.046Z</updated>
    
    <content type="html"><![CDATA[<p>NEXT十天训练营有关JS学习的笔记。<br><a id="more"></a></p>
<h2 id="认识JavaScript"><a href="#认识JavaScript" class="headerlink" title="认识JavaScript"></a>认识JavaScript</h2><p>JS是目前主流浏览器唯一支持的脚本语言，由以下三部分组成：</p>
<p>（1）ECMAScript:语言基础（核心）。</p>
<p>ECMA-262标准规定了ECMAScript这门语言的组成部分，例如语法、类型、语句、关键字、保留字、操作符、对象。</p>
<p>Web浏览器只是ECMAScript实现可能的宿主环境之一，其他宿主环境还包括Node(一种服务端JavaScript平台)和Adobe Flash。</p>
<p>（2）DOM（Document Object Model,文档对象模型）</p>
<p>通过DOM可以操作HTML元素，包括删除、添加、替换、修改节点等。DOM将整个HTML文档映射为一个多层节点结构，即DOM树。</p>
<p>（3）BOM（Browser Object Model,浏览器对象模型）</p>
<p>通过BOM获取一些浏览器的信息，以及控制浏览器的一些行为。</p>
<h2 id="引入JavaScript"><a href="#引入JavaScript" class="headerlink" title="引入JavaScript"></a>引入JavaScript</h2><p>有三种方式可以在HTML文档里引入JavaScript。</p>
<p>（1）行内方式。即直接在HTML元素的属性上应用js代码。</p>
<p>例如以下代码中button元素的onclick属性，点击button就会弹出消息框并显示“hello”。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot; onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点击弹出消息框&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>但这种方式不建议使用。一是因为这种方式针对一些用户的事件触发js执行，局限性较大。二是html文档中掺杂js代码会显得文档很乱，背离了结构应与样式、行为相分离的原则。</p>
<p>（2）内嵌方式。即通过一对<script></script>标签在html文档中插入js代码。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot; &gt;点击弹出消息框&lt;/button&gt;
    &lt;sript&gt;
        var helloBtn = documnet.getElementById(&quot;helloBtn&quot;);
        helloBtn.onclick = function() {
            alert(&quot;hello&quot;);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>此种方式也有缺点。例如在不同页面使用上述<script></script>标签之间这段js代码时，即在不同页面使用同一段js代码会有冗余。根据场景判断是否使用该方式。</p>
<p>（3）外链方式。即将js代码从html文档中提取出来单独形成一个.js文件，并在html文档中引入这个.js文件。</p>
<p>例如将方法（2）中<script></script>标签之间这段js代码提取出来，保存在一个hello.js文件中，并在html文件中引入。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot;&gt;点击弹出消息框&lt;/button&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>根据场景判断是否使用该方式。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>（1）语法:</p>
<pre><code>var 变量名
</code></pre><p>变量名区分大小写，首字母必须是字母、下划线或者$，非关键字和保留字。<br>例如，<code>var name = &quot;bottle&quot;;</code></p>
<p>（2）全局变量和局部变量：</p>
<p>使用var定义的变量可能是全局变量也可能是局部变量，取决于是否在一个function中。如在function中使用var定义一个变量message，此变量即为一个局部变量。局部变量在function外面访问不到。若在function内不使用var定义变量message，则在函数外可以访问到该变量。</p>
<p>使用var定义</p>
<pre><code>function test() {
    var message = &quot;hi&quot;;//定义一个局部变量
}
test();
alert(message);//错误，找不到变量message
</code></pre><p>不使用var定义</p>
<pre><code>function test() {
    message = &quot;hi&quot;;//定义一个全局变量
}
test();
alert(message);//hi
</code></pre><p>使用控制台console来调试js代码。alert()弹出一个提示框。console.log()打印。</p>
<p>利用sources里面的snippets来观察变量。如下所示。</p>
<p><img src="/images/next-js/1.png" alt="1"></p>
<p>局部变量测试结果如下所示。</p>
<p><img src="/images/next-js/2.png" alt="2"></p>
<p><img src="/images/next-js/3.png" alt="3"></p>
<p>全局变量测试结果如下所示。</p>
<p><img src="/images/next-js/4.png" alt="4"></p>
<p><img src="/images/next-js/5.png" alt="5"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1、基本数据类型</p>
<p>（1）字符串类型String</p>
<p>（2）数字类型Number</p>
<p>（3）布尔类型Boolean ,取值true或false</p>
<p>（4）Null</p>
<p>（5）Undefined</p>
<p>2、复杂数据类型/引用数据类型 Object</p>
<p><strong>怎样判断数据类型</strong></p>
<p>在浏览器控制台可使用type of 操作符来判断以下数据类型。</p>
<pre><code>typeof 1//&quot;number&quot;
typeof &apos;a&apos;//&quot;string&quot;
typeof true//&quot;boolean&quot;
typeof undefined//&quot;undefined&quot;
typeof null//&quot;object&quot; (这个比较特殊)
typeof {}//&quot;object&quot;
typeof function(){};//&quot;function&quot;
</code></pre><p>判断数据类型的几个例子如下。</p>
<p><img src="/images/next-js/6.png" alt="6"></p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p>1、创建对象</p>
<p>（1）使用对象字面量{}创建杯子对象。（推荐，简洁明了）</p>
<pre><code>var bottle = {
    name: &quot;bottle&quot;, //key: value
    price: 49, 
    isKeepWarm: true 
}
</code></pre><p>对象的每一个属性都可以用对应的键值对(key: value)来描述，其中key为任一合法字符，value为任意数据类型。如果属性名包含多个中间含空格的字符，要用引号包含起来。</p>
<p>（2）使用Object构造函数创建杯子对象。</p>
<pre><code>var bottle = new Object();
bottle.name = &quot;bottle&quot;;
bottle.price = 49;
bottle.isKeepWarm = true;
</code></pre><p>2、对象属性读操作</p>
<p>（1）使用点操作符 <code>console.log(bottle.name);//&quot;bottle&quot;</code>（推荐）</p>
<p>（2）使用中括号操作符 <code>console.log(bottle[&quot;name&quot;]);//&quot;bottle&quot;</code>（如果对象属性名即key包含空格时，必须使用中括号操作符）</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1、函数的定义</p>
<p>（1）函数声明</p>
<pre><code>function 函数名（参数1，参数2，...）{
    函数体
    return ;
}
</code></pre><p>函数声明的特点，在相同作用域下，不管在何处声明都可以调用的到。即使声明在调用之后。</p>
<p>（2）函数表达式</p>
<pre><code>var 变量 = function(参数1，参数2，...){
    函数体
    return ;
}
</code></pre><p>函数表达式的调用必须在函数表达式声明之后。这是区别于函数声明的地方。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="/images/next-js/7.png" alt="7"></p>
<p>如上图所示，bottles是在函数之外声明的，是全局作用域的一个变量，所以在函数内部可以访问到bottles。而函数内部（函数作用域）声明的num为局部变量，只可以在函数内部被访问到，在函数外部无法获取。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>（1）if语句</p>
<pre><code>if(条件) {
    执行语句1;
}
else{
    执行语句2;
}
</code></pre><p>（2）switch语句</p>
<pre><code>swith(n){
    case 0: 执行语句1；
    case 1: 执行语句2;
    ...

}
</code></pre><h2 id="字符串的有关操作"><a href="#字符串的有关操作" class="headerlink" title="字符串的有关操作"></a>字符串的有关操作</h2><h3 id="分割字符串-split"><a href="#分割字符串-split" class="headerlink" title="分割字符串 split"></a>分割字符串 split</h3><p>split()方法可以把字符串分割为字符串数组。</p>
<pre><code>&quot;2:3:4:5&quot;.split(&quot;:&quot;)    // 将返回 [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]

&quot;|a|b|c&quot;.split(&quot;|&quot;)    // 将返回 [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h3 id="截取字符串-substring"><a href="#截取字符串-substring" class="headerlink" title="截取字符串 substring"></a>截取字符串 substring</h3><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。语法：<code>str.substring(indexStart, [indexEnd])</code></p>
<pre><code>var str = &apos;Hello World!&apos;;
console.log(str.substring(3)); // 将返回 lo world!
</code></pre><h3 id="字符串转换大写-toUpperCase"><a href="#字符串转换大写-toUpperCase" class="headerlink" title="字符串转换大写 toUpperCase()"></a>字符串转换大写 toUpperCase()</h3><p>toUpperCase() 方法用于把字符串转换为大写。</p>
<pre><code>var str = &apos;Hello World!&apos;;
console.log(str.toUpperCase()); // 将返回 HELLO WORLD!
</code></pre><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>完善函数 convertToCamelCase 的功能。函数 convertToCamelCase 会转换传入的字符串参数 string 为驼峰格式，并返回转换后的字符串。具体要求如下：</p>
<ul>
<li><p>参数 string 是以中划线（-）连接单词的字符串，需将第二个起的非空单词首字母转为大写，如 -webkit-border-radius 转换后的结果为 webkitBorderRadius。</p>
</li>
<li><p>返回转换后的字符串</p>
</li>
</ul>
<p>解决方法：</p>
<pre><code>function convertToCamelCase(str){
    var strSplit = str.split(&quot;-&quot;);//转换为字符串数组
    if(strSplit[0] === &quot;&quot;){ //如果第一个字符串为空的话，左移删掉，否则的话不变
        strSplit.shift();
    }
    for(var i = 1; i &lt; strSplit.length; i++){
            var letter = strSplit[i].charAt(0);//取得字符串数组中每个字符串的首字母
            //使用replace方法将每个字符串的首写字母大写
            strSplit[i] = strSplit[i].replace(letter, function replace(letter){
                return letter.toUpperCase();
            });

    }  
    return strSplit.join(&quot;&quot;);//join方法串接起字符串
}
convertToCamelCase(&quot;-ni-hao-a&quot;);
</code></pre><p>还可以使用<strong>正则表达式</strong>的方法。</p>
<pre><code>function convertToCamelCase(str) {
  return str.replace(/\-[a-z]/g , function(a, b){
      return b == 0 ? a.replace(&apos;-&apos;,&apos;&apos;) : a.replace(&apos;-&apos;,&apos;&apos;).toUpperCase();
  });
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NEXT十天训练营有关JS学习的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>PS切图笔记from慕课网</title>
    <link href="http://yoursite.com/2017/10/18/PS%E5%88%87%E5%9B%BE%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/10/18/PS切图笔记/</id>
    <published>2017-10-18T08:19:00.000Z</published>
    <updated>2017-10-19T14:31:00.721Z</updated>
    
    <content type="html"><![CDATA[<p>在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接<a href="http://www.imooc.com/learn/506" target="_blank" rel="external">前端工程师必备的PS技能——切图篇</a>。<br><a id="more"></a></p>
<h2 id="Photoshop界面设置"><a href="#Photoshop界面设置" class="headerlink" title="Photoshop界面设置"></a>Photoshop界面设置</h2><p>使用的photoshop版本为photoshop cc 2015。</p>
<h3 id="新建设置"><a href="#新建设置" class="headerlink" title="新建设置"></a>新建设置</h3><p>文件–&gt;新建–&gt;文档类型（自定）–&gt;宽度一般固定（1920像素）–&gt;高度一般不定(此时设为2000像素)–&gt;分辨率72像素/英寸–&gt;背景内容(透明)。</p>
<p>再点击“确定”即可生成一张新的界面。此时还可点击“存储预设为”将本次自定义设置预设，留作以后使用该设置参数时使用。参数设置即生成图片分别为下列两图所示。</p>
<p><img src="/images/PS切图笔记/1.png" alt="1"></p>
<p><img src="/images/PS切图笔记/2.png" alt="2"></p>
<p>不知道是不是我下载的破解版的原因，键盘在中文输入法状态下时，左侧导航栏的工具图标不显示提示名称，切换到英文输入状态时就会显示。。</p>
<h3 id="移动工具设置"><a href="#移动工具设置" class="headerlink" title="移动工具设置"></a>移动工具设置</h3><p>第一个工具图标为：移动工具，快捷键V。 如下图所示。</p>
<p><img src="/images/PS切图笔记/3.png" alt="3"></p>
<p>选择移动工具–不勾选自动选择–选择图层–按住ctrl+鼠标左键可以自由选择想要的图层，会在右侧图层显示信息栏为你筛选出当前鼠标左键选择的图层。如下图所示。</p>
<p><img src="/images/PS切图笔记/4.png" alt="4"></p>
<h3 id="视图设置"><a href="#视图设置" class="headerlink" title="视图设置"></a>视图设置</h3><p>勾选两个功能：（1）视图–&gt;显示–&gt;智能参考线  （2）视图–&gt;标尺<br>可以在窗口–&gt;库，颜色，路径，通道， 把这几个功能关掉。</p>
<p>窗口–&gt;历史记录，信息，图层，三个功能模块打开。</p>
<p>最后在右侧区域一共用到四个功能，即信息，字符，图层，历史纪录。见下图。</p>
<p><img src="/images/PS切图笔记/5.png" alt="5"></p>
<p>信息面板设置如下：</p>
<p><img src="/images/PS切图笔记/6.png" alt="6"></p>
<p>在编辑–&gt;首选项–&gt;单位与标尺，将单位改为像素。</p>
<h2 id="Photoshop基本操作"><a href="#Photoshop基本操作" class="headerlink" title="Photoshop基本操作"></a>Photoshop基本操作</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接&lt;a href=&quot;http://www.imooc.com/learn/506&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端工程师必备的PS技能——切图篇&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="PS" scheme="http://yoursite.com/categories/PS/"/>
    
    
      <category term="PS" scheme="http://yoursite.com/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>有默认margin，padding值的html标签</title>
    <link href="http://yoursite.com/2017/10/18/%E9%BB%98%E8%AE%A4margin%E5%80%BC%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2017/10/18/默认margin值元素/</id>
    <published>2017-10-18T05:00:44.000Z</published>
    <updated>2017-10-18T05:20:44.081Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。<br><a id="more"></a></p>
<h2 id="h1-h6标签"><a href="#h1-h6标签" class="headerlink" title="h1~h6标签"></a>h1~h6标签</h2><p>有默认margin（top,bottom且相同）值，没有默认padding值。</p>
<pre><code>在chrome中：16,15,14,16,17,19;

在firefox中：16,15,14,16,17,20;

在safari中：16,15,14,16,17,19;

在opera中：16,15,14,14,17,21;

在maxthon中：16,14,14,15,16,18;

在IE6.0中：都是19；

在IE7.0中：都是19；

在IE8.0中：16,15,14,16,17,19;
</code></pre><h2 id="dl标签"><a href="#dl标签" class="headerlink" title="dl标签"></a>dl标签</h2><p>有默认margin（top,bottom且相同）值，没有默认padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><p>dd标签有默认margin-left：40px;(在所有上述浏览器中)。</p>
<h2 id="ol-ul标签"><a href="#ol-ul标签" class="headerlink" title="ol,ul标签"></a>ol,ul标签</h2><p>有默认margin-（top,bottom且相同）值，有默认padding-left值</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><p>默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。</p>
<h2 id="th-td标签"><a href="#th-td标签" class="headerlink" title="th,td标签"></a>th,td标签</h2><p>th,td标签没有默认的margin值，有默认的padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon中：padding：1px;

在IE8.0中：padding：0px 1px 1px;

在IE7.0中：padding：0px 1px；
</code></pre><p>相同内容th的宽度要比td宽，因为th字体有加粗效果。</p>
<p><strong>注意 ：table标签没有默认的margin,padding值。</strong></p>
<h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><p>form标签在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中没有默认的margin,padding值，但在IE6.0,7.0中有默认的margin：19px 0px;</p>
<h2 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h2><p>p标签有默认margin(top,bottom)值,没有默认padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><h2 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h2><p>textarea标签在上述所有浏览器中：margin:2px；padding:2px；</p>
<h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>select标签在Chrome,Safari,Maxthon中有默认的margin：2px；在Opera,Firefox,IE6.0,7.0,8.0没有默认的margin值。</p>
<h2 id="option标签"><a href="#option标签" class="headerlink" title="option标签"></a>option标签</h2><p>option标签只有在firefox中有默认的padding-left：3px；</p>
<h2 id="CSS-reset"><a href="#CSS-reset" class="headerlink" title="CSS reset"></a>CSS reset</h2><pre><code>/*CSS style init*/
body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,option,textarea,form,th,td{margin: 0; padding: 0;}
body{font:14px/1.5 &quot;宋体&quot;;}
img{border:none;}
li{list-style:none;}
input,select,textarea{outline:none;border:none;background:none;}
textarea{resize:none;}
a{text-decoration:none;}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS清除浮动的几种方法</title>
    <link href="http://yoursite.com/2017/10/17/clearfix/"/>
    <id>http://yoursite.com/2017/10/17/clearfix/</id>
    <published>2017-10-17T08:09:35.000Z</published>
    <updated>2017-10-17T11:48:10.266Z</updated>
    
    <content type="html"><![CDATA[<p>几种定位方式，以及CSS清除浮动的几种方法。<br><a id="more"></a></p>
<h1 id="几种定位方式"><a href="#几种定位方式" class="headerlink" title="几种定位方式"></a>几种定位方式</h1><h2 id="普通流定位-static"><a href="#普通流定位-static" class="headerlink" title="普通流定位 static"></a>普通流定位 static</h2><p>普通流定位即文档流定位，是页面元素的默认定位方式。按照元素在文档流中的出现顺序以默认形式呈现元素。</p>
<pre><code>页面中的块级元素：按照从上到下的方式逐个排列 。
页面中的行内元素：按照从左到右的方式逐个排列 。
</code></pre><p>此时考虑如何让多个块级元素显示在一行，就引出了浮动的概念。</p>
<h2 id="浮动定位-float"><a href="#浮动定位-float" class="headerlink" title="浮动定位 float"></a>浮动定位 float</h2><p>float属性取值为 left/right。这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕。</p>
<h2 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h2><p>元素会相对于它原来的位置偏移某个距离。<strong>使元素偏离原来位置后，元素原本的空间依然会被保留</strong>。</p>
<pre><code>语法
属性：position
取值：relative
再配合 偏移属性top/right/bottom/left实现位置改变
</code></pre><h2 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h2><p>若元素被设置为绝对定位，具备以下几个特征：</p>
<pre><code>1、脱离文档流-不占据页面空间
2、通过偏移属性固定元素位置
3、相对于 最近的已定位的祖先元素实现位置固定
4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定 
语法
属性：position
取值：absolute
再配合 偏移属性(top/right/bottom/left)实现位置的固定
</code></pre><h2 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h2><p>将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动。</p>
<pre><code>语法
属性：position
取值：fixed
配合着 偏移属性(top/right/bottom/left)实现位置的固定
</code></pre><h1 id="浮动的效果"><a href="#浮动的效果" class="headerlink" title="浮动的效果"></a>浮动的效果</h1><pre><code>1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位
2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动)
3、浮动元素依然位于父元素之内
4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 
注意
1、一行内，显示不下所有的已浮动元素时，最后一个将换行
2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定)
3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大（块级元素：允许修改尺寸；行内元素：不允许修改尺寸 ） 
4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素
</code></pre><p>浮动的影响：由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）。</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>直接设置父元素的高度。<br>优势：极其简单；<br>弊端：必须要知道父元素高度是多少</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>在父元素中，追加空子元素，并设置其clear属性为both。clear是css中专用于清除浮动的属性。<br>作用：清除当前元素前面的元素浮动所带来的影响</p>
<pre><code>取值：
1、none
默认值，不做任何清除浮动的操作
2、left
清除前面元素左浮动带来的影响
3、right
清除前面元素右浮动带来的影响
4、both
清除前面元素所有浮动带来的影响
</code></pre><p>优势：代码量少 容易掌握 简单易懂<br>弊端：会添加许多无意义的空标签，有违结构与表现的分离，不便于后期的维护</p>
<h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>设置父元素浮动。</p>
<p>优势：简单，代码量少，没有结构和语义化问题；<br>弊端：对后续元素会有影响 </p>
<h2 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h2><p>为父元素设置overflow属性。</p>
<pre><code>取值：hidden 或 auto
</code></pre><p>优势：简单，代码量少<br>弊端：如果有内容要溢出显示(弹出菜单)，也会被一同隐藏</p>
<h2 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h2><p>父元素设置display:table.</p>
<p>优势：不影响结构与表现的分离，语义化正确，代码量少；<br>弊端：盒模型属性已经改变，会造成其他问题</p>
<h2 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h2><p>使用内容生成的方式清除浮动。</p>
<pre><code>.clearfix:after {
    content:&quot;&quot;;
    display:block;
    clear:both;
}
</code></pre><p>:after 选择器向选定的元素之后插入内容 </p>
<pre><code>content:&quot;&quot;; 生成内容为空
display: block; 生成的元素以块级元素显示,
clear:both; 清除前面元素浮动带来的影响
</code></pre><p>相对于空标签闭合浮动的方法，<br>优势：不破坏文档结构，没有副作用；<br>弊端：代码量多</p>
<h2 id="方法7"><a href="#方法7" class="headerlink" title="方法7"></a>方法7</h2><pre><code>.cf:before,.cf:after {
   content:&quot;&quot;;
   display:table;
}
.cf:after { clear:both; }
</code></pre><p>优势：不破坏文档结构，没有副作用；<br>弊端： 代码量多 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种定位方式，以及CSS清除浮动的几种方法。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>NTFS文件系统介绍</title>
    <link href="http://yoursite.com/2017/10/16/NTFS-file-system/"/>
    <id>http://yoursite.com/2017/10/16/NTFS-file-system/</id>
    <published>2017-10-16T02:49:05.000Z</published>
    <updated>2017-10-16T05:50:34.771Z</updated>
    
    <content type="html"><![CDATA[<p>【转】Windows文件系统FAT16、FAT32、NTFS的简单介绍。<br><a id="more"></a></p>
<h1 id="什么是NTFS文件系统"><a href="#什么是NTFS文件系统" class="headerlink" title="什么是NTFS文件系统"></a>什么是NTFS文件系统</h1><p>介绍NTFS之前，先来介绍一下FAT。</p>
<p>FAT(File Allocation Table)表示“文件分配表”，它的意义在于对硬盘分区的管理。FAT16、FAT32、NTFS是Windows系统最常见的三种文件系统。   </p>
<p>FAT16：以前用的DOS、Windows95都使用FAT16文件系统，后来的Windows98/2000/XP等系统均支持FAT16文件系统。它最大可以管理大到2GB的分区，但每个分区最多只能有65525个簇（簇是磁盘空间的配置单位，即文件的存取的最小单位，一个簇包含若干扇区，而扇区是磁盘驱动器向磁盘读取和写入数据的最小单位）。随着硬盘或分区容量的增大，每个簇所占的空间将越来越大，从而导致硬盘空间的浪费。 更多关于硬盘的基本知识参见博客<a href="http://blog.csdn.net/fyfcauc/article/details/39576065" target="_blank" rel="external">硬盘基本知识</a>。</p>
<p>FAT32：随着大容量硬盘的出现，从Windows98开始，FAT32开始流行。它是FAT16的增强版本，可以支持大到2TB（2048GB)的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。</p>
<p>NTFS：微软Windows NT内核的系列操作系统支持的、一个特别为网络和磁盘配额、文件加密等管理安全特性设计的磁盘格式。从1993年开始，随着以NT为内核的Windows 2000/XP的普及，很多个人用户开始用到了NTFS。NTFS也是以簇为单位来存储数据文件，但NTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。NTFS支持文件加密管理功能，可为用户提供更高层次的安全保证。</p>
<p>在NTFS文件系统中，文件存取是按簇进行分配，一个簇必需是物理扇区的整数倍，而且总是2的整数次方倍。NTFS文件系统并不去关心什么是扇区，也不会去关心扇区到底有多大（如是不是512字节）。簇大小在使用格式化程序时则会由格式化程序根据卷大小自动的进行分配。 </p>
<p>文件通过主文件表（MFT）来确定其在磁盘上的存储位置。主文件表是一个对应的数据库，由一系列的文件记录组成。 卷中每一个文件都有一个文件记录（对于大型文件还可能有多个记录与之相对应）。主文件表本身也有它自己的文件记录。</p>
<p>NTFS卷上的每个文件都有一个64 bit称为文件引用号（File Reference Number，也称文件索引号）的唯一标识。文件引用号由两部分组成：一是文件号，二是文件顺序号。文件号为48位，对应于该文件在MFT中的位置。文件顺序号随着每次文件记录的重用而增加，这是为NTFS进行内部一致性检查而设计的。</p>
<p>NTFS使用逻辑簇号（Logical Cluster Number，LCN）和虚拟簇号（Virtual Cluster Number，VCN）来进行簇的定位。LCN是对整个卷中所有的簇从头到尾所进行的简单编号。卷因子乘以LCN，NTFS就能够得到卷上的物理字节偏移量，从而得到物理磁盘地址。VCN则是对属于特定文件的簇从头到尾进行编号，以便于引用文件中的数据。VCN可以映射成LCN，而不必要求在物理上连续。</p>
<p>NTFS的目录只是一个简单的文件名和文件引用号的索引，如果目录的属性列表小于一个记录的长度，那么该目录的所有信息都存储在主文件表的记录中，对于大于记录的目录则使用B+树进行管理。</p>
<p>主文件表中的基本文件记录中有一个指针指向一个存储非常驻索引缓冲–包括该目录下所有下一级子目录和文件的外部簇，而B+树结构便于大型目录中文件和子目录的快速查找。</p>
<p>在NTFS中，所有存储在卷上的数据都包含在文件中，包括用来定位和获取文件的数据结构，以及引导程序和记录这个卷的记录（NTFS元数据）的位图，这体现了NTFS的原则：磁盘上的任何事物都为文件。在文件中存储一切使得文件系统很容易定位和维护数据，而在NTFS中，卷中所有存放的数据均在一个叫做MFT的文件记录数组中，称为主文件表(Master File Table)，MFT是由高级格式化产生的。而MFT则由文件记录(File Record)数组构成。File Record的大小一般是固定的，不管簇的大小是多少，均为1KB，这个概念相当于Linux中的inode（i节点）。File Record在MFT文件记录数组中物理上是连续的，且从0开始编号。</p>
<p>MFT仅供系统本身组织、架构文件系统使用，这在NTFS中称为元数据(metadata)。其中最基本的前16个记录是操作系统使用的非常重要的元数据文件。这些NTFS主文件表的重要的元数据文件都是以$(美元符号)开始的名字，所以是隐藏文件，在Windows 2000中不能使用dir命令(甚至加上/ah参数)像普通文件一样列出这些元数据文件。实际上File System Driver(ntfs.sys)维护了一个系统变量NTFS Protect System Files用于隐藏这些元数据。但是微软公司也提供了一个OEM TOOL,叫做NFI.EXE,用此工具可以转储NTFS主文件表的重要的元数据文件（元数据：是存储在卷上支持文件系统格式管理的数据。它不能被应用程序来访问，它只能为系统提供服务）。这些元数据文件文件是系统驱动程序装配卷所必需的，WINDOWS 2000给每个分区赋予一个盘符并不表示该分区包含有WINDOWS 2000可以识别的文件系统格式，如果一旦主文件表损坏，那么该分区在WINDOWS 2000下是无法读取的。为了使该分区能够在WINDOWS 2000下能被识别，也就是必须首先建立WINDOWS 2000可以识别的文件系统格式即主文件表，这可通过高级格式化该分区来完成。众所周知，Windows以簇号来定位文件在磁盘存储的位置，在FAT格式的文件系统中有关簇号的指针是包含在FAT表中的，而在NTFS中有关簇号的指针是包含在$MFT及$MFTMirr文件中的。 </p>
<h2 id="NTFS元文件"><a href="#NTFS元文件" class="headerlink" title="NTFS元文件"></a>NTFS元文件</h2><p>MFT中的第1个记录就是MFT自身。由于MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（＄MftMirr），也就是MFT中的第2个记录。 </p>
<p>第3个记录是日志文件（＄LogFile）。该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，例如复制，从而在系统失败时能够恢复NTFS卷。 </p>
<p>第4个记录是卷文件（＄Volume），它包含了卷名、被格式化的卷的NTFS版本和一个标明该磁盘是否损坏的标志位（NTFS系统以此决定是否需要调用Chkdsk程序来进行修复）。 </p>
<p>第5个记录是属性定义表（＄AttrDef，attribute definition table），其中存放了卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。 </p>
<p>第6个记录是根目录（\），其中保存了存放于该卷根目录下所有文件和目录的索引。在访问了一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接进行对该文件的访问。 </p>
<p>第7个记录是位图文件（＄Bitmap）。NTFS卷的分配状态都存放在位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲的还是已被分配了的，由于该文件可以很容易的被扩大，所以NTFS的卷可以很方便的动态的扩大，而FAT格式的文件系统由于涉及到FAT表的变化，所以不能随意的对分区大小进行调整。 </p>
<p>第8个记录是引导文件（＄Boot），它是另一个重要的系统文件，存放着Windows 2000/XP的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统。该文件是在Format程序运行时创建的，这正体现了NTFS把磁盘上的所有事物都看成是文件的原则。这也意味着虽然该文件享受NTFS系统的各种安全保护，但还是可以通过普通的文件I/O操作来修改。 </p>
<p>第9个记录是坏簇文件（＄BadClus），它记录了磁盘上该卷中所有的损坏的簇号，防止系统对其进行分配使用。 </p>
<p>第10个记录是安全文件（＄Secure），它存储了整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为了节省空间，NTFS将具有相同描述符的文件和目录存放在一个公共文件中。 </p>
<p>第11个记录为大写文件（＄UpCase，upper case file），该文件包含一个大小写字符转换表。 </p>
<p>第12个记录是扩展元数据目录（＄Extended metadata directory）。 </p>
<p>第13个记录是重解析点文件（$Extend\$Reparse）。 </p>
<p>第14个记录是变更日志文件（$Extend\$UsnJrnl）。</p>
<p>第15个记录是配额管理文件（$Extend\$Quota）。 </p>
<p>第16个记录是对象ID文件（$Extend\$ObjId）。 </p>
<p>第17～23记录是是系统保留记录，用于将来扩展。 </p>
<p>MFT的前16个元数据文件是如此重要，为了防止数据的丢失，NTFS系统在该卷文件存储部分的正中央对它们进行了备份。</p>
<p>NTFS把磁盘分成了两大部分，其中大约12%分配给了MFT，以满足其不断增长的文件数量。为了保持MFT元文件的连续性，MFT对这12%的空间享有独占权。余下的88%的空间被分配用来存储文件。而剩余磁盘空间则包含了所有的物理剩余空间–MFT剩余空间也包含在里面。MFT空间的使用机制可以这样来描述：当文件耗尽了存储空间时，Windows操作系统会简单地减少MFT空间，并把它分配给文件存储。当有剩余空间时，这些空间又会重新被划分给MFT。虽然系统尽力保持MFT空间的专用性，但是有时不得不做出牺牲。尽管MFT碎片有时是无法忍受的，却无法阻止它的发生。 </p>
<p>那么NTFS到底是怎么通过MFT来访问卷的呢？首先，当NTFS访问某个卷时，它必须”装载”该卷：NTFS会查看引导文件（在图中的＄Boot元数据文件定义的文件），找到MFT的物理磁盘地址。然后它就从文件记录的数据属性中获得VCN到LCN的映射信息，并存储在内存中。这个映射信息定位了MFT的运行（run或extent）在磁盘上的位置。接着，NTFS再打开几个元数据文件的MFT记录，并打开这些文件。如有必要NTFS开始执行它的文件系统恢复操作。在NTFS打开了剩余的元数据文件后，用户就可以开始访问该卷了。</p>
<h1 id="文件和目录记录"><a href="#文件和目录记录" class="headerlink" title="文件和目录记录"></a>文件和目录记录</h1><p>NTFS将文件作为属性/属性值的集合来处理，这一点与其他文件系统不一样。文件数据就是未命名属性的值，其他文件属性包括文件名、文件拥有者、文件时间标记等。</p>
<p>每个属性由单个的流（stream）组成，即简单的字符队列。严格地说，NTFS并不对文件进行操作，而只是对属性流进行读写。NTFS提供对属性流的各种操作：创建、删除、读取（字节范围）以及写入（字节范围）。读写操作一般是针对文件的未命名属性的，对于已命名的属性则可以通过已命名的数据流句法来进行操作。</p>
<p>一个文件通常占用一个文件记录。然而，当一个文件具有很多项属性值或很零碎的时候，就可能需要占用一个以上的文件记录。这种情况下，第一个文件记录是其基本的文件记录，存储有该文件需要的其它文件记录的位置。<strong>小文件和文件夹（典型的如1500字节或更少）将全部存储在文件的MFT记录里</strong>。 <strong>文件夹记录</strong>包括索引信息，小文件夹记录完全存储在MFT结构内，然而大的文件夹则被组织成B+树结构，用一个指针指向一个外部簇，该簇用来存储那些MFT内存储不了的文件夹的属性。 </p>
<p><strong>NTFS卷上文件的常用属性</strong>列出如下（并不是所有文件都有所有这些属性）：</p>
<p>（1）常驻属性与非常驻属性</p>
<p>当一个文件很小时，其所有属性和属性值可存放在MFT的文件记录中。当属性值能直接存放在MFT中时，该属性就称为常驻属性（resident attribute）。有些属性总是常驻的，这样NTFS才可以确定其他非常驻属性。例如，标准信息属性和根索引就总是常驻属性。</p>
<p>每个属性都是以一个标准头开始的，在头中包含该属性的信息和NTFS通常用来管理属性的信息。该头总是常驻的，并记录着属性值是否常驻、对于常驻属性，头中还包含着属性值的偏侈量和属性值的长度。</p>
<p>如果属性值能直接存放在MFT中，那么NTFS对它的访问时间就将大大缩短。NTFS只需访问磁盘一次，就可立即获得数据；而不必像FAT文件系统那样，先在FAT表中查找文件，再读出连续分配的单元，最后找到文件的数据。<br>小文件或小目录的所有属性，均可以在MFT中常驻。小文件的未命名属性可以包括所有文件数据。</p>
<p>大文件或大目录的所有属性，就不可能都常驻在MFT中。如果一个属性（如文件数据属性）太大而不能存放在只有1KB的MFT文件记录中，那么NTFS将从MFT之外分配区域。这些区域通常称为一个运行（run）或一个盘区（extent），它们可用来存储属性值，如文件数据。如果以后属性值又增加，那么NTFS将会再分配一个运行，以便用来存储额外的数据。值存储在运行中而不是在MFT文件记录中的属性称为非常驻属性（nonresident attribute）。NTFS决定了一个属性是常驻还是非常驻的；而属性值的位置对访问它的进程而言是透明的。当一个属性为非常驻时，如大文件的数据，它的头部包含了NTFS需要在磁盘上定位该属性值的有关信息。 </p>
<p>在标准属性中，只有可以增长的属性才是非常驻的。对文件来说，可增长的属性有数据、属性列表等。标准信息和文件名属性总是常驻的。 </p>
<p>（2）MFT文件记录结构分析  </p>
<p>主文件表MFT的文件记录由记录头和属性列表组成，由”FF FF FF FF”结束，一般大小为1K，或一个簇大小（这样一般就更大），记录头包括以下一些域： </p>
<p><img src="/images/NTFS-file-system/1.png" alt="1"></p>
<p>每次记录被修改都将导致日志文件序列号$LogFile Sequence Number（LSN）发生变化。<br>序列号Sequence Number（SN）用于记录主文件表记录被重复使用的次数。<br>硬连接数Hard Link Count记录硬连接的数目，只出现在基本文件记录中。<br>文件记录的实际长度是文件记录在磁盘上实际占用的字节空间。<br>基本文件记录中的文件索引号，对于基本文件记录，其值为0，如果不为0，则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号，在基本文件记录中包含有扩展文件记录的信息，存储在”属性列表ATTRIBUTE_LIST”属性中。<br>属性列表是可变长度区，以”FF FF FF FF”结束，对于1K长度的MFT记录，属性列表的起始偏移为0x30。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【转】Windows文件系统FAT16、FAT32、NTFS的简单介绍。&lt;br&gt;
    
    </summary>
    
      <category term="文件系统" scheme="http://yoursite.com/categories/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="NTFS" scheme="http://yoursite.com/tags/NTFS/"/>
    
  </entry>
  
  <entry>
    <title>慕课网七夕动画学习总结+github pages展示</title>
    <link href="http://yoursite.com/2017/09/29/demo-qixi/"/>
    <id>http://yoursite.com/2017/09/29/demo-qixi/</id>
    <published>2017-09-29T12:31:33.000Z</published>
    <updated>2017-09-30T07:26:16.812Z</updated>
    
    <content type="html"><![CDATA[<p>这段时间照着慕课网上的一个动画案例-<a href="http://www.imooc.com/learn/453" target="_blank" rel="external">H5+JS+CSS3实现七夕言情</a>学习，<br><a id="more"></a><br>并将学习的各部分的代码进行整合，最后将代码托管到github上，并通过github pages展示这个动画demo。一些地方自己修改以后没有老师的效果好，但这是自己第一个敲出来的前端小demo，成就感满满，哈哈。。。</p>
<h1 id="关于动画案例"><a href="#关于动画案例" class="headerlink" title="关于动画案例"></a>关于动画案例</h1><p>里面用到一些jQuery和ajax相关的知识，由于自己学习js不久，很多深一点的概念理解不到位，比如一开始代码的封装和流程的编写，都是照葫芦画瓢，不是很理解，但是慢慢的看得多了，这个过程也就熟悉起来了。</p>
<p>页面布局部分比较容易理解，但是三个主题页面滚动起来最开始对自己还是有点难度。该案例很多部分都利用了CSS3的transform属性和animation属性。而且这个案例的思想是，把实现特定动作或者动能的代码封装起来，暴露一个接口出来，增强了安全性简化了编程过程。</p>
<p>具体的学习过程和用到的知识点，大家可以跟着<a href="http://www.imooc.com/learn/453" target="_blank" rel="external">H5+JS+CSS3实现七夕言情</a>学习，边看边学的效果比抱着书一直看的效果要好一些。但js高级教程的基础必须打牢，很多师兄师姐给的建议，也是网上一些大佬的建议。</p>
<p>关于画面自己做的一点小改动，button的样式做了修改，并增加了链接到github仓库的logo（shirly与猫）,嘤嘤嘤。如下，左下角和右下角辣么一点点。</p>
<p><img src="/images/demo-qixi/1.png" alt="1"></p>
<h1 id="关于将页面搭建在github-pages上"><a href="#关于将页面搭建在github-pages上" class="headerlink" title="关于将页面搭建在github pages上"></a>关于将页面搭建在github pages上</h1><p>关于动画制作的学习过程如果说困难和迷惑的话，那这最后一步展示在github pages上的过程，就应该是差点死在最后的1%上。在网上看了很多博客和教程，总会遇到很多小问题，无法显示自己在本地的效果。最后看到了这篇博客，<a href="http://www.cnblogs.com/lijiayi/p/githubpages.html" target="_blank" rel="external">【 js 工具 】如何在Github Pages搭建自己写的页面？</a>，这篇博客对于利用github pages搭建自己写的网页描述很详细，从在github上建仓库，到github pages的设置，再到利用git命令克隆github上的仓库到本地，最后push到远程master分支上。</p>
<p>更多关于github的使用可参考<a href="http://www.runoob.com/w3cnote/git-guide.html" target="_blank" rel="external">Github 简明教程</a>,其中讲解的git维护的本地仓库的工作流很清晰，对于我这个初步使用git的菜鸟十分友好。而且关于branch和更新与合并功能也讲的比较清楚。</p>
<p>本地仓库由git维护的“三棵树”组成。第一个是工作目录，使用<code>$ git status</code>可以查看，列出了当前目录下所有还未被git管理的文件，以及被git管理了且被修改过但还未添加（add）的文件，也即所有改动文件，用红色字体标出。如下所示，当我在本地仓库demo-qixi用<code>$ git status</code>命令查看后，可以看到红色文件均为未提交的。</p>
<p><img src="/images/demo-qixi/2.png" alt="2"></p>
<p>第二个是暂存区（Index），它类似一个缓存区，临时保存你的改动。通过<code>$ git add .</code>命令添加当前目录下的所有文件和子目录到暂存区。注意<code>.</code>表示当前目录下的所有文件和子目录。也可以指定文件添加到暂存区，使用<code>$ git add &lt;filename&gt;</code>。如下使用<code>$ git add .</code>添加文件到暂存区：</p>
<p><img src="/images/demo-qixi/3.png" alt="3"></p>
<p>此时我们再使用<code>$ git status</code>命令查看下工作目录，你会发现所有的文件都变绿了，这就表示这些文件已被添加到暂存区准备好被提交（commit）了。</p>
<p><img src="/images/demo-qixi/4.png" alt="4"></p>
<p>第三个是HEAD，它指向你最后一次提交的结果。使用<code>$ git commit -m &quot;代码提交说明信息&quot;</code>命令，将暂存区最后一次添加更改情况提交到HEAD。如下所示。</p>
<p><img src="/images/demo-qixi/5.png" alt="5"></p>
<p>上述“三棵树”的工作流程如下所示。</p>
<p><img src="/images/demo-qixi/6.png" alt="6"></p>
<p>此时改动虽然已经提交到了HEAD，但是还没到远端仓库。使用<code>$ git push</code>命令将这些改动提交到远端仓库的default master分支。也可以使用<code>$ git push origin master</code>命令，把改动提交到master分支。可以把master换成自己想要推送的任何分支。</p>
<h1 id="动画demo展示"><a href="#动画demo展示" class="headerlink" title="动画demo展示"></a>动画demo展示</h1><p>demo网页展示链接<a href="https://shirley5li.github.io/demo-qixi/index.html" target="_blank" rel="external">慕课七夕主题网页展示</a>。</p>
<p>该动画demo在github上的代码仓库<a href="https://github.com/shirley5li/demo-qixi" target="_blank" rel="external">demo-qixi</a>。</p>
<p>tips:在打开demo页面展示链接时，浏览器链接窗口出现提示“此页面上部分内容不安全，例如图像”，并且网页内容不能完整显示，我使用的firefox浏览器。如下所示，</p>
<p><img src="/images/demo-qixi/7.png" alt="7"></p>
<p>原因是我们用来展示demo的github pages站点是使用https协议的安全站点，而demo中的一些图片链接是使用的http协议，浏览器不会渲染混合内容（即来自安全站点的不安全数据）。如果我们浏览https网页，浏览器会拒绝加载不安全的内容（例如这里的demo-qixi中图片使用的http协议），浏览器将向用户发出“此页面上部分内容不安全”的警告。可以参考这篇讲web安全的文章，<a href="https://paper.seebug.org/112/" target="_blank" rel="external">绕过混合内容警告 - 在安全的页面加载不安全的内容</a>。</p>
<p>解决办法：我用的火狐浏览器，点浏览器链接窗口左侧的黄色警告三角形-&gt;点右侧箭头显示连接细节-&gt;点暂时解除保护，就可以看到完整的动画demo了。</p>
<p>然后点击 Go!开始动画啦。。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间照着慕课网上的一个动画案例-&lt;a href=&quot;http://www.imooc.com/learn/453&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;H5+JS+CSS3实现七夕言情&lt;/a&gt;学习，&lt;br&gt;
    
    </summary>
    
      <category term="github" scheme="http://yoursite.com/categories/github/"/>
    
    
      <category term="animation" scheme="http://yoursite.com/tags/animation/"/>
    
      <category term="github pages" scheme="http://yoursite.com/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>匆匆拉萨之行</title>
    <link href="http://yoursite.com/2017/09/13/tour-lahsa/"/>
    <id>http://yoursite.com/2017/09/13/tour-lahsa/</id>
    <published>2017-09-13T12:34:02.000Z</published>
    <updated>2017-09-14T14:01:26.245Z</updated>
    
    <content type="html"><![CDATA[<p>第一次尝试写游记，嗯，是在周老师的文艺熏陶之下，试着记录一哈，但愿最后读起来不是一篇作文的感觉 T T ~~真的太久没动手写点儿文字了，想当年语文也是考过140分的人呐 = = 哈哈哈哈哈哈哈哈哈<br><a id="more"></a></p>
<p>嗯，这一定会是一本气质爆炸的流水账，如此鼓励自己，就像拉萨的阳光和色彩，希望经得起时间，淡化模糊了的时候再来强化一遍，反正又不是背英语词汇书，不用每次拾起都abandon 哈哈哈</p>
<p>在被林子放鸽子（为了她的大好前程，以及许诺将来可以赚很多钱养我的情况下，对于她的这种抛弃我的行为予以了包容，哈哈哈，我就是这么体贴大方聪明美丽可爱。。。。。。然而，在她晓得我自己去耍，她却在加班以后，果断从内疚的心态转为了说我抛弃了她==），又不想回家监督老弟学习，团队的小伙伴接连回家只剩我自己的情况下，突然萌生了想去远一点的地方这个想法，其实之前也有想过去趟拉萨，但是纠结于各种原因，一直没有付出行动。</p>
<p>从打算去拉萨，到最后决定并买票只花了一天时间，这是第一次去一个远一点的地方没有攻略过就这么仓促决定了。去的火车票没有，只好买机票，回程的也没有直达的火车票了，机票略贵不舍，只好坐着火车出拉萨到西宁再转车，真是一次相当难忘的硬座经历。虽然匆匆忙忙腿脚肿胀，但遇到些有趣的人始终是种新鲜。</p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p><img src="/images/tour_lahsa/1.JPG" alt="1"></p>
<p>贡嘎机场外连绵的山，云彩触手可及的感觉，很凉爽，不过光秃秃的山还是有点荒凉，阳光很炫</p>
<p><img src="/images/tour_lahsa/2.JPG" alt="2"></p>
<p>停放机场大巴的车站，一出门就被这片云吸引到了，坐在旁边的叔叔说拉萨比这漂亮的云很多，这个太一般了，他们已经习惯了这片土地的蓝天和云，而我这个刚刚落地的游客真的十分激动哇，嘤嘤嘤，超爱高原上的感觉，怎么形容呢，就是会心情变得超级好，好心情养成地啊</p>
<p>来之前准备了红景天，由于时间仓促只提前喝了一天，然而下飞机之后感觉自己一点高原反应都没有，默默地瞎激动，以为自己会是逃脱高反的那个例外，就像当初觉得自己也是那个会逃过警告的人，but，瞎激动的幸运之后高反是说来就来的，晚上头疼的睡不着。</p>
<h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>红景天真特么不管用，第二天头疼头晕还是躺了大半天，还不如连喝几壶热水管用，必须要赞一下的是，本来带的防感冒的药吃了一片居然有治头疼的奇效，在感冒药的助攻下，晕晕乎乎吃了一顿串串。夏天拉萨夜晚的街头很是凉快，于是决定去布宫广场转转。夜晚吃饱了坐在电瓶车上吹着凉风浪荡在一座陌生城市的感觉，贼爽。</p>
<p><img src="/images/tour_lahsa/3.JPG" alt="3"></p>
<p>傍晚酒店对面的拉萨河，高山和低垂的白云环抱一整座城市。</p>
<p><img src="/images/tour_lahsa/4.JPG" alt="4"></p>
<p>布宫广场上一对拍婚纱照的恋人。想起回程的火车上遇到的一个妹子，她说起登珠峰途中遇到的一对六十多岁的爷爷奶奶，爷爷说，只有去过珠峰的爱情才是真的爱情。这种高调的秀恩爱的方式，真的很动人。在高海拔缺氧的环境下，我与你一起经历头晕和窒息，一起经受岁月无情的摧残。</p>
<h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p><img src="/images/tour_lahsa/5.JPG" alt="5"></p>
<p>从这顿早饭开始体验到拉萨的物价之高，这样的包子在我高反胃口不好的情况下，吃了六个还不饱，一块五一个。原来我也可以是一个早饭能吃十几块钱包子的人= =</p>
<p><img src="/images/tour_lahsa/6.JPG" alt="6"></p>
<p>去的时候正好赶上拉萨的雪顿节，雪顿节又叫酸奶节，他们告诉我说是专门喝酸奶的节日，我觉得是在糊弄我，但我对西藏节日文化也没甚了解，不甚感兴趣，也没去深究。但雪顿节的林卡气氛我是感受到了，比我们春节似乎还要热闹。整个就是全家集体公园春游的感觉。</p>
<p><img src="/images/tour_lahsa/7.JPG" alt="7"></p>
<p>罗布林卡草地上到处都是来过林卡的藏民，一家人围坐在坐席上，带上酸奶，带上酥油茶，带上不远赶来的美好愿景。</p>
<p><img src="/images/tour_lahsa/8.JPG" alt="8"></p>
<p>喜欢拉萨的色彩，尤其这种对比强烈的红色和黄色，蓝天，白云，一切都很美丽。</p>
<h1 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h1><p><img src="/images/tour_lahsa/9.JPG" alt="9"></p>
<p>波林卡路措姆凉粉店的菜单，排队的人超级多。字很秀气。</p>
<p><img src="/images/tour_lahsa/10.JPG" alt="10"></p>
<p>点了酸奶，土豆，凉粉。酸奶超级喜欢，加了一勺白砂糖，还有点酸。</p>
<p><img src="/images/tour_lahsa/11.JPG" alt="11"></p>
<p>布宫的一角，就像童话里的一座宫殿。能想象到历史上权利曾在此集中过。宫殿上方的阳光，明亮刺眼，你只能仰视它，它离你那么近那么远。</p>
<p><img src="/images/tour_lahsa/12.JPG" alt="12"></p>
<p>龙王潭公园的树荫下看到的布宫背面。布宫真的是360度无死角的美丽。不知道为什么，就是感觉阳光映照下，这片绿很可口的样子，看起来真的很好吃的样子啊。</p>
<p><img src="/images/tour_lahsa/13.JPG" alt="13"></p>
<p>阳光穿过树隙。这株柳树目测应该几百年历史了，在高原长这么粗壮，它一定经历和见证了很多。</p>
<h1 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h1><p>布宫的门票真的太抢手，200块的门票听说被黄牛炒到了一千多，在一番折腾排队下，终于被放进这个大宫殿。不过在参观过程中，除了游客对各种精致奢华的惊叹，还有那些朝拜者的认真和虔诚。可以看到一家人把坐在轮椅上的老人从山脚下一级级石阶往上抬，也可以看到七旬的两个老奶奶大概是姐妹吧，相互搀扶一起双手合十，一起磕长头，一起留着长长的辫子。不羡慕这虔诚的信仰，但羡慕这种跨越时间温暖的陪伴。不管你去哪儿，都和你一起。</p>
<p><img src="/images/tour_lahsa/14.JPG" alt="14"></p>
<p>布宫的一角，红色的墙壁里面是一种高原上的草。惊叹于古人的建筑智慧和手艺。</p>
<p><img src="/images/tour_lahsa/15.JPG" alt="15"></p>
<p>进入主要的宫殿参观文物前最后能拍照的地方。</p>
<p><img src="/images/tour_lahsa/16.JPG" alt="16"></p>
<p>同行的一个小妹妹，红墙的映衬下，宛若一只仙女。</p>
<p><img src="/images/tour_lahsa/17.JPG" alt="17"></p>
<p>出布宫后在山上俯瞰整个拉萨，布宫就是整个拉萨的观景台。</p>
<p><img src="/images/tour_lahsa/18.JPG" alt="18"></p>
<p>格桑花盛开的山坡，此时山顶上的布宫十分安静。</p>
<p><img src="/images/tour_lahsa/19.JPG" alt="19"></p>
<p>大昭寺门前磕长头的朝拜者。我是看客，无法理解信仰的力量，但激动于世界上还有这样一群人。</p>
<p><img src="/images/tour_lahsa/20.JPG" alt="20"></p>
<p>八廓街的一角，蓝天，云朵，建筑，一切都温柔和谐。</p>
<p><img src="/images/tour_lahsa/21.JPG" alt="21"></p>
<p>八廓街上一家叫南卡的冷饮店。名字很美丽。</p>
<p><img src="/images/tour_lahsa/22.JPG" alt="22"></p>
<p>一对环绕大昭寺磕长头的姐妹，她们还很小，但我好像看到了在布宫那一对磕头相扶的老奶奶。</p>
<p><img src="/images/tour_lahsa/23.JPG" alt="23"></p>
<p>阴影里的长椅上坐了一排在转经的老爷爷。朋友调侃道，我那么帅你不拍我，去拍老头子。但是，一排老爷爷排排坐真的很可爱啊。</p>
<h1 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h1><p>早晨七点就坐车去纳木错，七点的拉萨还有些黑，尽管穿了外套街头还是很冷。但天微微亮的时候，拉萨的街头十分美丽。</p>
<p><img src="/images/tour_lahsa/24.JPG" alt="24"></p>
<p>圣湖就是圣湖，远远的就被迷住了。蓝天，云彩，雪山，清水。天空就像是湖水的倒影。坐在湖边发呆，感觉都很美好。</p>
<p><img src="/images/tour_lahsa/25.JPG" alt="25"></p>
<p>阳光倾泻而下。此处该有个美丽的仙仙的背影= =</p>
<p><img src="/images/tour_lahsa/26.JPG" alt="26"></p>
<p>再来一张透明的湖水。</p>
<p><img src="/images/tour_lahsa/27.JPG" alt="27"></p>
<p>一个仙仙的小姐姐的背影，超美，嘤嘤嘤</p>
<p><img src="/images/tour_lahsa/28.JPG" alt="28"></p>
<p>湖边一个浅滩，云朵和人群的倒影。</p>
<p><img src="/images/tour_lahsa/29.JPG" alt="29"></p>
<p>海拔5190米，那拉根山口飘舞的经幡。途中总有那么一抹颜色吸引了你，总有那么一个人惊艳于你。</p>
<p><img src="/images/tour_lahsa/30.JPG" alt="30"></p>
<p>青藏线上的黄昏。安静，美丽。</p>
<p>The End</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次尝试写游记，嗯，是在周老师的文艺熏陶之下，试着记录一哈，但愿最后读起来不是一篇作文的感觉 T T ~~真的太久没动手写点儿文字了，想当年语文也是考过140分的人呐 = = 哈哈哈哈哈哈哈哈哈&lt;br&gt;
    
    </summary>
    
      <category term="游记" scheme="http://yoursite.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="tour" scheme="http://yoursite.com/tags/tour/"/>
    
      <category term="lahsa" scheme="http://yoursite.com/tags/lahsa/"/>
    
  </entry>
  
  <entry>
    <title>Next主题配置---打赏功能+文章结束标志</title>
    <link href="http://yoursite.com/2017/08/10/blog-donate/"/>
    <id>http://yoursite.com/2017/08/10/blog-donate/</id>
    <published>2017-08-10T12:44:56.000Z</published>
    <updated>2017-09-13T12:57:24.933Z</updated>
    
    <content type="html"><![CDATA[<p>这次介绍一下next主题下添加打赏功能，以及在每篇文章末尾统一添加“文章结束”标志 ~~~吼吼吼<br><a id="more"></a></p>
<h1 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h1><p>首先在主题配置文件即hexo/themes/next/_config.yml找到version字段，查看自己的next主题的版本，如下图所示，我用的next主题的版本为5.1.2</p>
<p><img src="/images/blog_donate/1.png" alt="1"></p>
<p>在网上查了一些添加打赏功能的方法，参照来做的时候，发现了一些问题，可能是由于next主题升级到version5后自身增加了些隐藏的新功能，所以在网上找到的别人的一些方法不太适用，下面的添加文章结束功能也是如此。因此自己尝试设置好后特来分享一哈~</p>
<p>在主题配置文件找到Reward字段部分，如下图所示，其中reward_comment字段设置你的打赏介绍，wechatpay和alipay分别为你保存微信以及支付宝收款二维码的路径，可以是本地路径，也可以是用图床生成的链接地址。我是把图片放在本地的，即将两个二维码图片放在了next/source/images文件夹下。</p>
<p><img src="/images/blog_donate/2.png" alt="2"></p>
<p>此时默认的打赏按钮如下，略丑。。。然后作了小小改动，把打赏按钮变好看一点点 ~~~</p>
<p><img src="/images/blog_donate/3.png" alt="3"></p>
<p>改动方法如下：在hexo\themes\next\layout_macro下找到reward.swig文件，这个文件是关于打赏功能样式设置的。用下面代码覆盖原文件中的代码即可。由于保存的自动生成的微信及支付宝二维码图片的大小不一，且原图略大，所以可以通过设置包裹两幅图片的div元素的宽度和高度（代码两处注解处）来限制图片的大小，使其更加美观。宽度和高度可以依据自己喜欢更改大小。当然也可以自己使用图片处理工具将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;div style=&quot;padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;&quot;&gt;</div><div class="line">  &lt;div&gt;&#123;&#123; theme.reward_comment &#125;&#125;&lt;/div&gt;</div><div class="line">  &lt;button id=&quot;rewardButton&quot; disable=&quot;enable&quot; style=&quot;width: 80px;line-height: 38px;text-align: center;font-weight: bold;color: #fff;border-radius: 5px;</div><div class="line">margin:0 20px 20px 0;position: relative;overflow: hidden;color: #8c96a0;text-shadow:1px 1px 1px #fff;border:1px solid #dce1e6;box-shadow: 0 1px 2px #fff inset,0 -1px 0 #a8abae inset;background: -webkit-linear-gradient(top,#f2f3f7,#e4e8ec);background: -moz-linear-gradient(top,#f2f3f7,#e4e8ec);background: linear-gradient(top,#f2f3f7,#e4e8ec);&quot; onclick=&quot;var qr = document.getElementById(&apos;QR&apos;); if (qr.style.display === &apos;none&apos;) &#123;qr.style.display=&apos;block&apos;;&#125; else &#123;qr.style.display=&apos;none&apos;&#125;&quot;&gt;</div><div class="line">    打赏</div><div class="line">  &lt;/button&gt;</div><div class="line">  &lt;div id=&quot;QR&quot; style=&quot;display: none;&quot;&gt;</div><div class="line"></div><div class="line">    &#123;% if theme.wechatpay %&#125;</div><div class="line">      &lt;div id=&quot;wechat&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt;</div><div class="line">        &lt;img id=&quot;wechat_qr&quot; src=&quot;&#123;&#123; theme.wechatpay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; WeChat Pay&quot;/&gt;</div><div class="line">        &lt;p&gt;WeChat Pay&lt;/p&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line"></div><div class="line">    &#123;% if theme.alipay %&#125;</div><div class="line">      &lt;div id=&quot;alipay&quot; style=&quot;display: inline-block;width:150px;height:150px&quot;&gt;</div><div class="line">        &lt;img id=&quot;alipay_qr&quot; src=&quot;&#123;&#123; theme.alipay &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Alipay&quot;/&gt;</div><div class="line">        &lt;p&gt;Alipay&lt;/p&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line"></div><div class="line">    &#123;% if theme.bitcoin %&#125;</div><div class="line">      &lt;div id=&quot;bitcoin&quot; style=&quot;display: inline-block&quot;&gt;</div><div class="line">        &lt;img id=&quot;bitcoin_qr&quot; src=&quot;&#123;&#123; theme.bitcoin &#125;&#125;&quot; alt=&quot;&#123;&#123; theme.author &#125;&#125; Bitcoin&quot;/&gt;</div><div class="line">        &lt;p&gt;Bitcoin&lt;/p&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &#123;% endif %&#125;</div><div class="line"></div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>调整后的效果见下图，是不是稍微不那么丑了一点点呢，红红火火恍恍惚惚~~~~</p>
<p><img src="/images/blog_donate/4.png" alt="4"></p>
<h1 id="文章结束标志"><a href="#文章结束标志" class="headerlink" title="文章结束标志"></a>文章结束标志</h1><p>本以为这是一个非常简单的小功能，其实的确是一个很简单的功能，但由于参考的人家的做法可能不适于我使用的版本，导致这个小小的问题又折腾了好久T T</p>
<p>在hexo\themes\next\layout_macro文件夹下新建passage-end-tag.swig文件，并添加代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;</div></pre></td></tr></table></figure>
<p>其中的 <code>&lt;i class=&quot;fa fa-smile-o&quot;&gt;&lt;/i&gt;</code>为<a href="http://www.yeahzan.com/fa/facss.html" target="_blank" rel="external">FontAwesome图标</a>,可以在其中挑选自己喜欢的图标，我选了一个笑脸，嘻嘻(●’◡’●)</p>
<p>然后打开hexo\themes\next\layout_macro文件夹下的post.swig文件，在 <code>END POST BODY</code>这段注解后添加如下图框框中的代码：</p>
<p><img src="/images/blog_donate/5.png" alt="5"></p>
<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if theme.passage_end_tag.enabled and not is_index %&#125;</div><div class="line">   &lt;div&gt;</div><div class="line">      &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</div><div class="line">   &lt;/div&gt;</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>再然后，打开主题配置文件hexo/themes/next/_config.yml，在末尾添加如下代码：</p>
<pre><code># 文章末尾添加“本文结束”标记
passage_end_tag:
  enabled: true
</code></pre><p>效果如下图所示：</p>
<p><img src="/images/blog_donate/6.png" alt="6"></p>
<p>最后，运行下hexo g -d 看下部署到github后的效果吧！</p>
<p><strong>PS:</strong>比较坑的一点，我使用的markdownpad，使用Tab缩进打代码块时，在右侧预览区可以正常显示代码块文本，但是 <code>hexo s</code> 在本地浏览器预览后，代码块文本却没有正确完整的显示，有些html标签被解释掉了。好像是Tab缩进可以被markdownpad的解释器正确解释，但是hexo的解释器却没有将其正确解析。后面换了一种打代码块的方式，就可以在浏览器正确显示了，但在markdownpad的预览区却没得到正常显示。即在代码块的最前面和最后面单独一行使用三个反引号    ```。如下图所示。</p>
<p><img src="/images/blog_donate/7.png" alt="7"></p>
<p>效果显示如下：</p>
<p><img src="/images/blog_donate/8.png" alt="8"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次介绍一下next主题下添加打赏功能，以及在每篇文章末尾统一添加“文章结束”标志 ~~~吼吼吼&lt;br&gt;
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>基于hexo和github搭建个人博客概述</title>
    <link href="http://yoursite.com/2017/08/06/hello-world/"/>
    <id>http://yoursite.com/2017/08/06/hello-world/</id>
    <published>2017-08-05T16:00:00.000Z</published>
    <updated>2017-08-08T03:22:18.200Z</updated>
    
    <content type="html"><![CDATA[<p>前言：第一次写博客，小激动~~~分享总结下用hexo+github搭建个人博客的过程，以及过程中遇到的问题。（我用的win10 64位系统）<br><a id="more"></a></p>
<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><ul>
<li>hexo </li>
</ul>
<p>根据<a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a>的介绍，hexo是一个快速简洁且高效的博客框架。hexo利用markdown等渲染引擎解析文章，快速生成静态网页。</p>
<p>Hexo是基于node.js的, 在安装它之前需要用到npm安装工具, 这个工具是 node.js 安装包的工具, 所以需要先安装 node.js。</p>
<p>关于hexo搭建博客原理进一步了解-<a href="https://segmentfault.com/a/1190000008784436" target="_blank" rel="external">hexo原理浅析</a>。</p>
<ul>
<li>node.js </li>
</ul>
<p>node.js是运行在服务端的javascript，是一个允许开发人员使用javascript语言编写服务端代码的框架。</p>
<ul>
<li>npm </li>
</ul>
<p>npm是随同node.js一起安装的包管理工具，能解决node.js代码部署上的很多问题。<br>允许用户从npm服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p>
<p>新版的node.js已经集成了npm，所以下载安装node.js也一并将npm安装好了。</p>
<ul>
<li>git </li>
</ul>
<p>git是一种非常流行的分布式版本控制系统，它和其他版本控制系统的主要差别在于git只关心文件数据的整体是否发生变化，而大多数版本其他系统只关心文件内容的具体差异。</p>
<p>我们利用git将hexo生成的静态博客页面，部署到github pages上。关于git的<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="external">更多了解</a>。</p>
<ul>
<li>github </li>
</ul>
<p>随着git迅速成为最流行的分布式版本控制系统，github网站上线了。github是一个基于git的代码托管平台，它为开源项目免费提供git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p>
<p>github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。</p>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>1.环境准备（node.js，git，github相关设置）  </p>
<p>2.hexo下载安装  </p>
<p>3.hexo相关配置 </p>
<p>4.hexo与github pages链接     </p>
<p>5.发布第一篇博文</p>
<p>6.hexo主题介绍及配置  </p>
<p>7.hexo第三方服务集成（disqus评论，百度分享，访客记录等）</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="node-js下载安装"><a href="#node-js下载安装" class="headerlink" title="node.js下载安装"></a>node.js下载安装</h3><p><a href="http://nodejs.cn/download/" target="_blank" rel="external">node.js下载</a></p>
<p>下载完成后一路默认next即可。利用win+R打开命令窗口，在命令窗口中输入以下命令，可以查看node和npm的版本信息。如果可以正确显示版本信息，说明安装正确，否则检查安装过程，重新安装。</p>
<pre><code>node -v
npm -v
</code></pre><p>结果如下图所示。</p>
<p><img src="/images/b1.png" alt="node版本检查"></p>
<h3 id="git下载安装"><a href="#git下载安装" class="headerlink" title="git下载安装"></a>git下载安装</h3><p><a href="https://git-scm.com/downloads" target="_blank" rel="external">git下载</a></p>
<p>下载完成后一路默认next即可。在命令窗口中输入以下命令，可以查看git的版本信息。</p>
<pre><code>git --version
</code></pre><p>结果如下图所示。</p>
<p><img src="/images/b2.png" alt="git版本检查"></p>
<h3 id="github注册相关"><a href="#github注册相关" class="headerlink" title="github注册相关"></a>github注册相关</h3><p>若没有注册过github账号，在<a href="https://github.com/" target="_blank" rel="external">github官网</a>按照步骤注册成功就好。</p>
<p>注册登录后，在页面右上角+号选择New repository创建新的代码仓库。</p>
<p><img src="/images/b3.png" alt="新建仓库"></p>
<p>在Create a new repository页面下，填写Repository name框框，框框中填写yourname.github.io，其中yourname为Owner框框中的那个名字。再勾选一下Initialize this repository with a README 。</p>
<p><img src="/images/b4.png" alt="新建仓库"></p>
<p>正确创建代码仓库后，需要开启github pages功能。在刚刚新建的代码仓库界面点击Settings，就会打开这个库的设置页面，向下拖动，会看见GitHub Pages，点击Launch Automatic page generator，github 自动创建出一个github pages页面。然后你可以试着访问yourname.github.io这个网址。</p>
<h2 id="hexo下载安装"><a href="#hexo下载安装" class="headerlink" title="hexo下载安装"></a>hexo下载安装</h2><p>在合适的盘，例如以E盘为例，在E盘根目录下新建hexo文件夹，然后右键点击选中hexo,选择Git Bash Here,在git命令窗口中输入以下命令：</p>
<pre><code>$ npm install hexo-cli -g
</code></pre><p>然后输入</p>
<pre><code>$ npm install hexo --save
</code></pre><p>建议将hexo以下插件一起安装了</p>
<pre><code>$ npm install hexo-generator-index --save #索引生成器
$ npm install hexo-generator-archive --save #归档生成器 
$ npm install hexo-generator-category --save #分类生成器
$ npm install hexo-generator-tag --save #标签生成器 
$ npm install hexo-server --save #本地服务 
$ npm install hexo-deployer-git --save #hexo通过git发布（必装） 
$ npm install hexo-renderer-marked@0.2.7--save #渲染器 
$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器
</code></pre><p>(或者可以执行 npm install命令，npm会自动安装部分组件，但自己试了下，用npm命令不能安装全组件，部分组件还需自己手动安装，比如最重要的用于部署功能的组件 hexo-deployer-git 用 npm install命令就没装上。可以在hexo/node_modules文件下查看已经安装了的组件。)</p>
<p>安装完成后可查看下所安装的hexo版本信息。在hexo文件夹下右键进入git bash,输入以下命令:</p>
<pre><code>$ hexo -v
</code></pre><p>若看到类似如图所示版本信息说明hexo安装成功。</p>
<p><img src="/images/b5.png" alt="hexo版本信息"></p>
<h2 id="hexo相关配置"><a href="#hexo相关配置" class="headerlink" title="hexo相关配置"></a>hexo相关配置</h2><ul>
<li>hexo初始化 -&gt;在hexo文件夹下右键进入git bash,输入以下初始化命令： <code>$ hexo init</code></li>
<li>hexo生成 -&gt;输入以下命令生成静态页面: <code>$ hexo g</code></li>
<li>本地服务 -&gt;输入以下命令建立本地hexo预览： <code>$ hexo s</code><br>(确保已经安装了hexo-server组件，否则该命令无效）</li>
</ul>
<p>执行完 hexo s 命令后会提示</p>
<pre><code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
</code></pre><p>在浏览器中打开上述链接地址，会看到hexo默认的主题页面，至此hexo本地配置完成。</p>
<p>PS：注意！！！安装了福昕阅读器的朋友，福昕阅读器会占用4000端口，导致 hexo s 命令后出错提示4000端口被占用。你可以在hexo/_config.yml站点配置文件里修改端口号，换成自己想设置的端口即可，如下修改：</p>
<pre><code>server:
  port: 4001
  compress: true
  header: true
</code></pre><h2 id="hexo与github-pages链接"><a href="#hexo与github-pages链接" class="headerlink" title="hexo与github pages链接"></a>hexo与github pages链接</h2><ul>
<li><p>deployment配置  -&gt;在hexo/_config.yml站点配置文件里，修改下面的字段内容如下：</p>
<pre><code>deploy:     
  type: git 
  repo: https://github.com/yourname/yourname.github.com.git #yourname即为创建仓库时的那个yourname    
  branch: master
</code></pre><p>PS:注意.yml格式文件冒号后面有一个空格。</p>
</li>
</ul>
<h2 id="发布第一篇博文"><a href="#发布第一篇博文" class="headerlink" title="发布第一篇博文"></a>发布第一篇博文</h2><p>在hexo文件夹下右键进入git bash,输入以下命令即可生成一篇新文章：</p>
<pre><code>hexo new post &quot;post_title&quot;   #其中post_title为你想新建文章的文件名
</code></pre><p>此时在 E:\hexo\source\ _posts 下生成一个 post_title.md 文件（此后你可以用markdown编辑器打开该.md文件就可以编辑文章了）。</p>
<p>然后运行下面两条命令即可将新建的文章生成-&gt;部署到github上。</p>
<pre><code>hexo g  #生成
hexo d  #部署
</code></pre><p>部署完毕后，即可访问<a href="https://yourname.github.io看到刚刚生成部署到github的文章。" target="_blank" rel="external">https://yourname.github.io看到刚刚生成部署到github的文章。</a></p>
<p>PS：以后每次用markdown编辑器修改post_title.md文件后，记得用 <code>hexo g -d</code> 命令来生成和部署。修改完配置后也要<code>hexo g -d</code>一下。</p>
<p>PPS:hexo常用命令</p>
<pre><code>hexo new post &quot;postName&quot; #新建文章 
hexo new page &quot;pageName&quot; #新建页面 
hexo generate #生成静态页面至public目录 
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub 
hexo help  #查看帮助 
hexo version #查看Hexo的版本
</code></pre><p>简写</p>
<pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><h2 id="hexo主题介绍及配置"><a href="#hexo主题介绍及配置" class="headerlink" title="hexo主题介绍及配置"></a>hexo主题介绍及配置</h2><p>我选用的较为简洁大方的next主题。</p>
<ul>
<li><p>next主题下载 -&gt;在hexo文件夹下右键进入git bash,输入以下命令：</p>
<p>  <code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></p>
</li>
<li><p>启用next主题 -&gt;在hexo/_config.yml站点配置文件下，修改如下字段：</p>
<p>   <code>theme: next</code></p>
</li>
<li>测试主题启用是否成功 -&gt;执行 <code>hexo s</code>命令，在浏览器访问 <a href="http://localhost:4000查看主题效果。" target="_blank" rel="external">http://localhost:4000查看主题效果。</a></li>
</ul>
<p>PS：主题的其他相关设置可以参考该博客，写的很详细<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="external">手把手教你用Hexo+Github 搭建属于自己的博客</a>。</p>
<h2 id="hexo第三方服务集成"><a href="#hexo第三方服务集成" class="headerlink" title="hexo第三方服务集成"></a>hexo第三方服务集成</h2><h3 id="添加disqus评论"><a href="#添加disqus评论" class="headerlink" title="添加disqus评论"></a>添加disqus评论</h3><p>由于以前国内使用较多的多说评论下架了，所以选用了国外较为稳定的disqus，但使用该评论功能需要“科学上网”！</p>
<ul>
<li>注册disqus账号<a href="https://disqus.com" target="_blank" rel="external">https://disqus.com</a></li>
<li>在disqus设置页面中点 Add Disqus to your site 添加你的网站地址(即为<a href="https://yourname.github.io" target="_blank" rel="external">https://yourname.github.io</a>), 和设置Choose your unique Disqus URL, 你所填写的unique Disqus URL即为hexo配置文件中需要修改的short_name字段。</li>
<li><p>打开hexo/themes/next/_config.yml主题配置文件，修改下面字段：</p>
<pre><code>#Disqus
disqus:
  enable: true
  shortname:     #shortname即为你上面填写的唯一disqus路径，填上就好
  count: true
</code></pre></li>
</ul>
<h3 id="添加百度分享功能"><a href="#添加百度分享功能" class="headerlink" title="添加百度分享功能"></a>添加百度分享功能</h3><p>百度分享功能的添加可以参考下面这篇博客。<a href="http://blog.csdn.net/cl534854121/article/details/76121105" target="_blank" rel="external">Hexo+Github搭建个人博客(三)——百度分享集成</a></p>
<h3 id="百度统计访客访问量功能"><a href="#百度统计访客访问量功能" class="headerlink" title="百度统计访客访问量功能"></a>百度统计访客访问量功能</h3><p>其他酷炫小功能参考<a href="http://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="external">hexo的next主题个性化教程:打造炫酷网站</a>。</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="external">手把手教你用Hexo+Github 搭建属于自己的博客 </a></p>
<p><a href="http://www.jianshu.com/p/017e01718d41" target="_blank" rel="external">记录第一次搭建hexo</a></p>
<p>嘤嘤嘤<del>~</del>~~THE END!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：第一次写博客，小激动~~~分享总结下用hexo+github搭建个人博客的过程，以及过程中遇到的问题。（我用的win10 64位系统）&lt;br&gt;
    
    </summary>
    
      <category term="搭建博客" scheme="http://yoursite.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="node.js" scheme="http://yoursite.com/tags/node-js/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
</feed>
