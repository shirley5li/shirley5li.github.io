<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirley</title>
  <subtitle>一只自学成菜的仙女!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-27T00:58:47.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShirleyLi</name>
    <email>1363814017@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序开发文档总结</title>
    <link href="http://yoursite.com/2018/03/26/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/26/微信小程序开发文档总结/</id>
    <published>2018-03-26T14:15:57.000Z</published>
    <updated>2018-03-27T00:58:47.667Z</updated>
    
    <content type="html"><![CDATA[<p>小程序开发文档的简要概括。<br><a id="more"></a></p>
<h1 id="基本的文件结构"><a href="#基本的文件结构" class="headerlink" title="基本的文件结构"></a>基本的文件结构</h1><p>最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个，<code>.js</code>后缀的是脚本文件，<code>.json</code>后缀的文件是配置文件，<code>.wxss</code>后缀的是样式表文件。</p>
<p><code>app.js</code>： 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。</p>
<p><code>app.json</code>： 对整个小程序的全局配置。可以在这个文件中配置小程序是由哪些页面(<code>&quot;pages&quot;</code>)组成，配置小程序的窗口(<code>&quot;window&quot;</code>)背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。</p>
<p><code>app.wxss</code>： 整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。</p>
<h1 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h1><p>小程序的页面都在根目录下的pages文件目录，例如一开始的示例程序中（有展示用户头像的欢迎页和小程序启动日志展示页），这两个页面都在pages目录下，即<code>pages/index/</code>和<code>pages/logs/</code>。</p>
<p>微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 <code>&quot;pages&quot;</code> 中，且 <code>&quot;pages&quot;</code> 中的第一个页面是小程序的首页。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"pages"</span>:[</div><div class="line">  <span class="string">"pages/index/index"</span>,</div><div class="line">  <span class="string">"pages/logs/logs"</span></div><div class="line">],</div></pre></td></tr></table></figure>
<p>每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js(脚本)、 index.wxml(页面结构)、 index.wxss(样式表)、 index.json(配置)。</p>
<ul>
<li><p>index.wxml 是页面的结构文件。</p>
</li>
<li><p>index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。</p>
</li>
<li><p>index.wxss 是页面的样式表。 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。</p>
</li>
</ul>
<p>注意微信小程序开发中使用了新的尺寸单位，<code>rpx</code>(responsive pixel)，可以根据屏幕宽度自适应，规定屏幕宽度为750rpx。</p>
<p>如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。微信官方建议视觉稿以iPhone 6为标准。(补充rem: 规定屏幕宽度为20rem，所以1rem=750/20 rpx)</p>
<ul>
<li>index.json 是页面的配置文件。 页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。</li>
</ul>
<p>文件目录安排如下所示如下图所示。<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="小程序基本的目录结构"></p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>框架提供了自己的视图层描述语言WXML和WXSS，以及基于JavaScript的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。</p>
<ul>
<li>响应的数据绑定</li>
</ul>
<p>框架的核心是一个响应的数据绑定系统。整个系统分为两块视图层(View)和逻辑层(App Service)。框架可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p>
<ul>
<li>页面管理</li>
</ul>
<p>框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据，方法，生命周期函数注册进框架中，其他的一切复杂的操作都交由框架处理。</p>
<ul>
<li>基础组件</li>
</ul>
<p>框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序 。</p>
<ul>
<li>丰富的API</li>
</ul>
<p>框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。<a href="https://www.w3cschool.cn/weixinapp/hw9k1q8m.html" target="_blank" rel="noopener">app.json的配置项</a>列表包括： <code>pages</code> <code>window</code> <code>tabBar</code> <code>networkTimeout</code> <code>debug</code>。</p>
<p><code>pages</code> ：接受一个数组，每一项都是字符串，来指定小程序由哪些页面组成。每一项代表对应页面的【路径+文件名】信息，数组的第一项代表小程序的初始页面。小程序中新增/减少页面，都需要对 pages 数组进行修改。 文件名不需要写文件后缀，因为框架会自动去寻找路径.json,.js,.wxml,.wxss的四个文件进行整合。</p>
<p><code>window</code>： 用于设置小程序的状态栏、导航条、标题、窗口背景色。具体参数如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E9%85%8D%E7%BD%AE%E9%A1%B9window%E5%8F%82%E6%95%B0.png" alt="window配置项参数"></p>
<p><code>tabBar</code>： 如果我们的小程序是一个多 tab 应用（客户端窗口的底部有tab栏可以切换页面），那么我们可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p>page.json： 每一个小程序页面也可以使用.json文件来对本页面的窗口表现进行配置。页面的配置比app.json全局配置简单得多，只是设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。页面的.json只能设置window相关的配置项，以决定本页面的窗口表现，所以无需写window这个键。</p>
<h1 id="逻辑层-APP-Service"><a href="#逻辑层-APP-Service" class="headerlink" title="逻辑层(APP Service)"></a>逻辑层(APP Service)</h1><p>小程序开发框架的逻辑层是由JavaScript编写。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 在javascript基础上，增加 App 和 Page 方法，进行程序和页面的注册； 提供丰富的 API，如扫一扫，支付等微信特有能力； 每个页面有独立的作用域，并提供模块化能力； 由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等； 开发者写的所有代码最终将会打包成一份 JavaScript，并在小程序启动的时候运行，直到小程序销毁。类似 ServiceWorker，所以逻辑层也称之为 App Service。</p>
<h2 id="注册程序"><a href="#注册程序" class="headerlink" title="注册程序"></a>注册程序</h2><p><strong>APP()</strong></p>
<p>App()函数用来注册一个小程序。接受一个object参数，其指定小程序的生命周期函数等。<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/APP%E6%B3%A8%E5%86%8C%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png" alt="APP注册参数说明"></p>
<p>前台、后台定义：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁，而是进入了后台；当再次进入微信或再次打开小程序，又会从后台进入前台。需要注意的是：只有当小程序进入后台一定时间，或者系统资源占用过高，才会被真正的销毁。</p>
<p>关闭小程序(基础库版本1.1.0开始支持)：当用户从扫一扫、转发等入口(场景值为1007, 1008, 1011, 1025)进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。小程序运行机制在基础库版本 1.4.0 有所改变：上一条关闭逻辑在新版本已不适用，。</p>
<p><strong>getAPP()</strong></p>
<p>提供了全局的getApp()函数，可以获取到小程序实例。</p>
<p><strong>注意：</strong>App()必须在app.js中注册，且不能注册多个。</p>
<p>不要在定义于App()内的函数中调用getApp()，使用this就可以拿到app实例。</p>
<p>不要在onLaunch的时候调用getCurrentPage()，此时page还没有生成。</p>
<p>通过getApp()获取实例之后，不要私自调用生命周期函数。</p>
<h2 id="场景值"><a href="#场景值" class="headerlink" title="场景值"></a>场景值</h2><p><a href="https://www.w3cschool.cn/weixinapp/weixinapp-scene.html" target="_blank" rel="noopener">场景值</a>描述了开启小程序的来源，例如如果从发现栏小程序主入口开启，场景值为1001。可以在 App 的 onLaunch 和 onShow 中获取。</p>
<h2 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h2><p><strong>Page()</strong></p>
<p>Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E9%A1%B5%E9%9D%A2%E6%B3%A8%E5%86%8C%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E.png" alt="页面注册参数说明"></p>
<p><strong>初始化数据</strong> 将作为页面的第一次渲染。data 将会以 JSON 的形式由逻辑层传至渲染层，所以其数据必须是可以转成 JSON 的格式：字符串，数字，布尔值，对象，数组。渲染层可以通过 WXML 对数据进行绑定。</p>
<pre><code>Page.prototype.route  route字段可以获取到当前页面的路径。
Page.prototype.setData()  setData 函数用于将数据从逻辑层发送到视图层，同时改变对应的 this.data 的值。
</code></pre><p>setData() 参数格式： 接受一个对象，以 key，value 的形式表示将 this.data 中的 key 对应的值改变成 value。ey 可以非常灵活，以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。</p>
<p>注意：</p>
<pre><code>直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致
单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。
</code></pre><p><strong>Page实例的生命周期</strong></p>
<p><img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/mina-lifecycle.png" alt="Page实例的生命周期"></p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><strong>页面路由：</strong>所有页面的路由全部由框架进行管理。</p>
<p><strong>页面栈：</strong> 框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E8%B7%AF%E7%94%B1%E4%B8%8E%E9%A1%B5%E9%9D%A2%E6%A0%88.png" alt="路由与页面栈"></p>
<p><strong>getCurrentPages()</strong> 用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。(注意;不要尝试修改页面栈，会导致路由以及页面状态错误。)</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E8%B7%AF%E7%94%B1%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F.png" alt="路由的触发方式"></p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/Tab%E5%88%87%E6%8D%A2%E5%AF%B9%E5%BA%94%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Tab切换对应的生命周期"></p>
<pre><code>navigateTo,redirectTo只能打开非 tabBar 页面。
switchTab 只能打开 tabBar 页面。
reLaunch 可以打开任意页面。
页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
调用页面路由带的参数可以在目标页面的onLoad中获取。
</code></pre><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>文件作用域：在JavaScript文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。</p>
<p>通过全局函数getApp()可以获取全局的应用实例，如果需要全局的数据可以在App()中设置全局数据。</p>
<p><strong>模块化：</strong> 将一些公共的代码抽离成为一个单独的js文件，作为一个模块。模块只有通过module.exports或者 exports才能对外暴露接口。​在需要使用这些模块的文件中，使用require(path)将公共代码引入(tips: require暂时不支持绝对路径)。</p>
<p>注意： exports是module.exports的一个引用，因此在模块里边随意更改exports的指向会造成未知的错误。所以我们更推荐开发者采用module.exports来暴露模块接口，除非你已经清晰知道这两者的关系。</p>
<h1 id="视图层-View"><a href="#视图层-View" class="headerlink" title="视图层(View)"></a>视图层(View)</h1><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><p>WXML(WeiXin Markup Language)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p>
<p>WXML具有数据绑定、列表渲染、条件渲染、模板、事件、引用等功能。</p>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>WXML中的动态数据均来自对应Page的 <code>data</code>对象中的数据。数据绑定使用 双大括号 将变量包起来。</p>
<p>（1）用于内容： <code>&lt;view&gt; {{ message }} &lt;/view&gt;</code></p>
<p>（2）组件属性(需要在双引号之内)： <code>&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt;</code></p>
<p>（3）控制属性(需要在双引号之间)： <code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; &lt;/view&gt;</code></p>
<p>（4）关键字(需要在双引号之间)： <code>&lt;checkbox checked=&quot;{{false}}&quot;&gt; &lt;/checkbox&gt;</code> 其中 false：boolean 类型的 false，代表假值。<br>注意: 特别注意：不要直接写 <code>checked=&quot;false&quot;</code>，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<p>（5）计算： 可以在{{}}内进行简单的运算。支持以下几种方式，</p>
<p>三元运算： <code>&lt;view hidden="{{flag ? true : false}}&quot;&gt; Hidden &lt;/view&gt;</code></p>
<p>算数运算： <code>view&gt; {{a + b}} + {{c}} + d &lt;/view&gt;</code></p>
<p>逻辑判断： <code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; &lt;/view&gt;</code></p>
<p>字符串运算： <code>&lt;view&gt;{{"hello" + name}}&lt;/view&gt;</code></p>
<p>数据路径运算： <code>&lt;view&gt;{{object.key}} {{array[0]}}&lt;/view&gt;</code></p>
<p>组合： 也可以在Mustache(双大括号)内直接进行组合，构成新的对象或者数组。</p>
<p>数组：<code>&lt;view wx:for-items=&quot;{{[zero, 1, 2, 3, 4]}}&quot;&gt; {{item}} &lt;/view&gt;</code></p>
<pre><code>Page({
  data: {
    zero: 0
  }
})
</code></pre><p>对象： <code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{for: a, bar: b}}&quot;&gt;&lt;/template&gt;</code>， 最终组合成的对象是<code>{for: 1, bar: 2}</code></p>
<pre><code>Page({
  data: {
    a: 1,
    b: 2
  }
})
</code></pre><p>也可以用扩展运算符…来将一个对象展开，<code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, e: 5}}&quot;&gt;&lt;/template&gt;</code>,最终组合成的对象是<code>{a: 1, b: 2, c: 3, d: 4, e: 5}</code></p>
<pre><code>Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      c: 3,
      d: 4
    }
  }
})
</code></pre><p>注意：注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如<code>&lt;template is=&quot;objectCombine&quot; data=&quot;{{...obj1, ...obj2, a, c: 6}}&quot;&gt;&lt;/template&gt;</code>，根据以下数据，最终组合成的对象是 <code>{a: 5, b: 3, c: 6}</code>。</p>
<pre><code>Page({
  data: {
    obj1: {
      a: 1,
      b: 2
    },
    obj2: {
      b: 3,
      c: 4
    },
    a: 5
  }
})
</code></pre><p>注意： 花括号和引号之间如果有空格，将最终被解析成为字符串,如下</p>
<pre><code>&lt;view wx:for=&quot;{{[1,2,3]}} &quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><p>等同于</p>
<pre><code>&lt;view wx:for=&quot;{{[1,2,3] + ' '}}&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>（1）<strong>wx:for</strong></p>
<p><strong>wx:for</strong> 在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code>。</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot;&gt;
  {{index}}: {{item.message}}
&lt;/view&gt;
</code></pre><p><strong>wx:for-item</strong> 指定数组当前元素的变量名。</p>
<p><strong>wx:for-index</strong> 指定数组当前下标的变量名。</p>
<pre><code>&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  {{idx}} {{itemName.message}}
&lt;/view&gt;
</code></pre><p>wx:for 也可以嵌套，下边是一个九九乘法表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&quot; wx:for-item=&quot;i&quot;&gt;</div><div class="line">  &lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item=&quot;j&quot;&gt;</div><div class="line">    &lt;view wx:if=&quot;&#123;&#123;i &lt;= j&#125;&#125;&quot;&gt;</div><div class="line">     &#123;&#123;i&#125;&#125; *&#123;&#123;j&#125;&#125; = &#123;&#123;i * j&#125;&#125;</div><div class="line">    &lt;/view&gt;</div><div class="line">  &lt;/view&gt;</div><div class="line">&lt;/view&gt;</div></pre></td></tr></table></figure>
<p>（2）<strong>block wx:for</strong></p>
<p>将 wx:for 用在<code>&lt;block/&gt;</code>标签上，以渲染一个包含多节点的结构块。</p>
<pre><code>&lt;block wx:for=&quot;{{[1, 2, 3]}}&quot;&gt;
  &lt;view&gt; {{index}}: &lt;/view&gt;
  &lt;view&gt; {{item}} &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>（3）<strong>wx:key</strong></p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <code>&lt;input/&gt;</code> 中的输入内容，<code>&lt;switch/&gt;</code> 的选中状态），需要使用 wx:key 来<code>指定列表中项目的唯一的标识符</code>。</p>
<p>wx:key 的值以两种形式提供:</p>
<pre><code>1.字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
2.保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如：
</code></pre><p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>注意： 当 wx:for 的值为字符串时，会将字符串解析成字符串数组。</p>
<pre><code>&lt;view wx:for=&quot;array&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><p>等同于</p>
<pre><code>&lt;view wx:for=&quot;{{['a','r','r','a','y']}}&quot;&gt;
  {{item}}
&lt;/view&gt;
</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>（1）<strong>wx:if</strong></p>
<p>用<code>wx:if=&quot;{{condition}}&quot;</code>来判断是否需要渲染该代码块, <code>&lt;view wx:if=&quot;{{condition}}&quot;&gt; True &lt;/view&gt;</code>。也可以用<code>wx:elif</code>和<code>wx:else</code>来添加一个else块：</p>
<pre><code>&lt;view wx:if=&quot;{{length > 5}}&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;{{length > 2}}&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre><p>（2）<strong>block wx:if</strong></p>
<p><code>wx:if</code>是一个控制属性，需要将它添加到一个标签上。如果想一次性判断多个组件标签，可以使用一个<code>&lt;block/&gt;</code>标签将多个组件包装起来，并在上边使用<code>wx:if</code>控制属性。</p>
<pre><code>&lt;block wx:if=&quot;{{true}}&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre><p>注意：<code>&lt;block/&gt;</code>并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<p><code>wx:if</code> <strong>vs</strong> <code>hidden</code></p>
<p>因为<code>wx:if</code>之中的模板也可能包含数据绑定，所以当<code>wx:if</code>的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。同时<code>wx:if</code>也是惰性的，如果在初始渲染条件为<code>false</code>，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p>
<p>相比之下，<code>hidden</code>就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p>
<p>一般来说，<code>wx:if</code>有更高的切换消耗而<code>hidden</code>有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用<code>hidden</code>更好，如果在运行时条件不大可能改变则<code>wx:if</code>较好。</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。 模板拥有自己的作用域，只能使用data传入的数据。</p>
<p>（1）定义模板：使用name属性，作为模板的名字，然后在<code>&lt;template/&gt;</code>内定义代码片段。如下：</p>
<pre><code>&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; {{index}}: {{msg}} &lt;/text&gt;
    &lt;text&gt; Time: {{time}} &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;
</code></pre><p>（2）使用模板： 使用 <code>is</code>属性，声明需要使用的模板，然后将模板所需要的data传入。 <code>&lt;template is=&quot;msgItem&quot; data=&quot;{{...item}}&quot;/&gt;</code></p>
<pre><code>Page({
  data: {
    item: {
      index: 0,
      msg: &apos;this is a template&apos;,
      time: &apos;2016-09-15&apos;
    }
  }
})
</code></pre><p><code>is</code> 属性可以使用Mustache语法，来动态决定具体需要渲染哪个模板。</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;{{[1, 2, 3, 4, 5]}}&quot;&gt;
    &lt;template is=&quot;{item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;}}&quot;/&gt;
&lt;/block&gt;
</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>什么是事件：<br>    事件是视图层到逻辑层的通讯方式。<br>    事件可以将用户的行为反馈到逻辑层进行处理。<br>    事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。<br>    事件对象可以携带额外信息，如id, dataset, touches。 </p>
<p>（1）事件的使用方式 </p>
<ul>
<li><p>在组件中绑定一个事件处理函数，如 <code>bindtap</code>，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数。<br><code>&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;</code></p>
</li>
<li><p>在相应的Page定义中写上相应的事件处理函数，参数是event。</p>
<p>  Page({</p>
<pre><code>tapName: function(event) {
  console.log(event)
}
</code></pre><p>  })</p>
</li>
</ul>
<p>事件分为<strong>冒泡事件</strong>(当一个组件上的事件被触发后，该事件会向父节点传递)和<strong>非冒泡事件</strong>(当一个组件上的事件被触发后，该事件不会向父节点传递),WXML的冒泡事件列表如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/WXML%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6%E5%88%97%E8%A1%A8.png" alt="WXML冒泡事件列表"></p>
<p>tips：除上表之外的其他组件自定义事件都是非冒泡事件，如<code>&lt;form/&gt;</code>的submit事件，<code>&lt;input/&gt;</code>的input事件，<code>&lt;scroll-view/&gt;</code>的scroll事件。</p>
<p>（2）事件的绑定</p>
<p>事件绑定的写法同组件的属性，以key、value的形式。 key以<code>bind</code>或<code>catch</code>开头，然后跟上事件的类型，如<code>bindtap</code>, <code>catchtouchstart</code>。 value是一个字符串，需要在对应的Page中定义同名的函数。不然当触发事件的时候会报错。 </p>
<p><code>bind</code>事件绑定不会阻止冒泡事件向上冒泡，<code>catch</code>事件绑定可以阻止冒泡事件向上冒泡。例如，如在下边这个例子中，点击inner view会先后触发<code>handleTap3</code>和<code>handleTap2</code>(因为tap事件会冒泡到middle view，而middle view阻止了tap事件冒泡，不再向父节点传递)，点击middle view会触发<code>handleTap2</code>，点击outter view会触发<code>handleTap1</code>。</p>
<pre><code>&lt;view id=&quot;outter&quot; bindtap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>（3）事件对象</p>
<p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。事件对象属性如下：<br><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8.png" alt="事件对象属性"></p>
<p>在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。书写方式：以<code>data-</code>开头，多个单词由连字符<code>-</code>链接，不能有大写(大写会自动转成小写)如<code>data-element-type</code>，最终在 <code>event.target.dataset</code> 中会将连字符转成驼峰elementType。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>WXML提供两种文件引用方式<code>import</code>和<code>include</code>。</p>
<p>（1）import</p>
<p>import可以在该文件中使用目标文件定义的template。 import有作用域的概念，即只会import目标文件中定义的template，而不会import目标文件import的template。</p>
<p>（2）include</p>
<p>include可以将目标文件除了<code>&lt;template/&gt;</code>的整个代码引入，相当于是拷贝到include位置。（感觉有点ejs中模板include的感觉）</p>
<h2 id="WXS"><a href="#WXS" class="headerlink" title="WXS"></a>WXS</h2><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。</p>
<p>注意:</p>
<pre><code>wxs 不依赖于运行时的基础库版本，可以在所有版本的小程序中运行。
wxs 与 javascript 是不同的语言，有自己的语法，并不和 javascript 一致。
wxs 的运行环境和其他 javascript 代码是隔离的，wxs 中不能调用其他 javascript 文件中定义的函数，也不能调用小程序提供的API。
wxs 函数不能作为组件的事件回调。
由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。在 android 设备上二者运行效率无差异。
</code></pre><p>wxs用于页面渲染的使用示例，页面输出 hello world：</p>
<pre><code>&lt;!--wxml--&gt;
&lt;wxs module=&quot;m1&quot;&gt;
var msg = &quot;hello world&quot;;

module.exports.message = msg;
&lt;/wxs&gt;

&lt;view&gt; {{m1.message}} &lt;/view&gt;
</code></pre><p>wxs还可用于数据处理。</p>
<h3 id="WXS模块"><a href="#WXS模块" class="headerlink" title="WXS模块"></a>WXS模块</h3><p>WXS 代码可以编写在 wxml 文件中的 <code>&lt;wxs&gt;</code> 标签内，或以 .wxs 为后缀名的文件内。</p>
<pre><code>每一个 .wxs 文件和 &lt;wxs&gt; 标签都是一个单独的模块。
每个模块都有自己独立的作用域。即在一个模块里面定义的变量与函数，默认为私有的，对其他模块不可见。
一个模块要想对外暴露其内部的私有变量与函数，只能通过 module.exports 实现。
</code></pre><p>每个 wxs 模块均有一个内置的 module 对象,通过exports属性，可以对外共享本模块的私有变量与函数。</p>
<p>在.wxs模块中引用其他 wxs 文件模块，可以使用 require 函数。引用的时候，要注意如下几点：</p>
<pre><code>只能引用 .wxs 文件模块，且必须使用相对路径。
wxs 模块均为单例，wxs 模块在第一次被引用时，会自动初始化为单例对象。多个页面，多个地方，多次引用，使用的都是同一个 wxs 模块对象。
如果一个 wxs 模块在定义之后，一直没有被引用，则该模块不会被解析与运行。
</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>WXS 中的变量均为值的引用。
没有声明的变量直接赋值使用，会被定义为全局变量。
如果只声明变量而不赋值，则默认值为 undefined。
var表现与javascript一致，会有变量提升。
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释 <code>//</code> 多行注释<code>/* */</code></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>WXS 语言目前共有以下几种数据类型：</p>
<pre><code>number ： 数值
string ：字符串
boolean：布尔值
object：对象
function：函数
array : 数组
date：日期
regexp：正则
</code></pre><p>(1)number 整数、小数</p>
<p>方法：</p>
<pre><code>toString
toLocaleString
valueOf
toFixed
toExponential
toPrecision
</code></pre><p>(2)string </p>
<p>方法:</p>
<pre><code>toString
valueOf
charAt
charCodeAt
concat
indexOf
lastIndexOf
localeCompare
match
replace
search
slice
split
substring
toLowerCase
toLocaleLowerCase
toUpperCase
toLocaleUpperCase
trim
</code></pre><p>(3)boolean</p>
<p>方法:</p>
<pre><code>toString
valueOf
</code></pre><p>(4)object</p>
<p>方法:</p>
<pre><code>toString：返回字符串 &quot;[object Object]&quot;
</code></pre><p>(5)function</p>
<p>方法:</p>
<pre><code>toString：返回字符串 &quot;[function Function]&quot;。
</code></pre><p>(6)array</p>
<p>方法:</p>
<pre><code>toString
concat
join
pop
push
reverse
shift
slice
sort
splice
unshift
indexOf
lastIndexOf
every
some
forEach
map
filter
reduce
reduceRight
</code></pre><p>(7)date </p>
<p>生成 date 对象需要使用 getDate()函数, 返回一个当前时间的对象。date类型还有很多<a href="https://www.w3cschool.cn/weixinapp/weixinapp-54te2czr.html" target="_blank" rel="noopener">方法</a>。</p>
<p>(8)regexp </p>
<p>生成 regexp 对象需要使用 getRegExp()函数。 方法有<code>exec</code>、<code>test</code>、<code>toString</code>。</p>
<p>tips: 数据类型的判断可以使用 constructor 属性。使用 typeof 也可以区分部分数据类型。</p>
<h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><p>WXSS(WeiXin Style Sheets)是一套样式语言，用于描述WXML的组件样式。WXSS具有CSS大部分特性。同时为了更适合开发微信小程序，对CSS进行了扩充以及修改。扩展的特性有尺寸单位、样式导入。</p>
<p>尺寸单位：px（responsive pixel），可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在iPhone6上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像。</p>
<p>样式导入：使用@import语句可以导入外联样式表，@import跟需要导入的外联样式表的相对路径（相对路径放在引号中），用<code>;</code>表示语句结束。</p>
<p>内联样式：框架组件上支持使用style、class属性来控制组件的样式。</p>
<ul>
<li>style：静态的样式统一写到class中。style接收动态的样式，在运行时会进行解析，尽量避免将静态的样式写进style中，以免影响渲染速度。<br><code>&lt;view style=&quot;color:{{color}};&quot; /&gt;</code></li>
</ul>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/WXSS%E7%9B%AE%E5%89%8D%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="WXSS目前支持的选择器"></p>
<h1 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h1><p>小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。</p>
<p>可以通过<code>wx.getSystemInfo</code>或者<code>wx.getSystemInfoSync</code>获取到小程序的基础库版本号。也可以通过 <code>wx.canIUse</code> 来判断是否可以在该基础库版本下直接使用对应的API或者组件。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>对于新增的 API，可以用以下代码来判断是否支持用户的手机。</p>
<pre><code>if (wx.openBluetoothAdapter) {
  wx.openBluetoothAdapter()
} else {
  // 如果希望用户在最新版本的客户端上体验您的小程序，可以这样子提示
  wx.showModal({
    title: &apos;提示&apos;,
    content: &apos;当前微信版本过低，无法使用该功能，请升级到最新微信版本后重试。&apos;
  })
}
</code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>对于 API 的参数或者返回值有新增的参数，可以用以下代码判断。</p>
<pre><code>wx.showModal({
  success: function(res) {
    if (wx.canIUse(&apos;showModal.cancel&apos;)) {
      console.log(res.cancel)
    }
  }
})
</code></pre><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>对于组件，新增的属性在旧版本上不会被处理，不过也不会报错。如果特殊场景需要对旧版本做一些降级处理，可以这样子做。</p>
<pre><code>Page({
  data: {
    canIUse: wx.canIUse(&apos;button.open-type.contact&apos;)
  }
})
&lt;!-- wxml --&gt;
&lt;button wx:if=&quot;{{canIUse}}&quot; open-type=&quot;contact&quot;&gt; 客服消息 &lt;/button&gt;
&lt;contact-button wx:else&gt;&lt;/contact-button&gt;
</code></pre><h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><pre><code>小程序没有重启的概念
当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是5分钟）会被微信主动销毁
置顶的小程序不会被微信主动销毁
当收到系统内存告警也会进行小程序的销毁
</code></pre><p>再次打开逻辑： 基础库 1.4.0 开始支持，低版本需做兼容处理。</p>
<pre><code>用户打开小程序的预期有以下两类场景：
A. 打开首页： 场景值有 1001, 1019, 1022, 1023, 1038, 1056
B. 打开小程序指定的某个页面： 场景值为除 A 以外的其他
</code></pre><p><img src="http://ou3oh86t1.bkt.clouddn.com/smallProgram/images/%E5%86%8D%E6%AC%A1%E6%89%93%E5%BC%80%E9%80%BB%E8%BE%91.png" alt="再次打开逻辑"></p>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>setData是小程序开发中使用最频繁的接口，也是最容易引发性能问题的接口。</p>
<p><code>setData</code>工作原理：</p>
<p>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的evaluateJavascript所实现。即用户传输的数据(由视图层去往逻辑层)，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p>
<p>而evaluateJavascript的执行会受很多方面的影响，数据到达视图层并不是实时的。同一进程内的 WebView 实际上会共享一个 JS VM，如果 WebView 内 JS 线程正在执行渲染或其他逻辑，会影响 evaluateJavascript 脚本的实际执行时间，另外多个 WebView 也会抢占 JS VM 的执行权限；另外还有 JS 本身的编译执行耗时，都是影响数据传输速度的因素。</p>
<h2 id="常见的-setData-操作错误"><a href="#常见的-setData-操作错误" class="headerlink" title="常见的 setData 操作错误"></a>常见的 setData 操作错误</h2><p>(1)频繁的去 setData。 Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重；渲染有出现延时。</p>
<p>(2) 每次 setData 都传递大量新数据。</p>
<p>(3)后台态页面进行 setData。</p>
<h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><p>图片资源的主要性能问题在于大图片和长列表图片上，这两种情况都有可能导致 iOS 客户端内存占用上升，从而触发系统回收小程序页面。除了内存问题外，大图片也会造成页面切换的卡顿。</p>
<h2 id="代码包大小的优化"><a href="#代码包大小的优化" class="headerlink" title="代码包大小的优化"></a>代码包大小的优化</h2><p>小程序一开始时代码包限制为 1MB，后增加到 2MB 。代码包上限的增加对于开发者来说，能够实现更丰富的功能，但对于用户来说，也增加了下载流量和本地空间的占用。</p>
<p><strong>控制代码包内图片资源：</strong> 小程序代码包经过编译后，会放在微信的 CDN 上供用户下载，CDN 开启了 GZIP 压缩，所以用户下载的是压缩后的 GZIP 包，其大小比代码包原体积会更小。 GZIP 对基于文本资源的压缩效果最好，在压缩较大文件时往往可高达 70%-80% 的压缩率，而如果对已经压缩的资源（例如大多数的图片格式）则效果甚微。</p>
<p><strong>及时清理没有使用到的代码和资源：</strong> 在日常开发的时候，我们可能引入了一些新的库文件，而过了一段时间后，由于各种原因又不再使用这个库了，我们常常会只是去掉了代码里的引用，而忘记删掉这类库文件了。目前小程序打包是会将工程下所有文件都打入代码包内，也就是说，这些没有被实际使用到的库文件和资源也会被打入到代码包里，从而影响到整体代码包的大小。</p>
<h1 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h1><p>框架为开发者提供了一系列<a href="https://www.w3cschool.cn/weixinapp/itz51q8o.html" target="_blank" rel="noopener">基础组件</a>，开发者可以通过组合这些基础组件进行快速开发。</p>
<pre><code>组件是视图层的基本组成单元。
组件自带一些功能与微信风格的样式。
一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。
</code></pre><p>注意：所有组件与属性都是小写，以连字符-连接。</p>
<p>基础组件分为以下八大类：</p>
<p><strong>视图容器</strong>： <code>view</code>(视图容器)、 <code>scroll-view</code>（可滚动视图容器）、 <code>swiper</code>(可滑动视图容器)</p>
<p><strong>基础内容</strong>： <code>icon</code>(图标)、  <code>text</code>(文字)、  <code>progress</code>(进度条)</p>
<p><strong>表单</strong>：</p>
<pre><code>button     按钮
form     表单
input     输入框
checkbox     多项选择器
radio     单项选择器
picker     列表选择器
picker-view     内嵌列表选择器
slider     滑动选择器
switch     开关选择器
label   标签
</code></pre><p><strong>导航</strong>： <code>navigator</code>(应用内跳转)</p>
<p><strong>多媒体</strong>： </p>
<pre><code>audio     音频
image     图片
video     视频
</code></pre><p><strong>地图</strong>： <code>map</code>(地图)</p>
<p><strong>画布</strong>： <code>canvas</code>(画布)</p>
<p><strong>客服会话</strong>： <code>contact-button</code>(进入客服会话按钮)</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>框架提供丰富的微信原生API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<pre><code>wx.on开头的API是监听某个事件发生的API接口，接受一个CALLBACK函数作为参数。当该事件触发时，会调用CALLBACK函数。
如未特殊约定，其他API接口都接受一个OBJECT作为参数。
OBJECT中可以指定success,fail,complete来接收接口调用结果。
</code></pre><h3 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h3><pre><code>wx.request      发起网络请求
wx.uploadFile      上传文件
wx.downloadFile      下载文件
wx.connectSocket    创建WebSocket连接
wx.onSocketOpen      监听WebSocket打开
wx.onSocketError    监听WebSocket错误
wx.sendSocketMessage    发送WebSocket消息
wx.onSocketMessage      接受WebSocket消息
wx.closeSocket      关闭WebSocket连接
wx.onSocketClose    监听WebSocket关闭
</code></pre><h3 id="媒体API"><a href="#媒体API" class="headerlink" title="媒体API"></a>媒体API</h3><pre><code>wx.chooseImage    从相册选择图片，或者拍照
wx.previewImage    预览图片
wx.startRecord    开始录音
wx.stopRecord    结束录音
wx.playVoice    播放语音
wx.pauseVoice    暂停播放语音
wx.stopVoice    结束播放语音
wx.getBackgroundAudioPlayerState    获取音乐播放状态
wx.playBackgroundAudio    播放音乐
wx.pauseBackgroundAudio    暂停播放音乐
wx.seekBackgroundAudio    控制音乐播放进度
wx.stopBackgroundAudio    停止播放音乐
wx.onBackgroundAudioPlay    监听音乐开始播放
wx.onBackgroundAudioPause    监听音乐暂停
wx.onBackgroundAudioStop    监听音乐结束
wx.chooseVideo    从相册选择视频，或者拍摄
</code></pre><h3 id="文件API"><a href="#文件API" class="headerlink" title="文件API"></a>文件API</h3><pre><code>wx.saveFile    保存文件
wx.getSavedFileList    获取已保存的文件列表
wx.getSavedFileInfo    获取已保存的文件信息
wx.removeSavedFile    删除已保存的文件信息
wx.openDocument    打开文件
</code></pre><h3 id="数据API"><a href="#数据API" class="headerlink" title="数据API"></a>数据API</h3><pre><code>wx.getStorage    获取本地数据缓存
wx.getStorageSync    获取本地数据缓存
wx.setStorage    设置本地数据缓存
wx.setStorageSync    设置本地数据缓存
wx.getStorageInfo    获取本地缓存的相关信息
wx.getStorageInfoSync    获取本地缓存的相关信息
wx.removeStorage    删除本地缓存内容
wx.removeStorageSync    删除本地缓存内容
wx.clearStorage    清理本地数据缓存
wx.clearStorageSync    清理本地数据缓存
</code></pre><h3 id="位置API"><a href="#位置API" class="headerlink" title="位置API"></a>位置API</h3><pre><code>wx.getLocation    获取当前位置
wx.chooseLocation    打开地图选择位置
wx.openLocation    打开内置地图
wx.createMapContext    地图组件控制
</code></pre><h3 id="设备API"><a href="#设备API" class="headerlink" title="设备API"></a>设备API</h3><pre><code>wx.getNetworkType    获取网络类型
wx.onNetworkStatusChange    监听网络状态变化
wx.getSystemInfo    获取系统信息
wx.getSystemInfoSync    获取系统信息
wx.onAccelerometerChange    监听加速度数据
wx.startAccelerometer    开始监听加速度数据
wx.stopAccelerometer    停止监听加速度数据
wx.onCompassChange    监听罗盘数据
wx.startCompass    开始监听罗盘数据
wx.stopCompass    停止监听罗盘数据
wx.setClipboardData    设置剪贴板内容
wx.getClipboardData    获取剪贴板内容
wx.makePhoneCall    拨打电话
wx.scanCode    扫码
</code></pre><h3 id="界面API"><a href="#界面API" class="headerlink" title="界面API"></a>界面API</h3><pre><code>wx.showToast    显示提示框
wx.showLoading    显示加载提示框
wx.hideToast    隐藏提示框
wx.hideLoading    隐藏加载提示框
wx.showModal    显示模态弹窗
wx.showActionSheet    显示菜单列表
wx.setNavigationBarTitle    设置当前页面标题
wx.showNavigationBarLoading    显示导航条加载动画
wx.hideNavigationBarLoading    隐藏导航条加载动画
wx.navigateTo    新窗口打开页面
wx.redirectTo    原窗口打开页面
wx.switchTab    切换到 tabbar 页面
wx.navigateBack    退回上一个页面
wx.createAnimation    动画
wx.createCanvasContext    创建绘图上下文
wx.drawCanvas    绘图
wx.stopPullDownRefresh    停止下拉刷新动画
</code></pre><h3 id="WXML节点信息API"><a href="#WXML节点信息API" class="headerlink" title="WXML节点信息API"></a>WXML节点信息API</h3><pre><code>wx.createSelectorQuery    创建查询请求
selectorQuery.select    根据选择器选择单个节点
selectorQuery.selectAll    根据选择器选择全部节点
selectorQuery.selectViewport    选择显示区域
nodesRef.boundingClientRect    获取布局位置和尺寸
nodesRef.scrollOffset    获取滚动位置
nodesRef.fields    获取任意字段
selectorQuery.exec    执行查询请求
</code></pre><h3 id="开放接口"><a href="#开放接口" class="headerlink" title="开放接口"></a>开放接口</h3><pre><code>wx.login    登录
wx.getUserInfo    获取用户信息
wx.chooseAddress    获取用户收货地址
wx.requestPayment    发起微信支付
wx.addCard    添加卡券
wx.openCard    打开卡券
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小程序开发文档的简要概括。&lt;br&gt;
    
    </summary>
    
      <category term="wechat_smallProgram" scheme="http://yoursite.com/categories/wechat-smallProgram/"/>
    
    
      <category term="wechat_smallProgram" scheme="http://yoursite.com/tags/wechat-smallProgram/"/>
    
  </entry>
  
  <entry>
    <title>2018春招研发岗在线模拟笔试编程题总结</title>
    <link href="http://yoursite.com/2018/03/24/2018-Tencent-spring-programming-simulation/"/>
    <id>http://yoursite.com/2018/03/24/2018-Tencent-spring-programming-simulation/</id>
    <published>2018-03-24T06:52:04.000Z</published>
    <updated>2018-03-27T01:04:04.751Z</updated>
    
    <content type="html"><![CDATA[<p>2018春季腾讯研发岗在线模拟笔试算法题目总结。<br><a id="more"></a></p>
<h3 id="给出四个点的坐标判断是否为正方形"><a href="#给出四个点的坐标判断是否为正方形" class="headerlink" title="给出四个点的坐标判断是否为正方形"></a>给出四个点的坐标判断是否为正方形</h3><p>思路：暴力方法，求出任意两点之间的距离，如果有四条相等，剩下两条距离相等，则构成正方形。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">      <span class="comment">//给出四个点的坐标，判断这四个点能否构成一个正方形，其中四个点的横坐标存在x数组中，与横坐标对应的纵坐标存在y数组中</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">judgeSquare</span>(<span class="params">x, y</span>) </span>&#123; </div><div class="line">          <span class="keyword">var</span> dists = []; <span class="comment">//用来存放四边形任意两点之间的距离</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">              <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">                  <span class="keyword">var</span> dist = distance(x[i], y[i], x[j], y[j]);</div><div class="line">                  dists.push(dist);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          dists = dists.sort();</div><div class="line">          <span class="keyword">if</span> (dists[<span class="number">0</span>] === dists[<span class="number">1</span>] &amp;&amp; dists[<span class="number">1</span>] === dists[<span class="number">2</span>] &amp;&amp; dists[<span class="number">2</span>] === dists[<span class="number">3</span>] &amp;&amp; dists[<span class="number">4</span>] === dists[<span class="number">5</span>]) &#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'Yes, this is a square!'</span>);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line"><span class="comment">// distance表示两点之间距离的平方</span></div><div class="line">      <span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1, y1, x2, y2</span>) </span>&#123; <span class="comment">//参数x1,y1和x2,y2分别表示两个点的横纵坐标</span></div><div class="line">          <span class="keyword">var</span> distance = <span class="built_in">Math</span>.pow(x1 - x2, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(y1 - y2, <span class="number">2</span>);</div><div class="line">          <span class="keyword">return</span> distance;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">var</span> xArr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>];</div><div class="line">      <span class="keyword">var</span> yArr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>];</div><div class="line">      judgeSquare(xArr, yArr); <span class="comment">//Yes, this is a square!</span></div></pre></td></tr></table></figure>
<h3 id="2-k面值的n组合问题"><a href="#2-k面值的n组合问题" class="headerlink" title="2^k面值的n组合问题"></a>2^k面值的n组合问题</h3><p>问题描述：（记不清了，大概是这样,k和n的上限也记不得了，只记录下实现思路）有面值分别为2^k的硬币各2枚(k&gt;=0，且k为整数)，现在要买n元的东西，问有多少种不同的硬币组合方式？</p>
<p>思路：从最小面额的开始考虑，</p>
<p>(1)如果给出的n元是偶数，那么又分为花掉面额为1的(如果花掉面额为1的肯定是花掉2个)，和不花掉面额为1的。</p>
<p>如果花掉两个面额为1的，那么问题的规模就缩小为求n-2的组合情况(即n-2要用2，4，8…来组合，因为此时1已经用光了)，又因为n-2也是个偶数，所以可以对半分，即(n-2)/2用1，2，4，8…来组合，可以用递归了。</p>
<p>如果不花掉面额为1的，那么从面额2开始花起，又n为偶数，所以问题的规模可以对半分为，求n/2用 1，2，4，8…来组合，可以用递归了。</p>
<p>(2)如果给出的n元是奇数，那么肯定要花掉一个面额为1的，那么n-1是个偶数，此时已经不能再花面额为1的了，即n是奇数的时候只能花掉一个面额为1的，所以问题规模就变成了n-1用面额为2，4，8…来组合，即问题规模折半为(n-1)/2用1，2，4，8…来组合，可以用递归了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">    <span class="comment">// 初始条件</span></div><div class="line">    <span class="comment">// if (n === 1) &#123;</span></div><div class="line">    <span class="comment">//     return 1;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="comment">// if (n === 2) &#123;</span></div><div class="line">    <span class="comment">//     return 2;</span></div><div class="line">    <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 先判断n的奇偶性</span></div><div class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> === <span class="number">0</span>) &#123; <span class="comment">//n为偶数</span></div><div class="line">        <span class="keyword">return</span> combination((n - <span class="number">2</span>) / <span class="number">2</span>) + combination(n / <span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> combination((n - <span class="number">1</span>) / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">combination(<span class="number">12</span>); <span class="comment">//5</span></div></pre></td></tr></table></figure>
<h3 id="头条：-打印一行数字的字符串形式"><a href="#头条：-打印一行数字的字符串形式" class="headerlink" title="头条： 打印一行数字的字符串形式"></a>头条： 打印一行数字的字符串形式</h3><p>思路：将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式，然后一行一行的打印（总共打印五行，因为每个数字用五行字符串描述），每一行由给出的数组中的数字的第i行的字符串形式拼接起来再打印。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">//将0-9的数字的打印形式保存成一个二维数组，例如num[0]中保存了数字0一到第五行的打印字符串形式</span></div><div class="line">   <span class="keyword">var</span> num = [[<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'6...6'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6....'</span>, <span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>, <span class="string">'....6'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>],</div><div class="line">              [<span class="string">'66666'</span>, <span class="string">'6...6'</span>, <span class="string">'66666'</span>, <span class="string">'....6'</span>, <span class="string">'66666'</span>]];</div><div class="line">   <span class="keyword">var</span> numArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]; <span class="comment">//测试数组</span></div><div class="line">   <span class="comment">// 一行一行的打印，每个数字用五行表示，每两个数字之间用两个点点分隔开</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</div><div class="line">       <span class="keyword">var</span> resultStr = <span class="string">''</span>; <span class="comment">//保存每一行结果的字符串</span></div><div class="line">       <span class="comment">// 将第numArr中的numArr.length个数字的第i行拼接起来并打印</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; numArr.length; j ++) &#123;</div><div class="line">           resultStr += num[numArr[j]][i] + <span class="string">'..'</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 每一行最后会多两个点点，截取掉</span></div><div class="line">       <span class="keyword">var</span> len = resultStr.length - <span class="number">2</span>;</div><div class="line">       <span class="built_in">console</span>.log(resultStr.substring(<span class="number">0</span>, len));</div><div class="line">   &#125;</div><div class="line"><span class="comment">//打印结果</span></div><div class="line"><span class="number">66666.</span>....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.6</span>.....<span class="number">.6</span>.........<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div><div class="line"><span class="number">6.</span>.<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>.........<span class="number">.6</span>.....<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.....<span class="number">.6</span>.<span class="number">.6</span>..<span class="number">.6</span>.....<span class="number">.6</span></div><div class="line"><span class="number">66666.</span>....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span>.....<span class="number">.6</span>.<span class="number">.66666</span>.<span class="number">.66666</span></div></pre></td></tr></table></figure>
<h3 id="百词斩：-找一个字符串中包含的最大数"><a href="#百词斩：-找一个字符串中包含的最大数" class="headerlink" title="百词斩： 找一个字符串中包含的最大数"></a>百词斩： 找一个字符串中包含的最大数</h3><p>问题描述： 给出一个字符串，例如<code>&#39;helloworld520helloworld1314&#39;</code>，找出字符串中包含的最大数字，即输出为<code>1314</code>。</p>
<p>思路：利用正则表达式，先把字符串中的连续数字子串提取出来放到数组中，然后再求这个数字字符串数组中的最大数字。</p>
<p>注意：正则表达式的全局标志<code>g</code>一定要加上，不然只会找到第一个匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">searchMaxNum</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> reg = <span class="regexp">/([0-9]+)/g</span>; <span class="comment">//正则表达式，匹配字符串中的连续数字子串，并使用String的match方法将捕获组返回至numArr数组中</span></div><div class="line">    <span class="keyword">var</span> numArr = string.match(reg); <span class="comment">//numArr中的元素类型为字符串，即numAr为数字字符串数组</span></div><div class="line">    <span class="keyword">var</span> maxNum = numArr[<span class="number">0</span>] - <span class="number">0</span>; <span class="comment">//将数字字符串转换为数值类型</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numArr.length; i ++) &#123; <span class="comment">//找出numArr数字字符串数组中的最大值</span></div><div class="line">        <span class="keyword">var</span> tempNum = numArr[i] - <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (tempNum &gt;= maxNum) &#123;</div><div class="line">            maxNum = tempNum;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(maxNum);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> string = <span class="string">'helloworld520helloworld1314'</span>;</div><div class="line">searchMaxNum(string); <span class="comment">//返回 1314</span></div></pre></td></tr></table></figure>
<h3 id="百词斩-压缩连续数字1-7"><a href="#百词斩-压缩连续数字1-7" class="headerlink" title="百词斩: 压缩连续数字1-7"></a>百词斩: 压缩连续数字1-7</h3><p>问题描述： 给出一个由数字1-7组成的有序数字字符串(分别代表星期一~星期天)，若这个数字字符串有三个或三个以上连续的数字，例如<code>234</code>，则返回其压缩形式<code>2-4</code>(由该段连续数字的首尾中间加一根短横线组成)，若连续的数字长度小于等于二，则将该数字直接返回就好，不用压缩。</p>
<p>例如给定输入 <code>124567</code>，则输出为<code>1,2,4-7</code>。 若给定输入<code>12</code>，则输出为<code>1,2</code>。</p>
<p>思路：(1)如果给定的字符串长度小于等于2，则直接在这段字符串中间加一个逗号 <code>,</code>返回即可。</p>
<p>(2)若给定的字符串长度大于2，先将数字字符串转化为数字数组，再将该数组中连续的数字提取出来放到一个二维数组中，再将数组中字符串元素处理拼接。即判断该二维数组中元素的长度，若数组中元素的长度小于2，则直接加逗号拼接，若元素长度大于2，则写成压缩形式(用该元素的首尾再加短横线)拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressStr</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> resultStr = <span class="string">''</span>; <span class="comment">//压缩后的字符串，即输出结果</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (str.length &lt;= <span class="number">2</span>) &#123; <span class="comment">//如果输入字符串长度&lt;=2，则直接中间加逗号返回</span></div><div class="line">            resultStr = str.split(<span class="string">""</span>).join(<span class="string">","</span>);</div><div class="line">            <span class="built_in">console</span>.log(resultStr);</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//输入字符串长度&gt;=3</span></div><div class="line">            <span class="comment">// 先将数字字符串转化为数值类型并存进数组</span></div><div class="line">            <span class="keyword">var</span> numArr = [];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i ++) &#123;</div><div class="line">                numArr.push(str[i] - <span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// 将数组numArr中的连续数字提取出来放进一个二维数组</span></div><div class="line">            <span class="keyword">var</span> twoDimArr = extractContinuity(numArr);</div><div class="line"></div><div class="line">            <span class="comment">// 处理二维数组twoDimArr</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; twoDimArr.length; i ++) &#123;</div><div class="line">                <span class="keyword">var</span> len = twoDimArr[i].length; <span class="comment">//二维数组元素的长度</span></div><div class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">2</span>) &#123;</div><div class="line">                    resultStr = resultStr + twoDimArr[i].join(<span class="string">','</span>) + <span class="string">','</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    resultStr = resultStr + twoDimArr[i][<span class="number">0</span>] + <span class="string">'-'</span> + twoDimArr[i][len<span class="number">-1</span>] + <span class="string">','</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            resultStr = resultStr.substring(<span class="number">0</span>, resultStr.length - <span class="number">1</span>); <span class="comment">//去掉最后多出的一个逗号</span></div><div class="line">            <span class="built_in">console</span>.log(resultStr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断一个数组的数字是否连续，将连续的数字提取出来转化为一个二维数组</span></div><div class="line">    <span class="comment">// 例如[3, 4, 13 ,14, 15, 17, 20, 22] 转化为 [[3,4],[13,14,15],[17],[20],[22]]</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">extractContinuity</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> result = [];</div><div class="line">        <span class="keyword">var</span> temp;</div><div class="line">        <span class="keyword">while</span> (temp = arr.shift()) &#123;</div><div class="line">            <span class="keyword">if</span> (result.length === <span class="number">0</span>) &#123; <span class="comment">//如果二维数组为空，则直接将arr的第一个数字push进该二维数组</span></div><div class="line">                result.push([temp]);</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> element = result[result.length - <span class="number">1</span>]; <span class="comment">//二维数组中的最后一个元素</span></div><div class="line">            <span class="keyword">if</span> (temp === element[element.length - <span class="number">1</span>] + <span class="number">1</span>) &#123;</div><div class="line">                element.push(temp);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                result.push([temp]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> string = <span class="string">'12367'</span>;</div><div class="line">    compressStr(string); <span class="comment">//输出 '1-3,6,7'</span></div></pre></td></tr></table></figure>
<h3 id="百词斩：-给出一组数字的从小到大的全排列形式"><a href="#百词斩：-给出一组数字的从小到大的全排列形式" class="headerlink" title="百词斩： 给出一组数字的从小到大的全排列形式"></a>百词斩： 给出一组数字的从小到大的全排列形式</h3><p>问题描述：给出一个数字数组，数组里的数字各不相同，例如[3, 1, 5],给出这几个数字的全排列并按从小到大的形式输出，即输出为 135,153,315,351,513,531。</p>
<p>思路：从数组的数字里面任意选一个，放在第一项,然后将剩下的数字递归全排。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullSort</span>(<span class="params">arr</span>)  </span>&#123;</div><div class="line">    <span class="keyword">var</span> arr = arr.sort(); <span class="comment">//先将数组排序</span></div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) &#123;</div><div class="line">        result.push(arr);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</div><div class="line">        <span class="keyword">var</span> temp = [];</div><div class="line">        temp.push(arr[i]); <span class="comment">//取arr的任意一项放到temp的第一项</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> remain = arr.slice(<span class="number">0</span>); <span class="comment">//深复制原数组到remain</span></div><div class="line">        remain.splice(i, <span class="number">1</span>); <span class="comment">//去掉temp中的那一项</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> temp2 = fullSort(remain).concat(); <span class="comment">//将剩下的项全排列，返回[[3,5],[5,3]]这样的数据</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; temp2.length; j ++) &#123;</div><div class="line">            temp2[j].unshift(temp[<span class="number">0</span>]); <span class="comment">//得到[[1,3,5],[1,5,3]]这样的数据</span></div><div class="line">            result.push(temp2[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> resultArr = fullSort(arr);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; resultArr.length; i ++) &#123;</div><div class="line">    <span class="keyword">var</span> num = resultArr[i].join(<span class="string">""</span>) - <span class="number">0</span>;</div><div class="line">    <span class="built_in">console</span>.log(num);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="number">135</span></div><div class="line"><span class="number">153</span></div><div class="line"><span class="number">315</span></div><div class="line"><span class="number">351</span></div><div class="line"><span class="number">513</span></div><div class="line"><span class="number">531</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018春季腾讯研发岗在线模拟笔试算法题目总结。&lt;br&gt;
    
    </summary>
    
      <category term="js算法题" scheme="http://yoursite.com/categories/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="js算法题" scheme="http://yoursite.com/tags/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>汉诺塔递归算法JS实现</title>
    <link href="http://yoursite.com/2018/03/13/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/03/13/汉诺塔递归算法JS实现/</id>
    <published>2018-03-13T03:25:25.000Z</published>
    <updated>2018-03-13T06:05:45.270Z</updated>
    
    <content type="html"><![CDATA[<p>递归把一组问题分解为一组相似的子问题，每一个问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。<br><a id="more"></a></p>
<h2 id="“汉诺塔问题”描述"><a href="#“汉诺塔问题”描述" class="headerlink" title="“汉诺塔问题”描述"></a>“汉诺塔问题”描述</h2><p>塔上有三根柱子和一套直径各不相同的空心圆盘，开始时源柱子上的所有圆盘都按从大到小的顺序排列。目标是通过每一次移动一个圆盘到另一根柱子上，最终把一堆圆盘移动到目标柱子上，过程中不允许把较大的圆盘放置在较小的圆盘上；</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/%E6%B1%89%E8%AF%BA%E5%A1%94%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="汉诺塔示意图"><br>当n=3时的移动如下：</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/n=3%E6%97%B6%E7%9A%84%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98.gif" alt="n=3时的汉诺塔问题"></p>
<p>把所有圆盘(n个)从A(src)移动到C(dst)。</p>
<p>(1) 当n=1时<br>第一次：1号 A -&gt; C</p>
<p>(2) 当n=2时<br>第一次： 1号 A -&gt; B<br>第二次:  2号 A -&gt; C<br>第三次： 1号 B -&gt; C</p>
<p>(3) 当n=3时<br>第一次： 1号 A -&gt; C<br>第二次： 2号 A -&gt; B<br>第三次： 1号 C -&gt; B<br>第四次： 3号 A -&gt; C<br>第五次： 1号 B -&gt; A<br>第六次： 2号 B -&gt; C<br>第七次： 1号 A -&gt; C</p>
<p>可发现移动次数与n的关系为：2^n - 1</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>实现这个算法可以简单分为三个步骤：<br>(1)把A上的 n-1 个圆盘借助辅助塔(C塔)由A移到B;<br>(2)把 n号(即最大的那个)由A移到C；<br>(3)把B上的 n-1 个圆盘借助辅助塔(A塔)由B移到C；</p>
<h2 id="javascript实现"><a href="#javascript实现" class="headerlink" title="javascript实现"></a>javascript实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js语言精粹 4.8递归 汉诺塔问题</span></div><div class="line"><span class="keyword">var</span> times = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params">n, src, aux, dist</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">        hanoi(n - <span class="number">1</span>, src, dist, aux); <span class="comment">//递归，把A(src)塔上编号1~n-1的圆盘移到B(aux)上，以C(dist)为辅助塔</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"第"</span> + (++times) + <span class="string">"次移动："</span> + n + <span class="string">"号盘从"</span> + src + <span class="string">"移到"</span> + dist); <span class="comment">//把A塔上编号为n的圆盘移到C上</span></div><div class="line">        hanoi(n - <span class="number">1</span>, aux, src, dist); <span class="comment">//递归，把B塔上编号1~n-1的圆盘移到C上，以A为辅助塔</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">hanoi(<span class="number">3</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);</div><div class="line"><span class="comment">//运行结果</span></div><div class="line">第<span class="number">1</span>次移动：<span class="number">1</span>号盘从A移到C</div><div class="line">第<span class="number">2</span>次移动：<span class="number">2</span>号盘从A移到B</div><div class="line">第<span class="number">3</span>次移动：<span class="number">1</span>号盘从C移到B</div><div class="line">第<span class="number">4</span>次移动：<span class="number">3</span>号盘从A移到C</div><div class="line">第<span class="number">5</span>次移动：<span class="number">1</span>号盘从B移到A</div><div class="line">第<span class="number">6</span>次移动：<span class="number">2</span>号盘从B移到C</div><div class="line">第<span class="number">7</span>次移动：<span class="number">1</span>号盘从A移到C</div></pre></td></tr></table></figure>
<h2 id="调用方法的栈机制"><a href="#调用方法的栈机制" class="headerlink" title="调用方法的栈机制"></a>调用方法的栈机制</h2><p>从主线程开始调用方法（函数）进行不停的压栈和出栈操作，函数的调用就是将函数压如栈中，函数的结束就是函数出栈的过程，这样就保证了方法调用的顺序流，即当函数出现多层嵌套时，需要从外到内一层层把函数压入栈中，最后栈顶的函数先执行结束（最内层的函数先执行结束）后出栈，再倒数第二层的函数执行结束出栈，到最后，第一个进栈的函数调用结束后从栈中弹出回到主线程，并且结束。</p>
<h2 id="图解程序运行流程"><a href="#图解程序运行流程" class="headerlink" title="图解程序运行流程"></a>图解程序运行流程</h2><p>(1)函数hanoi(n, A, B, C)的功能是把编号为n的圆盘借助B从A移到C上；<br>(2)函数move(n, M, N)的功能是把编号为n的圆盘从M移到N上；</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/demo/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95JS%E5%AE%9E%E7%8E%B0/images/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98n=3%E6%97%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="汉诺塔问题n=3时的运行流程"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归把一组问题分解为一组相似的子问题，每一个问题都用一个寻常解去解决。递归函数就是会直接或者间接调用自身的一种函数，一般来说，一个递归函数调用自身去解决它的子问题。在自己这个函数里有调用自己这个函数的语句，而这个调用怎么才能调用结束呢？，这里还必须有一个结束点，或者具体的说是在调用到某一次后函数能返回一个确定的值，接着倒数第二个就能返回一个确定的值，一直到第一次调用的这个函数能返回一个确定的值。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习from菜鸟教程</title>
    <link href="http://yoursite.com/2018/03/12/MongoDB%E5%AD%A6%E4%B9%A0from%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/12/MongoDB学习from菜鸟教程/</id>
    <published>2018-03-12T05:12:29.000Z</published>
    <updated>2018-03-12T07:31:14.101Z</updated>
    
    <content type="html"><![CDATA[<p>在学习<a href="https://github.com/nswbmw/N-blog" target="_blank" rel="noopener">《一起学 Node.js》</a>中，需要使用 Express + MongoDB 搭建多人博客，因此在<a href="http://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" rel="noopener">菜鸟MongoDB 教程</a>上学习总结MongoDB的基本用法。<br><a id="more"></a><br>MongoDB是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能, 为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。 字段值可以包含其他文档，数组及文档数组。<br>mongodb中基本的概念是文档、集合、数据库。一个mongodb中可以建立多个数据库。MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p>
<p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先cd到bin文件夹下，执行”mongo”启动客户端。<br>(1)<code>show dbs</code> 命令可以显示所有数据的列表。</p>
<pre><code>&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>(2)<code>db</code> 命令可以显示当前数据库对象或集合。</p>
<pre><code>&gt; db
test
</code></pre><p>(3)<code>use database_name</code>命令，可以连接到一个指定的数据库。</p>
<pre><code>&gt; use local
switched to db local
&gt; db
local
</code></pre><p>(4)<strong>数据库名命名规则：</strong>可以是满足以下条件的任意UTF-8字符串。</p>
<pre><code>不能是空字符串（&quot;&quot;)。
不得含有&apos; &apos;（空格)、.、$、/、\和\0 (空字符)。
应全部小写。
最多64字节
</code></pre><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p>
<pre><code>admin： 从权限的角度来看，这是&quot;root&quot;数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。
local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合
config: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。
</code></pre><p><strong>(5)文档</strong><br>文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。一个简单的文档如下所示：</p>
<pre><code>{&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;}

文档中的键/值对是有序的。
文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。
MongoDB区分类型和大小写。
MongoDB的文档不能有重复的键。
文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。
</code></pre><p>文档键命名规范：</p>
<pre><code>键不能含有\0 (空字符)。这个字符用来表示键的结尾。
.和$有特别的意义，只有在特定环境下才能使用。
以下划线&quot;_&quot;开头的键是保留的(不是严格要求的)。
</code></pre><p><strong>(6)集合</strong><br>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。<br>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。<br>可以将以下不同数据结构的文档插入到集合中：</p>
<pre><code>{&quot;site&quot;:&quot;www.baidu.com&quot;}
{&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;}
{&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5}
</code></pre><p>集合名命名规范：</p>
<pre><code>集合名不能是空字符串&quot;&quot;。
集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。
集合名不能以&quot;system.&quot;开头，这是为系统集合保留的前缀。
用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。
</code></pre><p>Capped collections 就是固定大小的collection。<br><strong>(7)元数据</strong><br>数据库的信息是存储在集合中。它们使用了系统的命名空间：<code>dbname.system.*</code></p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p><code>use DATABASE_NAME</code> 如果数据库不存在，则创建数据库，否则切换到指定数据库。</p>
<pre><code>&gt; use test
switched to db test
&gt; db
test
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>刚创建的test数据库不在数据库列表中，要显示它，必须插入一些数据。</p>
<pre><code>&gt; db.test.insert({&quot;name&quot;:&quot;hello&quot;})
WriteResult({ &quot;nInserted&quot; : 1 })
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
test    0.000GB
</code></pre><p>MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>先切换到要删除的数据库，再执行<code>db.dropDatabase()</code></p>
<pre><code>&gt; use test
switched to db test
&gt; db
test
&gt; db.dropDatabase()
{ &quot;dropped&quot; : &quot;test&quot;, &quot;ok&quot; : 1 }
&gt; show dbs
admin   0.000GB
config  0.000GB
local   0.000GB
</code></pre><p>关于MongoDB更详细的操作命令见菜鸟教程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在学习&lt;a href=&quot;https://github.com/nswbmw/N-blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《一起学 Node.js》&lt;/a&gt;中，需要使用 Express + MongoDB 搭建多人博客，因此在&lt;a href=&quot;http://www.runoob.com/mongodb/mongodb-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;菜鸟MongoDB 教程&lt;/a&gt;上学习总结MongoDB的基本用法。&lt;br&gt;
    
    </summary>
    
      <category term="MongoDB" scheme="http://yoursite.com/categories/MongoDB/"/>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库的安装及基本的使用方法</title>
    <link href="http://yoursite.com/2018/03/09/MySQL-install-and-usage/"/>
    <id>http://yoursite.com/2018/03/09/MySQL-install-and-usage/</id>
    <published>2018-03-09T02:37:30.000Z</published>
    <updated>2018-03-10T03:32:39.183Z</updated>
    
    <content type="html"><![CDATA[<p>关于MySQL数据库基本的安装和操作方法。<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL教程–菜鸟</a>。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装步骤可参考博客<a href="http://blog.csdn.net/pansanday/article/details/51321178" target="_blank" rel="noopener">mysql数据库下载、安装、使用</a>前部分，我选择安装的是MySQL Server组件，其他基本照着默认方式就好了。</p>
<h2 id="基本的使用方法"><a href="#基本的使用方法" class="headerlink" title="基本的使用方法"></a>基本的使用方法</h2><p>参考博客<a href="http://blog.csdn.net/whq19890827/article/details/48752517" target="_blank" rel="noopener"> MySql基本使用方法 </a>。</p>
<h3 id="1．显示当前数据库服务器中的数据库列表"><a href="#1．显示当前数据库服务器中的数据库列表" class="headerlink" title="1．显示当前数据库服务器中的数据库列表"></a>1．显示当前数据库服务器中的数据库列表</h3><p><code>mysql&gt; SHOW DATABASES;</code></p>
<pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
</code></pre><h3 id="2-显示某个数据库中的数据"><a href="#2-显示某个数据库中的数据" class="headerlink" title="2.显示某个数据库中的数据"></a>2.显示某个数据库中的数据</h3><pre><code>mysql&gt; USE 库名；//使用某个库
mysql&gt; SHOW TABLES；//列出库中所有的表
</code></pre><h3 id="3-显示数据表的结构"><a href="#3-显示数据表的结构" class="headerlink" title="3.显示数据表的结构"></a>3.显示数据表的结构</h3><pre><code>mysql&gt; DESCRIBE 表名；
</code></pre><h3 id="4-建立数据库"><a href="#4-建立数据库" class="headerlink" title="4.建立数据库"></a>4.建立数据库</h3><p> <code>mysql&gt; CREATE DATABASE 库名；</code> 例如新建一个名为test的数据库，再查看下数据库列表，多了个新的test数据库</p>
<pre><code>mysql&gt; CREATE DATABASE test;
Query OK, 1 row affected (0.01 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
</code></pre><h3 id="5-建立数据表"><a href="#5-建立数据表" class="headerlink" title="5.建立数据表"></a>5.建立数据表</h3><pre><code>mysql&gt; USE 库名;
mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1))；
//CREATE TABLE table_name (column_name column_type);
</code></pre><p>新建一个名为Websites的数据表，字段值分别为id, name, url, alexa, country。关于MySQL建表字段的类型参考博客<a href="http://blog.sina.com.cn/s/blog_80613dc40100s0c8.html" target="_blank" rel="noopener">MySQL建表字段类型</a>。</p>
<pre><code>mysql&gt; CREATE TABLE Websites(id int,name varchar(18),url varchar(100),alexa int,country varchar(18));
Query OK, 0 rows affected (0.04 sec)
</code></pre><h3 id="6-删除数据库"><a href="#6-删除数据库" class="headerlink" title="6.删除数据库"></a>6.删除数据库</h3><p> <code>mysql&gt; DROP DATABASE 库名；</code></p>
<h3 id="7-删除数据表"><a href="#7-删除数据表" class="headerlink" title="7.删除数据表"></a>7.删除数据表</h3><p><code>mysql&gt; DROP TABLE 表名;</code></p>
<h3 id="8-将表中记录清空"><a href="#8-将表中记录清空" class="headerlink" title="8.将表中记录清空"></a>8.将表中记录清空</h3><p> <code>mysql&gt; DELETE FROM 表名;</code></p>
<h3 id="9-显示表中的所有记录"><a href="#9-显示表中的所有记录" class="headerlink" title="9.显示表中的所有记录"></a>9.显示表中的所有记录</h3><p> <code>mysql&gt; SELECT * FROM 表名;</code></p>
<h3 id="10-往表中插入记录"><a href="#10-往表中插入记录" class="headerlink" title="10.往表中插入记录"></a>10.往表中插入记录</h3><p> <code>mysql&gt; INSERT INTO 表名 VALUES (&quot;hyq&quot;,&quot;M&quot;);</code><br>往名为Websites的表中插入第一条记录，各字段值分别为：<code>id=1,name=&quot;Google&quot;,url=&quot;https://www.google.com/&quot;, alexa=1,country=&quot;USA&quot;</code>。然后查看添加记录后表中的记录显示如下所示：</p>
<pre><code>mysql&gt; INSERT INTO Websites VALUES (1,&quot;Google&quot;,&quot;https://www.google.com/&quot;,1,&quot;USA&quot;);
Query OK, 1 row affected (0.02 sec)

mysql&gt; SELECT * FROM Websites;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
+------+--------+-------------------------+-------+---------+
</code></pre><p>添加完菜鸟教程中SQL示例代码数据表中的5条示例记录后，Websites数据表显示如下：</p>
<pre><code>mysql&gt; SELECT * FROM Websites;
+------+--------------+--------------------------+-------+---------+
| id   | name         | url                      | alexa | country |
+------+--------------+--------------------------+-------+---------+
|    1 | Google       | https://www.google.com/  |     1 | USA     |
|    2 | 淘宝         | https://www.taobao.com/  |    13 | CN      |
|    3 | 菜鸟教程     | http://www.runoob.com     |  4689 | CN      |
|    4 | 微博         | http://weibo.com         |    20 | CN      |
|    5 | Facebook     | http://www.facebook.com/ |     3 | USA     |
+------+--------------+--------------------------+-------+---------+
</code></pre><h3 id="11-更新表中数据"><a href="#11-更新表中数据" class="headerlink" title="11.更新表中数据"></a>11.更新表中数据</h3><p> <code>mysql-&gt; UPDATE 表名 SET 字段名1=&#39;a&#39;,字段名2=&#39;b&#39; WHERE 字段名3=&#39;c&#39;；</code></p>
<h3 id="12-用文本方式将数据装入数据表中"><a href="#12-用文本方式将数据装入数据表中" class="headerlink" title="12.用文本方式将数据装入数据表中"></a>12.用文本方式将数据装入数据表中</h3><p> <code>mysql&gt; LOAD DATA LOCAL INFILE &quot;D:/mysql.txt&quot; INTO TABLE 表名;</code></p>
<p>###13.导入.sql文件命令 ###</p>
<pre><code>mysql&gt; USE 数据库名;
mysql&gt; SOURCE d:/mysql.sql;
</code></pre><h3 id="14-显示正在use的数据库名"><a href="#14-显示正在use的数据库名" class="headerlink" title="14.显示正在use的数据库名"></a>14.显示正在use的数据库名</h3><p> <code>mysql&gt; SELECT DATABASE();</code><br>如下所示，在新建的test数据库中建立的Websites数据表，因此正在使用的数据库是test。</p>
<pre><code>mysql&gt; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| test       |
+------------+
</code></pre><h3 id="15-显示当前的user"><a href="#15-显示当前的user" class="headerlink" title="15.显示当前的user"></a>15.显示当前的user</h3><p> <code>mysql&gt; SELECT USER();</code></p>
<pre><code>mysql&gt; SELECT USER();
+----------------+
| USER()         |
+----------------+
| root@localhost |
+----------------+
</code></pre><h3 id="16-SELECT-TOP-子句"><a href="#16-SELECT-TOP-子句" class="headerlink" title="16.SELECT TOP 子句"></a>16.SELECT TOP 子句</h3><p>返回规定的记录数目。MySQL语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
LIMIT number;
</code></pre><p>从 “Websites” 表中选取头两条记录如下：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; LIMIT 2;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
|    2 | 淘宝   | https://www.taobao.com/ |    13 | CN      |
+------+--------+-------------------------+-------+---------+
</code></pre><h3 id="17-LIKE-操作符"><a href="#17-LIKE-操作符" class="headerlink" title="17.LIKE 操作符"></a>17.LIKE 操作符</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name LIKE pattern;
</code></pre><p>以下示例选取 name 以字母 “G” 开始的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;G%&quot;;
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    1 | Google | https://www.google.com/ |     1 | USA     |
</code></pre><p>以下示例选取 name 以字母 “k” 结尾的所有客户：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;%k&quot;;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>以下示例选取 name 包含模式 “oo” 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name LIKE &quot;%oo%&quot;;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    1 | Google   | https://www.google.com/  |     1 | USA     |
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>注意：”%” 符号用于在模式的前后定义通配符（缺省字母），通配符可用于替代字符串中的任何其他字符。 通配符与 SQL LIKE 操作符一起使用。</p>
<pre><code>%                          替代 0 个或多个字符
_                          替代一个字符
[charlist]                 字符列中的任何单一字符
[^charlist]或[!charlist]   不在字符列中的任何单一字符
</code></pre><p>搭配以上通配符可以让LIKE命令实现多种技巧：</p>
<pre><code>1、LIKE&apos;Mc%&apos; 将搜索以字母 Mc 开头的所有字符串（如 McBadden）。
2、LIKE&apos;%inger&apos; 将搜索以字母 inger 结尾的所有字符串（如 Ringer、Stringer）。
3、LIKE&apos;%en%&apos; 将搜索在任何位置包含字母 en 的所有字符串（如 Bennet、Green、McBadden）。
4、LIKE&apos;_heryl&apos; 将搜索以字母 heryl 结尾的所有六个字母的名称（如 Cheryl、Sheryl）。
5、LIKE&apos;[CK]ars[eo]n&apos; 将搜索下列字符串：Carsen、Karsen、Carson 和 Karson（如 Carson）。
6、LIKE&apos;[M-Z]inger&apos; 将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称（如 Ringer）。
7、LIKE&apos;M[^c]%&apos; 将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称（如MacFeather）。
</code></pre><h3 id="18-charlist-通配符"><a href="#18-charlist-通配符" class="headerlink" title="18.[charlist] 通配符"></a>18.[charlist] 通配符</h3><p>MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。<br>下面的 SQL 语句选取 name 以 “G”、”F” 或 “s” 开始的所有网站：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name REGEXP &quot;^[GFs]&quot;;
+------+---------------+----------------------------+-------+---------+
| id   | name          | url                        | alexa | country |
+------+---------------+----------------------------+-------+---------+
|    1 | Google        | https://www.google.com/    |     1 | USA     |
|    5 | Facebook      | http://www.facebook.com/   |     3 | USA     |
|    6 | stackoverflow | https://stackoverflow.com/ |     0 | IND     |
+------+---------------+----------------------------+-------+---------+
</code></pre><h3 id="19-IN-操作符"><a href="#19-IN-操作符" class="headerlink" title="19.IN 操作符"></a>19.IN 操作符</h3><p>IN 操作符允许在 WHERE 子句中规定多个值，然后返回规定相应的记录。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1,value2,...);
</code></pre><p>以下语句选取 name 为 “Google” 或 “菜鸟教程” 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE name IN (&quot;Google&quot;,&quot;菜鸟教程&quot;);
+------+--------------+-------------------------+-------+---------+
| id   | name         | url                     | alexa | country |
+------+--------------+-------------------------+-------+---------+
|    1 | Google       | https://www.google.com/ |     1 | USA     |
|    3 | 菜鸟教程     | http://www.runoob.com   |  4689 | CN      |
+------+--------------+-------------------------+-------+---------+
</code></pre><p><strong>IN 与 = 的异同</strong>：<br>    相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义<br>    不同点：IN可以规定多个值，等于规定一个值</p>
<h3 id="20-BETWEEN-操作符"><a href="#20-BETWEEN-操作符" class="headerlink" title="20.BETWEEN 操作符"></a>20.BETWEEN 操作符</h3><p>用于选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。 语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
</code></pre><p>以下语句选取 alexa 介于 1 和 20 之间的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE alexa BETWEEN 1 AND 20;
+------+----------+--------------------------+-------+---------+
| id   | name     | url                      | alexa | country |
+------+----------+--------------------------+-------+---------+
|    1 | Google   | https://www.google.com/  |     1 | USA     |
|    2 | 淘宝     | https://www.taobao.com/  |    13 | CN      |
|    4 | 微博     | http://weibo.com         |    20 | CN      |
|    5 | Facebook | http://www.facebook.com/ |     3 | USA     |
+------+----------+--------------------------+-------+---------+
</code></pre><p>NOT BETWEEN 显示不在范围内的所有记录。<br>以下语句语句选取alexa介于 1 和 20 之间但 country 不为 USA 和 IND 的所有记录：</p>
<pre><code>mysql&gt; SELECT * FROM Websites
    -&gt; WHERE alexa BETWEEN 1 AND 20
    -&gt; AND NOT country IN (&quot;USA&quot;,&quot;IND&quot;);
+------+--------+-------------------------+-------+---------+
| id   | name   | url                     | alexa | country |
+------+--------+-------------------------+-------+---------+
|    2 | 淘宝   | https://www.taobao.com/ |    13 | CN      |
|    4 | 微博   | http://weibo.com        |    20 | CN      |
+------+--------+-------------------------+-------+---------+
</code></pre><h3 id="21-连接-JOIN"><a href="#21-连接-JOIN" class="headerlink" title="21.连接(JOIN)"></a>21.连接(JOIN)</h3><p>参考<a href="http://www.runoob.com/sql/sql-join.html" target="_blank" rel="noopener">SQL 连接(JOIN)</a>。<br>用于把来自两个或多个表的行结合起来。基于这些表之间的共同字段。<br>最常见的 JOIN 类型：SQL <strong>INNER JOIN</strong>（简单的 JOIN）。<br>SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。<br>“Websites” 表中的 “id” 列指向 “<code>access_log</code>“ 表中的字段 “<code>site_id</code>“。将这两个表是通过 “<code>site_id</code>“ 列联系起来的。</p>
<pre><code>mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date
    -&gt; FROM Websites
    -&gt; INNER JOIN access_log
    -&gt; ON Websites.id=access_log.site_id;
+------+--------------+-------+------------+
| id   | name         | count | date       |
+------+--------------+-------+------------+
|    1 | Google       |    45 | 2016-05-10 |
|    3 | 菜鸟教程     |   100 | 2016-05-13 |
|    1 | Google       |   230 | 2016-05-14 |
|    2 | 淘宝         |    10 | 2016-05-14 |
|    5 | Facebook     |   205 | 2016-05-14 |
|    4 | 微博         |    13 | 2016-05-15 |
|    3 | 菜鸟教程     |   220 | 2016-05-15 |
|    5 | Facebook     |   545 | 2016-05-16 |
|    3 | 菜鸟教程     |   201 | 2016-05-17 |
+------+--------------+-------+------------+
</code></pre><p>不同的 SQL JOIN：</p>
<pre><code>INNER JOIN：如果表中有至少一个匹配，则返回行
LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行
RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行
FULL JOIN：只要其中一个表中存在匹配，则返回行
</code></pre><p>首先，连接的结果可以在逻辑上看作是由SELECT语句指定的列组成的新表。<br>左连接与右连接的左右指的是以两张表中的哪一张为基准，它们都是外连接。<br>外连接就好像是为非基准表添加了一行全为空值的万能行，用来与基准表中找不到匹配的行进行匹配。假设两个没有空值的表进行左连接，左表是基准表，左表的所有行都出现在结果中，右表则可能因为无法与基准表匹配而出现是空值的字段。</p>
<h3 id="22-INNER-JOIN"><a href="#22-INNER-JOIN" class="headerlink" title="22.INNER JOIN"></a>22.INNER JOIN</h3><p>在表中存在至少一个匹配时返回行。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
INNER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p>或：</p>
<pre><code>SELECT column_name(s)
FROM table1
JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_innerjoin.gif" alt="inner join"><br>具体例子如21所示。<br>注释：INNER JOIN 与 JOIN 是相同的<br>注释：INNER JOIN 关键字在表中存在至少一个匹配时返回行。如果 “Websites” 表中的行在 “<code>access_log</code>“ 中没有匹配，则不会列出这些行。</p>
<h3 id="23-LEFT-JOIN"><a href="#23-LEFT-JOIN" class="headerlink" title="23.LEFT JOIN"></a>23.LEFT JOIN</h3><p>从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
LEFT JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p>或：</p>
<pre><code>SELECT column_name(s)
FROM table1
LEFT OUTER JOIN table2
ON table1.column_name=table2.column_name;
// 在某些数据库中，LEFT JOIN 称为 LEFT OUTER JOIN。
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_leftjoin.gif" alt="left join"></p>
<p>以下示例语句将返回所有网站及他们的访问量（如果有的话）。把 Websites 作为左表，<code>access_log</code> 作为右表：</p>
<pre><code>mysql&gt; SELECT Websites.id, Websites.name, access_log.count, access_log.date
    -&gt; FROM Websites
    -&gt; LEFT JOIN access_log
    -&gt; ON Websites.id=access_log.site_id
    -&gt; ORDER BY access_log.count DESC;
+------+---------------+-------+------------+
| id   | name          | count | date       |
+------+---------------+-------+------------+
|    5 | Facebook      |   545 | 2016-05-16 |
|    1 | Google        |   230 | 2016-05-14 |
|    3 | 菜鸟教程      |   220 | 2016-05-15 |
|    5 | Facebook      |   205 | 2016-05-14 |
|    3 | 菜鸟教程      |   201 | 2016-05-17 |
|    3 | 菜鸟教程      |   100 | 2016-05-13 |
|    1 | Google        |    45 | 2016-05-10 |
|    4 | 微博          |    13 | 2016-05-15 |
|    2 | 淘宝          |    10 | 2016-05-14 |
|    6 | stackoverflow |  NULL | NULL       |
+------+---------------+-------+------------+
</code></pre><h3 id="24-FULL-OUTER-JOIN"><a href="#24-FULL-OUTER-JOIN" class="headerlink" title="24.FULL OUTER JOIN"></a>24.FULL OUTER JOIN</h3><p>FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行。<br>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。<br>FULL OUTER JOIN 关键字返回左表（Websites）和右表（<code>access_log</code>）中所有的行。如果 “Websites” 表中的行在 “<code>access_log</code>“ 中没有匹配或者 “<code>access_log</code>“ 表中的行在 “Websites” 表中没有匹配，也会列出这些行。<br>语法如下：</p>
<pre><code>SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2
ON table1.column_name=table2.column_name;
</code></pre><p><img src="http://www.runoob.com/wp-content/uploads/2013/09/img_fulljoin.gif" alt="full outer join"></p>
<p><strong>注意：</strong> MySQL中不支持 FULL OUTER JOIN，可以在 SQL Server 测试实例。</p>
<h3 id="25-UNION"><a href="#25-UNION" class="headerlink" title="25.UNION"></a>25.UNION</h3><p>用于合并两个或多个 SELECT 语句的结果。<br>注意： UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。<br>语法如下：<br>    SELECT column_name(s) FROM table1<br>    UNION<br>    SELECT column_name(s) FROM table2;<br>注释：(1) 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。<br>(2) UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
<pre><code>mysql&gt;  SELECT country FROM Websites
    -&gt; UNION
    -&gt; SELECT country FROM apps
    -&gt; ORDER BY country;
+---------+
| country |
+---------+
| CN      |
| IND     |
| USA     |
+---------+
</code></pre><p>注释：UNION 不能用于列出两个表中所有的country。如果一些网站和APP来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！<br>使用UNION命令时需要注意，只能在最后使用一个ORDER BY命令，是将两个查询结果合在一起之后，再进行排序！绝对不能写两个ORDER BY命令。</p>
<h3 id="26-INSERT-INTO-SELECT-SELECT-INTO"><a href="#26-INSERT-INTO-SELECT-SELECT-INTO" class="headerlink" title="26.INSERT INTO SELECT / SELECT INTO"></a>26.INSERT INTO SELECT / SELECT INTO</h3><p>从一个表复制信息插入到另一个已存在的表，目标表中任何已存在的行都不会受影响。。<br><strong>注意：</strong>MySQL 数据库不支持 SELECT … INTO 语句，但支持 INSERT INTO … SELECT 。<br>以使用以下语句来拷贝表结构及数据：<code>CREATE TABLE 新表 SELECT * FROM 旧表;</code><br>语法如下：</p>
<pre><code>INSERT INTO table2
SELECT * FROM table1;
</code></pre><p>或者只复制希望的列插入到另一个已存在的表中：</p>
<pre><code>INSERT INTO table2
(column_name(s))
SELECT column_name(s)
FROM table1;
</code></pre><p>以下语句复制 “apps” 中的数据插入到 “Websites” 中：</p>
<pre><code>mysql&gt; INSERT INTO Websites(name,country)
    -&gt; SELECT app_name,country FROM apps
    -&gt; WHERE id=1;
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT * FROM Websites;
+------+---------------+----------------------------+-------+---------+
| id   | name          | url                        | alexa | country |
+------+---------------+----------------------------+-------+---------+
|    1 | Google        | https://www.google.com/    |     1 | USA     |
|    2 | 淘宝          | https://www.taobao.com/    |    13 | CN      |
|    3 | 菜鸟教程      | http://www.runoob.com      |  4689 | CN      |
|    4 | 微博          | http://weibo.com           |    20 | CN      |
|    5 | Facebook      | http://www.facebook.com/   |     3 | USA     |
|    6 | stackoverflow | https://stackoverflow.com/ |     0 | IND     |
| NULL | QQ APP        | NULL                       |  NULL | CN      |
+------+---------------+----------------------------+-------+---------+
</code></pre><p>表apps中的数据如下：</p>
<pre><code>mysql&gt; SELECT * FROM apps;
+------+------------+------------------------+---------+
| id   | app_name   | url                    | country |
+------+------------+------------------------+---------+
|    1 | QQ APP     | http://im.qq.com/      | CN      |
|    2 | 微博 APP   | http://weibo.com/      | CN      |
|    3 | 淘宝 APP   | http://www.taobao.com/ | CN      |
+------+------------+------------------------+---------+
</code></pre><h3 id="27-约束（Constraints）"><a href="#27-约束（Constraints）" class="headerlink" title="27.约束（Constraints）"></a>27.约束（Constraints）</h3><p>SQL 约束用于规定表中的数据规则。<br>如果存在违反约束的数据行为，行为会被约束终止。<br>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。语法如下：</p>
<pre><code>CREATE TABLE table_name
(
column_name1 data_type(size) constraint_name,
column_name2 data_type(size) constraint_name,
column_name3 data_type(size) constraint_name,
....
);
</code></pre><p>在 SQL 中，有如下约束：</p>
<pre><code>NOT NULL - 指示某列不能存储 NULL 值。
UNIQUE - 保证某列的每行必须有唯一的值。
PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。
FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。
CHECK - 保证列中的值符合指定的条件。
DEFAULT - 规定没有给列赋值时的默认值。
</code></pre><p>(1) NOT NULL 约束<br>强制列不接受 NULL 值, 强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。<br>(2)  UNIQUE 约束<br>唯一标识数据库表中的每条记录。<br>UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。<br>PRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。<br>注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。<br>下面的 SQL 在 “Persons” 表创建时在 “<code>P_Id</code>“ 列上创建 UNIQUE 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
UNIQUE (P_Id)
);
</code></pre><p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName)
);
</code></pre><p><strong>当表已被创建时</strong>，如需在 “<code>P_Id</code>“ 列创建 UNIQUE 约束，使用下面的 SQL：</p>
<pre><code>ALTER TABLE Persons
ADD UNIQUE (P_Id);
</code></pre><p>如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，使用下面的 SQL 语法：</p>
<pre><code>ALTER TABLE Persons
ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName);
</code></pre><p><strong>撤销 UNIQUE 约束:</strong></p>
<pre><code>ALTER TABLE Persons
DROP INDEX uc_PersonID
</code></pre><p>(3) PRIMARY KEY 约束<br>唯一标识数据库表中的每条记录。<br>主键必须包含唯一的值，主键列不能包含 NULL 值。<br>每个表都应该有一个主键，并且每个表只能有一个主键。<br>下面的 SQL 在 “Persons” 表创建时在 “<code>P_Id</code>“ 列上创建 PRIMARY KEY 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (P_Id)
);
</code></pre><p>如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)
);
</code></pre><p>注释：在上面的实例中，只有一个主键 PRIMARY KEY（<code>pk_PersonID</code>）。然而，pk_PersonID 的值是由两个列（<code>P_Id</code> 和 <code>LastName</code>）组成的。<br><strong>当表已被创建时</strong>，如需在 “<code>P_Id</code>“ 列创建 PRIMARY KEY 约束，使用下面的 SQL：</p>
<pre><code>ALTER TABLE Persons
ADD PRIMARY KEY (P_Id);
</code></pre><p>如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，使用下面的 SQL 语法：</p>
<pre><code>ALTER TABLE Persons
ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName);
</code></pre><p><strong>撤销 PRIMARY KEY 约束:</strong></p>
<pre><code>ALTER TABLE Persons
DROP PRIMARY KEY
</code></pre><p>撤销PRIMARY KEY约束时，不论约束条件为一列还是多列，对于MySQL，撤销都是如上的语句。<br>(4)  FOREIGN KEY 约束<br>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。<br>FOREIGN KEY 约束用于预防破坏表之间连接的行为。<br>FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。<a href="http://www.runoob.com/sql/sql-foreignkey.html" target="_blank" rel="noopener">参考菜鸟教程</a>。<br>(5) CHECK 约束<br>用于限制列中的值的范围。<br>如果对单个列定义 CHECK 约束，那么该列只允许特定的值。<br>如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。<a href="http://www.runoob.com/sql/sql-check.html" target="_blank" rel="noopener">参考菜鸟教程</a>。<br>(6) DEFAULT 约束<br>用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。<br>下面的 SQL 在 “Persons” 表创建时在 “City” 列上创建 DEFAULT 约束：</p>
<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT &apos;Sandnes&apos;
);
</code></pre><p>通过使用类似 GETDATE() 这样的函数，DEFAULT 约束也可以用于插入系统值：</p>
<pre><code>CREATE TABLE Orders
(
O_Id int NOT NULL,
OrderNo int NOT NULL,
P_Id int,
OrderDate date DEFAULT GETDATE()
);
</code></pre><p>当表已被创建时，如需在 “City” 列创建 DEFAULT 约束，使用下面的 SQL:</p>
<pre><code>ALTER TABLE Persons
ALTER City SET DEFAULT &apos;SANDNES&apos;;
</code></pre><p>撤销 DEFAULT 约束:</p>
<pre><code>ALTER TABLE Persons
ALTER City DROP DEFAULT;
</code></pre><h3 id="28-CREATE-INDEX"><a href="#28-CREATE-INDEX" class="headerlink" title="28.CREATE INDEX"></a>28.CREATE INDEX</h3><p>用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。<br>用户无法看到索引，它们只能被用来加速搜索/查询。<br><strong>注释：</strong>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。<br>在表上创建一个简单的索引。允许使用重复的值：</p>
<pre><code>CREATE INDEX index_name
ON table_name (column_name1, column_name2);
</code></pre><p>在表上创建一个唯一的索引。不允许使用重复的值(唯一的索引意味着两个行不能拥有相同的索引值)：</p>
<pre><code>CREATE UNIQUE INDEX index_name
ON table_name (column_name);
</code></pre><h3 id="29-DROP"><a href="#29-DROP" class="headerlink" title="29.DROP"></a>29.DROP</h3><p>使用 DROP 语句，可以轻松地删除索引、表和数据库。<br>DROP INDEX 语句用于删除表中的索引。MySQL 的 DROP INDEX 语法：<code>ALTER TABLE table_name DROP INDEX index_name;</code></p>
<p>DROP TABLE 语句用于删除表: <code>DROP TABLE table_name;</code></p>
<p>DROP DATABASE 语句用于删除数据库: <code>DROP DATABASE database_name;</code></p>
<p>仅仅删除表内的数据，但并不删除表本身时： <code>TRUNCATE TABLE table_name;</code></p>
<h3 id="30-ALTER"><a href="#30-ALTER" class="headerlink" title="30.ALTER"></a>30.ALTER</h3><p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。<br><strong>在表中添加列:</strong></p>
<pre><code>ALTER TABLE table_name
ADD column_name datatype;
</code></pre><p><strong>删除表中的列:</strong></p>
<pre><code>ALTER TABLE table_name
DROP COLUMN column_name;
</code></pre><p><strong>改变表中列的数据类型:</strong></p>
<pre><code>ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
</code></pre><h3 id="31-AUTO-INCREMENT"><a href="#31-AUTO-INCREMENT" class="headerlink" title="31.AUTO INCREMENT"></a>31.AUTO INCREMENT</h3><p><code>AUTO_INCREMENT</code> 会在新记录插入表中时生成一个唯一的数字。可用于在每次插入新记录时，自动地创建主键字段的值。<br>下面的 SQL 语句把 “Persons” 表中的 “ID” 列定义为 <code>AUTO_INCREMENT</code> 主键字段：</p>
<pre><code>CREATE TABLE Persons
(
ID int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (ID)
);
</code></pre><p>默认地，<code>AUTO_INCREMENT</code> 的开始值是 1，每条新记录递增 1。<br>要让 <code>AUTO_INCREMENT</code> 序列以其他的值起始，请使用下面的 SQL 语法： <code>ALTER TABLE Persons AUTO_INCREMENT=100;</code><br>要在 “Persons” 表中插入新记录，我们不必为 “ID” 列规定值（会自动添加一个唯一的值）：</p>
<pre><code>INSERT INTO Persons (FirstName,LastName)
VALUES (&apos;Lars&apos;,&apos;Monsen&apos;);
</code></pre><h3 id="32-视图（Views）"><a href="#32-视图（Views）" class="headerlink" title="32.视图（Views）"></a>32.视图（Views）</h3><p>视图是基于 SQL 语句的结果集的可视化的表。<br>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。<br>可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。<br>CREATE VIEW 语法:</p>
<pre><code>CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition;
</code></pre><p>注释：视图总是显示最新的数据！每当用户查询视图时，数据库引擎通过使用视图的 SQL 语句重建数据。</p>
<h3 id="33-日期（Dates）"><a href="#33-日期（Dates）" class="headerlink" title="33.日期（Dates）"></a>33.日期（Dates）</h3><p>确保所插入的日期的格式，与数据库中日期列的格式相匹配。<a href="http://www.runoob.com/sql/sql-dates.html" target="_blank" rel="noopener">MySQL Date 函数</a>。</p>
<h3 id="34-NULL-值"><a href="#34-NULL-值" class="headerlink" title="34.NULL 值"></a>34.NULL 值</h3><p>如果表中的某个列是可选的，那么我们可以在不向该列添加值的情况下插入新记录或更新已有的记录。这意味着该字段将以 NULL 值保存。<br>NULL 值的处理方式与其他值不同。<br>NULL 用作未知的或不适用的值的占位符。<br>无法使用比较运算符来测试 NULL 值，比如<code>=、&lt; 或 &lt;&gt;</code>。必须使用 IS NULL 和 IS NOT NULL 操作符。</p>
<pre><code>SELECT LastName,FirstName,Address FROM Persons
WHERE Address IS NULL;
</code></pre><h3 id="35-NULL-函数"><a href="#35-NULL-函数" class="headerlink" title="35.NULL 函数"></a>35.NULL 函数</h3><p>可以使用 IFNULL() 函数</p>
<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))
FROM Products;
</code></pre><p>或者：</p>
<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))
FROM Products;
</code></pre><p>示例：</p>
<pre><code>//如果alexa列为null值，则赋予0，否则，取原值
select id,name,url,ifnull(alexa,0)from websites;
select id,name,url,COALESCE(alexa,0) from websites;
</code></pre><h3 id="36-数据类型"><a href="#36-数据类型" class="headerlink" title="36.数据类型"></a>36.数据类型</h3><p>数据类型定义列中存放的值的种类。<a href="http://www.runoob.com/sql/sql-datatypes.html" target="_blank" rel="noopener">SQL 通用数据类型</a>。</p>
<h3 id="37-SQL-函数"><a href="#37-SQL-函数" class="headerlink" title="37.SQL 函数"></a>37.SQL 函数</h3><p>(1) SQL Aggregate 函数<br>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。常用的如下：</p>
<pre><code>AVG() - 返回平均值            SELECT AVG(column_name) FROM table_name;
COUNT() - 返回行数            SELECT COUNT(column_name) FROM table_name;
FIRST() - 返回第一个记录的值   //只有 MS Access 支持 FIRST() 函数。 MySQL语法实现此函数如：SELECT name AS FirstSite FROM Websites LIMIT 1; 
LAST() - 返回最后一个记录的值   //只有 MS Access 支持 LAST() 函数。
MAX() - 返回最大值            SELECT MAX(column_name) FROM table_name;
MIN() - 返回最小值
SUM() - 返回总和
</code></pre><p>(2) SQL Scalar 函数<br>SQL Scalar 函数基于输入值，返回一个单一的值。常用的如下：</p>
<pre><code>UCASE() - 将某个字段转换为大写                     SELECT UCASE(column_name) FROM table_name;
LCASE() - 将某个字段转换为小写
MID() - 从某个文本字段提取字符，MySql 中使用        SELECT MID(column_name,start[,length]) FROM table_name;
SubString(字段，1，end) - 从某个文本字段提取字符
LEN() - 返回某个文本字段的长度                     //MySQL中使用方法： SELECT LENGTH(column_name) FROM table_name;
ROUND() - 对某个数值字段进行指定小数位数的四舍五入   SELECT ROUND(column_name,decimals) FROM table_name;
NOW() - 返回当前的系统日期和时间                   SELECT NOW() FROM table_name;
FORMAT() - 格式化某个字段的显示方式                SELECT FORMAT(column_name,format) FROM table_name;
</code></pre><p>(3) <strong>GROUP BY 语句</strong><br>用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name; 
</code></pre><p>如下统计 <code>access_log</code> 各个 <code>site_id</code> 的访问量：</p>
<pre><code>mysql&gt; SELECT site_id,SUM(access_log.count)
    -&gt; FROM access_log
    -&gt; GROUP BY site_id;
+---------+-----------------------+
| site_id | SUM(access_log.count) |
+---------+-----------------------+
|       1 |                   275 |
|       2 |                    10 |
|       3 |                   521 |
|       4 |                    13 |
|       5 |                   750 |
+---------+-----------------------+
</code></pre><p>GROUP BY 多表连接时，以下语句统计所有网站的访问的记录数：</p>
<pre><code>mysql&gt; SELECT Websites.name,COUNT(access_log.aid) AS nums FROM access_log
    -&gt; LEFT JOIN Websites
    -&gt; ON access_log.site_id=Websites.id
    -&gt; GROUP BY Websites.name;
+--------------+------+
| name         | nums |
+--------------+------+
| Facebook     |    2 |
| Google       |    2 |
| 微博         |    1 |
| 淘宝         |    1 |
| 菜鸟教程     |    3 |
+--------------+------+
</code></pre><p>以上示例中，<code>access_log</code>作为左表，<code>Websites</code>作为右表，通过 GROUP BY 对 COUNT得到的结果按<code>site_id</code>分组。</p>
<p>(4) <strong>HAVING 子句</strong><br>增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。<br>HAVING 子句可以让我们筛选分组后的各组数据。语法如下：</p>
<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value; 
</code></pre><p>以下语句用于查找总访问量大于 200 的网站：</p>
<pre><code>mysql&gt; SELECT Websites.name,Websites.url,SUM(access_log.count) AS nums FROM access_log
    -&gt; INNER JOIN Websites
    -&gt; ON access_log.site_id=Websites.id
    -&gt; GROUP BY Websites.name
    -&gt; HAVING SUM(access_log.count) &gt; 200;
+--------------+--------------------------+------+
| name         | url                      | nums |
+--------------+--------------------------+------+
| Facebook     | http://www.facebook.com/ |  750 |
| Google       | https://www.google.com/  |  275 |
| 菜鸟教程     | http://www.runoob.com    |  521 |
+--------------+--------------------------+------+
</code></pre><p>以下语句用于查找总访问量大于 200 的网站，并且 alexa 排名小于 200：</p>
<pre><code>mysql&gt; SELECT Websites.name,Websites.alexa,SUM(access_log.count) AS nums FROM access_log
    -&gt; INNER JOIN Websites
    -&gt; ON Websites.id=access_log.site_id
    -&gt; WHERE Websites.alexa &lt; 200
    -&gt; GROUP BY Websites.name
    -&gt; HAVING SUM(access_log.count) &gt; 200;
+----------+-------+------+
| name     | alexa | nums |
+----------+-------+------+
| Facebook |     3 |  750 |
| Google   |     1 |  275 |
+----------+-------+------+
</code></pre><p>具体的使用方法参见<a href="http://www.runoob.com/sql/sql-function.html" target="_blank" rel="noopener">菜鸟教程SQL 函数</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于MySQL数据库基本的安装和操作方法。&lt;a href=&quot;http://www.runoob.com/mysql/mysql-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL教程–菜鸟&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about Web】</title>
    <link href="http://yoursite.com/2018/03/04/interview-questions-about-Web/"/>
    <id>http://yoursite.com/2018/03/04/interview-questions-about-Web/</id>
    <published>2018-03-04T07:20:40.000Z</published>
    <updated>2018-03-24T06:55:02.283Z</updated>
    
    <content type="html"><![CDATA[<p>Web方面的知识盲区补漏。<br><a id="more"></a></p>
<h3 id="匹配URL的正则表达式"><a href="#匹配URL的正则表达式" class="headerlink" title="匹配URL的正则表达式"></a>匹配URL的正则表达式</h3><p>URL由三部分组成：资源类型(协议)、存放资源的主机域名、资源文件名。<br>URL的一般语法格式为(带方括号[ ]的为可选项)：<br><code>protocol :// hostname[:port] / path / [;parameters][?query]#fragment</code><br>据说比较好用匹配较全面的是这个：<br><code>(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]</code><br>参考自博客<a href="https://www.cnblogs.com/speeding/p/5097790.html" target="_blank" rel="noopener">正确匹配URL的正则表达式</a>、<a href="http://blog.csdn.net/t_1007/article/details/52293475" target="_blank" rel="noopener">匹配URL的正则表达式解析</a>。</p>
<h3 id="React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快"><a href="#React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快" class="headerlink" title="React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快"></a>React虚拟DOM的优势，为什么虚拟DOM操作比原生方式快</h3><p>将数据的变化实时反映到UI上，这时需要对DOM进行操作，但复杂或频繁的DOM操作(会造成重排、重绘)通常是性能瓶颈产生的原因，为此，React引入了虚拟DOM（Virtual DOM）的机制。</p>
<p><strong>虚拟DOM?</strong><br> 在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，称之为virtual DOM。(是不是跟文档片段有异曲同工之妙？<a href="https://www.cnblogs.com/sdfcbs/p/6438784.html" target="_blank" rel="noopener">dom中的文档碎片</a>)</p>
<p>虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法 (<a href="http://www.infoq.com/cn/articles/react-dom-diff/#" target="_blank" rel="noopener">深入浅出React（四）：虚拟DOM Diff算法解析</a>)。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。</p>
<p><strong>虚拟DOM对比原生操作DOM</strong><br>原生操作DOM方式，使用 innerHTML。在一个大型列表所有数据都变了的情况下，还算是合理，但当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。<br>innerHTML: render html string + 重新创建所有 DOM 元素<br>Virtual DOM: render Virtual DOM + diff + 必要的 DOM 更新<br>和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。</p>
<p><strong>存疑</strong><br>React虚拟DOM的工作机制还不太理解，深入学习以后需要再回顾。<br><a href="https://www.cnblogs.com/chris-oil/p/6160985.html" target="_blank" rel="noopener">React虚拟DOM浅析</a><br><a href="https://segmentfault.com/a/1190000000606216" target="_blank" rel="noopener">React 的 diff 算法</a><br><a href="https://segmentfault.com/q/1010000000762295" target="_blank" rel="noopener">为什么 React 的 virtual DOM 比原生的DOM 渲染性能更好？</a></p>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><p>REST(Representational State Transfer)，“表述性状态转移”，是一种网络应用架构规范，目标是构建可扩展的web service。<br>REST规范可以提高架构的性能和可维护性。REST是一种更简单的<a href="https://www.cnblogs.com/leijiangtao/p/5137351.html" target="_blank" rel="noopener">SOAP协议</a>及以<a href="http://blog.csdn.net/liguocai2005/article/details/4402350" target="_blank" rel="noopener">WSDL</a>为基础的web service的替代。(SOAP暴露接口，REST暴露资源)<br>参考博客<a href="http://blog.csdn.net/zl834205311/article/details/62231545?ABstrategy=codes_snippets_optimize_v3" target="_blank" rel="noopener">WebService两种发布协议–SOAP和REST的区别</a>。<br><a href="https://blog.igevin.info/posts/restful-architecture-in-general/" target="_blank" rel="noopener">RESTful</a>（采用REST架构规范的）系统通常是通过HTTP协议，并且使用HTTP的GET,POST,PUT,DELETE等动词来收发数据。<br>W3C TAG开发了REST架构，基于HTTP 1.0。万维网代表了最大的REST架构实现，你可以认为所有的网页服务器都是采用REST架构的RESTful系统。<br>目前在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。<br><a href="https://www.cnblogs.com/bluewhale84/p/4443353.html" target="_blank" rel="noopener">常见的三种Web服务架构</a>。</p>
<h3 id="WebView相关"><a href="#WebView相关" class="headerlink" title="WebView相关"></a>WebView相关</h3><p><a href="https://www.cnblogs.com/dailc/p/5930231.html" target="_blank" rel="noopener">先了解什么是Hybrid APP</a>。所谓Hybrid,即混合开发,意味着半原生半Web,其实在H5兴盛之前,Hybrid模式就已经比较成熟了,但是一直不愠不火(因为系统的一些现在以及html本身功能的限制)。<br>怎么样的开发模式才算是Hybrid模式呢：</p>
<ul>
<li>Hybrid是半Native半web开发模式<br>Hybrid模式中,底层功能API均由原生容器通过某种方式提供,然后业务逻辑由H5页面完成,最终原生容器加载H5页面,完成整个App</li>
<li>成熟的Hybrid模式意味着业务逻辑均由H5实现<br>一款成熟的Hybrid框架,意味着各种类型的api都很完善,那么这时候几乎所有与业务相关的逻辑都是放在H5页面中的,原生只作为容器存在</li>
<li>成熟的Hybrid模式可复用性非常高,可以跨平台开发<br>成熟的Hybrid框架,那么原生只会提供底层API,也就是说所有的业务是H5完成,不管是什么项目,业务只由H5实现,这时候就可以发现,业务代码是可以跨平台的,也就是说,开发一次,就可以和各自原生容器结合,组成两种原生安装包了,达到了跨平台开发效果</li>
</ul>
<p><a href="http://blog.csdn.net/qibanxuehua/article/details/69944087?locationNum=12&amp;fps=1" target="_blank" rel="noopener">APP三种开发模式–之–HybridApp解决方案</a></p>
<p>原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。<br>在Html5没有兴盛之前,加载的Html往往只能用来做一些简单的静态资源显示,但是H5大行其道以后,Html5中有很多新增的功能,炫酷的效果,特别是iOS中H5支持一直都很良好,Android 4.4以上支持也足够,所以这时候发现可以将一些主要的逻辑都用H5页面来编写,然后原生直接用webview加载显示,这样大大提高了开发效率,而且体验也很不错。<br>webview用来展示网页的view组件，该组件是你运行自己的浏览器或者在你的线程中展示线上内容的基础。使用webkit渲染引擎来展示，并且支持前进后退等基于浏览历史，放大缩小，等更多功能。<br>简单来说WebView是手机中内置了一款高性能 webkit 内核浏览器,在 SDK 中封装的一个组件。不给过没有提供地址栏和导航栏，只是单纯的展示一个网页界面。<br>参考文章<a href="https://www.cnblogs.com/pqjwyn/p/7120342.html" target="_blank" rel="noopener">前端解读Webview</a>、<a href="https://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">WebView JavascriptBridge机制解析</a>、<a href="http://blog.csdn.net/rookie_small/article/details/68488335" target="_blank" rel="noopener">JS交互与WebView的工作原理浅析</a>。</p>
<h3 id="软件开发模式之“快速迭代”开发"><a href="#软件开发模式之“快速迭代”开发" class="headerlink" title="软件开发模式之“快速迭代”开发"></a>软件开发模式之“快速迭代”开发</h3><p>几种常见的软件开发模式对比参考博客<a href="https://www.cnblogs.com/tianguook/p/4004726.html" target="_blank" rel="noopener">软件开发模式对比(瀑布、迭代、螺旋、敏捷)</a>。<br>迭代成本比较低，一般采用敏捷开发的模式，产品快速的推动上线，上线后会通过用户反馈和用户行为分析不断的进行产品改进，并且每次改进的周期比较短，如果把“快速迭代”理解为快速并持续的更新和改进产品。</p>
<p><a href="http://blog.csdn.net/xiaoxian8023/article/details/8883791" target="_blank" rel="noopener">敏捷开发-快速迭代</a></p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><p><a href="https://www.zhihu.com/question/25532384" target="_blank" rel="noopener">线程和进程的区别是什么？–知乎</a><br>进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文。<br>线程是共享了进程的上下文环境的更为细小的CPU时间段。<br><a href="https://www.cnblogs.com/lgk8023/p/6430592.html" target="_blank" rel="noopener">进程和线程的区别</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释–阮一峰</a></p>
<p><strong><a href="http://blog.csdn.net/w2765006513/article/details/53743051" target="_blank" rel="noopener">浅谈js运行机制(线程）</a></strong><br>js运作在浏览器中,是单线程的，即js代码始终在一个线程上执行，这个线程称为js引擎线程。<br>浏览器是多线程的，除了js引擎线程，它还有：</p>
<pre><code> UI渲染线程
浏览器事件触发线程
http请求线程
EventLoop轮询的处理线程
....
</code></pre><p>单线程的含义是js只能在一个线程上运行，也就说，js同时只能执行一个js任务，其它的任务则会排队等待执行。<br>js是单线程的,并不代表js引擎线程只有一个。js引擎有多个线程，一个主线程，其它的后台配合主线程。<br>多线程之间会共享运行资源，浏览器端的js会操作dom，多个线程必然会带来同步的问题，所有js核心选择了单线程来避免处理这个麻烦。js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。这也就解释了js执行时会阻塞页面的渲染。</p>
<p><strong><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop–阮一峰</a></strong><br><strong><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">Javascript异步编程的4种方法–阮一峰</a></strong><br><strong><a href="https://www.cnblogs.com/nidaye/p/4604147.html" target="_blank" rel="noopener">关于javascript的单线程和异步的一些问题</a></strong><br><a href="https://www.cnblogs.com/chris-oil/p/5339305.html" target="_blank" rel="noopener">Node.js的线程和进程</a></p>
<h3 id="图片加载完成之前获取图片高度"><a href="#图片加载完成之前获取图片高度" class="headerlink" title="图片加载完成之前获取图片高度"></a>图片加载完成之前获取图片高度</h3><p><strong><a href="http://www.css88.com/archives/5224" target="_blank" rel="noopener">JS快速获取图片宽高的方法</a></strong></p>
<p>参考自博客<a href="https://www.cnblogs.com/ztoz/p/5930277.html" target="_blank" rel="noopener">图片加载完成之前获取图片高度</a>。</p>
<p>原理：利用的就是浏览器加载图片时的一个策略：当图片头部信息加载完成后，浏览器即获知了图片的大小，然后就会在页面上空出相应的区域来，然后再下载图片的剩余数据并且显示到之前空出的区域中。<br>所以我们要做的就是不断的去问浏览器你得到高度信息了没有，问到之后就可以马上做相应的处理，而此时图片还没有下载完成。</p>
<p><strong>补充：</strong><a href="http://www.jb51.net/article/26264.htm" target="_blank" rel="noopener">js图片img的onload事件与complete属性之间的关系</a>,onload是图片加载完成执行的事件，complete属性是图片显示出来以后为true，那么在onload之前complete肯定是false的，那么我们就可以在onload事件内部判断complete属性是否为true。如果为true那么代表图片真正的加载成功，否则可以重新加载。</p>
<p>img加载完成就会触发onload事件，src是异步加载图片的，如果在绑定事件前就已经加载完成，onload事件不会触发。img.complete是一直都有的属性，加载完成后为true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> imgReady = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="keyword">var</span> list = [],</div><div class="line">               intervalId = <span class="literal">null</span>,</div><div class="line"></div><div class="line">               <span class="comment">// 用来执行队列    </span></div><div class="line">               tick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">                   <span class="keyword">for</span> (; i &lt; list.length; i++) &#123;</div><div class="line">                       list[i].end ? list.splice(i--, <span class="number">1</span>) : list[i]();</div><div class="line">                   &#125;;</div><div class="line">                   !list.length &amp;&amp; stop();</div><div class="line">               &#125;,</div><div class="line"></div><div class="line">               <span class="comment">// 停止所有定时器队列    </span></div><div class="line">               stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   clearInterval(intervalId);</div><div class="line">                   intervalId = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">           <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">url, ready, load, error</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> onready, width, height, newWidth, newHeight,</div><div class="line">                   img = <span class="keyword">new</span> Image();</div><div class="line"></div><div class="line">               img.src = url;</div><div class="line"></div><div class="line">               <span class="comment">// 如果图片被缓存，则直接返回缓存数据    </span></div><div class="line">               <span class="keyword">if</span> (img.complete) &#123;</div><div class="line">                   ready.call(img);</div><div class="line">                   load &amp;&amp; load.call(img);</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               width = img.width;</div><div class="line">               height = img.height;</div><div class="line"></div><div class="line">               <span class="comment">// 加载错误后的事件    </span></div><div class="line">               img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   error &amp;&amp; error.call(img);</div><div class="line">                   onready.end = <span class="literal">true</span>;</div><div class="line">                   img = img.onload = img.onerror = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               <span class="comment">// 图片尺寸就绪    </span></div><div class="line">               onready = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   newWidth = img.width;</div><div class="line">                   newHeight = img.height;</div><div class="line">                   <span class="keyword">if</span> (newWidth !== width || newHeight !== height ||</div><div class="line">                       <span class="comment">// 如果图片已经在其他地方加载可使用面积检测    </span></div><div class="line">                       newWidth * newHeight &gt; <span class="number">1024</span></div><div class="line">                   ) &#123;</div><div class="line">                       ready.call(img);</div><div class="line">                       onready.end = <span class="literal">true</span>;</div><div class="line">                   &#125;;</div><div class="line">               &#125;;</div><div class="line">               onready();</div><div class="line"></div><div class="line">               <span class="comment">// 完全加载完毕的事件    </span></div><div class="line">               img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="comment">// onload在定时器时间差范围内可能比onready快    </span></div><div class="line">                   <span class="comment">// 这里进行检查并保证onready优先执行    </span></div><div class="line">                   !onready.end &amp;&amp; onready();</div><div class="line"></div><div class="line">                   load &amp;&amp; load.call(img);</div><div class="line"></div><div class="line">                   <span class="comment">// IE gif动画会循环执行onload，置空onload即可    </span></div><div class="line">                   img = img.onload = img.onerror = <span class="literal">null</span>;</div><div class="line">               &#125;;</div><div class="line"></div><div class="line">               <span class="comment">// 加入队列中定期执行    </span></div><div class="line">               <span class="keyword">if</span> (!onready.end) &#123;</div><div class="line">                   list.push(onready);</div><div class="line">                   <span class="comment">// 无论何时只允许出现一个定时器，减少浏览器性能损耗    </span></div><div class="line">                   <span class="keyword">if</span> (intervalId === <span class="literal">null</span>) intervalId = setInterval(tick, <span class="number">40</span>);</div><div class="line">               &#125;;</div><div class="line">           &#125;;</div><div class="line">       &#125;)();</div></pre></td></tr></table></figure>
<p>代码取自腾讯图片详情页。这种做法仅适用于 img 元素的 src 属性是一个 URL 的情况，如果是 <a href="http://blog.csdn.net/zdy0_2004/article/details/50370107" target="_blank" rel="noopener">Data URI </a>则不能这么做，因为浏览器是另外一套处理逻辑了。</p>
<h3 id="图片预加载与懒加载"><a href="#图片预加载与懒加载" class="headerlink" title="图片预加载与懒加载"></a>图片预加载与懒加载</h3><p><a href="http://www.zhangxinxu.com/wordpress/2016/06/image-preload-based-on-user-behavior/" target="_blank" rel="noopener">基于用户行为的图片等资源预加载–张鑫旭</a></p>
<p>预加载和懒加载的区别，懒加载当用户触发到某块内容区后才去加载，预加载是用户行为还没发生，资源已经加载完毕。</p>
<p><a href="https://www.cnblogs.com/jiekk/p/5687720.html" target="_blank" rel="noopener">实现图片预加载的三大方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web方面的知识盲区补漏。&lt;br&gt;
    
    </summary>
    
      <category term="interview questions" scheme="http://yoursite.com/categories/interview-questions/"/>
    
    
      <category term="interview questions" scheme="http://yoursite.com/tags/interview-questions/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about JS】 from牛客网</title>
    <link href="http://yoursite.com/2018/02/27/interview-questions-about-JS/"/>
    <id>http://yoursite.com/2018/02/27/interview-questions-about-JS/</id>
    <published>2018-02-27T08:35:38.000Z</published>
    <updated>2018-03-03T02:48:47.858Z</updated>
    
    <content type="html"><![CDATA[<p>来自牛客网<a href="https://www.nowcoder.com/ta/front-end-interview?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">前端面试经典题目合集</a> 篇学习总结。<br><a id="more"></a></p>
<h3 id="Cookie的弊端"><a href="#Cookie的弊端" class="headerlink" title="Cookie的弊端"></a>Cookie的弊端</h3><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。<br><strong>优点：</strong><br>1) 数据持久性。<br>2) 不需要任何服务器资源。 Cookie 存储在客户端并在发送后由服务器读取。<br>3) 可配置到期规则。 控制 cookie 的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的 cookie 。<br>4) 简单性。 基于文本的轻量结构。<br>5) 通过良好的编程，控制保存在 cookie 中的 session 对象的大小。<br>6) 通过加密和安全传输技术（ SSL ），减少 cookie 被破解的可能性。<br>7) 只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。<br><strong>缺点：</strong><br>1) Cookie 数量和长度的限制 。<br>数量：每个域的 cookie 总数有限。</p>
<pre><code>a) IE6 或更低版本最多 20 个 cookie
b) IE7 和之后的版本最后可以有 50 个 cookie
c) Firefox 最多 50 个 cookie
d) chrome 和 Safari 没有做硬性限制
</code></pre><p>长度：每个 cookie 长度不超过 4KB （ 4096B ），否则会被截掉。<br>2) 潜在的安全风险。 Cookie 可能被拦截、篡改。如果 cookie 被拦截，就有可能暴露所有的 session 信息。<br>3)额外开销。  cookie 在每次发起 HTTP 请求的时候都会被发送给服务器，一些不需要的信息也有可能会被发送，会增加开销。<br>4) 用户配置为禁用 。有些用户禁用了浏览器或客户端设备接受 cookie 的能力，因此限制了这一功能。<br>5) 有些状态不可能保存在客户端 。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</p>
<h3 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h3><p>1)Cookie ：广泛应用，局限明显。支持数据存储量相对较少，每个 domain 最多只能有 20 条 cookie ，每个 cookie 长度不能超过 4KB ，否则会被截掉；同时，存在安全性问题，如果被拦截，就可以取得所有的 session 信息。<br>2)Flash SharedObject ：使用的是 kissy 的 store 模块来调用 Flash SharedObject 。<br>优点：容量适中，基本上不存在兼容性问题<br>缺点：要在页面中引入特定的 Flash 和 JS ，增加额外负担，处理繁琐；还是有部分机子没有 flash 运行环境。<br>3)Google Gears ：  Google 的离线方案，已经停止更新，官方推荐使用 HTML5 的 localStorage 方案。<br>4)User Data ：   是微软为 IE 专门在系统中开辟的一块存储空间，只支持 Windows+IE 的组合。单个文件的大小限制是 128KB ，一个域名下总共可以保存 1024KB 的文件，文件个数应该没有限制。在受限站点里这两个值分别是 64KB 和 640KB 。（所以如果考虑到各种情况的话，单个文件最好能控制 64KB 以下。）<br>（实际测试 2000(IE5.5)、 XP(IE6 、 IE7)， Vista(IE7)下都是可正常使用。）<br>5)indexedDB : indexedDB是适合在本地存储大量非关系型数据（NOSQL），采取的是事件+异步回调进行操作。<br><strong>6)Web Storage</strong><br>在较高版本的浏览器中， JS 提供了 sessionStorage 和 globalStorage 。在 HTML5 中提供了 sessionStorage 和 <strong>localStorage</strong> 。<br>sessionStorage 用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。<br>globalStorage 跨越会话存储数据。有特定访问限制，要指定哪些域可访问该数据。</p>
<p><strong>localStorage</strong> 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。不能给 localStorage 指定任何规则，要访问同一个 localStorage ，页面必须使用同一个域名，使用同一种协议，在同一个端口上，即要求同源，不能跨域。</p>
<p>优点：容量大、易用、强大、原生支持<br>缺点： a) 兼容性差（ Chrome,Safari,Firefox,Opera,IE8+ 支持 ， IE8 以下版本不支持）<br>b) 安全性差（所以请勿使用 localStorage 保存敏感信息）<br>c)跨域限制<br>用途：<br>localStorage 可以利用持久化数据本地存储的特点来做网站优化，把一些静态资源，存储在本地，但是这个意义对PC端可能相对小一些，PC端的网速一般比较理想，读取本地localStorage的消耗 和读取服务器的消耗优化不了多少，而且存在本地localstorage的维护成本，总体性价比一般，移动端是可以利用这一点做一些优化，移动端的网络环境还是没达到理想，所以读取localstorage的代价应该小于服务器加载。 </p>
<h3 id="Web-Storage-与-Cookie-的区别"><a href="#Web-Storage-与-Cookie-的区别" class="headerlink" title="Web Storage 与 Cookie 的区别"></a>Web Storage 与 Cookie 的区别</h3><p>1 、 Web Storage 中的数据仅在存在本地，不与服务器发生交互。Cookie 中的数据会在浏览器和服务器中来回传递。<br>2 、 Web Storage 存储空间更大，可以达到 5M。Cookie 数据大小不超过 4KB 。<br>3 、 Web Storage 提供更多丰富易用的接口，如 setItem ， getItem ， removeItem ， clear 等方法，操作数据更方便。Cookie 需要自己封装方法。<br>4 、 cookie 需要指定作用域，不可以跨域调用，同样Web Storage 也存在跨域问题。<br>5、 cookie 中的数据在过期时间之前均有效， Web Storage 则不同， sessionStorage 中的数据在当前浏览器窗口关闭后自动删除， localStorage持久存储数据，除非主动删除数据。</p>
<p>注： 但 Cookie 是不可以或缺的，Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地 “ 存储 ” 数据而生。</p>
<h3 id="position的absolute与fixed共同点与不同点"><a href="#position的absolute与fixed共同点与不同点" class="headerlink" title="position的absolute与fixed共同点与不同点"></a>position的absolute与fixed共同点与不同点</h3><p>共同点：<br>1.改变行内元素的呈现方式，display被置为inline-block；<br>2.让元素脱离普通流，不占据空间；<br>3.默认会覆盖到非定位元素上</p>
<p>不同点：<br>absolute的“根元素”是可以设置的，在父元素上设定定位relative；而fixed的“根元素”固定为浏览器窗口。<br>当滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p>
<h3 id="CSS-哪些属性可以继承-CSS3新增伪类"><a href="#CSS-哪些属性可以继承-CSS3新增伪类" class="headerlink" title="CSS 哪些属性可以继承? CSS3新增伪类?"></a>CSS 哪些属性可以继承? CSS3新增伪类?</h3><p>可继承的样式：<br>1.font-size<br>2.font-family<br>3.color<br>4.text-indent<br>不可继承的样式：<br>1.border<br>2.padding<br>3.margin<br>4.width<br>5.height<br>CSS3新增伪类举例：</p>
<pre><code>p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。 
</code></pre><h3 id="CSS3的新特性"><a href="#CSS3的新特性" class="headerlink" title="CSS3的新特性"></a>CSS3的新特性</h3><p>答题套路：在我们的项目中经常用CSS3中的XX属性来实现XX特效。</p>
<ol>
<li>CSS3实现圆角（border-radius），阴影（box-shadow）</li>
<li>对文字加特效（text-shadow、），线性渐变（gradient）</li>
<li>transform变换: rotate(9deg); scale(0.85,0.90); translate(0px,-30px); skew(-9deg,0deg) // 旋转,缩放,定位,倾斜</li>
<li>动画animation</li>
<li>增加了更多的CSS选择器  多背景 rgba()</li>
<li>在CSS3中唯一引入的伪类是 ::selection.</li>
<li>媒体查询，多栏布局</li>
<li>border-image</li>
</ol>
<h3 id="CSS-sprites-的理解及使用"><a href="#CSS-sprites-的理解及使用" class="headerlink" title="CSS sprites 的理解及使用"></a>CSS sprites 的理解及使用</h3><p>CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，再利用 CSS 的”background-image”，”background-repeat”，”background-position” 的组合进行背景定位，background-position 可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了 http2。 </p>
<p>HTTP/1.x 有个问题叫线端阻塞(head-of-line blocking), 它是指一个连接(connection)一次只提交一个请求的效率比较高, 多了就会变慢。 HTTP/1.1 试过用流水线(pipelining)来解决这个问题, 但是效果并不理想(数据量较大或者速度较慢的响应, 会阻碍排在他后面的请求). 此外, 由于网络媒介(intermediary )和服务器不能很好的支持流水线, 导致部署起来困难重重。<br>而多路传输(Multiplexing)能很好的解决这些问题, 因为它能同时处理多个消息的请求和响应; 甚至可以在传输过程中将一个消息跟另外一个掺杂在一起。 所以客户端只需要一个连接就能加载一个页面。<br>参见博客<a href="http://www.sohu.com/a/161201715_714863" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a>。</p>
<h3 id="Doctype文档类型"><a href="#Doctype文档类型" class="headerlink" title="Doctype文档类型"></a>Doctype文档类型</h3><ol>
<li>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</li>
<li>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</li>
<li>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</li>
<li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li>
</ol>
<h3 id="HTML与XHTML之间的区别"><a href="#HTML与XHTML之间的区别" class="headerlink" title="HTML与XHTML之间的区别"></a>HTML与XHTML之间的区别</h3><p>1、XHTML 元素必须被正确地嵌套，不正确嵌套会报错。<br>错误：<code>&lt;p&gt;&lt;span&gt;this is example.&lt;/p&gt;&lt;/span&gt;</code><br>正确：<code>&lt;p&gt;&lt;span&gt;this is example.&lt;/span&gt;&lt;/p&gt;</code><br>而html不被正确嵌套也不会报错。<br>2、 XHTML 元素必须被关闭，即使是空标签<code>&lt;/br&gt;</code>，否则报错。而html可以写成<code>&lt;br&gt;</code>而不报错。<br>3、 XHTML 标签名必须用小写字母。html可以大写。<br>4、 XHTML 文档必须拥有根元素html，所有的 XHTML 元素必须被嵌套于 <html> 根元素中。<br>而html不是必须的。</html></p>
<h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3><p>1、 创建新节点</p>
<pre><code>createDocumentFragment() // 创建一个DOM片段
createElement() // 创建一个具体的元素
createTextNode() // 创建一个文本节点
</code></pre><p>2、 添加、移除、替换、插入</p>
<pre><code>appendChild()
removeChild()
replaceChild()
insertBefore() // 在已有的子节点前插入一个新的子节点
</code></pre><p>3、查找</p>
<pre><code>getElementsByTagName() // 通过标签名称
getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
document.getElementById() // 通过元素Id，唯一性
getElementsByClassName() //通过类名
queryselector()  
querySeletorAll() // (IE67 不支持)
</code></pre><h3 id="html5-的新特性以及新标签的浏览器兼容问题"><a href="#html5-的新特性以及新标签的浏览器兼容问题" class="headerlink" title="html5 的新特性以及新标签的浏览器兼容问题"></a>html5 的新特性以及新标签的浏览器兼容问题</h3><p><strong>新特性：</strong><br>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。<br>1、拖拽释放(Drag and drop) API<br>2、语义化更好的内容标签（header,nav,footer,aside,article,section）<br>3、 音频、视频API(audio,video)<br>4、 画布(Canvas) API<br>5、 地理(Geolocation) API<br>6、 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；<br>7、 sessionStorage 的数据在浏览器关闭后自动删除<br>8、 表单控件，calendar、date、time、email、url、search<br>9、 新的技术webworker, websocket, Geolocation<br><strong>移除的元素：</strong><br>1、 纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>2、 对可用性产生负面影响的元素：frame，frameset，noframes；<br><strong>支持HTML5新标签：</strong><br> IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shiv框架）：</p>
<pre><code>&lt;!--[if lt IE 9]&gt; 
&lt;script&gt; src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; 
&lt;![endif]--&gt; 
</code></pre><p><strong>如何区分：</strong><br>DOCTYPE声明新增的结构元素、功能元素</p>
<h3 id="iframe的优缺点"><a href="#iframe的优缺点" class="headerlink" title="iframe的优缺点"></a>iframe的优缺点</h3><p>优点：<br>1、 解决加载缓慢的第三方内容如图标和广告等的加载问题<br>2、 Security sandbox<br>3、 并行加载脚本<br>4、 重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)<br>5、 方便制作导航栏<br>缺点：<br>1、 iframe会阻塞主页面的Onload事件<br>2、 即时内容为空，加载也需要时间<br>3、 没有语意<br>4、 会产生很多页面，不容易管理<br>5、 不容易打印<br>6、 浏览器的后退按钮无效<br>7、 代码复杂,无法被一些搜索引擎索引到<br>8、 多数小型的移动设备（PDA 手机）无法完全显示框架<br>9、 多框架的页面会增加服务器的http请求<br>10、 由于上面诸多缺点，因此不符合标准网页设计的理念,已经被标准网页设计抛弃</p>
<h3 id="webSocket-如何兼容低浏览器"><a href="#webSocket-如何兼容低浏览器" class="headerlink" title="webSocket 如何兼容低浏览器"></a>webSocket 如何兼容低浏览器</h3><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR </p>
<h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位。<br>1、 一个程序至少有一个进程,一个进程至少有一个线程<br>2、 线程的划分尺度小于进程，使得多线程程序的并发性高<br>3、 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率<br>4、 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>5、 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</p>
<h3 id="如何对网站的文件和资源进行优化"><a href="#如何对网站的文件和资源进行优化" class="headerlink" title="如何对网站的文件和资源进行优化"></a>如何对网站的文件和资源进行优化</h3><p>1、 文件合并<br>2、 文件最小化/文件压缩<br>3、 使用 CDN 托管<br>4、 缓存的使用（多个域名来提供缓存）<br>雅虎军规：<br>1、尽可能减少http请求次数，将css, js, 图片各自合并<br>2、使用CDN，降低通信距离<br>3、添加Expire/Cache-Control头<br>4、启用Gzip压缩文件<br>5、将css放在页面最上面<br>6、将script放在页面最下面<br>7、避免在css中使用表达式<br>8、将css, js都放在外部文件中<br>9、减少DNS查询<br>10、最小化css, js，减小文件体积<br>11、避免重定向<br>12、移除重复脚本<br>13、配置实体标签ETag<br>14、使用AJAX缓存，让网站内容分批加载，局部更新</p>
<h3 id="三种减少页面加载时间的方法"><a href="#三种减少页面加载时间的方法" class="headerlink" title="三种减少页面加载时间的方法"></a>三种减少页面加载时间的方法</h3><p>1、 优化图片<br>2、 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3、 优化CSS（压缩合并css，如 margin-top, margin-left…)<br>4、 网址后加斜杠（如www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）<br>5、 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。<br>当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>6、 减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面 </p>
<h3 id="测试JS代码性能的工具"><a href="#测试JS代码性能的工具" class="headerlink" title="测试JS代码性能的工具"></a>测试JS代码性能的工具</h3><p><a href="https://www.zhihu.com/question/20704098" target="_blank" rel="noopener">如何测试javascript代码的性能？—知乎</a><br>1、 浏览器debug中现在都有原生的profile功能，可定位那个函数调用得多，用的时间多，这个可以比较精确定位耗时的函数。<br>2、JSPerf  <a href="http://blog.csdn.net/meloseven/article/details/61615591?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">使用Benchmark.js和jsPerf分析代码性能</a><br>3、 Dromaeo</p>
<p>前端性能测试：<br><strong>Page Speed Online</strong><br>Google Page Speed 是当下很流行的在线测试网站性能工具，基于Google的一套最佳的前端性能的规则，你可以很方便得到大量的性能信息，甚至还提供了移动设备的最佳实践报告<br><strong>WebPagetest</strong><br>WebPagetest 是性能测试的黄金标准，它提供了多方面的量化指标用于性能测试，比如有一个基本的评分，用于评价当前页面优化的水平；有一个截图，显示页面加载后的视觉效果；还有一个浏览器加载资源的瀑布流…<br>根据用户浏览器真实的连接速度，在全球范围内进行网页速度测试，并提供详细的优化建议。<br><a href="http://www.51testing.com/index.php?action-viewnews-itemid-3720205-php-1" target="_blank" rel="noopener">前端性能测试必备工具清单</a><br><a href="https://www.jianshu.com/p/cdf777f13ff6" target="_blank" rel="noopener">前端性能优化和测试工具总结</a><br><a href="http://www.daqianduan.com/3962.html" target="_blank" rel="noopener">推荐10个免费在线测试网页性能工具</a></p>
<h3 id="什么是-FOUC？-如何来避免-FOUC？"><a href="#什么是-FOUC？-如何来避免-FOUC？" class="headerlink" title="什么是 FOUC？ 如何来避免 FOUC？"></a>什么是 FOUC？ 如何来避免 FOUC？</h3><p>FOUC - Flash Of Unstyled Content 文档样式闪烁<br>使用<code>&lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt;</code> @import导入外部样式文件时，IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br>解决办法：将@import换成link，link是顺序加载，这样页面就会等css下载完之后再下载html文件，这样就先布好了局，所以就不会出现focus闪烁问题。</p>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p>null是一个表示”无”的对象，转为数值时为0<br>undefined是一个表示”无”的原始值，转为数值时为NaN</p>
<p>当声明的变量还未被初始化时，变量的默认值为undefined<br>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象</p>
<p>undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>1、 变量被声明了，但没有赋值时，就等于 undefined<br>2、 调用函数时，应该提供的参数没有提供，该参数等于 undefined<br>3、 对象没有赋值的属性，该属性的值为 undefined<br>4、 函数没有返回值时，默认返回 undefined</p>
<p>null表示“没有对象”，即该处不应该有值。典型用法是：<br>1、 作为函数的参数，表示该函数的参数不是对象<br>2、 作为对象原型链的终点</p>
<h3 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么"></a>new操作符具体干了什么</h3><p>1、 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br>2、 属性和方法被加入到 this 引用的对象中<br>3、 新创建的对象由 this 所引用，并且最后隐式的返回 this</p>
<pre><code>//var obj = new Base();    
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
</code></pre><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。<code>{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;}</code></p>
<pre><code>json.stringify({a:10,b:20}); //json对象转换成字符串 
json.parse(&apos;{&quot;a&quot;:10,&quot;b&quot;:20}&apos;) //字符串转换成json对象
</code></pre><p><a href="http://blog.csdn.net/qq_32528231/article/details/52783210" target="_blank" rel="noopener">博客—对json的理解</a></p>
<h3 id="js延迟加载的方式"><a href="#js延迟加载的方式" class="headerlink" title="js延迟加载的方式"></a>js延迟加载的方式</h3><p>JS延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。<br>JS延迟加载有助于提高页面加载速度。</p>
<pre><code>defer 属性
async 属性
动态创建DOM方式
使用jQuery的getScript方法
使用setTimeout延迟方法
让JS最后加载
</code></pre><p>1、 defer<br>HTML 4.01 为 <code>&lt;script&gt;</code>标签定义了 defer属性。<br>用途：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕之后再执行。<br>defer属性只适用于外部脚本文件。支持 HTML5 的实现会忽略嵌入脚本设置的 defer属性。<br>2、 async<br>HTML5 为 <code>&lt;script&gt;</code>标签定义了 async属性。与defer属性类似，都用于改变处理脚本的行为。同样，只适用于外部脚本文件。<br>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。<br>异步脚本一定会在页面 load 事件前执行。<br>不能保证脚本会按顺序执行。<br>3、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）<br>4、 按需异步载入js(可以将js文件加载绑定到一个事件上，这样当事件发生时，才会加载相应的js文件)<br><a href="http://blog.csdn.net/meijory/article/details/76389762" target="_blank" rel="noopener">JS延迟加载的几种方式</a></p>
<h3 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h3><pre><code>1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域
</code></pre><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a><br><a href="https://github.com/shirley5li/cross-domain" target="_blank" rel="noopener">关于跨域的简单demo集合–github</a></p>
<h3 id="documen-write和-innerHTML-的区别"><a href="#documen-write和-innerHTML-的区别" class="headerlink" title="documen.write和 innerHTML 的区别"></a>documen.write和 innerHTML 的区别</h3><p>document.write 只能同步执行，如果在window.onload之前执行则在文档流中绘制内容，如果在window.onload之后则会重绘整个页面（之前内容被冲刷掉）<br>innerHTML 则是绘制某个元素内的内容，没有这个限制 </p>
<h3 id="call-和-apply-的作用"><a href="#call-和-apply-的作用" class="headerlink" title=".call() 和 .apply() 的作用"></a>.call() 和 .apply() 的作用</h3><p>改变上下文，即this的指向。<br>apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性.</p>
<p>Function.apply(obj,args)方法能接收两个参数<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</p>
<p>call:和apply的意思一样,只不过是参数列表不一样.</p>
<p>Function.call(obj,[param1[,param2[,…[,paramN]]]])<br>obj：这个对象将代替Function类里this对象<br>params：这个是一个参数列表</p>
<h3 id="哪些操作会造成内存泄漏"><a href="#哪些操作会造成内存泄漏" class="headerlink" title="哪些操作会造成内存泄漏"></a>哪些操作会造成内存泄漏</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 </p>
<ol>
<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li>
<li>闭包</li>
<li>全局变量引起的内存泄漏</li>
<li>循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>
<li>dom清空或删除时，事件未清除导致的内存泄漏，脱离 DOM 的引用<br><a href="http://developer.51cto.com/art/201605/511624.htm#topx" target="_blank" rel="noopener">JavaScript内存泄露的4种方式及如何避免</a><br><a href="https://www.cnblogs.com/libin-1/p/6013490.html" target="_blank" rel="noopener">JavaScript常见的内存泄漏原因</a><br><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">JavaScript 内存泄漏教程—阮一峰</a></li>
</ol>
<h3 id="如何判断当前脚本运行在浏览器还是node环境中"><a href="#如何判断当前脚本运行在浏览器还是node环境中" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中"></a>如何判断当前脚本运行在浏览器还是node环境中</h3><p>通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。即在node中的全局变量是global ,浏览器的全局变量是window。 可以通过该全局变量是否定义来判断宿主环境。</p>
<pre><code>exports = typeof window === &apos;undefined&apos; ? global : window ;
//获取全局对象的方式
//同理可得，typeof window可以用来判断是不是在浏览器环境中
</code></pre><h3 id="Node-js的优缺点"><a href="#Node-js的优缺点" class="headerlink" title="Node.js的优缺点"></a>Node.js的优缺点</h3><p>优点：<br>　　　1、 高并发。采用事件驱动，异步编程，为网络服务而设计。NodeJS能支持比Java、PHP程序更高的并发量，虽然维护事件队列也需要成本，再由于NodeJS是单线程，事件队列越长，得到响应的时间就越长，并发量上还是会力不从心。<br>　　　2、 适合I/O密集型应用。 node.js非阻塞模式的IO处理给node.js带来在相对较低的资源耗用下的高性能与出众的负载能力,适合处理并发请求。<br>　　　3、 node.js轻量高效，可以认为是数据密集型实时应用系统的完美解决方案。<br>　　　4、 js语言适合前端工程师上手。<br>　　　5、 社区活跃发展速度快<br>缺点：<br>　　　1、 单线程，单进程，只支持单核CPU，不能充分的利用多核CPU服务器。<br>　　　2、 对程序员要求高一旦进程崩溃，那么整个web服务器就崩溃了。 解决方案：（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；（2）开多个进程监听同一个端口，使用cluster模块；<br>　　　3、 不适合做复杂性很高的计算。<br>　　　4、 不适合CPU密集型应用；CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；<br>　　　5、 开源组件库质量参差不齐，更新快，向下不兼容<br>　　　6、 Debug不方便，错误没有stack trace<br>NodeJS适合运用在高并发、I/O密集、少量业务逻辑的场景。<br><a href="http://blog.csdn.net/xiaemperor/article/details/38234979" target="_blank" rel="noopener">NodeJS优缺点及适用场景讨论</a></p>
<h3 id="前端界面工程师-理解及前景"><a href="#前端界面工程师-理解及前景" class="headerlink" title="前端界面工程师 理解及前景"></a>前端界面工程师 理解及前景</h3><p> 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。<br>1、 实现界面交互<br>2、 提升用户体验<br>3、 有了Node.js，前端可以实现服务端的一些事情<br>4、 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好<br>5、 参与项目，快速高质量完成实现效果图，精确到1px；<br>6、 与团队成员，UI设计，产品经理的沟通；<br>7、 做好的页面结构，页面重构和用户体验；<br>8、 处理hack，兼容、写出优美的代码格式；<br>9、 针对服务器的优化、拥抱最新前端技术。 </p>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><p>1xx: 信息性状态码，表示服务器接收到请求正在处理。<br>2xx: 成功状态码，表示服务器正确处理完请求。<br>3xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。301永久重定向，302临时重定向。<br>4xx: 客户端错误状态码，服务器无法处理该请求。 404 not found<br>5xx: 服务器错误状态码，服务器处理请求出错。</p>
<p>100 Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200 OK   正常返回信息<br>201 Created  请求成功并且服务器创建了新的资源<br>202 Accepted  服务器已接受请求，但尚未处理<br>301 Moved Permanently  请求的网页已永久移动到新位置<br>302 Found  临时性重定向<br>303 See Other  临时性重定向，且总是使用 GET 请求新的 URI<br>304 Not Modified  自从上次请求后，请求的网页未修改过<br>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求<br>401 Unauthorized  请求未授权<br>403 Forbidden  禁止访问<br>404 Not Found  找不到如何与 URI 相匹配的资源<br>500 Internal Server Error  最常见的服务器端错误<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</p>
<h3 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h3><p>1、 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。(DNS查询方式：浏览器缓存-&gt;系统缓存-&gt;路由器缓存)<br>2、 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。<br>3、 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。<br>4、 此时，Web 服务器提供资源服务，客户端开始下载资源。</p>
<p>请求返回后，便进入了我们关注的前端模块<br>浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM</p>
<h3 id="如何管理项目"><a href="#如何管理项目" class="headerlink" title="如何管理项目"></a>如何管理项目</h3><p>1、 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等<br>2、 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）<br>3、 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）<br>4、 页面进行标注（例如 页面 模块 开始和结束）<br>5、 CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）<br>6、 JS 分文件夹存放 命名以该 JS 功能为准的英文翻译<br>7、 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理</p>
<h3 id="javascript对象的几种创建方式"><a href="#javascript对象的几种创建方式" class="headerlink" title="javascript对象的几种创建方式"></a>javascript对象的几种创建方式</h3><p>1、工厂模式<br>2、构造函数模式<br>3、原型模式 </p>
<h3 id="javascript继承的-6-种方法"><a href="#javascript继承的-6-种方法" class="headerlink" title="javascript继承的 6 种方法"></a>javascript继承的 6 种方法</h3><p>1、 原型链继承<br>2、 借用构造函数继承<br>3、 组合继承(原型+借用构造)<br>4、 原型式继承<br>5、 寄生式继承<br>6、 寄生组合式继承<br><a href="http://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">JS继承的实现方式</a></p>
<h3 id="ajax-的过程"><a href="#ajax-的过程" class="headerlink" title="ajax 的过程"></a>ajax 的过程</h3><p>1、 创建XMLHttpRequest对象,也就是创建一个异步调用对象<br><code>var xhr = new XMLHttpRequest()</code><br>2、 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br><code>xhr.open(url,&quot;get&quot;,false);</code><br>3、 设置响应HTTP请求状态变化的函数<br><code>onreadyState监听</code><br>4、 发送HTTP请求<br>如果是post必须发送<code>xhr.send(null);</code>(null不能为空)<br>5、 获取异步调用返回的数据<br>6、 使用JavaScript和DOM实现局部刷新</p>
<pre><code>var xhr=new XMLHttpRequest();
    xhr.onreadystatechange=function(){
        if(xhr.readyState===4){
            if(xhr.status===200){
                doResponse(xhr.responseText);
            }
        }
    }
    xhr.open(&apos;GET&apos;,&apos;URL&apos;,true);
    xhr.send(null);

    xhr.open(&apos;POST&apos;,&apos;URL&apos;,true);
    setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;);
    xhr.send(&apos;k=v&amp;k=v&apos;);
</code></pre><h3 id="异步加载和延迟加载"><a href="#异步加载和延迟加载" class="headerlink" title="异步加载和延迟加载"></a>异步加载和延迟加载</h3><p>把script标签放在head之间，意味着必须等到全部js代码都被下载，解析，执行完成之后，才开始呈现页面的内容。浏览器在遇到body标签时才开始呈现内容</p>
<p>1、<code>&lt;script&gt;</code>标签定义了defer属性，这个属性的用途表明脚本在执行的时候不会影响页面结构，相当于告诉浏览器立即下载，但延迟执行。<br>注意defer属性只使用于外部脚本文件，支持html5的实现会忽略给嵌入脚本设置的defer属性。因此把延迟脚本放在页面的底部仍是最佳的选择<br><code>&lt;script  type = &quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;.js&quot;&gt;</code><br>2、异步脚本<br>async只使用于外部脚本文件，并告诉浏览器立即下载文件，但与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。<br><code>&lt;script  type = &quot;text/javascript&quot; async src=&quot;.js&quot;&gt;</code></p>
<h3 id="前端的安全问题"><a href="#前端的安全问题" class="headerlink" title="前端的安全问题"></a>前端的安全问题</h3><p>1、XSS指cross-site-scripting, 跨站脚本攻击，恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。<br> <a href="https://zhuanlan.zhihu.com/p/26177815?utm_source=weibo&amp;utm_medium=social" target="_blank" rel="noopener">浅谈XSS攻击的那些事（附常用绕过姿势）</a><br>2、SQL注入，指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。<br><a href="http://blog.csdn.net/qq_34858648/article/details/52750038" target="_blank" rel="noopener">SQL注入攻击原理以及基本方法</a><br>3、OS命令注入攻击，指的是通过web应用，执行非法的操作系统命令达到非法攻击的目的。<br>4、HTTP首部注入攻击，指攻击者通过在相应首部字段内插入换行，然后添加任意响应首部过主体的攻击。 邮件首部注入攻击，指攻击者通过向邮件首部to或subject内任意添加非法内容引起的攻击。<br><a href="http://blog.csdn.net/ffm83/article/details/44222319" target="_blank" rel="noopener">攻击服务端(4)-HTTP参数注入攻击</a><br>5、会话劫持，指攻击者通过某种手段拿到了用户的会话id，并非法使用此会话id伪装成用户达到攻击的目的。 6、还有DoS DDoS，一种让运行中的服务成停止状态的攻击。<br>7、CSRF，跨站点请求伪造攻击，指的是攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等<br><a href="http://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="noopener"> CSRF攻击与防御</a></p>
<h3 id="ie-各版本和-chrome-可以并行下载多少个资源"><a href="#ie-各版本和-chrome-可以并行下载多少个资源" class="headerlink" title="ie 各版本和 chrome 可以并行下载多少个资源"></a>ie 各版本和 chrome 可以并行下载多少个资源</h3><p>1、 IE6 2 个并发<br>2、 iE7 升级之后的 6 个并发，之后版本也是 6 个<br>3、 Firefox，chrome 也是6个</p>
<h3 id="js继承怎么实现，如何避免原型链上面的对象共享"><a href="#js继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="js继承怎么实现，如何避免原型链上面的对象共享"></a>js继承怎么实现，如何避免原型链上面的对象共享</h3><p>1、 原型链继承<br>2、 借用构造函数继承<br>3、 组合继承(原型+借用构造)<br>4、 原型式继承<br>5、 寄生式继承<br>6、 寄生组合式继承<br>利用空对象作为中介。<br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html" target="_blank" rel="noopener">Javascript面向对象编程（二）：构造函数的继承 —阮一峰</a></p>
<h3 id="代码压缩工具及使用方法"><a href="#代码压缩工具及使用方法" class="headerlink" title="代码压缩工具及使用方法"></a>代码压缩工具及使用方法</h3><p>1、Google Closure Compile<br>2、Yahoo Yui Compresso<br>3、UglifyJS<br>GCC压缩混淆的最彻底，但是破坏原有代码，并且不可压缩CSS文件，运行在java环境下，危险，要严格注意书写规范。<br>Yui可以压缩CSS文件，安全，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，运行在java环境下。<br>UglifyJs不可以压缩混淆CSS文件，运行在NodeJs环境下，但是压缩完的文件函数名称没有混淆，压缩混淆的作用小，安全<br><a href="http://blog.csdn.net/nh18304030935/article/details/70846649" target="_blank" rel="noopener">JS代码压缩混淆工具使用说明</a></p>
<h3 id="Flash、Ajax各自的优缺点，在使用中如何取舍"><a href="#Flash、Ajax各自的优缺点，在使用中如何取舍" class="headerlink" title="Flash、Ajax各自的优缺点，在使用中如何取舍"></a>Flash、Ajax各自的优缺点，在使用中如何取舍</h3><p>Flash：<br>1、 Flash适合处理多媒体、矢量图形、访问机器<br>2、 对CSS、处理文本上不足，不容易被搜索<br>Ajax：<br>1、 Ajax对CSS、文本支持很好，支持搜索<br>2、 多媒体、矢量图形、机器访问不足<br>共同点：<br>1、 与服务器的无刷新传递消息<br>2、 可以检测用户离线和在线状态<br>3、 操作DOM</p>
<h3 id="JavaScript-的同源策略"><a href="#JavaScript-的同源策略" class="headerlink" title="JavaScript 的同源策略"></a>JavaScript 的同源策略</h3><p>概念：<br>同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。<br>同源策略是浏览器为了保护用户的个人信息以及企业数据的安全而设置的一种策略，不同源的客户端脚本是不能在对方未允许的情况下访问或索取对方的数据信息。</p>
<p>为什么要有同源限制：<br>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。<br>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<h3 id="什么是-“use-strict”-使用它的好处和坏处"><a href="#什么是-“use-strict”-使用它的好处和坏处" class="headerlink" title="什么是 “use strict” ? 使用它的好处和坏处"></a>什么是 “use strict” ? 使用它的好处和坏处</h3><p>ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。<br>设立”严格模式”的目的，主要有以下几个：<br>1、 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;<br>2、 消除代码运行的一些不安全之处，保证代码运行的安全；<br>3、 提高编译器效率，增加运行速度；<br>4、 为未来新版本的Javascript做好铺垫。<br>注：经过测试 IE6,7,8,9 均不支持严格模式。<br>缺点：<br>现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p>
<p>GET方式需要使用 Request.QueryString 来取得变量的值<br>POST方式通过 Request.Form 来获取变量的值<br>也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。</p>
<p>在以下情况中，请使用 POST 请求：<br>1、 无法使用缓存文件（更新服务器上的文件或数据库）<br>2、 向服务器发送大量数据（POST 没有数据量限制）<br>3、 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<p>HTTP方法 是根据意图区分的，HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br>表面区别：<br>(1)传参方式<br>1、 GET可以通过URL直接传参<br>2、 两者都可以通过body传参<br>(2)长度<br>1、 header和body都没有对长度的限制<br>2、 URL的长度受到部分早期浏览器的限制<br>3、 URL的长度还可能受到服务器的限制，由于URL的实际超长或者设定其Content-Length较大值会引起服务器最大并发数下降或者资源空耗<br>4、 2和3间接限定了URL方式发起GET方法的长度<br>(3)安全性<br>1、 GET不会修改服务端数据，POST可以修改数据<br>2、 URL方式发起GET请求，参数会明文暴露<br>3、 使用GET提交数据还可能会造成Cross-site request forgery攻击<br>4、 本质上安全性无区别 </p>
<h3 id="css阻塞，js阻塞"><a href="#css阻塞，js阻塞" class="headerlink" title="css阻塞，js阻塞"></a>css阻塞，js阻塞</h3><p><strong>js 的阻塞特性：</strong>所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。<br>浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。<br>嵌入 JS 会阻塞所有内容的呈现，而外部 JS 只会阻塞其后内容的显示，2 种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。 </p>
<p>CSS 怎么会阻塞加载了？CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）<br>当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了。<br>根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。 </p>
<p> 嵌入JS应该放在什么位置？<br>1、 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。<br>2、 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。<br>3、 使用 defer（只支持IE）<br>4、 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用</p>
<p>Javascript无阻塞加载具体方式：<br>1、 将脚本放在底部。<code>&lt;link&gt;</code>还是放在head中，用以保证在js加载前，能加载出正常显示的页面。<code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>前。<br>2、 阻塞脚本：由于每个<code>&lt;script&gt;</code>标签下载时阻塞页面解析过程，所以限制页面的<code>&lt;script&gt;</code>总数也可以改善性能。适用于内联脚本和外部脚本。<br>3、 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。<br>4、 defer属性：支持IE4和fierfox3.5更高版本浏览器<br>5、 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：</p>
<pre><code>&lt;script&gt;
    var script=document.createElement(&quot;script&quot;);
    script.type=&quot;text/javascript&quot;;
    script.src=&quot;file.js&quot;;
    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);
&lt;/script&gt;
</code></pre><p>此技术的重点在于：无论在何处启动下载，文件下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）<br><strong>关于CSS加载造成阻塞问题</strong><br>css并不会阻塞DOM树的解析，但会阻塞DOM树渲染。css加载会阻塞后面js语句的执行。<br>为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:<br>1.使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)<br>2.对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)<br>3.合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)<br>4.减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)<br><a href="https://www.cnblogs.com/chenjg/p/7126822.html" target="_blank" rel="noopener">css加载会造成阻塞吗</a></p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>1、 它的功能是把对应的字符串解析成JS代码并运行<br>2、 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</p>
<h3 id="一个通用的事件侦听器函数"><a href="#一个通用的事件侦听器函数" class="headerlink" title="一个通用的事件侦听器函数"></a>一个通用的事件侦听器函数</h3><pre><code>// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent : function(fn) {
        if (fn==null) {
            fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != &apos;function&apos;) {
            window.onload = fn;
        } else {
            window.onload = function() {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent : function(element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent(&apos;on&apos; + type, function() {
                handler.call(element);
            });
        } else {
            element[&apos;on&apos; + type] = handler;
        }
    },
    // 移除事件
    removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent(&apos;on&apos; + type, handler);
        } else {
            element[&apos;on&apos; + type] = null;
        }
    }, 
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation : function(ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault : function(event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget : function(event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev &amp;&amp; Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
</code></pre><h3 id="Node-js-的适用场景"><a href="#Node-js-的适用场景" class="headerlink" title="Node.js 的适用场景"></a>Node.js 的适用场景</h3><p>1、 高并发<br>2、 聊天<br>3、 实时消息推送   </p>
<p>1 Web开发：Express + EJS + Mongoose/MySQL<br>express 是轻量灵活的Nodejs Web应用框架，它可以快速地搭建网站。Express框架建立在Nodejs内置的Http模块上，并对Http模块再包装，从而实际Web请求处理的功能。<br>ejs是一个嵌入的Javascript模板引擎，通过编译生成HTML的代码。<br>mongoose 是MongoDB的对象模型工具，通过Mongoose框架，可以进行访问MongoDB的操作。<br>mysql 是连接MySQL数据库的通信API，可以进行访问MySQL的操作。<br>通常用Nodejs做Web开发，需要3个框架配合使用，就像Java中的SSH。<br>2 REST开发：Restify<br>restify 是一个基于Nodejs的REST应用框架，支持服务器端和客户端。restify比起express更专注于REST服务，去掉了express中的 template, render等功能，同时强化了REST协议使用，版本化支持，HTTP的异常处理。<br>3 Web聊天室(IM)：Express + Socket.io<br>socket.io一个是基于Nodejs架构体系的，支持websocket的协议用于时时通信的一个软件包。socket.io 给跨浏览器构建实时应用提供了完整的封装，socket.io完全由javascript实现。<br>4 Web爬虫：Cheerio/Request<br>cheerio 是一个为服务器特别定制的，快速、灵活、封装jQuery核心功能工具包。Cheerio包括了 jQuery核心的子集，从jQuery库中去除了所有DOM不一致性和浏览器不兼容的部分，揭示了它真正优雅的API。Cheerio工作在一个非常简 单，一致的DOM模型之上，解析、操作、渲染都变得难以置信的高效。基础的端到端的基准测试显示Cheerio大约比JSDOM快八倍(8x)。 Cheerio封装了@FB55兼容的htmlparser，几乎能够解析任何的 HTML 和 XML document。<br>5 Web博客：Hexo<br>Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架。通过Hexo我们可以快速创建自己的博客，仅需要几条命令就可以完成。<br>发布时，Hexo可以部署在自己的Node服务器上面，也可以部署github上面。对于个人用户来说，部署在github上好处颇多，不仅可以省 去服务器的成本，还可以减少各种系统运维的麻烦事(系统管理、备份、网络)。所以，基于github的个人站点，正在开始流行起来….<br>6 Web论坛: nodeclub<br>Node Club 是用 Node.js 和 MongoDB 开发的新型社区软件，界面优雅，功能丰富，小巧迅速， 已在Node.js 中文技术社区 CNode 得到应用，但你完全可以用它搭建自己的社区。<br>7 Web幻灯片：Cleaver<br>Cleaver 可以生成基于Markdown的演示文稿。如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。<br>8 前端包管理平台: bower.js<br>Bower 是 twitter 推出的一款包管理工具，基于nodejs的模块化思想，把功能分散到各个模块中，让模块和模块之间存在联系，通过 Bower 来管理模块间的这种联系。<br>9 OAuth认证：Passport<br>Passport项 目是一个基于Nodejs的认证中间件。Passport目的只是为了“登陆认证”，因此，代码干净，易维护，可以方便地集成到其他的应用中。Web应用 一般有2种登陆认证的形式：用户名和密码认证登陆,OAuth认证登陆。Passport可以根据应用程序的特点，配置不同的认证机制。本文将介绍，用户 名和密码的认证登陆。<br>10 定时任务工具: later<br>Later 是一个基于Nodejs的工具库，用最简单的方式执行定时任务。Later可以运行在Node和浏览器中。<br>11 浏览器环境工具: browserify<br>Browserify 的出现可以让Nodejs模块跑在浏览器中，用require()的语法格式来组织前端的代码，加载npm的模块。在浏览器中，调用browserify编译后的代码，</p>
<h3 id="JavaScript-原型，原型链-有什么特点？"><a href="#JavaScript-原型，原型链-有什么特点？" class="headerlink" title="JavaScript 原型，原型链 ? 有什么特点？"></a>JavaScript 原型，原型链 ? 有什么特点？</h3><p><strong>1.什么是原型，原型有什么特点：</strong><br>JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。<br>使用原型的好处是：原型对象上的所有属性和方法，都能被对应的构造函数创建的实例对象共享（这就是 JavaScript 继承机制的基本设计），也就是说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。<br>每一个构造函数都有一个prototype（原型）属性，这个属性就是使用构造函数创建出来的实例对象的原型对象。<br><strong>2.什么是原型链，原型链有什么特点</strong><br>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象上。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。<br>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。而Object.prototype对象的原型就是没有任何属性和方法的null对象，而null对象没有自己的原型。<br>“原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。<br>如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。<br>需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<h3 id="怎么重构页面"><a href="#怎么重构页面" class="headerlink" title="怎么重构页面"></a>怎么重构页面</h3><p>页面重构是一种思想，是页面的二次构造（在实现层次）：包括设计稿的重构、过时页面的重构、功能不全页面的重构、代码重构。<br>设计稿的重构：设计师的设计稿可能不是特别符合页面效果，当拿到设计稿时需要通过二次重构和修改达到预期效果。<br>功能不全页面的重构：页面功能不符合用户体验、用户交互。<br>过时页面的重构：使用的是过时的代码和标签，跟不上时代的发展。<br>代码重构：代码质量、SEO优化、页面性能、更好的语义化、浏览器兼容、CSS优化。</p>
<h3 id="WEB应用从服务器主动推送Data到客户端的方式"><a href="#WEB应用从服务器主动推送Data到客户端的方式" class="headerlink" title="WEB应用从服务器主动推送Data到客户端的方式"></a>WEB应用从服务器主动推送Data到客户端的方式</h3><p>1、<strong>AJAX轮询</strong><br>利用XHR，通过setInterval定时发送请求，但会造成数据同步不及时及无效的请求，增加后端处理压力<br>2、<strong>基于 AJAX 的长轮询</strong>（long-polling）方式<br>在Ajax轮询基础上做的一些改进，在没有更新的时候不再返回空响应，而且把连接保持到有更新的时候，客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求，通常把这种实现也叫做<strong>comet</strong>。<br>3、<strong>Server-sent-events(SSE)</strong><br>让服务端可以向客户端流式发送文本消息，在实现上，客户端浏览器中增加EventSource对象，使其能通过事件的方式接收到服务器推送的消息，在服务端，使用长连接的事件流协议，即请求响应时增加新数据流数据格式。<br>适应于后端数据更新频繁且对实时性要求较高而又不需要客户端向服务端通信的场景下。<br>缺点： 只能单向通信，服务器端向客户端推送事件；事件流协议只能传输UTF-8数据，不支持二进制流。<br>4、<strong>HTTP Streaming</strong><br>通过iframe和<code>&lt;script&gt;</code>标签完成数据的传输<br>5、<strong>TCP 长连接</strong><br>6、<strong>HTML5 WebSocket</strong><br>可以实现服务器主动发送数据至网页端，它和HTTP一样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应<br><a href="https://www.zhihu.com/question/24938934" target="_blank" rel="noopener">服务端是如何主动推送信息到客户端的？</a><br><a href="http://www.daimajiayuan.com/sitejs-65893-1.html" target="_blank" rel="noopener">几种web服务器端推送技术的简单介绍</a><br><a href="https://www.cnblogs.com/Herzog3/p/5939144.html" target="_blank" rel="noopener">HTML5服务器推送消息的各种解决办法</a></p>
<h3 id="事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1、 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为<br>2、 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件<br>3、 ev.stopPropagation();<br>注意旧ie的方法：ev.cancelBubble = true;</p>
<h3 id="Ajax-是什么？Ajax-的交互模型？同步和异步的区别？如何解决跨域问题？"><a href="#Ajax-是什么？Ajax-的交互模型？同步和异步的区别？如何解决跨域问题？" class="headerlink" title="Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？"></a>Ajax 是什么？Ajax 的交互模型？同步和异步的区别？如何解决跨域问题？</h3><p>AJAX 的全称是异步的 Javascript 和 XML ，是一种创建快速动态网页的技术，通过在后台与服务器进行少量数据交互，实现网页的异步更新，在不重新加载整个界面的情况下，做到网页的部分刷新；<br><strong>AJAX 的交互模型（ AJAX 的过程）：</strong><br>用户发出异步请求；<br>创建 XMLHttpRequest 对象；<br>告诉 XMLHttpRequest 对象，哪个函数会处理 XMLHttpRequest 对象状态的改变，为此要把对象的 onReadyStateChange 属性设置为响应该事件的 JavaScript 函数的引用；<br>创建请求，用 open 方法指定是 get 还是 post ，是否异步， url 地址；<br>发送请求， send 方法；<br>接收结果并分析；<br>实现刷新<br><strong>同步异步的区别:</strong><br>同步：脚本会停留并等待服务器发送回复然后再继续<br>异步：脚本允许页面继续其进程，服务器返回结果时再作处理<br><strong>跨域问题的解决</strong><br>1、 使用 document.domain+iframe 解决跨子域问题<br>2、 使用 window.name<br>3、 使用 flash<br>4、 使用 iframe+location.hash<br>5、 使用 html5 的 postMessage ；<br>6、 使用 jsonp （创建动态 script ）</p>
<h3 id="js对象的深度克隆代码实现"><a href="#js对象的深度克隆代码实现" class="headerlink" title="js对象的深度克隆代码实现"></a>js对象的深度克隆代码实现</h3><pre><code>function clone(obj){
    if(!obj || typeof(obj) != &apos;object&apos;) return obj;
    var r = Array.prototype.splice === obj.splice ? []:{};
    for(var i in obj){
        if(obj.hasOwnProperty(i)){
            r[i] = clone(obj[i]);
        }
    }
    return r ;
}
//数组、对象都可以for in,同时针对对象必须需要判断hasOwnProperty属性，以防克隆原型链上的属性
</code></pre><p><a href="http://www.cnblogs.com/jq-melody/p/4499333.html" target="_blank" rel="noopener">javascript中对象的深度克隆</a></p>
<h3 id="网站重构"><a href="#网站重构" class="headerlink" title="网站重构"></a>网站重构</h3><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。<br>对于传统的网站来说重构通常是：<br>1、 表格(table)布局改为 DIV + CSS<br>2、 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对 IE6 有效的)<br>3、 对于移动平台的优化<br>4、 针对于 SEO 进行优化<br>5、 深层次的网站重构应该考虑的方面<br>6、 减少代码间的耦合<br>7、 让代码保持弹性<br>8、 严格按规范编写代码<br>9、 设计可扩展的API<br>10、 代替旧有的框架、语言(如VB)<br>11、 增强用户体验<br>12、 通常来说对于速度的优化也包含在重构中<br>13、 压缩JS、CSS、image等前端资源(通常是由服务器来解决)<br>14、 程序的性能优化(如数据读写)<br>15、 采用CDN来加速资源加载<br>16、 对于JS DOM的优化<br>17、 HTTP服务器的文件缓存</p>
<h3 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a>如何获取UA</h3><p>浏览器标识（UA,User Agent）可以使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件，从而判断用户是使用电脑浏览还是手机浏览，让网页作出自动的适应。<br>使用navigator对象:<br>1、Navigator.appCodeName,浏览器代码名的字符表示<br>2、appName，浏览器的名称<br>3、appVersion 返回broswer平台和版本信息<br>4、platform，返回运行浏览器的操作系统平台<br>5、userAgent，返回客户机发送给服务器的useragent头部的值</p>
<pre><code>&lt;script&gt; 
function whatBrowser() {  
    document.Browser.Name.value=navigator.appName;  
    document.Browser.Version.value=navigator.appVersion;  
    document.Browser.Code.value=navigator.appCodeName;  
    document.Browser.Agent.value=navigator.userAgent;  
}
&lt;/script&gt;
</code></pre><h3 id="js-数组去重"><a href="#js-数组去重" class="headerlink" title="js 数组去重"></a>js 数组去重</h3><p>1、</p>
<pre><code>function uniqArray(arr) {
    //利用es6 新的数据类型，Set() 集合来做，集合不的每个元素是不允许重复的

    return [... new Set(arr)];

    //return Array.from(new Set(arr));
}
</code></pre><p>2、</p>
<pre><code>Array.prototype.filterOverlap = function(){
    var temp = [];
    if(!this.length){
         return [];
    }
    for(var i=0,len = this.length;i&lt;len;i++){
     if(temp.indexOf(this[i])&lt;0){
          temp.push(this[i]);
      }   
    }
    return temp;
}
</code></pre><h3 id="网页缓存-cache-control"><a href="#网页缓存-cache-control" class="headerlink" title="网页缓存 cache-control"></a>网页缓存 cache-control</h3><p>1、http响应头信息，可以用来设置缓存，优化页面的性能。<br>服务器可以通过HTTP定义的几种方式来指定在文档过期之前可以将其缓存多长时间。<br>2、添加在HTTP响应头中<br>3、no-store：禁止缓存对响应进行复制<br>no-cache：在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用<br>max-age: 从服务器将文档传来之时，可以认为此文档处于新鲜状态的秒数<br>max-age=0;将最大使用时间设置为零，从而在每次访问的时候都进行刷新<br>Expires响应首部：实际的过期时间而不是秒数 (GMT格式)</p>
<p><a href="http://www.51testing.com/html/28/116228-238337.html" target="_blank" rel="noopener">Http头介绍:Expires,Cache-Control,Last-Modified,ETag</a><br><a href="http://blog.csdn.net/zhouziyu2011/article/details/71312452" target="_blank" rel="noopener">浅谈前端性能优化（一）——Expires和Cache-Control</a></p>
<h3 id="js-操作获取和设置-cookie"><a href="#js-操作获取和设置-cookie" class="headerlink" title="js 操作获取和设置 cookie"></a>js 操作获取和设置 cookie</h3><pre><code>// 创建cookie
function setCookie(name, value, expires, path, domain, secure) {
    var cookieText = encodeURIComponent(name) + &apos;=&apos; + encodeURIComponent(value);
    if (expires instanceof Date) {
        cookieText += &apos;; expires=&apos; + expires;
    }
    if (path) {
        cookieText += &quot;; path=&quot; + path     }
    if (domain) {
        cookieText += &apos;; domain=&apos; + domain;
    }
    if (secure) {
        cookieText += &apos;; secure&apos;;
    }
    document.cookie = cookieText;
}
// 获取cookie
function getCookie(name) {
    var cookieName = encodeURIComponent(name) + &apos;=&apos;;
    var cookieStart = document.cookie.indexOf(cookieName);
    var cookieValue = null;
    if (cookieStart &gt; -1) {
        var cookieEnd = document.cookie.indexOf(&apos;;&apos;, cookieStart);
        if (cookieEnd == -1) {
            cookieEnd = document.cookie.length;
        }
        cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));
    }
    return cookieValue;
}
// 删除cookie
function unsetCookie(name) {
    document.cookie = name + &quot;= ; expires=&quot; + new Date(0);
}
</code></pre><p><a href="https://www.cnblogs.com/anniey/p/6510911.html" target="_blank" rel="noopener">前端开发中通过js设置/获取cookie的一组方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自牛客网&lt;a href=&quot;https://www.nowcoder.com/ta/front-end-interview?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试经典题目合集&lt;/a&gt; 篇学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="interview questions" scheme="http://yoursite.com/categories/interview-questions/"/>
    
    
      <category term="interview questions" scheme="http://yoursite.com/tags/interview-questions/"/>
    
  </entry>
  
  <entry>
    <title>前端面试常见算法题总结</title>
    <link href="http://yoursite.com/2018/02/26/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/02/26/前端面试常见算法题/</id>
    <published>2018-02-26T06:24:48.000Z</published>
    <updated>2018-02-27T08:30:03.042Z</updated>
    
    <content type="html"><![CDATA[<p>十道前端面试常见算法题。<br><a id="more"></a></p>
<h3 id="判断一个单词是否是回文"><a href="#判断一个单词是否是回文" class="headerlink" title="判断一个单词是否是回文"></a>判断一个单词是否是回文</h3><p>思路：将字符串转换为数组，利用数组方法reverse()比较翻转后的字符串是否与源字符串一致。</p>
<p>实现：</p>
<pre><code>function checkPalindrome(str) {
    return str == str.split(&apos;&apos;).reverse().join(&apos;&apos;);
}
</code></pre><h3 id="去掉一组整型数组重复的值"><a href="#去掉一组整型数组重复的值" class="headerlink" title="去掉一组整型数组重复的值"></a>去掉一组整型数组重复的值</h3><pre><code>function uniqueArr(arr) {
    var result = [];
    for(var i = 0; i &lt; arr.length; i++) {
        if(arr.indexOf(arr[i]) === i) {
            result.push(arr[i]);
        }
    }
    return result;
}
uniqueArr([1,13,24,11,11,14,1,2]);//返回 [1, 13, 24, 11, 14, 2]
</code></pre><h3 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h3><pre><code>function maxDuplicateLetter(str) {
    //如果字符串仅有一个字符，即为该字符
    if(str.length === 1) {
        return str;
    }
    var letterObj = {};
    for(var i = 0; i &lt; str.length; i++) {
        if(!letterObj[str[i]]) {//存放字母的对象中还未记录过该字母出现的次数
            letterObj[str[i]] = 1;
        }
        letterObj[str[i]] += 1;
    }
    //接下来寻找存放字母的对象中最大的value所对应的key
    var maxValue = 1;
    var maxKey = &apos;&apos;;
    for(var key in letterObj) {
        if(letterObj[key] &gt; maxValue) {
            maxValue = letterObj[key];
            maxKey = key;
        }
    }
    return maxKey;
}
maxDuplicateLetter(&quot;abcdddbb&quot;);//返回 &quot;a&quot;
</code></pre><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p><strong>（1）冒泡排序</strong><br>依次比较相邻两个数的大小，进行位置上的交换，若按由小到大排序，第一轮可以将最大的排在最右边。<br>平均时间复杂度：O(n^2)  &nbsp;&nbsp;最好情况：O(n) &nbsp;&nbsp;  最坏情况：O(n^2)<br>空间复杂度：O(1)<br>排序方式:In-place<br>稳定性:稳定</p>
<pre><code>function bubbleSort(arr) {
    for(var i = 0; i &lt; arr.length; i++) {
        for(var j = 0; j &lt; arr.length - i -1; j ++) {
            // 由小到大排序
            if(arr[j] &gt; arr[j + 1]){
                var swap = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = swap;
            }
        }
    }
    return arr;
}
bubbleSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7]
</code></pre><p><strong>(2)快速排序</strong><br>参考某个元素值，将小于它的值，放到左数组中，大于它的值的元素就放到右数组中，然后递归进行上一次左右数组的操作，返回合并的数组就是已经排好顺序的数组。<br>平均时间复杂度: O(n log n)  &nbsp;&nbsp;最好情况：O(n log n) &nbsp;&nbsp;  最坏情况：O(n^2)<br>空间复杂度：O(1)<br>排序方式:In-place<br>稳定性:不稳定</p>
<pre><code>function quickSort(arr) {
    if(arr.length &lt;= 1) {
        return arr;
    }
    var referValue = arr[0];
    var leftArr = [];
    var rightArr = [];
    // 由小到大排序
    for(var i = 1; i &lt; arr.length; i++) {
        if(arr[i] &lt; referValue) {
            leftArr.push(arr[i]);
        } else {
            rightArr.push(arr[i]);
        }
    }
    return quickSort(leftArr).concat([referValue], quickSort(rightArr));
}
quickSort([3, 2, 4, 1, 7]);//返回 [1, 2, 3, 4, 7]
</code></pre><p>另外还有 <strong>选择排序、插入排序、希尔排序、归并排序、堆排序、计数排序、桶排序等</strong>，见博客<a href="https://www.cnblogs.com/beli/p/6297741.html" target="_blank" rel="noopener">js十大排序算法</a>。</p>
<h3 id="不借助临时变量，进行两个整数的交换"><a href="#不借助临时变量，进行两个整数的交换" class="headerlink" title="不借助临时变量，进行两个整数的交换"></a>不借助临时变量，进行两个整数的交换</h3><p>利用 + – 去进行运算，类似 a = a + ( b – a) 实际上等同于最后 的 a = b;</p>
<pre><code>function swap([a, b]) {
    var b = b - a;
    var a = a + b;
    var b = a - b;
    return [a, b];
}
swap([2, 5]);//返回 [5, 2]
</code></pre><h3 id="使用canvas-绘制一个有限度的斐波那契数列的曲线"><a href="#使用canvas-绘制一个有限度的斐波那契数列的曲线" class="headerlink" title="使用canvas 绘制一个有限度的斐波那契数列的曲线"></a>使用canvas 绘制一个有限度的斐波那契数列的曲线</h3><p><img src="http://img1.vued.vanthink.cn/vued90edf7b944ec479ee8b4203cf56e158d.png" alt="斐波那契数列曲线"><br>数列长度限定在9时的图像。<br>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……<br><code>fibo[i] = fibo[i-1]+fibo[i-2];</code><br>即生成斐波那契数列，然后再将该数列值作为半径，利用canvas arc方法绘制曲线。</p>
<pre><code>function generateFibo(n) {
    var fiboArr = [];
    var i = 0;
    while(i &lt; n) {
        if (i &lt;= 1) {
            fiboArr.push(i);
        } else {
            fiboArr[i] = fiboArr[i - 1] + fiboArr[i - 2];
        }
        i++;
    }
    return fiboArr;
}
generateFibo(6);//返回 [0, 1, 1, 2, 3, 5]
</code></pre><h3 id="找出正数组的最大差值"><a href="#找出正数组的最大差值" class="headerlink" title="找出正数组的最大差值"></a>找出正数组的最大差值</h3><p>相当于找到一个数组中的最大值与最小值，最大差值即为两者之差。</p>
<pre><code>function maxDifference(arr) {
    var minValue = arr[0];
    var maxDiffer = 0;
    for(var i = 0; i &lt; arr.length; i++) {
        minValue = Math.min(minValue, arr[i]);
        currentDiffer = arr[i] - minValue;
        maxDiffer = Math.max(maxDiffer, currentDiffer);
    }
    return maxDiffer;
}
maxDifference([10,5,11,7,8,9]);//返回 6
</code></pre><h3 id="随机生成指定长度的字符串"><a href="#随机生成指定长度的字符串" class="headerlink" title="随机生成指定长度的字符串"></a>随机生成指定长度的字符串</h3><pre><code>function randomString(n) {
    var rangeStr = &apos;abcdefghijklmnopqrstuvwxyz0123456789&apos;;
    var l = rangeStr.length;
    var randomStr = &apos;&apos;;
    for(var i = 0; i &lt; n; i++) {
        randomStr += rangeStr.charAt(Math.floor(Math.random() * l));
    }
    return randomStr;
}
randomString(10);//返回 &quot;itfjah8rte&quot;
</code></pre><h3 id="实现类似getElementsByClassName-的功能"><a href="#实现类似getElementsByClassName-的功能" class="headerlink" title="实现类似getElementsByClassName 的功能"></a>实现类似getElementsByClassName 的功能</h3><p>查找某个DOM节点下面的包含某个class的所有DOM节点？不允许使用原生提供的 getElementsByClassName、 querySelectorAll 等原生提供DOM查找的函数。</p>
<pre><code>function queryClassName(node, name) {
    var starts = &apos;(^|[ \n\r\t\f])&apos;,
        ends = &apos;([ \n\r\t\f]|$)&apos;;
    var resultArr = [],
        reg = new RegExp(starts + name + ends),
        elements = node.getElementsByTagName(&quot;*&quot;);
        length = elements.length,
        i = 0;
    while(i &lt; length) {
        var element = elements[i];
        if(reg.test(element.className)) {
            resultArr.push(element);
        }
        i++;
    }
    return resultArr;
}
// 方法2
function queryClassName2(node, name) {
    var elements = node.getElementsByTagName(&quot;*&quot;),
        length = elements.length,
        resultArr = [];
    for(var i = 0; i &lt; length; i ++) {
        if(elements[i].className) {
            var classNames = elements[i].className.split(&quot; &quot;);/*这里其实还要考虑类名间隔大于一个空格的情况*/
            if(classNames.indexOf(name) !== -1) {
                resultArr.push(elements[i]);
            }
        }
    }
    return resultArr;
}
//HTML结构
&lt;ul id=&quot;ull&quot;&gt;  
    &lt;li&gt;0&lt;/li&gt;  
    &lt;li class=&apos;box box2&apos;&gt;1&lt;/li&gt;  
    &lt;li&gt;2&lt;/li&gt;  
    &lt;li class=&apos;box1&apos;&gt;3&lt;/li&gt;  
    &lt;li class=&apos;box1&apos;&gt;4&lt;/li&gt;  
    &lt;li class=&apos;box box1&apos;&gt;5&lt;/li&gt;   
&lt;/ul&gt;
//测试结果
 window.onload = function() {
    node = document.getElementById(&quot;ull&quot;);
    queryClassName(node, &quot;box&quot;);//返回 (2) [li.box.box2, li.box.box1]
    queryClassName2(node, &quot;box&quot;);// 返回 (2) [li.box.box2, li.box.box1]
};
</code></pre><h3 id="JS-实现二叉查找树-Binary-Search-Tree"><a href="#JS-实现二叉查找树-Binary-Search-Tree" class="headerlink" title="JS 实现二叉查找树(Binary Search Tree)"></a>JS 实现二叉查找树(Binary Search Tree)</h3><p>在实际使用时会根据链表和有序数组等数据结构的不同优势进行选择。有序数组的优势在于二分查找，链表的优势在于数据项的插入和数据项的删除。但是在有序数组中插入数据就会很慢，同样在链表中查找数据项效率就很低。综合以上情况，二叉树可以利用链表和有序数组的优势，同时可以合并有序数组和链表的优势，二叉树也是一种常用的数据结构。<br>二叉查找树，也称二叉搜索树、有序二叉树（英语：ordered binary tree）是指一棵空树或者具有下列性质的二叉树：</p>
<pre><code>任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。
</code></pre><p><strong>二叉树相关概念：</strong><br>凡是每个节点都最多有两个叉的树，都叫二叉树。<br>查找树和排序树是一个东西。特点是中序遍历一遍的结果是单调的。这种树建出来可以用来做二分搜索。<br>平衡树一般是排序树的一种，并且加点条件，就是任意一个节点的两个叉的深度差不多（比如差值的绝对值小于某个常数，或者一个不能比另一个深出去一倍之类的）。<br>这样的树可以保证二分搜索任意元素都是O(log n)的，一般还附带带有插入或者删除某个元素也是O(log n)的的性质。<br>二叉树由节点（node）和边组成。节点分为根节点、父节点、子节点。如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20160919221509693" alt="二叉树示意图"><br>红色是根节点（root）。蓝色是子节点也是父节点，绿色的是子节点。其余的线是边。节点和链表中的节点一样都可以存放数据信息。树中的边可以用自引用表示，这种引用就是C/C++里面的指针。通常来说树是顶部小，底部大，且树呈分层结构。root节点时第0层，以此类推。二叉树最多有两个节点。<br>二叉树搜索： 二叉树一个节点左子节点的关键字小于这个节点，右子节点关键字大于或等于这个父节点。<br>创建一个树节点。<br><strong>BST创建过程：</strong><br>(1)创建一个树节点包括左节点引用和右节点引用。<br>(2)创建一个树结构。 创建一个树结构首先是向一个树种插入数据节点。当一棵树为null时，数据项是从树的root节点处开始插入，之后的插入顺序是根据搜索节点顺序规则进行插入。具体规则是：如果数据项比父节点的数据项要小，则插在父节点的左节点（leftNode），如果比父节点的数据项要大，则将新的node插入在父节点的右节点处（rightNode）。<br>插入数据节点过程如下所示：<br><img src="http://img.blog.csdn.net/20160919230148150" alt="BST插入数据节点示意图"><br>插入节点的过程中其实也就是对tree遍历的过程，最终根据条件遍历到左右节点为null时进行添加新的节点。<br><strong>查找关键字</strong><br>查找关键字是数据结构一项重要操作项，在有序数组中通过二分排序效率非常高。在二叉树中的查找效率也比较高。因为二叉树的添加node的过程就是根据数据项的大小进行有序添加的，并不是毫无秩序的插入数据项。在有序的基础上进行查找关键字效率就会快很多。<br>树的最值查找在树中查找是比较容易的，因为从root开始查找，最小值只会出现所有父节点的左节点处，同样最大值只会出现在所有父节点的沿着右节点搜索的最底层右节点处。<br><a href="http://blog.csdn.net/cai2016/article/details/52589952" target="_blank" rel="noopener">参考自博客</a>。<br><strong>删除节点</strong><br>给出如下二叉查找树</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/BST.png" alt="二叉查找树"><br>删除节点3之后，可以返回</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/newBST1.png" alt="新的BST1"><br>或者</p>
<p><img src="http://ou3oh86t1.bkt.clouddn.com/blog/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98/newBST2.png" alt="新的BST2"><br>思路:<br>若要删除一个BST的一个结点，需要考虑如下三种情况：</p>
<pre><code>需要删除的节点下并没有其他子节点
需要删除的节点下有一个子节点（左或右）
需要删除的节点下有两个子节点（既左右节点都存在）
</code></pre><p>对这三种情况分别采取的措施是：<br>    直接删除此结点<br>    删除此结点，将此结点父节点连接到此结点左（右）子树<br>    找出此结点右子树中的最小结点，用以代替要删除的结点，然后删除此最小结点</p>
<p><strong>设定每个节点的数据结构：</strong></p>
<pre><code>class Node {
    constructor(data, left, right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
</code></pre><p>树由节点构成，由根节点逐渐延生到各个子节点，因此它基本的结构就是具备一个根节点，具备添加，查找和删除节点的方法。</p>
<pre><code>// 构建BST，具备一个根节点、以及添加、查找、删除节点的方法
class BinarySearchTree {
    constructor() {
        this.root = null;
    }
    // 插入节点的方法
    insert(data) {
        let n = new Node(data, null, null);
        if (!this.root) { //如果此二叉树为空，则数据项从树的root节点处开始插入
            return this.root = n;
        }
        let currentNode = this.root;
        let parent = null;
        while (true) {
            parent = currentNode; //保存当current变为null之前的那一个父节点
            if (data &lt; currentNode.data) { //插在父节点的左节点
                currentNode = currentNode.left;
                if (currentNode === null) { //不断向左node寻找是否为null
                    parent.left = n;
                    break;
                }
            } else { //插在父节点的右节点
                currentNode = currentNode.right;
                if (currentNode === null) {
                    parent.right = n;
                    break;
                }
            }
        }
    }
    // 删除数据项
    remove(data) {
        this.root = this.removeNode(this.root, data);
    }
    // 删除节点
    // 删除树中与给定值相同的节点，如果树中没有相同值的节点，则不做处理，应该保证处理之后的树仍是二叉查找树。
    removeNode(node, data) {
        if (node === null) { // 如果根节点为空
            return null;
        }
        if (data === node.data) {
            // 没有子节点，即node为叶子节点
            if (node.left === null &amp;&amp; node.right === null) {
                return null;
            }
            // 要删除的节点下只有右节点
            if (node.left === null) {
                return node.right;
            }
            // 要删除的节点下只有左节点
            if (node.right === null) {
                return node.left;
            }
            // 要删除的节点下有两个子节点的情况
            // getSmallest用于找到该节点右子树中的最小节点，用以替代要删除的节点，然后删除此最小节点
            let getSmallest = function (node) {
                if (node.left === null &amp;&amp; node.right === null) {
                    return node;
                }
                if (node.left !== null) {
                    return node.left;
                }
                if (node.right !== null) {
                    return getSmallest(node.right);
                }
            }
            let temNode = getSmallest(node.right);
            node.data = temNode.data;
            node.right = this.removeNode(temNode.right, temNode.data);
            return node;
        } else if (data &lt; node.data) {
            node.left = this.removeNode(node.left, data);
            return node;
        } else {
            node.right = this.removeNode(node.right, data);
            return node;
        }
    }
    // 查找方法
    find(data) {
        let currentNode = this.root;
        while (currentNode !== null) {
            if (data === currentNode.data) {
                return true;
            }
            if (data &lt; currentNode.data) {
                if (currentNode.left !== null) {
                    currentNode = currentNode.left;
                } else {
                    return false;
                }
            } else {// data &gt; currentNode.data
                if (currentNode.right !== null) {
                    currentNode = currentNode.right;
                } else {
                    return false;
                }
            }
        }
    }
}
</code></pre><p>有关数组的一些操作见博客后半部分<a href="https://www.cnblogs.com/libin-1/p/5998870.html" target="_blank" rel="noopener">前端面试中的常见的算法问题</a>。</p>
<p>下面是一篇总结常见数据结构的javascript实现的文章：<br><strong><a href="http://blog.csdn.net/haoshidai/article/details/52263191" target="_blank" rel="noopener">常见数据结构的javascript实现</a></strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十道前端面试常见算法题。&lt;br&gt;
    
    </summary>
    
      <category term="js算法题" scheme="http://yoursite.com/categories/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="js算法题" scheme="http://yoursite.com/tags/js%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>vscode快捷键</title>
    <link href="http://yoursite.com/2018/02/26/vscodeKeyboardShortcuts/"/>
    <id>http://yoursite.com/2018/02/26/vscodeKeyboardShortcuts/</id>
    <published>2018-02-26T05:35:19.000Z</published>
    <updated>2018-02-26T06:06:33.652Z</updated>
    
    <content type="html"><![CDATA[<p>vscode中常用的快捷键功能。<br><a id="more"></a></p>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p>alt+up/down    向上/下移动单行</p>
<p>shift+alt+up/down    向上/下复制单行</p>
<p>shift+alt+f    格式化文本</p>
<p>command + +/-  增大/减小文本字体</p>
<p>Ctrl+Enter   在当前行下边插入一行</p>
<p>Ctrl+Shift+Enter  在当前行上方插入一行</p>
<p>代码行缩进：  向左缩进 Ctrl+[ &nbsp;&nbsp; 向右缩进 Ctrl+]</p>
<h3 id="光标相关"><a href="#光标相关" class="headerlink" title="光标相关"></a>光标相关</h3><p>移动到行首：Home</p>
<p>移动到行尾：End</p>
<p>移动到文件结尾：Ctrl+End</p>
<p>移动到文件开头：Ctrl+Home</p>
<p>移动到后半个括号： Ctrl+Shift+]</p>
<p>选中当前行   Ctrl+i</p>
<p>选择从光标到行尾   Shift+End</p>
<p>选择从行首到光标处   Shift+Home</p>
<p>删除光标右侧的所有字： Ctrl+Delete</p>
<p>删除光标所在行:    Ctrl+Shift+K </p>
<p>扩展/缩小选取范围： Shift+Alt+Left/Right</p>
<p>多行编辑(列编辑)：Alt+Shift+鼠标左键，Ctrl+Alt+Down/Up</p>
<p>同时选中所有匹配： Ctrl+Shift+L</p>
<p>回退上一个光标操作： Ctrl+U</p>
<h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><p>移动到定义处： F12</p>
<p>定义处缩略图：只看一眼而不跳转过去 Alt+F12</p>
<p>列出所有引用： Shift+F12</p>
<p>同时修改本文件中所有匹配的： Ctrl+F12</p>
<p>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了</p>
<p>跳转到下一个 Error 或 Warning：当有多个错误时可以按 F8 逐个跳转</p>
<p>查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose</p>
<h3 id="左侧边栏及显示相关"><a href="#左侧边栏及显示相关" class="headerlink" title="左侧边栏及显示相关"></a>左侧边栏及显示相关</h3><p>打开资源  ctrl+shift+E</p>
<p>打开搜索  ctrl+shift+F</p>
<p>打开git    ctrl+shift+G</p>
<p>打开调试 ctrl+shift+D</p>
<p>打开扩展 ctrl+shift+X</p>
<p>全屏：F11</p>
<p>侧边栏显/隐：Ctrl+B</p>
<p>输出Show Output：  Ctrl+Shift+U</p>
<p>预览markdown：  Ctrl+Shift+V</p>
<h3 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a>编辑器与窗口管理</h3><p>打开一个新窗口： Ctrl+Shift+N</p>
<p>关闭窗口： Ctrl+Shift+W</p>
<p>新建文件：   Ctrl+N</p>
<p>文件之间切换：   Ctrl+Tab</p>
<p>切出一个新的编辑器： Ctrl+\  (也可以按住 Ctrl 鼠标点击 Explorer 里的文件名。左中右 3 个编辑器的快捷键分别为 Ctrl+1 Ctrl+2 Ctrl+3)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode中常用的快捷键功能。&lt;br&gt;
    
    </summary>
    
      <category term="vscode" scheme="http://yoursite.com/categories/vscode/"/>
    
    
      <category term="vscode" scheme="http://yoursite.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 calc()的使用</title>
    <link href="http://yoursite.com/2018/01/23/CSS3-calc-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/23/CSS3-calc-的使用/</id>
    <published>2018-01-23T12:15:51.000Z</published>
    <updated>2018-01-23T13:08:16.986Z</updated>
    
    <content type="html"><![CDATA[<p>参考转自博客<a href="https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html" target="_blank" rel="noopener">CSS3的calc()使用</a>。<br><a id="more"></a></p>
<h3 id="为什么使用calc"><a href="#为什么使用calc" class="headerlink" title="为什么使用calc()"></a>为什么使用calc()</h3><p>平时在制作页面的时候，总会碰到有的元素是100%的宽度。众所周知，如果元素宽度(这里的宽度是盒模型content的宽度)为100%时，其自身不带其他盒模型属性设置还好，要是有别的（比如添加了padding和border），那将导致盒子撑破。</p>
<p>比如说，有一个边框，或者说有margin和padding，这些都会让你的盒子撑破。我们换句话来说，如果你的元素宽度是100%时，只要你在元素中添加了border,padding,margin任何一值，都将会把元素盒子撑破（标准模式下，除IE怪异模式）。这样一来就会相当的麻烦，平时我们碰到这样的现象时，也是相当的谨慎，有时甚至无法解决，只能通过改变结构来实现。就算你通过繁琐的方法实现了，但有于浏览器的兼容性而导致最终效果不一致。虽然前面介绍的CSS3属性中的box-sizing在一定程度上解决这样的问题，其实今天的calc()函数功能实现上面的效果来得更简单。</p>
<h3 id="什么是calc"><a href="#什么是calc" class="headerlink" title="什么是calc()"></a>什么是calc()</h3><p>calc()是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽度。</p>
<h3 id="calc-能做什么"><a href="#calc-能做什么" class="headerlink" title="calc() 能做什么"></a>calc() 能做什么</h3><p>calc()能让你给元素的做计算，你可以给一个div元素，使用百分比、em、px和rem单位值计算出其宽度或者高度，比如说 <code>width: calc(50% + 2em);</code>，这样一来你就不用考虑元素DIV的宽度值到底是多少，而把这个烦人的任务交由浏览器去计算。</p>
<h3 id="calc-语法"><a href="#calc-语法" class="headerlink" title="calc()语法"></a>calc()语法</h3><pre><code>.element {
  width: calc(expression);
}
</code></pre><p>其中”expression”是一个表达式，用来计算长度的表达式。</p>
<h3 id="calc-运算规则"><a href="#calc-运算规则" class="headerlink" title="calc()运算规则"></a>calc()运算规则</h3><p>calc()使用通用的数学运算规则，但是也提供更智能的功能：</p>
<ul>
<li>使用“+”、“-”、“*” 和 “/”四则运算；</li>
<li>可以使用百分比、px、em、rem等单位；</li>
<li>可以混合使用各种单位进行计算；</li>
<li>表达式中有“+”和“-”时，其前后必须要有空格，如<code>widht: calc(12%+5em);</code>这种没有空格的写法是错误的；</li>
<li><p>表达式中有“*”和“/”时，其前后可以没有空格，但建议留有空格。</p>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>浏览器对calc()的兼容性还算不错，在IE9+、FF4.0+、Chrome19+、Safari6+都得到较好支持，同样需要在其前面加上各浏览器厂商的识别符，不过可惜的是，移动端的浏览器还没仅有“firefox for android 14.0”支持，其他的全军覆没。<br>大家在实际使用时，同样需要添加浏览器的前缀</p>
<p>   .element {</p>
<pre><code>/*Firefox*/
-moz-calc(expression);
/*chrome safari*/
-webkit-calc(expression);
/*Standard */
calc();
</code></pre><p>   }</p>
</li>
</ul>
<p>通过上面的了解，大家对calc()不在那么陌生，但对于实际的运用可能还是不太了解，那么大家就接下来跟我一起动手，通过实例来了解他吧。首先我们来看一个最常用的实例：</p>
<pre><code>&lt;div class=&quot;demo&quot;&gt;
     &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;/div&gt;    
</code></pre><p>上面的结构很简单，就是一个div.demo的元素中包含了一个div.box的元素，接下来我们一步一步来看其中的变化。<br><strong>第一步：添加普通样式：</strong></p>
<pre><code>.demo {
    width: 300px;
    background: #60f;
}
.box {
  width: 100%;
    background: #f60;
    height: 50px;
}
</code></pre><p>此时的效果很简单，就是div.box完全遮盖了div.demo，如下图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/201202/css3-calc-step1.jpg" alt="calc-step1"></p>
<p><strong>第二步，在div.box上添加border和padding</strong></p>
<p>这一步很棘手的事情来了，在div.box上添加10px的内距padding，同时添加5px的border：</p>
<pre><code>.demo {
    width: 300px;
    background: #60f;
}
.box {
  width: 100%;
  background: #f60;
  height: 50px;
  padding: 10px;
  border: 5px solid green;
}
</code></pre><p>为了更好的说明问题，我在div.demo上添加了一个 <code>padding：3px 0;</code></p>
<pre><code>.demo {
    width: 300px;
    background: #60f;
padding: 3px 0;    
}
.box {
  width: 100%;
  background: #f60;
  height: 50px;
  padding: 10px;
  border: 5px solid green;
}
</code></pre><p>这个时候大家不知道能否想到问题会发生在哪？其实很简单，这个时候div.box的宽度大于了其容器div.demo的总宽度，从而撑破容器伸出来了，如图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/201202/css3-calc-step2.jpg" alt="calc-step2"></p>
<p><strong>第三步，calc()的运用</strong></p>
<p>为了解决撑破容器的问题，以前我们只能去计算div.box的宽度，用容器宽度减去padding和border的值，但有时候，我们苦于不知道元素的总宽度，比如说是自适应的布局，只知道一个百分值，但其他的值又是px之类的值，这就是难点，死卡住了。随着CSS3的出现，其中利用box-sizing来改变元素的盒模型类型实使实现效果，但今天我们学习的calc()方法更是方便。</p>
<p>知道总宽度是100%，在这个基础上减去boder的宽度（5px <em> 2 = 10px）,在减去padding的宽度（10px </em> 2 = 20px），即”100% - (10px + 5px) * 2 = 30px” ，最终得到的值就是div.box的width值：</p>
<pre><code>.demo {
    width: 300px;
    background: #60f;
    padding: 3px 0;
}
.box {
    background: #f60;
    height: 50px;
    padding: 10px;
    border: 5px solid green;
width: 90%;/*写给不支持calc()的浏览器*/
    width:-moz-calc(100% - (10px + 5px) * 2);
    width:-webkit-calc(100% - (10px + 5px) * 2);
    width: calc(100% - (10px + 5px) * 2);
}
</code></pre><p>这样一来，通过calc()计算后，div.box不在会超出其容器div.demo的宽度，如图所示：</p>
<p><img src="http://www.w3cplus.com/sites/default/files/201202/css3-calc-step3.jpg" alt="calc-step3"></p>
<h3 id="采用calc-方法的自适应布局demo"><a href="#采用calc-方法的自适应布局demo" class="headerlink" title="采用calc()方法的自适应布局demo"></a>采用calc()方法的自适应布局demo</h3><p>在这个布局中，采用了自适应布局。整个布局包含了“头部”、“主内容”、“边栏”和“脚部”，并且“主内容”居左，“边栏”靠右。html结构如下：</p>
<pre><code>&lt;!-- 头部 --&gt;
&lt;div id=&quot;header&quot;&gt;我是头部&lt;/div&gt;
&lt;!-- 内容区容器 --&gt;
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;!-- 主内容 --&gt;
    &lt;div id=&quot;main&quot;&gt;我是主内容区&lt;/div&gt;
    &lt;!-- 右边栏 --&gt;
    &lt;div id=&quot;accessory&quot;&gt;我是右边栏&lt;/div&gt;
&lt;/div&gt;
&lt;!-- 脚部 --&gt;
&lt;div id=&quot;footer&quot;&gt;我是脚部&lt;/div&gt;
</code></pre><p><strong>1、在body中设置一个内距，并附上一些基本的样式</strong></p>
<pre><code>body {
    background: #E8EADD;
    color: #3C323A;
    padding: 20px; 
}
</code></pre><p><strong>2、设置主容器“wrapper”的样式</strong></p>
<p>主容器的宽度是“100% - 20px * 2”,并且水平居中：</p>
<pre><code>    .wrapper {
    width: 1024px; /* Fallback for browsers that don&apos;t support the calc() function */
    width: -moz-calc(100% - 40px);
    width: -webkit-calc(100% - 40px);
    width: calc(100% - 40px);
    margin: auto; 
}
</code></pre><p>给不支持calc()的浏览器设置了一个固定宽度值“1024px”。</p>
<p><strong>3、给header和footer设置样式</strong></p>
<p>这个例子中的header和footer很简单，给他们添加了一个内距为20px，其他就是一些基本的样式设置，那么其对应的宽度应该是<code>100% - 20px * 2</code></p>
<pre><code>#header {
    background: #f60;
    padding: 20px;
    width: 984px;/*Fallback for browsers that don&apos;t support the calc() function*/
    width: -moz-calc(100% - 40px);
    width: -webkit-calc(100% - 40px);
    width: calc(100% - 40px);
}
#footer {
    clear:both;
    background: #000;
    padding: 20px;
    color: #fff;
    width: 984px;/* Fallback for browsers that don&apos;t support the calc() function */
    width: -moz-calc(100% - 40px);
    width: -webkit-calc(100% - 40px);
    width: calc(100% - 40px);
}
</code></pre><p><strong>4、给主内容设置样式</strong></p>
<p>给主内容设置了一个8px的边框，20px的内距，并且向左浮动，同时设置了一个向右的外边距“20”px，关键之处，我们主内容占容器宽度的75%，这样一来，主内容的宽度应该是<code>75% - 8px * 2 - 20px * 2</code></p>
<pre><code>#main {
    border: 8px solid #B8C172;
    float: left;
    margin-bottom: 20px;
    margin-right: 20px;
    padding: 20px;
    width: 704px; /* Fallback for browsers that don&apos;t support the calc() function */
    width: -moz-calc(75% - 20px * 2 - 8px * 2);
    width: -webkit-calc(75% - 20px * 2 - 8px * 2);
    width: calc(75% - 20px * 2 - 8px * 2); 
}
</code></pre><p><strong>5、设置右边栏样式</strong></p>
<p>给边栏设置了一个25%的宽度，其除了包含8px的边框，10px的内距外，还有主内容外距20px也要去掉，不然整个宽度与容器会相差20px,换句话说就会撑破容器掉下来。因此边栏的实际宽度应该是<code>25% - 10px * 2 - 8px * 2 -20px</code></p>
<pre><code>#accessory {
    border: 8px solid #B8C172;
    float: right;
    padding: 10px;
    width: 208px; /* Fallback for browsers that don&apos;t support the calc() function */
    width: -moz-calc(25% - 10px * 2 - 8px * 2 - 20px);
    width: -webkit-calc(25% - 10px * 2 - 8px * 2 - 20px);
    width: calc(25% - 10px * 2 - 8px * 2 - 20px);
}
</code></pre><p>完整代码见<a href="https://github.com/shirley5li/someDemosForExercise" target="_blank" rel="noopener">github</a>。</p>
<p>另附一篇<a href="https://www.cnblogs.com/mracale/p/7170385.html" target="_blank" rel="noopener">移动端页面布局</a>，讲得比较好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考转自博客&lt;a href=&quot;https://www.w3cplus.com/css3/how-to-use-css3-calc-function.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS3的calc()使用&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CSS3" scheme="http://yoursite.com/categories/CSS3/"/>
    
    
      <category term="CSS3" scheme="http://yoursite.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about CSS】 from牛客网</title>
    <link href="http://yoursite.com/2018/01/13/interview-questions-about-CSS/"/>
    <id>http://yoursite.com/2018/01/13/interview-questions-about-CSS/</id>
    <published>2018-01-13T07:02:40.000Z</published>
    <updated>2018-01-23T13:40:33.123Z</updated>
    
    <content type="html"><![CDATA[<p>来自牛客网<a href="https://www.nowcoder.com/ta/review-frontend?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">前端面试常考知识点 HTML+CSS</a> 篇学习总结。<br><a id="more"></a></p>
<h3 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h3><p>CSS盒子模型组成：外边距（margin）、边框（border）、内边距（padding）、内容（content）。<br>CSS盒子模型有两种，分别是标准 W3C 盒子模型和 IE 盒子模型。<br><strong>W3C标准盒子模型:</strong><br><img src="http://img.blog.csdn.net/20140124141001609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenl1eml4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="标准盒子模型示意图"><br>标准W3C 盒子模型的范围包括 margin、border、padding、content， content 部分不包含其他部分。<br>width(content) = content<br>盒子模型占据的宽度= width + padding + border + margin<br>盒子的实际宽度大小=  width + padding + border<br><strong>IE盒子模型:</strong><br><img src="http://img.blog.csdn.net/20140124141131218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenl1eml4aWFv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="IE盒子模型示意图"><br>IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。<br>width(content) = content + padding-left + padding-right + border-left + border-right<br>盒子模型占据的宽度= width + margin<br>盒子的实际宽度大小=  width<br>参考<a href="http://blog.csdn.net/zyuzixiao/article/details/18733463" target="_blank" rel="noopener">标准盒子模型和IE盒子模型</a>。</p>
<h3 id="CSS选择器的类型"><a href="#CSS选择器的类型" class="headerlink" title="CSS选择器的类型"></a>CSS选择器的类型</h3><p>类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素。<br>参考<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html" target="_blank" rel="noopener">CSS选择器笔记-阮一峰</a>。</p>
<h3 id="CSS优先级、计算特殊值"><a href="#CSS优先级、计算特殊值" class="headerlink" title="CSS优先级、计算特殊值"></a>CSS优先级、计算特殊值</h3><p><strong>优先级</strong><br>(1) 同类型，同级别的样式后者先于前者<br>(2) ID选择器(#example) &gt; 类选择器(.example)|属性选择器([type=”radio”])|伪类(:hover) &gt; 标签选择器(h1)|伪元素(::before)<br>(3) 内联 &gt; ID选择器 &gt; 类|伪类|属性 &gt; 标签|伪元素 &gt; 继承 &gt; 通用选择器(<em>)<br>(4) 具体 &gt; 泛化的，特殊性即css优先级<br>(5) 近的 &gt; 远的 (内联样式 &gt; 内部样式表 &gt; 外部样式表)<br>  内联样式：内嵌在元素中，<code>&lt;span style=&quot;color:red&quot;&gt;span&lt;/span&gt;</code><br>  内部样式表：在页面中的样式，写在<code>&lt;style&gt;&lt;/style&gt;</code>中的样式<br>  外部样式表：单独存在一个css文件中，通过link引入或import导入的样式<br>有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。<br>(6) !important 权重最高，比 inline style 还要高<br><em>*选择器的优先权-计算特殊性值</em></em><br><img src="http://ou3oh86t1.bkt.clouddn.com/blog/interview-questions-about-CSS/selecter%20weight.png" alt="选择器优先权"></p>
<ol>
<li>内联样式表的权值最高 1000；</li>
<li>ID 选择器的权值为 100</li>
<li>Class 类选择器的权值为 10</li>
<li>HTML 标签选择器的权值为 1<br><img src="http://ou3oh86t1.bkt.clouddn.com/blog/interview-questions-about-CSS/css%20selector%20priority.png" alt="css selector priority"><br>CSS 优先级法则：<br>A  选择器都有一个权值，权值越大越优先；<br>B  当权值相等时，后出现的样式表设置要优于先出现的样式表设置；<br>C  创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；<br>D  继承的CSS 样式不如后来指定的CSS 样式；<br>E  在同一组属性设置中标有“!important”规则的优先级最大</li>
</ol>
<h3 id="动态改变层中内容的方法"><a href="#动态改变层中内容的方法" class="headerlink" title="动态改变层中内容的方法"></a>动态改变层中内容的方法</h3><p>通过innerHTML()，innerText()方法动态添加内容和文本。</p>
<h3 id="常见浏览器兼容性问题与解决方案"><a href="#常见浏览器兼容性问题与解决方案" class="headerlink" title="常见浏览器兼容性问题与解决方案"></a>常见浏览器兼容性问题与解决方案</h3><p><strong>(1)一：不同浏览器的标签默认的margin和padding不同</strong><br>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。<br>碰到频率:100%<br>解决方案：CSS样式初始化，即将使用到的有默认margin,padding值的标签的默认值置为0；或者用 <code>*{margin:0;padding:0;}</code>。但第二种方式不推荐，全局重置浏览器的默认样式，是一种粗暴的方式，会降低效率，使用第一种方式重置部分样式就可以了。<br><strong>(2)二：块属性标签float后，又有横向的margin情况下，在IE6显示margin比设置的大</strong><br>问题症状:常见症状是IE6中后面的一块被顶到下一行<br>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）<br>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性<br>备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。<br><strong>(3)三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</strong><br>问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度<br>碰到频率：60%<br>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。<br><strong>(4)四：行内属性标签，设置display:block后采用float布局，又有横向的margin的情况，IE6间距bug</strong><br>问题症状：IE6里的间距比超过设置的间距<br>碰到几率：20%<br>解决方案 ： 在display:block;后面加入display:inline;display:table;<br>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。<br><strong>(5)五：图片默认有间距</strong><br>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。<br>碰到几率：20%<br>解决方案：使用float属性为img布局<br>备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以不建议使用）<br><strong>(6)六：标签最低高度设置min-height不兼容</strong><br>问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容<br>碰到几率：5%<br>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}<br>备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时，容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。<br><strong>(7)七：透明度的兼容CSS设置</strong><br>一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容。</p>
<h3 id="列出display的值并说明作用"><a href="#列出display的值并说明作用" class="headerlink" title="列出display的值并说明作用"></a>列出display的值并说明作用</h3><p>display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex<br>默认值：inline</p>
<p><strong>none：</strong> 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间<br><strong>inline：</strong> 指定对象为内联元素。<br><strong>block：</strong> 指定对象为块元素。<br>list-item： 指定对象为列表项目。<br><strong>inline-block：</strong> 指定对象为内联块元素。(CSS2)<br><strong>table：</strong> 指定对象作为块元素级的表格。类同于html标签<code>&lt;table&gt;</code>(CSS2)<br>inline-table： 指定对象作为内联元素级的表格。类同于html标签<code>&lt;table&gt;</code>(CSS2)<br>table-caption： 指定对象作为表格标题。类同于html标签<code>&lt;caption&gt;</code>(CSS2)<br>table-cell： 指定对象作为表格单元格。类同于html标签<code>&lt;td&gt;</code>(CSS2)<br>table-row： 指定对象作为表格行。类同于html标签<code>&lt;tr&gt;</code>(CSS2)<br>table-row-group： 指定对象作为表格行组。类同于html标签<code>&lt;tbody&gt;</code>(CSS2)<br>table-column： 指定对象作为表格列。类同于html标签<code>&lt;col&gt;</code>(CSS2)<br>table-column-group：指定对象作为表格列组显示。类同于html标签<code>&lt;colgroup&gt;</code>(CSS2)<br>table-header-group： 指定对象作为表格标题组。类同于html标签<code>&lt;thead&gt;</code>(CSS2)<br>table-footer-group：指定对象作为表格脚注组。类同于html标签<code>&lt;tfoot&gt;</code>(CSS2)<br>run-in： 根据上下文决定对象是内联对象还是块级对象。(CSS3)<br>box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)<br>inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）(CSS3)<br><strong>flexbox：</strong> 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)<br>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）(CSS3)<br>flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)<br>inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）(CSS3)<br>参考<a href="https://segmentfault.com/a/1190000012833458" target="_blank" rel="noopener">display的32种写法</a>。</p>
<h3 id="居中div，居中一个浮动元素"><a href="#居中div，居中一个浮动元素" class="headerlink" title="居中div，居中一个浮动元素"></a>居中div，居中一个浮动元素</h3><p>(1)非浮动元素居中：div为块级元素，居中块级元素首先要设置宽度,然后<code>margin:0 auto;</code>就居中了；还可以通过定位 方式；父级元素设置<code>text-align:center;</code>的方式等等。<br>参考<a href="https://www.w3cplus.com/css/centering-css-complete-guide.html" target="_blank" rel="noopener">CSS居中完整指南</a>。<br>(2)、浮动元素居中:<br>方法一:设置当前div的宽度，然后设置<code>margin-left:50%; position:relative; left:-width/2 px;</code>其中的left是宽度的一半。<br>方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。<br>方法三:position定位等等。<br>例如：</p>
<pre><code>&lt;style&gt;
    .box{
        position: relative;
        left:50%;
        float:left;
    }
    .item{
        position: relative;
        left:-50%;
        float:left;
        background: red;
    }
&lt;/style&gt;
&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;123&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>注：<code>left:50%;</code>这个left按照百分比来设置left值实际移动是按父容器的宽度来算，可以先看成box容器为body宽度为也就是浏览器宽度，<code>left:50%;</code>就是向右移动到中间，现在还要向左移动浮动元素item一半的距离，box的float是为了让box自身收缩，这样item的父容器的宽度就是本身的宽度了，再设置为<code>left:-50%;</code>也就是向左移动自身宽度的一半。</p>
<h3 id="几种清除浮动的方法"><a href="#几种清除浮动的方法" class="headerlink" title="几种清除浮动的方法"></a>几种清除浮动的方法</h3><p>两种思路，五种方法。 思路1：父级定义；思路2：结尾定义。<br><strong>(1)、父级div定义 height</strong><br>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。<br>优点：简单、代码少、容易掌握<br>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题<br>建议：不推荐使用，只建议高度固定的布局时使用<br><strong>(2)、结尾处加空div标签 clear:both</strong><br>原理：在父元素中，追加空子元，即添加一个空div，并利用css提供的clear:both清除浮动，让父级div能自动获取到高度<br>优点：简单、代码少、浏览器支持好、不容易出现怪问题<br>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好<br>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法<br><strong>(3)、父级div定义 伪类:after 和 zoom</strong><br>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6,ie7浮动问题<br>优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）<br>缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。<br>建议：推荐使用，建议定义公共类，以减少CSS代码。<br><strong>(4)、父级div定义 overflow:hidden</strong><br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度<br>优点：简单、代码少、浏览器支持好<br>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。<br>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。<br><strong>(5)、父级div定义 overflow:auto</strong><br>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度<br>优点：简单、代码少、浏览器支持好<br>缺点：内部宽高超过父级div时，会出现滚动条。<br>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。<br><strong>(6)、使用内容生成的方式清除浮动</strong></p>
<pre><code>.clearfix:after {
   content:&quot;&quot;; 
   display: block; 
   clear:both; 
}
</code></pre><p>:after 选择器向选定的元素之后插入内容<br>content:””; 生成内容为空<br>display: block; 生成的元素以块级元素显示,<br>clear:both; 清除前面元素浮动带来的影响<br>相对于空标签闭合浮动的方法<br>优势：不破坏文档结构，没有副作用<br>弊端：代码量多<br>参考 <a href="http://blog.csdn.net/FE_dev/article/details/68954481" target="_blank" rel="noopener">详解 清除浮动 的多种方式（clearfix）</a>、 <a href="http://www.daqianduan.com/3606.html" target="_blank" rel="noopener">解读浮动闭合最佳方案：clearfix</a>。</p>
<h3 id="block，inline和inlinke-block细节对比"><a href="#block，inline和inlinke-block细节对比" class="headerlink" title="block，inline和inlinke-block细节对比"></a>block，inline和inlinke-block细节对比</h3><ul>
<li>display:block<br>a、block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。<br>b、block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。<br>c、block元素可以设置margin和padding属性。</li>
<li>display:inline<br>a、inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。<br>b、inline元素设置width,height属性无效。<br>c、inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</li>
<li><p>display:inline-block<br>a、简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个链接（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。<br><strong>补充说明</strong><br>a、一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。<br>b、IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 </p>
<h3 id="优雅降级和渐进增强的含义"><a href="#优雅降级和渐进增强的含义" class="headerlink" title="优雅降级和渐进增强的含义"></a>优雅降级和渐进增强的含义</h3><p><strong>优雅降级：</strong> Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。<br><strong>渐进增强：</strong> 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 </p>
<h3 id="浮动元素引起的问题及相应解决办法"><a href="#浮动元素引起的问题及相应解决办法" class="headerlink" title="浮动元素引起的问题及相应解决办法"></a>浮动元素引起的问题及相应解决办法</h3><p><strong>浮动的工作原理：</strong> 浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。<br><strong>问题：</strong><br>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构<br><strong>解决方法：</strong><br>使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式：</p>
<p>  .clearfix:after {</p>
<pre><code>content: &quot;.&quot;;
display: block;
height: 0;
clear: both;
visibility: hidden;
</code></pre><p>  }<br>  .clearfix {</p>
<pre><code>display: inline-block; /* for IE/Mac */
</code></pre><p>  }<br><strong>清除浮动的几种方法：</strong><br>(1)、额外标签法(使用空标签清除浮动)<br><code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code>（缺点：会增加额外的标签，使HTML结构看起来不够简洁。）<br>(2)、使用after伪类</p>
<p>  #parent:after{<br>    content:” “;<br>    height:0;<br>    visibility:hidden;<br>    display:block;<br>    clear:both;<br>  }<br>(3)、浮动外部元素<br>(4)、设置<code>overflow</code>为<code>hidden</code>或者<code>auto</code> </p>
<h3 id="性能优化的方法"><a href="#性能优化的方法" class="headerlink" title="性能优化的方法"></a>性能优化的方法</h3><p><strong>总结一：</strong><br>（1）、减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>（2）、前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数。<br>（3）、用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>（4）、当需要设置的样式很多时设置className而不是直接操作style。<br>（5）、少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>（6）、避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>（7）、图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br><strong>回答二：</strong><br>(1)、减少HTTP请求次数<br>(2)、使用CDN<br>(3)、避免空的src和href<br>(4)、为文件头指定Expires<br>(5)、使用gzip压缩内容<br>(6)、把CSS放到顶部<br>(7)、把JS放到底部<br>(8)、避 免使用CSS表达式<br>(9)、将CSS和JS放到外部文件中<br>(10)、避免跳转<br>(11)、可缓存的AJAX<br>(12)、使用GET来完成AJAX请求</p>
<h3 id="初始化CSS样式的意义"><a href="#初始化CSS样式的意义" class="headerlink" title="初始化CSS样式的意义"></a>初始化CSS样式的意义</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的(比如标签默认的margin、padding值不同等情况)，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，力求影响最小的情况下初始化。<br>最简单的初始化方法就是： <code>* {padding: 0; margin: 0;}</code> （不建议）</p>
<h3 id="CSS中的刻度"><a href="#CSS中的刻度" class="headerlink" title="CSS中的刻度"></a>CSS中的刻度</h3><p>在CSS中刻度是用于设置元素尺寸的单位。<br>a、特殊值<strong>0</strong>可以省略单位。例如：<code>margin:0px;</code>可以写成<code>margin:0;</code><br>b、一些属性可能允许有<strong>负长度</strong>值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。<br>c、<strong>长度单位</strong>包括：<strong>相对单位</strong>和<strong>绝对单位</strong>。<br>相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin<br>绝对长度单位有： cm, mm, q, in, pt, pc, px<br>绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px<br><strong>文本相对长度单位：em</strong><br>相对长度单位是相对于当前对象内文本的字体尺寸，如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(<strong>相对父元素的字体大小倍数</strong>)</p>
<p>  body { font-size: 14px; }<br>  h1 { font-size: 16px; }<br>  .size1 p { font-size: 1em; }<br>  .size2 p { font-size: 2em; }<br>  .size3 p { font-size: 3em; }<br><strong>文本相对长度单位：rem</strong><br>rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数。只<strong>相对于根元素(html元素)</strong>的大小。<br>浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。<br>作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法。<br>em与rem的重要区别：它们计算的规则一个是依赖父元素另一个是依赖根元素计算。</p>
<h3 id="box-sizing属性的用法"><a href="#box-sizing属性的用法" class="headerlink" title="box-sizing属性的用法"></a>box-sizing属性的用法</h3><p>a、<code>box-sizing:content-box</code><br>padding和border不被包含在定义的width和height之内。<br>对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin )。<br>此属性表现为标准模式下的盒模型。<br>b、<code>box-sizing:border-box</code><br>padding和border被包含在定义的width和height之内。<br>对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )。 此属性表现为怪异模式下的盒模型。 </p>
<h3 id="浏览器标准模式和怪异模式之间的区别"><a href="#浏览器标准模式和怪异模式之间的区别" class="headerlink" title="浏览器标准模式和怪异模式之间的区别"></a>浏览器标准模式和怪异模式之间的区别</h3><p>所谓的标准模式是指，浏览器按W3C标准解析执行代码；<br>怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。<br>浏览器解析时到底使用标准模式还是怪异模式，与你网页中的DTD声明直接相关，DTD声明定义了标准文档的类型(标准模式解析)，会使浏览器使用相应的方式加载网页并显示，忽略DTD声明,将使网页进入怪异模式(quirks mode)。</p>
<h3 id="怪异Quirks模式是什么，它和标准Standards模式有什么区别"><a href="#怪异Quirks模式是什么，它和标准Standards模式有什么区别" class="headerlink" title="怪异Quirks模式是什么，它和标准Standards模式有什么区别"></a>怪异Quirks模式是什么，它和标准Standards模式有什么区别</h3><p>从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。<br>在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？<br>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。 <strong>区别：</strong>总体会有布局、样式解析和脚本执行三个方面的区别。<br><strong>盒模型：</strong> 在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks模式下，IE的宽度和高度还包含了padding和border。<br><strong>设置行内元素的高宽：</strong>在Standards模式下，给<code>&lt;span&gt;</code>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。<br><strong>设置百分比的高度：</strong>在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的。<br><strong>用margin:0 auto设置水平居中：</strong>使<code>用margin:0 auto;</code>在standards模式下可以使元素水平居中，但在quirks模式下却会失效。<br>（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。） </p>
<h3 id="边距折叠"><a href="#边距折叠" class="headerlink" title="边距折叠"></a>边距折叠</h3><p><strong>外边距折叠：</strong> 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin）<br><strong>相邻：</strong> 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系<br><strong>垂直方向外边距合并计算:</strong><br>a、参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。<br>b、参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。<br>c、参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。</p>
<h3 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h3><p>a、使用CSS的display:none，不会占有原来的位置<br>b、使用CSS的visibility:hidden，会占有原来的位置<br>c、使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 </p>
<h3 id="为什么重置浏览器默认样式，如何重置默浏览器认样式"><a href="#为什么重置浏览器默认样式，如何重置默浏览器认样式" class="headerlink" title="为什么重置浏览器默认样式，如何重置默浏览器认样式"></a>为什么重置浏览器默认样式，如何重置默浏览器认样式</h3><p>每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。<br>a、最简单的办法：（不推荐使用）<code>*{margin: 0;padding: 0;}</code>。<br>b、使用CSSReset可以将所有浏览器默认样式设置成一样。<br>c、normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。<br>天猫 使用的css reset重置浏览器默认样式：</p>
<p>  body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td {margin: 0;padding: 0}<br>  body, button, input, select, textarea {font: 12px “microsoft yahei”;line-height: 1.5;-ms-overflow-style: scrollbar}<br>  h1, h2, h3, h4, h5, h6 {font-size: 100%}<br>  ul, ol {list-style: none}a {text-decoration: none;cursor:pointer}<br>  a:hover {text-decoration: underline}<br>  img {border: 0}<br>  button, input, select, textarea {font-size: 100%}<br>  table {border-collapse: collapse;border-spacing: 0}<br>  .clear {clear:both}<br>  .fr {float:right}<br>  .fl {float:left}<br>  .block {display:block;text-indent:-999em}</p>
</li>
</ul>
<h3 id="对BFC与IFC的理解？-是什么，如何产生，作用"><a href="#对BFC与IFC的理解？-是什么，如何产生，作用" class="headerlink" title="对BFC与IFC的理解？(是什么，如何产生，作用)"></a>对BFC与IFC的理解？(是什么，如何产生，作用)</h3><p><strong>(1)、什么是BFC与IFC</strong><br>a、BFC（Block Formatting Context）即”块级格式化上下文”， IFC（Inline Formatting Context）即”行内格式化上下文”。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。<br>b、BFC是W3C CSS 2.1规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。<br>c、在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。<br><strong>(2)、如何产生BFC</strong><br>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：<br>a、float的值不为none<br>b、overflow的值不为visible<br>c、display的值为table-cell, table-caption, inline-block中的任何一个<br>d、position的值不为relative和static<br>CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。</p>
<p><strong>(3)、BFC的作用与特点</strong><br>a、不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖。<br>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。</p>
<h3 id="对页面中使用定位-position-的理解"><a href="#对页面中使用定位-position-的理解" class="headerlink" title="对页面中使用定位(position)的理解"></a>对页面中使用定位(position)的理解</h3><p>osition：static | relative | absolute | fixed | center | page | sticky<br>默认值：static，center、page、sticky是CSS3中新增加的值。<br><strong>(1)、static</strong><br>可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。<br><strong>(2)、relative</strong><br>相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。<br><strong>(3)、absolute</strong><br>a、绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。<br>b、元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。<br><strong>(4)、fixed</strong><br>固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。<br><strong>(5)、center</strong><br>与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）<br><strong>(6)、page</strong><br>与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）<br><strong>(7)、sticky</strong><br>对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3） </p>
<h3 id="如何解决多个元素重叠问题"><a href="#如何解决多个元素重叠问题" class="headerlink" title="如何解决多个元素重叠问题"></a>如何解决多个元素重叠问题</h3><p>使用z-index属性可以设置元素的层叠顺序。<br>z-index属性<br>语法：<code>z-index: auto | &lt;integer&gt;</code><br>默认值：auto<br>适用于：定位元素。即定义了position为非static的元素<br><strong>取值：</strong><br>auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。<br>整数： 用整数值来定义堆叠级别。可以为负值。 说明：检索或设置对象的层叠顺序。<br>z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。<br>当多个元素层叠在一起时，数字大者将显示在上面。</p>
<h3 id="页面布局的方式"><a href="#页面布局的方式" class="headerlink" title="页面布局的方式"></a>页面布局的方式</h3><p><a href="https://www.nowcoder.com/ta/review-frontend/review?query=&amp;asc=true&amp;order=&amp;page=71" target="_blank" rel="noopener">页面布局方式</a>。</p>
<h3 id="overflow-hidden是否形成新的块级格式化上下文"><a href="#overflow-hidden是否形成新的块级格式化上下文" class="headerlink" title="overflow :hidden是否形成新的块级格式化上下文"></a>overflow :hidden是否形成新的块级格式化上下文</h3><p>会形成，触发BFC的条件有：<br>float的值不为none。<br>overflow的值不为visible。<br>display的值为table-cell, table-caption, inline-block 中的任何一个。<br>position的值不为relative 和static。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自牛客网&lt;a href=&quot;https://www.nowcoder.com/ta/review-frontend?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试常考知识点 HTML+CSS&lt;/a&gt; 篇学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="interview questions" scheme="http://yoursite.com/categories/interview-questions/"/>
    
    
      <category term="interview questions" scheme="http://yoursite.com/tags/interview-questions/"/>
    
  </entry>
  
  <entry>
    <title>introduction about HTTP</title>
    <link href="http://yoursite.com/2018/01/09/introduction-about-HTTP/"/>
    <id>http://yoursite.com/2018/01/09/introduction-about-HTTP/</id>
    <published>2018-01-08T16:15:58.000Z</published>
    <updated>2018-01-09T02:47:03.157Z</updated>
    
    <content type="html"><![CDATA[<p>关于HTTP协议相关知识的学习总结。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World    Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP基于TCP/IP通信协议来传递数据。  </p>
<p>HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。   </p>
<p>（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。   </p>
<p>（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><p><img src="https://uploadfiles.nowcoder.com/files/20160727/213669_1469604624728_cgiarch.gif" alt="http协议通信流程图"></p>
<h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p>
<p>客户端请求消息：请求行、请求头部、空行和请求数据。<br>    GET /hello.txt HTTP/1.1<br>    User-Agent: curl/7.16.3 libcurl/7.16.3<br>    OpenSSL/0.9.7l zlib/1.2.3<br>    Host: www.example.com Accept-Language: en, mi<br>服务端响应消息：状态行、消息报头、空行和响应正文。<br>    HTTP/1.1 200 OK<br>    Date: Mon, 27 Jul 2009 12:28:53 GMT<br>    Server: Apache<br>    Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT<br>    ETag: “34aa387-d-1568eb00”<br>    Accept-Ranges: bytes<br>    Content-Length: 51<br>    Vary: Accept-Encoding<br>    Content-Type: text/plain</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>​    GET 请求指定的页面信息，并返回实体主体。   </p>
<p>​    HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头   </p>
<p>​    POST   向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。     POST请求可能会导致新的资源的建立和/或已有资源的修改。   </p>
<p>​    PUT 从客户端向服务器传送的数据取代指定的文档的内容。   </p>
<p>​    DELETE  请求服务器删除指定的页面。   </p>
<p>​    CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。   </p>
<p>​    OPTIONS 允许客户端查看服务器的性能。   </p>
<p>​    TRACE   回显服务器收到的请求，主要用于测试或诊断</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>HTTP状态码分类</strong><br>​        1xx  信息，服务器收到请求，需要请求者继续执行操作<br>​        2xx 成功，操作被成功接收并处理<br>​        3xx 重定向，需要进一步的操作以完成请求<br>​        4xx 客户端错误，请求包含语法错误或无法完成请求<br>​        5xx 服务器错误，服务器在处理请求的过程中发生了错   </p>
<p><strong>HTTP状态码列表</strong><br>​    100 Continue    继续。客户端应继续其请求   </p>
<p>​    101 Switching Protocols      切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   </p>
<p>​      200 OK  请求成功。一般用于GET与POST请求    </p>
<p>​    201 Created 已创建。成功请求并创建了新的资源   </p>
<p>​    202 Accepted    已接受。已经接受请求，但未处理完成   </p>
<p>​    203 Non-Authoritative Information        非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   </p>
<p>​    204 No Content       无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   </p>
<p>​    205 Reset Content        重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   </p>
<p>​    206 Partial Content 部分内容。服务器成功处理了部分GET请求   </p>
<p>​    300 Multiple Choices         多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   </p>
<p>​      301 Moved Permanently   永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替    </p>
<p>​    302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   </p>
<p>​    303 See Other   查看其它地址。与301类似。使用GET和POST请求查看   </p>
<p>​      304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源    </p>
<p>​    305 Use Proxy   使用代理。所请求的资源必须通过代理访问   </p>
<p>​    306 Unused  已经被废弃的HTTP状态码   </p>
<p>​      307 Temporary Redirect  临时重定向。与302类似。使用GET请求重定向    </p>
<p>​    400 Bad Request 客户端请求的语法错误，服务器无法理解   </p>
<p>​    401 Unauthorized    请求要求用户的身份认证   </p>
<p>​    402 Payment Required    保留，将来使用   </p>
<p>​    403 Forbidden   服务器理解请求客户端的请求，但是拒绝执行此请求   </p>
<p>​      404 Not Found   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面    </p>
<p>​    405 Method Not Allowed  客户端请求中的方法被禁止   </p>
<p>​    406 Not Acceptable  服务器无法根据客户端请求的内容特性完成请求   </p>
<p>​    407 Proxy Authentication Required        请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权   </p>
<p>​    408 Request Time-out    服务器等待客户端发送的请求时间过长，超时   </p>
<p>​    409 Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   </p>
<p>​    410 Gone         客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   </p>
<p>​    411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   </p>
<p>​    412 Precondition Failed 客户端请求信息的先决条件错误   </p>
<p>​    413 Request Entity Too Large         由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   </p>
<p>​    414 Request-URI Too Large   请求的URI过长（URI通常为网址），服务器无法处理   </p>
<p>​    415 Unsupported Media Type  服务器无法处理请求附带的媒体格式   </p>
<p>​    416 Requested range not satisfiable 客户端请求的范围无效   </p>
<p>​    417 Expectation Failed  服务器无法满足Expect的请求头信息   </p>
<p>​      500 Internal Server Error   服务器内部错误，无法完成请求    </p>
<p>​    501 Not Implemented 服务器不支持请求的功能，无法完成请求   </p>
<p>​    502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   </p>
<p>​    503 Service Unavailable      由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   </p>
<p>​    504 Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求   </p>
<p>​    505 HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于HTTP协议相关知识的学习总结。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about HTML】 from牛客网</title>
    <link href="http://yoursite.com/2018/01/08/interview-questions-about-HTML/"/>
    <id>http://yoursite.com/2018/01/08/interview-questions-about-HTML/</id>
    <published>2018-01-08T07:16:53.000Z</published>
    <updated>2018-01-17T08:25:20.566Z</updated>
    
    <content type="html"><![CDATA[<p>来自牛客网<a href="https://www.nowcoder.com/ta/review-frontend?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">前端面试常考知识点 HTML+CSS</a> 篇学习总结。<br><a id="more"></a></p>
<h3 id="浏览器页面有哪三层构成"><a href="#浏览器页面有哪三层构成" class="headerlink" title="浏览器页面有哪三层构成"></a>浏览器页面有哪三层构成</h3><p><strong>浏览器页面有哪三层构成，分别是什么，作用是什么?</strong><br>浏览器页面有结构层、表示层、行为层，三层构成，分别是HTML、CSS、JavaScript，作用是HTML实现页面结构(骨架)，CSS完成页面的表现与风格(肌肤)，JavaScript实现一些客户端的功能与业务(动作)，对用户事件作出反应。<br>不过，在这三种技术之间存在着一些潜在的<strong>重叠区域</strong>，如DOM技术可以用来改变网页的结构；CSS诸如<code>:hover</code>和<code>:focus</code>之类的class伪类，使我们可以根据用户触发事件来改变呈现效果。<br>改变元素的呈现效果当然是表示层的“势力范围”，但对用户触发事件做出反应却是行为层的领地。表示层和行为层的这种重叠形成了一个灰色地带。class伪类是 CSS 正在深入DOM领地证据，但 DOM在这方面也不是毫无作为，完全可以利用 DOM 技术把样式信息施加在HTML元素身上。<br>分离的效果要做到即使去掉表示层和行为层，文档的内容也依然可以访问，因为“内容才是一切”。而且网页的行为层(javascript)与其结构(HTML)是彼此互不干扰的，不能混杂在一起。还要给行为层“预留退路”，要考虑到如果你的用户禁用了Javascript会怎样？网页是否还可以正常运作。做到<strong>平稳退化，渐进增强</strong>。</p>
<h3 id="HTML5的优点与缺点"><a href="#HTML5的优点与缺点" class="headerlink" title="HTML5的优点与缺点"></a>HTML5的优点与缺点</h3><p><strong>HTML5是什么:</strong>  HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ，RIA），例如：AdobeFlash 、Microsoft Silverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 HTML 最新版本，2014 年10月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。<br><strong>为什么有HTML5的出现：</strong> HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了 Web应用对插件的依赖，让用户体验更好，让开发更加方便，另外W3C 从推出 HTML4.0到5.0之间共经历了17年，HTML的变化很小，这并不符合一个好产品的演进规则。<br><strong>优点：</strong></p>
<ul>
<li>网络标准统一<br>HTML5本身是由W3C推荐出来的，它的开发是通过谷歌、苹果，诺基亚、中国移动等几百家公司一起酝酿的技术，这个技术最大的好处在于它是一个公开的技术。换句话说，每一个公开的标准都可以根据W3C的资料库找寻根源。另一方面，W3C通过的HTML5标准也就意味着每一个浏览器或每一个平台都会去实现。</li>
<li>多设备跨平台，可移植性好<br>HTML5的优点主要在于，这个技术可以进行跨平台的使用。比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台,甚至可以通过封装的技术发放到AppStore或GooglePlay上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。</li>
<li>自适应网页设计<br>即“一次设计，普遍适用”，让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局(layout)。</li>
<li>即时更新<br>游戏客户端每次都要更新，很麻烦。可是更新HTML5游戏就好像更新页面一样，是马上的、即时的更新。</li>
<li>提高可用性和改进用户的友好体验</li>
<li>增加几个新的标签，这将有助于开发人员定义重要的内容</li>
<li>可以给站点带来更多的多媒体元素(视频和音频)</li>
<li>可以很好的替代FLASH和Silverlight<br>Silverlight是一个跨浏览器、跨平台的插件，为网络带来下一代基于.NET媒体体验，和丰富的交互式应用程序。</li>
<li>当涉及到网站的抓取和索引的时候，对于SEO很友好<br>SEO，即搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。</li>
<li><p>将被大量应用于移动应用程序和游戏<br><strong>缺点：</strong></p>
</li>
<li><p>安全方面<br>像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket这样的功能很容易被黑客利用，来盗取用户的信息和资料。</p>
</li>
<li>完善性方面<br>许多特性各浏览器的支持程度也不一样。</li>
<li>技术门槛方面<br>HTML5技术开发者工作的同时，有许多新的属性和API需要开发者学习，像<a href="http://blog.csdn.net/leledexixi/article/details/55210717" target="_blank" rel="noopener">web worker、web socket、web storage</a>等新特性，甚至后台及浏览器原理的知识。这是机遇的同时也是巨大的挑战。</li>
<li>性能方面<br>某些平台上的引擎问题导致HTML5性能低下.</li>
<li>浏览器兼容性方面<br>IE9以下浏览器几乎不支持。</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><p><strong>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</strong><br>告诉浏览器应该用什么文档类型规范来解析这个文档。doctype不存在或格式不正确会导致文档以混杂模式呈现。严格模式的排版和js运作模式是以浏览器最高标准运行。混杂模式， 页面以宽松的向后兼容的形式展示。<br>参考博客<a href="http://blog.csdn.net/Vivian_jay/article/details/61933580" target="_blank" rel="noopener">DOCTYPE声明</a>。</p>
<h3 id="HTML5有哪些新特性、移除了哪些元素"><a href="#HTML5有哪些新特性、移除了哪些元素" class="headerlink" title="HTML5有哪些新特性、移除了哪些元素"></a>HTML5有哪些新特性、移除了哪些元素</h3><p>HTML5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性元素、级块性元素、行内语义性元素和交互性元素4大类。<br><strong>结构性元素</strong>主要负责web上下文结构的定义：<br><code>section</code>：在 web 页面应用中，该元素也可以用于区域的章节描述。<br><code>header</code>：页面主体上的头部， header 元素往往在一对 body 元素中。<br><code>footer</code>：页面的底部（页脚），通常会标出网站的相关信息。<br><code>nav</code>：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。<br><code>article</code>：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</p>
<p><strong>级块性元素</strong>主要完成web页面区域的划分，确保内容的有效分割。<br><code>aside</code>：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。<br><code>figure</code>：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。<br><code>code</code>：表示一段代码块。<br><code>dialog</code>：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</p>
<p><strong>行内语义性元素</strong>主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。<br><code>meter</code>：表示特定范围内的数值，可用于工资、数量、百分比等。<br><code>time</code>：表示时间值。<br><code>progress</code>：用来表示进度条，可通过对其 max 、min 、step 等属性进行控制，完成对进度的表示和监事。<br><code>video</code>：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。<br><code>audio</code>：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</p>
<p><strong>交互性元素</strong>主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。<br><code>details</code>：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。<br><code>datagrid</code>：用来控制客户端数据与显示，可以由动态脚本及时更新。<br><code>menu</code>：主要用于交互菜单（曾被废弃又被重新启用的元素）。<br><code>command</code>：用来处理命令按钮。 </p>
<p><strong>移除的元素</strong><br>纯表现的元素：<code>&lt;basefont&gt;</code> 默认字体，不设置字体，以此渲染; <code>&lt;font&gt;</code> 字体标签; <code>&lt;center&gt;</code>水平居中; <code>&lt;u&gt;</code>下划线; <code>&lt;big&gt;</code> 大字体; <code>&lt;strike&gt;</code>中横线; <code>&lt;tt&gt;</code>文本等宽;<br>框架集：<code>&lt;frameset&gt;</code> <code>&lt;noframes&gt;</code> <code>&lt;frame&gt;</code> </p>
<h3 id="HTML5行内元素、块级元素、空元素"><a href="#HTML5行内元素、块级元素、空元素" class="headerlink" title="HTML5行内元素、块级元素、空元素"></a>HTML5行内元素、块级元素、空元素</h3><p><strong>行内元素</strong><br><code>a</code> - 锚点<br><code>abbr</code> - 缩写<br><code>br</code> - 换行<br><code>em</code> - 强调<br><code>strong</code> - 粗体强调<br><code>i</code> - 斜体<br><code>cite</code> - 引用<br><code>code</code> - 计算机代码 ( 在引用源码的时候需要 )<br><code>img</code> - 图片<br><code>span</code> - 常用内联容器，定义文本内区块<br><code>input</code> - 输入框<br><code>textarea</code> - 多行文本输入框<br><code>label</code> - 表格标签<br><strong>块级元素</strong><br><code>div</code> - 常用块级容易，也是 css layout 的主要标签<br><code>p</code> - 段落<br><code>h1~h6</code> - 大标题<br><code>form</code> - 交互表单<br><code>table</code> - 表格<br><code>ol</code> - 排序表单<br><code>ul</code> - 非排序列表<br><code>address</code> - 地址<br><code>blockquote</code> - 块引用<br><strong>空元素</strong><br><code>&lt;br/&gt;</code> //换行<br><code>&lt;hr&gt;</code> //分隔线<br><code>&lt;input&gt;</code> //文本框等<br><code>&lt;img&gt; &lt;link&gt; &lt;meta&gt;</code></p>
<h3 id="浏览器的内核分类"><a href="#浏览器的内核分类" class="headerlink" title="浏览器的内核分类"></a>浏览器的内核分类</h3><p>IE: Trident 内核<br>Firefox： Gecko 内核(开源)<br>Safari: Webkit 内核(开源)<br>Chrome: Webkit<br>Opera: 以前是Presto内核，现已改用Blink内核(基于Webkit, Google与Opera Software共同开发)</p>
<h3 id="对WEB标准以及W3C的理解与认识"><a href="#对WEB标准以及W3C的理解与认识" class="headerlink" title="对WEB标准以及W3C的理解与认识"></a>对WEB标准以及W3C的理解与认识</h3><p>WEB标准 不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由 万维网联盟 （W3C）起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。<br>标签闭合、标签小写、不乱嵌套—》XHTML；<br>提高搜索机器人搜索几率–》DOM；<br>使用外 链css和 js 脚本—》结构行为表现的分离；<br>文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问；<br>容易维护、改版方便；<br>提高网站易用性。</p>
<h3 id="什么是WebGL-它有什么优点"><a href="#什么是WebGL-它有什么优点" class="headerlink" title="什么是WebGL,它有什么优点"></a>什么是WebGL,它有什么优点</h3><p>WebGL(Web Graphics Library) 是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。<br>WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。<br>WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：第一，它通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持;第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。<br>通俗的说WebGL是canvas绘图中的3D版本。因为原生的WebGL很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。 </p>
<h3 id="cookie，sessionStorage-和-localStorage-的区别"><a href="#cookie，sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别"></a>cookie，sessionStorage 和 localStorage 的区别</h3><p>共同点：都是保存在浏览器端，且同源的。</p>
<p>区别：</p>
<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
<li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li>
<li>存储大小限制也不同。cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>数据有效期不同。sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>
<li>作用域不同。sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>
<li>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。<br>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。<br>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的。<br>cookies 会发送到服务器端。其余两个不会。<br>Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ）；所有域名的存储量有限制（各浏览器不同，大致 4K ）； 有个数限制（各浏览器不同）；会随请求发送到服务器。<br>LocalStorage 永久存储；单个域名存储量比较大（推荐 5MB ，各浏览器不同）；总体数量无限制。<br>SessionStorage 只在 Session 内有效；存储量更大（推荐没有限制，但是实际上各浏览器也不同）。</li>
</ul>
<h3 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h3><ul>
<li>什么是 HTML 语义化<br>&lt;基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 &gt;<br>根据<strong>内容的结构化</strong>（内容语义化），选择<strong>合适的标签</strong>（代码语义化）便于<strong>开发者阅读</strong>和写出更优雅的代码的同时<strong>让浏览器的爬虫和机器很好地解析</strong>。</li>
<li>为什么要语义化<br>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；<br>用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；<br>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；<br>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 </li>
<li>语义化标签<br><code>&lt;header&gt;&lt;/header&gt;</code> <code>&lt;footer&gt;&lt;/footer&gt;</code> <code>&lt;nav&gt;&lt;/nav&gt;</code> <code>&lt;section&gt;&lt;/section&gt;</code><br><code>&lt;article&gt;&lt;/article&gt;</code> 用来在页面中表示一套结构完整且独立的内容部分<br><code>&lt;aside&gt;&lt;/aside&gt;</code> 主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了<br><code>&lt;figure&gt;&lt;/figure&gt;</code> 媒体元素，比如一些视频，图片等等<br><code>&lt;datalist&gt;&lt;/datalist&gt;</code> 选项列表，与 input 元素配合使用，来定义 input 可能的值<br><code>&lt;details&gt;&lt;/details&gt;</code> 用于描述文档或者文档某个部分的细节</li>
</ul>
<h3 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h3><p>HTML代码link:<br><code>&lt;link rel=&#39;stylesheet&#39; rev=&#39;stylesheet&#39; href=&#39;CSS文件 &#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;</code></p>
<p>HTML代码@import:</p>
<pre><code>&lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt;
@import url(&apos;CSS文件 &apos;);
&lt;/style&gt; 
</code></pre><ul>
<li>首先link和import语法结构不同，前者<link>是html标签，只能放入html源代码中使用，后者可看作为css样式，作用是引入css样式功能。</li>
<li>import在html使用时候需要<code>&lt;style type=&quot;text/css&quot;&gt;</code>标签，同时可以直接<code>@import url(CSS文件路径地址)</code>放入css文件或css代码里引入其它css文件。</li>
<li>本质上两者使用选择区别不大，但为了软件中编辑布局网页html代码，一般使用link较多，也推荐使用link。</li>
</ul>
<p>两者都是外部引用CSS的方式，但是存在一定的<strong>区别：</strong><br>区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。<br>区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。<br>区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。<br>区别5： link方式的样式权重 高于 @import的权重。 </p>
<h3 id="对SVG的理解"><a href="#对SVG的理解" class="headerlink" title="对SVG的理解"></a>对SVG的理解</h3><p>SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是 W3C 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。<br>特点：<br> (1)任意放缩：用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。<br> (2)文本独立：SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。<br> (3)较小文件： 总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。<br> (4)超强显示效果：SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。<br> (5)超级颜色控制：SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。<br> (6)交互 X 和智能化：SVG面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。<br>  Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的</p>
<h3 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h3><p>参考<a href="http://www.w3school.com.cn/tags/html_ref_standardattributes.asp" target="_blank" rel="noopener">HTML 全局属性</a>。例如<code>class</code>, <code>id</code>, <code>style</code>, <code>title</code>, <code>lang</code>等等。</p>
<h3 id="超链接target属性的取值和作用"><a href="#超链接target属性的取值和作用" class="headerlink" title="超链接target属性的取值和作用"></a>超链接target属性的取值和作用</h3><p>target属性指定所链接的页面在浏览器窗口中的打开方式。<br>参数值主要有：<br>_blank ：浏览器总在一个新打开、未命名的窗口中载入目标文档。<br>_parent ：在父框架集中打开被链接文档。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。<br>_self ：默认。在相同的框架中打开被链接文档。<br>_top ： 在整个窗口中打开被链接文档。这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。<br>framename：在指定的框架中打开被链接文档。</p>
<h3 id="data-属性的作用"><a href="#data-属性的作用" class="headerlink" title="data- 属性的作用"></a>data- 属性的作用</h3><p>data-<em> 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。<br>data-</em> 属性用于存储页面或应用程序的私有自定义数据。<br>存储的（自定义）数据能够被页面的 JavaScript利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。</p>
<p><code>data-</code>为HTML5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 <code>dataset</code> 属性获取，不支持该属性的浏览器可以通过 <code>getAttribute</code> 方法获取：<br>需要注意的是：<code>data-</code>之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 所有主流浏览器都支持 data-* 属性。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 </p>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。<br><strong>渲染引擎：</strong>负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。<br>浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br><strong>JS引擎：</strong> 解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="iframe的缺点"><a href="#iframe的缺点" class="headerlink" title="iframe的缺点"></a>iframe的缺点</h3><ul>
<li>iframe会阻塞主页面的 Onload 事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO;</li>
<li>iframe和主页面共享<a href="blog.csdn.net/u012152619/article/details/46287419">连接池</a>，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
</ul>
<p>如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 </p>
<p>历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。<br>现在，应该使用 iframe 的例子如：</p>
<ol>
<li>沙箱隔离。参考 <a href="https://www.imooc.com/article/17353" target="_blank" rel="noopener">写js沙箱原来如此简单</a></li>
<li>引用第三方内容。</li>
<li>独立的带有交互的内容，比如幻灯片。</li>
<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>
</ol>
<p>使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。<br>比较早期的网站使用iframe，主要是用于导航栏（navigator）。因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的URL不会随着页面的变化而变化。这就意味着一旦刷新，网站可能又回到首页。那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。<br>iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。所以从兼容性上来说，iframe 是没问题的。<br>那么现在什么时候会用到 iframe 呢？<br>因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。<br>典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。<br>正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 <a href="http://www.w3school.com.cn/html5/att_global_contenteditable.asp" target="_blank" rel="noopener">contentEditable</a>。</p>
<h3 id="label标签的作用"><a href="#label标签的作用" class="headerlink" title="label标签的作用"></a>label标签的作用</h3><p>对鼠标用户而言增进了可用性。<br>label标签用来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<pre><code>&lt;label for=&apos;Name&apos;&gt;Number:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot;/&gt;
</code></pre><p>注意:label的for属性值要与后面对应的input标签id属性值相同。</p>
<h3 id="浏览器内多个标签页之间的通信"><a href="#浏览器内多个标签页之间的通信" class="headerlink" title="浏览器内多个标签页之间的通信"></a>浏览器内多个标签页之间的通信</h3><p>调用localstorge、cookies等本地存储方式。<br>方法一：localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。例如<br>标签页1：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
            localStorage.setItem(&quot;name&quot;, name);   
        });    
    });    
&lt;/script&gt;  
</code></pre><p>标签页2：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
            localStorage.setItem(&quot;name&quot;, name);   
        });    
    });    
&lt;/script&gt;  
</code></pre><p>方法二：使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。<br>标签页1：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
         document.cookie=&quot;name=&quot;+name;    
        });    
    });    
&lt;/script&gt;
</code></pre><p>标签页2：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){   
        function getCookie(key) {    
            return JSON.parse(&quot;{\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;}&quot;)[key];    
        }     
        setInterval(function(){    
            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));    
        }, 10000);    
    });  
&lt;/script&gt; 
</code></pre><h3 id="在页面上实现一个圆形的可点击区域"><a href="#在页面上实现一个圆形的可点击区域" class="headerlink" title="在页面上实现一个圆形的可点击区域"></a>在页面上实现一个圆形的可点击区域</h3><p>第一种 使用image map</p>
<pre><code>&lt;img id=&quot;blue&quot; class=&quot;click-area&quot; src=&quot;blue.gif&quot; usemap=&quot;#Map&quot; /&gt; 
&lt;map name=&quot;Map&quot; id=&quot;Map&quot; class=&quot;click-area&quot;&gt;
    &lt;area shape=&quot;circle&quot; coords=&quot;50,50,50&quot;/&gt;
&lt;/map&gt;
#blue{
    cursor:pointer;
    width:100px;
    height:100px;
</code></pre><p>}<br>第二种 使用CSS border-radius</p>
<pre><code>&lt;div id=&quot;red&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt;
#red{  
 cursor:pointer;
 background:red;  
 width:100px;  
 height:100px;  
 border-radius:50%;  
} 
</code></pre><p>第三种 使用js检测鼠标位置,获取鼠标点击位置坐标，判断其到圆点的距离是否不大于圆的半径，来判断点击位置是否在圆内。</p>
<pre><code>&lt;div id=&quot;yellow&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt;
$(&quot;#yellow&quot;).on(&apos;click&apos;,function(e) {    
  var r = 50; 
  var x1 = $(this).offset().left+$(this).width()/2;            
  var y1 = $(this).offset().top+$(this).height()/2;   
  var x2= e.clientX;  
  var y2= e.clientY;    
  var distance = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));    
  if (distance &lt;= 50)  
    alert(&quot;Yes!&quot;);    
}); 
</code></pre><h3 id="title与h3、b与strong、及i与em的区别"><a href="#title与h3、b与strong、及i与em的区别" class="headerlink" title="title与h3、b与strong、及i与em的区别"></a>title与h3、b与strong、及i与em的区别</h3><p><code>&lt;strong&gt;</code> 表示html页面上的强调（emphasized text）， <code>&lt;em&gt;</code> 表示句子中的强调（即强调语义）<br><strong>1.b和strong的区别</strong><br>盲人朋友使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，<code>&lt;b&gt;</code>不会。两者虽然在网页中显示效果一样，但实际目的不同。<br><code>&lt;b&gt;</code>这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；<code>&lt;strong&gt;</code>这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；<br>总结：<code>&lt;b&gt;</code>为了加粗而加粗，<code>&lt;strong&gt;</code>为了标明重点而加粗，也可以用其它方式来强调，比如下划线，比如字体加大，比如红色，等等，可以通过css来改变strong的具体表现。<br><strong>2.i和em的区别</strong><br>同样，I是Italic(斜体)，而em是emphasize(强调)。<br><strong>3.title与h1的联系与区别：</strong><br>从网站角度看，title更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。<br>从文章角度看，h1则是用于概括文章主题。用户进入内容页，想看到的当然就是文章的内容，h1文章标题就是最重要的。文章标题最好只有一个，多个h1会导致搜索引擎不知道这个页面哪个标题内容最重要，导致淡化这个页面的标题和关键词，起不到突出主题的效果。<br>区别：<br>h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。</p>
<h3 id="不使用border画出1px高的线，考虑兼容性"><a href="#不使用border画出1px高的线，考虑兼容性" class="headerlink" title="不使用border画出1px高的线，考虑兼容性"></a>不使用border画出1px高的线，考虑兼容性</h3><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？ </p>
<pre><code>&lt;div style=&quot;width:100%;height:1px;background-color:black&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="src属性与href属性的区别"><a href="#src属性与href属性的区别" class="headerlink" title="src属性与href属性的区别"></a>src属性与href属性的区别</h3><p>src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。<br>src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。<br><code>&lt;script src =&#39;js.js&#39;&gt;&lt;/script&gt;</code>，当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br> href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，如果我们在文档中添加<code>&lt;link href=&#39;common.css&#39; rel=&#39;stylesheet&#39;/&gt;</code>，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 </p>
<h3 id="对canvas的理解"><a href="#对canvas的理解" class="headerlink" title="对canvas的理解"></a>对canvas的理解</h3><p>canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。canvas标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。</p>
<h3 id="WebSocket与消息推送"><a href="#WebSocket与消息推送" class="headerlink" title="WebSocket与消息推送"></a>WebSocket与消息推送</h3><p>B/S架构的系统多使用HTTP协议。<br><strong>HTTP协议的特点：</strong> 1 无状态协议； 2 用于通过 Internet 发送请求消息和响应消息； 3 使用端口接收和发送消息，默认为80端口； 4 底层通信还是使用Socket<br><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484203855304_198713B681803E835F62D3D3E22D5BBB" alt="HTTP协议请求响应"><br>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法实现 双向通信与消息推送 ：<br><strong>轮询：</strong> 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用<br><strong>长轮询：</strong> 客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求，耗费资小。<br>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，<br>实例：WebQQ、 Hi 网页版、 Facebook IM<br><strong>长连接：</strong> 在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求；管理起来也相对便。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天<br><strong>Flash Socket：</strong> 在页面中内嵌入一个使用了 Socket 类的 Flash 程序， JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。<br>优点：实现真正的即时通信，而不是伪即时。<br>缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。<br>实例：网络互动游戏。<br><strong>Websocket:</strong><br>WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。<br>特点:事件驱动；异步；使用 ws 或者 wss 协议的客户端 socket；能够实现真正意义上的推送功能<br>缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别<br><strong>参考文章：</strong><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket 教程-阮一峰</a><br><a href="https://www.cnblogs.com/myzhibie/p/4470065.html" target="_blank" rel="noopener">html5-websocket初探</a></p>
<h3 id="img的title和alt的区别"><a href="#img的title和alt的区别" class="headerlink" title="img的title和alt的区别"></a>img的title和alt的区别</h3><p>alt 是给搜索引擎识别，在图像无法显示时的替代文本； alt属性有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。<br>title 是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。<br>参考文章：<a href="http://blog.csdn.net/playkid123/article/details/44562235" target="_blank" rel="noopener">img图片标签alt和title属性的区别</a></p>
<h3 id="表单的基本组成"><a href="#表单的基本组成" class="headerlink" title="表单的基本组成"></a>表单的基本组成</h3><p>组成：表单标签、表单域、表单按钮。<br> a、表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。<br>b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。<br>c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。<br>主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 </p>
<pre><code>&lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt;  
    &lt;fieldset&gt;  
        &lt;legend&gt;个人基本信息&lt;/legend&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;userName&quot;&gt;名称：&lt;/label&gt;  
            &lt;input id=&quot;useName&quot; type=&quot;text&quot; /&gt;  
        &lt;/div&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;passWord&quot;&gt;密码：&lt;/label&gt;  
            &lt;input id=&quot;passWord&quot; type=&quot;password&quot; /&gt;  
        &lt;/div&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;msg&quot;&gt;详细信息：&lt;/label&gt;  
            &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt;  
         &lt;/div&gt;  
    &lt;/fieldset&gt;  
&lt;/form&gt; 
</code></pre><p><strong>form标签：</strong> <code>&lt;form action=&quot;表单提交的地址&quot;   method=&quot;表单提交的方法&quot;   id=&quot;&quot;  class=&quot;&quot;&gt;</code><br><strong>fieldset标签：</strong>作用是将表单内相关元素分组；将表单内容的一部分打包，生成一组表单的字段;在一个form表单中，可以有一个或者多个fielset标签。<br><strong>legend标签：</strong> 作用是为fieldset标签定义标题。<br><strong>label标签：</strong> 该标签在页面中使用不会为用户呈现任何特殊效果，但是却可以很好地为鼠标用户改进了可用性。其作用是为input元素定义标注，要注意的是label中的for属性应与input中的id属性一致，如上述代码所示。<br><strong>input标签：</strong> 输入框，其中可以根据type的属性值改变输入框的作用。例如：<code>&lt;input  type=&quot;text&quot;/&gt;</code> 是文本框，还可以是密码输入框、复选框、单选框等等。</p>
<h3 id="表单提交中Get和Post方式的区别"><a href="#表单提交中Get和Post方式的区别" class="headerlink" title="表单提交中Get和Post方式的区别"></a>表单提交中Get和Post方式的区别</h3><p><strong>原理性区别：</strong></p>
<ol>
<li>Http 定义的与服务器交互的四种基本方法，增删改查（ put delete post get ）；从定义而言 get 用于信息获取（状态不做迁移），而且是安全幂等的（不修改信息、同一 url 多次请求结果一致），但有时候并不严格遵循规定，比如腾讯新闻的刷新操作，因为从 server端来讲，数据状态并没有发生任何改变 ，所以也可以算成是幂等； post 可以修改服务器上的资源请求（资源的状态迁移），比如新闻评论的提交，提交前后资源被修改了。</li>
<li>关于幂等与否只是 http 的规定，实际中要看服务器端怎么写。<br><strong>表象上的区别：</strong></li>
<li>提交的安全性不同： Get 将表单中的数据按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用”? “连接，而各个变量之间使用”&amp;”连接（明文提交）； Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL （依照表单提交）。</li>
<li>Get 传输的数据量小（ 1024 字节），这主要是因为受 URL 长度限制； URL 长度在 http 协议中没有限制，只是 IE 对 URL 有长度限制，其他浏览器取决于操作系统，理论上没有限制。 Post 可以传输大量的数据（ 2M ），理论上 http 没有限制数据量长度，服务器处理程序的处理能力限制了表单域长度，而有限制</li>
<li>Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</li>
<li>传输信息所在 http 中的位置不同： Post 的信息作为 http 请求的内容，而 Get 是在 Http 头部传输的， get 请求可以有 body 但大多数服务器不会解析 get 请求的 body 。</li>
</ol>
<p>(1)、 get 是从服务器上获取数据， post 是向服务器传送数据。<br>(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。<br>(3)、对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。<br>(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。<br>(5)、 get 安全性低， post 安全性较高。</p>
<h3 id="关于HTML5标签的几个知识点"><a href="#关于HTML5标签的几个知识点" class="headerlink" title="关于HTML5标签的几个知识点"></a>关于HTML5标签的几个知识点</h3><p><strong><a href="http://www.w3school.com.cn/html5/html_5_form_elements.asp" target="_blank" rel="noopener">HTML5新增的表单元素：</a></strong><br><code>datalist</code> 元素：<br>datalist 元素规定输入域的选项列表；<br>列表是通过 datalist 内的 option 元素创建的,option 元素永远都要设置 value 属性；<br>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id。<br><code>keygen</code> 元素:<br>keygen 元素的作用是提供一种验证用户的可靠方法;<br>keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。<br>目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。<br><code>output</code> 元素:<br>output 元素用于不同类型的输出，比如计算或脚本输出。<br><strong><a href="http://yanue.net/post-106.html" target="_blank" rel="noopener">HTML5废弃的标签：</a></strong><br>第一类：表现性元素<br><code>basefont</code> <code>big</code> <code>center</code> <code>font</code> <code>s</code> <code>strike</code> <code>tt</code> <code>u</code>等。<br>建议用语义正确的元素代替他们，并使用CSS来确保渲染后的效果<br>第二类：框架类元素<br>因框架有很多可用性及可访问性问题，HTML5规范将以下元素移除:<br><code>frame</code> <code>frameset</code> <code>noframes</code><br>但html5支持iframe。<br>第三类：属性类<br>很多表现性的属性也被新规范移除，如下：<br>align<br>body标签上的link、vlink、alink、text属性<br>bgcolor<br>height和width<br>iframe元素上的scrolling属性<br>valign<br>hspace和vspace<br>table标签上的cellpadding、cellspacing和border属性<br>header标签上的profile属性<br>img和iframe元素的longdesc属性<br>第四类：其他<br>abbr取代acronym（用于表示缩写）<br>object取代了applet<br>ul取代了dir<br><strong><a href="https://www.cnblogs.com/oneplace/p/5616197.html" target="_blank" rel="noopener">HTML5 标准提供的新API</a></strong><br>Media API：例如video audio,Using the Camera API<br>Text Track API: textTracks属性;返回代表可用文本字幕的TextTrackList对象<br>Application Cache API： 应用程序缓存<br>User Interaction ：新增的语义化元素，output元素等<br>Data Transfer API ：webSocket<br>Command API<br>Constraint Validation API<br>History API : session localStorage cookie<br><strong>HTML5 存储类型有什么区别</strong><br>HTML5 能够本地存储数据，在之前都是使用 cookie。 HTML5  提供了下面两种本地存储方案：<br>localStorage  用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。<br> sessionStorage  同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，因此它不是一种持久化的本地存储，仅仅是会话级别的存储</p>
<p>cookies,seesionStorage,localStorage区别：<br>共同点：都是保存到浏览器端，都是同源。<br>区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大。seesionStroage,在窗口关闭前有效，不在不同浏览器窗口共享。 localStroage,始终有效，永久数据，所有同源窗口共享。 cookie:在过期前有效，所有同源窗口共享 。<br><strong><a href="https://www.cnblogs.com/xjchenhao/p/4032224.html" target="_blank" rel="noopener">HTML5 应用程序缓存和浏览器缓存的区别</a></strong><br>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。<br>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。<br>应用程序缓存为应用带来三个优势：离线浏览 - 用户可在应用离线时使用它们；<br>速度 - 已缓存资源加载得更快；减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</p>
<p>应用程序缓存是 HTML5  的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html manifest=”example.appcache”&gt;
…..
&lt;/html&gt;
</code></pre><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。<br><strong>除了 audio 和 video，HTML5 还有哪些媒体标签</strong><br><code>&lt;embed&gt;</code> 标签，定义嵌入的内容，比如插件。</p>
<pre><code>&lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt;
</code></pre><p><code>&lt;source&gt;</code> 标签，对于定义多个数据源很有用。</p>
<pre><code> &lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
     &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
     &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt;
&lt;/video&gt;
</code></pre><p><code>&lt;track&gt;</code>标签，为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code> &lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
     &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
     &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt;
     &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt;
      &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt;
&lt;/video&gt; 
</code></pre><p><strong>HTML5 中如何嵌入视频</strong><br>和音频类似，HTML5 支持 MP4 、WebM 和 Ogg 格式的视频，通过video标签嵌入视频，下面是简单示例：</p>
<pre><code>&lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
  &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
   Your browser does’ nt support video embedding feature.
&lt;/video&gt;
</code></pre><p><strong>HTML5 中如何嵌入音频</strong><br>HTML5 支持 MP3 、Wav 和 Ogg 格式的音频，通过audio标签嵌入音频，示例如下：</p>
<pre><code>&lt;audio controls&gt;
    &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt;
    Your browser does’ nt support audio embedding feature.
&lt;/audio&gt;
</code></pre><p><strong>新的 HTML5 文档类型和字符集是什么</strong><br>HTML5 文档类型：<code>&lt;!doctype html&gt;</code><br>HTML5 使用 UTF-8 编码: <code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自牛客网&lt;a href=&quot;https://www.nowcoder.com/ta/review-frontend?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端面试常考知识点 HTML+CSS&lt;/a&gt; 篇学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="interview questions" scheme="http://yoursite.com/categories/interview-questions/"/>
    
    
      <category term="interview questions" scheme="http://yoursite.com/tags/interview-questions/"/>
    
  </entry>
  
  <entry>
    <title>在两台电脑上更新维护github pages + hexo博客</title>
    <link href="http://yoursite.com/2018/01/07/maintain%20github%20blog%20on%20two%20computer/"/>
    <id>http://yoursite.com/2018/01/07/maintain github blog on two computer/</id>
    <published>2018-01-07T13:10:12.000Z</published>
    <updated>2018-01-09T02:47:03.126Z</updated>
    
    <content type="html"><![CDATA[<p>之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。</p>
<a id="more"></a>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>主要思路利用git分支实现。利用Hexo框架生成的静态博客文件默认放在博客repo的master分支，即台式机上初次搭建好的本地博客环境Hexo文件夹下的public文件夹的内容对应github上博客repo的master分支内容。现在我们需要在博客repo新建一个hexo分支，用来放Hexo源文件，即放台式机上Hexo文件夹下的全部文件，而不只是public文件夹（public用来存放静态网站文件）。</p>
<p>现在我们的博客repo即xxxx.github.io这个仓库有了两个分支，一个master分支用来放Hexo生成的静态网站，一个hexo分支放Hexo的源文件。相当于用hexo分支备份了之前台式机上本地的Hexo环境，在笔记本上将hexo分支clone下来，然后写文章、更新博客到hexo分支（<code>git push</code>到hexo分支，使得备份源文件最新），保证hexo分支的内容最新，然后执行<code>hexo g -d</code>命令，生成的静态文件会被默认push到master分支，更新博客站点内容。</p>
<p>下面来叙述一下具体的操作步骤。</p>
<h2 id="原来台式机上的操作"><a href="#原来台式机上的操作" class="headerlink" title="原来台式机上的操作"></a>原来台式机上的操作</h2><ul>
<li>在Github的xxx.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo（之前的默认分支是master），save保存。</li>
</ul>
<ul>
<li>然后将该仓库克隆到本地，进入该xxx.github.io文件目录。在当前目录使用Git Bash，执行<code>git branch</code>命令查看当前文件夹下内容所在的分支，查询结果应为新建的分支hexo。</li>
</ul>
<ul>
<li>接下来，将本地博客的部署文件（<strong>Hexo目录下的全部文件</strong>，即Hexo源文件）全部拷贝进xxx.github.io文件目录中去。最后将xxx.github.io目录下的全部文件push到hexo分支，即完成了Hexo源文件的备份过程。</li>
</ul>
<p><strong>注意：</strong>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。可能有人会问，删除了themes目录中的.git不就不能<code>git pull</code>更新主题了吗，很简单，需要更新主题时在另一个地方<code>git clone</code>下来该主题的最新版本，然后将内容拷到当前主题目录即可。</p>
<p>上面的注意点中的情形我没有遇到，直接把本地Hexo文件夹下的全部内容复制到新clone下来的xxx.github.io文件夹下，然后通过git命令push到博客repo的hexo分支。</p>
<p><strong>push到hexo分支的git命令介绍:</strong><code>git status</code>可以查看当前目录下哪些文件被改动过了，被改动过但还未被git管理的显示红色，被改动过但已经add添加到暂存区的显示绿色；<code>git add .</code>可以将当前目录下的全部改动文件添加到暂存区，以待被提交；<code>git commit -m &quot;back up hexo files&quot;</code>将暂存区的内容提交至HEAD，以待被push到远端；<code>git push</code>将HEAD内容push到远端github博客仓库的hexo分支。至此完成了台式机本地Hexo源文件备份到xxx.github.io仓库的hexo分支。</p>
<h2 id="新的笔记本上的操作"><a href="#新的笔记本上的操作" class="headerlink" title="新的笔记本上的操作"></a>新的笔记本上的操作</h2><p>由于上面过程已经完成了原来电脑上本地Hexo源文件的备份，所以博客现在可以在其他电脑上维护和更新了。</p>
<p>由于笔记本上没有安装node.js、git等，所以需要像初次搭建博客那样，先安装配置好环境。参考之前的文章<a href="http://shirley5li.me/2017/08/06/hello-world/" target="_blank" rel="noopener">基于hexo和github搭建个人博客概述</a>，先下载安装node.js，下载安装git。（如果电脑有这两个工具可以忽略这一步）</p>
<ul>
<li><p>将新电脑即笔记本生成的ssh key添加到GitHub账户上（因为通过SSH url方式，使用git客户端第一次git clone github.com代码需要验证ssh key），具体的添加SSH key方法参考<a href="http://blog.csdn.net/binyao02123202/article/details/20130891" target="_blank" rel="noopener">github设置添加SSH</a>。</p>
</li>
<li><p>在笔记本上克隆xxx.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支，使用<code>git branch</code>命令查看。</p>
</li>
</ul>
<ul>
<li>切换到xxx.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)。</li>
</ul>
<p>另外可以看到仓库hexo分支themes/next主题文件夹是空的，所以clone到本地的next主题文件夹也是空的（原因还没搞清楚，为什么备份的时候单单next主题文件夹push不上去），所以只好将台式机上的next主题文件夹拷贝一份到笔记本上，替换clone下来的空next主题文件夹。这个地方算是遇到的一个坑，因为本地测试的时候提示无法渲染index.html，搜索了原因有人回答是不是主题文件没有，这才发现next文件夹是空的。</p>
<p>还有就是，由于还需要Hexo框架帮我们生成静态网站并push到master分支，而此时你有没有发现我们还忘记装Hexo了，没装Hexo我们怎么能用<code>hexo g -d</code>这样的命令呢。所以最后一步，把Hexo装上。Hexo的下载安装同样参考之前的博客<a href="http://shirley5li.me/2017/08/06/hello-world/" target="_blank" rel="noopener">基于hexo和github搭建个人博客概述</a>。之前我以为备份好Hexo源文件，再clone下来就自带Hexo环境，可以执行<code>hexo g</code>这样命令，我参考的那篇博文也没重装Hexo这一步，但当我试着写了文章执行本地<code>hexo s</code>测试时，提示找不到<code>hexo</code>这样的命令，然后我照初次搭建博客那样<code>$ npm install hexo --save</code>，又装了一下Hexo，就可以执行<code>hexo s</code>命令了，并测试了一下正确。</p>
<p>至此就可以在笔记本上写博客了。</p>
<p>在xxx.github.io目录下，执行<code>hexo new post &quot;the first post on laptop&quot;</code>，可以新建一篇文章，然后编辑撰写，或者改动以前的文章。</p>
<ul>
<li><p>然后用执行<code>git status</code>可以查看当前目录下哪些文件被改动过了，即新写的文章、添加的文件、修改的文件等；执行<code>git add .</code>将当前目录下的全部改动文件添加到暂存区，以待被提交；执行<code>git commit -m &quot;back up hexo files&quot;</code>将暂存区的内容提交至HEAD，以待被push到远端；执行<code>git push</code>将HEAD内容push到远端github博客仓库的hexo分支。至此完成了笔记本本地Hexo源文件备份到xxx.github.io仓库的hexo分支的过程，即不管是在台式机操作还是在笔记本操作，都要保证hexo分支的内容是最新的。</p>
</li>
<li><p>最后执行<code>hexo g -d</code>命令，即将本地编辑好的.md形式的文件生成静态博客文件并push到博客repo的master分支，这一步完成了博客站点的更新。</p>
</li>
</ul>
<h2 id="再回到台式机上更新博客时的操作"><a href="#再回到台式机上更新博客时的操作" class="headerlink" title="再回到台式机上更新博客时的操作"></a>再回到台式机上更新博客时的操作</h2><p><strong>注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行<code>git pull hexo</code>命令</strong>，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。</p>
<p>另外看到一篇讲解<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="noopener">Hexo的版本控制与持续集成</a>的文章，将本地push到hexo分支和利用hexo部署博客静态文件到master分支的两个步骤合二为一，使用GitHub进行版本控制，又能做到一键发布。即用到了持续集成，也就是用CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo。自己还没有实际操作过，等操作过后再作总结。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">利用Hexo在多台电脑上提交和更新github pages博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="github pages" scheme="http://yoursite.com/categories/github-pages/"/>
    
    
      <category term="github pages" scheme="http://yoursite.com/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画简介</title>
    <link href="http://yoursite.com/2018/01/03/CSS%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/01/03/CSS动画简介/</id>
    <published>2018-01-03T01:53:24.000Z</published>
    <updated>2018-01-09T02:47:02.933Z</updated>
    
    <content type="html"><![CDATA[<p>来自于NEXT十天训练营CSS篇关于动画的笔记。<br><a id="more"></a></p>
<h2 id="CSS动画分类"><a href="#CSS动画分类" class="headerlink" title="CSS动画分类"></a>CSS动画分类</h2><p>CSS动画主要有两类，即<strong>补间动画和帧动画</strong>。</p>
<p>补间动画只需定义一个开始状态和结束状态，其余中间状态由浏览器自动填充，使用transition属性实现。</p>
<p>帧动画不只要定义开始和结束状态，还需要定义中间过程的帧，使用animation属性实现。</p>
<p><img src="/images/CSS动画简介/1.png" alt="1"> <img src="/images/CSS动画简介/2.png" alt="2"></p>
<h2 id="transition动画"><a href="#transition动画" class="headerlink" title="transition动画"></a>transition动画</h2><p>transition动画只需定义动画的开始和结束状态，其余过渡状态由浏览器自动补全。示例代码如下：</p>
<p>HTML结构：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS样式：</p>
<pre><code>.box {
    width: 600px;
    height: 200px;
    border: 1px solid #ccc;
    background-color: #fff;
    margin: 200px auto;
}
.circle {
    width: 50px;
    height: 50px;
    /*定义开始状态小球的颜色和位置*/
    background-color: blue;
    border-radius: 50%;
    margin: 75px 0;
    /*注意transition有多个属性，此处为简写新形式，包括了两个属性*/
    /*即transition-property: all; transition-duration: 2s;*/

    /*transition-property设置过渡效果的CSS属性的名称*/
    /*transtion-property的值为all，表示background-color和transform都是过渡渐变属性，*/

    /*若此处transtion-property值为background-color，而transform不变，则只过渡渐变颜色，位置瞬移*/
    transition: all 2s;
}
/*定义结束状态小球的位置和颜色*/
.box:hover .circle {
    background-color: red;
    transform: translate(550px, 0);
}
</code></pre><p>实例效果见<a href="https://codepen.io/shirley5li/full/wpeLmw/" target="_blank" rel="noopener">codepen</a>。transition共有如下四个属性。</p>
<p><img src="/images/CSS动画简介/3.png" alt="3"></p>
<p>另外transition-property不支持动画的一些属性如下：</p>
<p><img src="/images/CSS动画简介/4.png" alt="4"></p>
<p>不支持将a图片过渡渐变为b图片；不支持float属性（即float属性从无到有）；不支持将width/height属性从无渐变为某个值，但支持从一个长度渐变为另一个长度；不支持display属性从无到有；不支持visibility属性；不支持poisition属性。</p>
<h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>animation动画通过关键帧来定义动画的变化状态。示例代码如下：</p>
<p>HTML结构：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS样式：</p>
<pre><code>.circle {
    width: 50px;
    height: 50px;
    background-color: blue;
    border-radius: 50%;
    margin: 75px 0;
    /*animation: circleRun 2s ease infinite;*/
    /*animation也是一个简写属性，即上一句包括如下属性*/
    animation-name: circleRun;
    animation-duration: 2s;
    animation-timing-function: ease;
    animation-iteration-count: infinite;
    /*此外animation还有如下几个属性*/
    animation-delay: 2s;
    animation-direction: normal;
    animation-fill-mode: none;
    animation-play-state: running;
}
/*定义中间状态小球的关键帧*/
@keyframes circleRun {
    from {
        transform: translate(0, 75px);
    }
    33% {
        transform: translate(150px, 75px);
    }
    66% {
        transform: translate(400px, -75px);
    }
    to {
        transform: translate(550px, 0);
        background-color: red;
    }
}
</code></pre><p>实例效果见<a href="https://codepen.io/shirley5li/full/baRXbE/" target="_blank" rel="noopener">codepen</a>。</p>
<p>使用animation实现页面正在loading的效果见<a href="https://codepen.io/shirley5li/full/dJRxzB/" target="_blank" rel="noopener">codepen demo-animationLoading</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自于NEXT十天训练营CSS篇关于动画的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS几种布局方式的学习总结</title>
    <link href="http://yoursite.com/2018/01/02/CSS-layout/"/>
    <id>http://yoursite.com/2018/01/02/CSS-layout/</id>
    <published>2018-01-02T06:05:23.000Z</published>
    <updated>2018-01-09T02:47:02.933Z</updated>
    
    <content type="html"><![CDATA[<p>学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自<a href="http://www.sohu.com/a/168143624_274163" target="_blank" rel="noopener">CSS 常见布局方式 </a>。<br><a id="more"></a><br>CSS几种常见的布局方式如下图总结。</p>
<p><img src="/images/CSS-layout/1.jpeg" alt="1"></p>
<h2 id="传统盒模型布局方式"><a href="#传统盒模型布局方式" class="headerlink" title="传统盒模型布局方式"></a>传统盒模型布局方式</h2><p>传统布局方式就是通过盒模型，使用 display属性（文档流布局） + position属性（定位布局） + float属性（浮动布局）。</p>
<h3 id="文档流布局"><a href="#文档流布局" class="headerlink" title="文档流布局"></a>文档流布局</h3><p>最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行。</p>
<h3 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h3><p>通过 <strong>position属性</strong>来进行定位。该属性有四种不同类型的定位，分别为static（默认定位）、relative（相对定位）、absolute（绝对定位）和fixed（固定定位）。</p>
<p><strong>static：</strong>若某元素的position属性的是默认static，那这个元素就在文档流中。</p>
<p><strong>relative：</strong>设置为相对定位的元素<strong>不脱离文档流</strong>，参考自身的位置通过top、bottom、left和right进行定位，让这个元素以自身原来的位置为基准进行移动，<strong>元素仍然保持其未定位前的形状，它原本所占的空间仍然保留</strong>（因为它没有脱离文档流）。因此，采用相对定位的元素有可能覆盖了其他元素，因为它其实占据了两个位置，一个是移动前的位置，一个是移动后的位置，若移动后的位置和别的元素冲突，就把别的元素覆盖了。</p>
<p>与relative（相对定位）不同，<strong>设置为absolute（绝对定位）和fixed（固定定位）的元素脱离了文档流</strong>，元素原先在正常文档流中所占的空间会关闭，就像该元素不存在一样。</p>
<p><strong>absolute:</strong> absolute（绝对定位）元素的位置相对于最近的已定位的祖先元素，若该元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 </p>
<p><strong>fixed:</strong> fixed（固定定位）是相对于浏览器窗口的，即将设置为fixed（固定位置）的元素固定在浏览器的某个位置上，即使拖动浏览器的滚动条，该元素的位置也不会改变。</p>
<h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><p>使用 <strong>float属性</strong>，使元素脱离文档流，浮动起来。</p>
<p>在CSS中使用float属性用于改变块元素对象的默认显示方式。当块元素对象设置了float属性后，它将不再独占一行，而是可以浮动到左侧或右侧，直到浮动的框外缘碰到包含框或另一个浮动框的边框为止。</p>
<p><strong>注意：</strong>浮动框也不在文档流中，因此对文档流的中块框来说，浮动框就像不存在一样。这一点和absolute（绝对定位）属性类型有类似之处，但float和absolute还有以下<strong>不同：</strong></p>
<p>(1)absolute元素的位置相对于离它最近的已定位的祖先元素，它可以以父元素框的4个顶点为基准进行定位。而float属性定位时则是根据left或right属性值，以父元素的左上或右上为基准进行定位。</p>
<p>(2)采用absolute属性定位的元素不能被文本所包围，而采用float属性定位的元素可以被文本包围（float最初设计的用意就是这个，用以取代HTML中的align属性）。</p>
<p>(3)float的影响可控，absolute的影响不可控。<br>设置float和absolute属性的元素都脱离了文档流，因此它们都会影响到其下方的元素。但是，absolute是布局属性，使用它时没有一种有效的方法使之与其下方的元素不重合在一起。相反，若一个元素指定了float属性，当我们向其下方（或后面）的元素的应用了clear属性后（clear:left；clear:right；clear:both），其后的元素就不再受影响了。所以一般在网页布局时，更多的使用float属性。</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>flex是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果。但是要注意其浏览器的兼容性，flex 只支持 ie 10+，所以还是要根据项目情况使用。</p>
<h3 id="使用flex布局"><a href="#使用flex布局" class="headerlink" title="使用flex布局"></a>使用flex布局</h3><p>只需要将其display属性设置为 flex 即可，也可以设置行内的 flex。 Webkit内核的浏览器，必须加上 -webkit 前缀。<strong>注意：</strong>设为flex布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<p>Flexible Box模型如下：</p>
<p><img src="/images/CSS-layout/2.png" alt="2"></p>
<p>在flex中，最核心的概念就是<strong>容器和轴</strong>，所有的属性都是围绕容器和轴设置的。其中，容器分为父容器和子容器。轴分为主轴（main axis）和交叉轴（cross axis）（主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90°）。</p>
<p>在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。</p>
<p>在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
<h3 id="父容器属性"><a href="#父容器属性" class="headerlink" title="父容器属性"></a>父容器属性</h3><p>父容器上有六个属性：flex-direction：主轴的方向。 flex-wrap：超出父容器子容器的排列样式。 flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。 justify-content：子容器在主轴的排列方向。 align-items：子容器在交叉轴的排列方向。 align-content：多根轴线的对齐方式。</p>
<p><strong>flex-direction</strong> 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。</p>
<p><img src="/images/CSS-layout/3.jpeg" alt="3"></p>
<p><strong>flex-wrap</strong> 属性决定子容器如果在一条轴线排不下时，如何换行。</p>
<p><img src="/images/CSS-layout/4.jpeg" alt="4"></p>
<p><strong>flex-flow</strong> 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p>
<p><strong>justify-content</strong> 属性定义了子容器在主轴上的对齐方式。</p>
<p><img src="/images/CSS-layout/5.jpeg" alt="5"></p>
<p><strong>align-items</strong> 属性定义子容器在交叉轴上如何对齐,具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<p><img src="/images/CSS-layout/6.jpeg" alt="6"></p>
<p><strong>align-content</strong> 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p><img src="/images/CSS-layout/7.jpeg" alt="7"></p>
<h3 id="子容器属性"><a href="#子容器属性" class="headerlink" title="子容器属性"></a>子容器属性</h3><p>子容器也有 6 个属性：order：子容器的排列顺序。 flex-grow：子容器剩余空间的拉伸比例。 flex-shrink：子容器超出空间的压缩比例。 flex-basis：子容器在不伸缩情况下的原始尺寸。 子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写。 align-self属性。</p>
<p><strong>order</strong> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<p><strong>flex-grow</strong> 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。</p>
<p><strong>flex-shrink</strong> 属性定义了子容器弹性收缩的比例。例如，超出的部分按 1:2 的比例从给定子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap。</p>
<p><strong>flex-basis</strong> 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。</p>
<p><strong>flex</strong> 属性是 flex-grow,flex-shrink 和 flex-basis 的简写，默认值为 0 1auto。后两个属性可选。</p>
<p><strong>align-self</strong> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父容器align-items 属性。默认值为 auto，表示继承父元素的 align-items属性，如果没有父元素，则等同于 stretch。</p>
<h2 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h2><p>flex 布局虽然强大，但是只能是一维布局，如果要进行二维布局，还需要使用 grid。</p>
<p>grid 布局又称为“网格布局”，可以实现二维布局方式，和之前的 表格table布局差不多，然而，这是使用 CSS 控制的，不是使用 HTML 控制的，同时还可以依赖于媒体查询根据不同的上下文得新定义布局。</p>
<p>网格布局还可以让我们摆脱现在布局中存在的文档流限制，换句话说，你的结构不需要根据设计稿从上往下布置了。这也意味着您可以自由地更改页面元素位置。这最适合你在不同的断点位置实现你最需要的布局，而不再需要为响应你的设计而担心HTML结构的问题。<br>和 table 布局不同的是，grid 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。</p>
<p>没有 HTML 结构的网格布局有助于使用流体、调整顺序等技术管理或更改布局。通过结合 CSS 的媒体查询属性，可以控制网格布局容器和他们的子元素，使用页面的布局根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容。</p>
<h3 id="grid-网格布局中的基本概念"><a href="#grid-网格布局中的基本概念" class="headerlink" title="grid 网格布局中的基本概念"></a>grid 网格布局中的基本概念</h3><p><strong>网格线(Grid Lines)</strong> 组成了网格，他是网格的水平和垂直的分界线。一个网格线存在行或列的两侧。我们可以引用它的数目或者定义的网格线名称。</p>
<p><img src="/images/CSS-layout/8.jpeg" alt="8"></p>
<p><strong>网格轨道(Grid Track)</strong>是就是相邻两条网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。</p>
<p><img src="/images/CSS-layout/9.jpeg" alt="9"></p>
<p><strong>网格单元格(Grid Cell)</strong> 是指四条网格线之间的空间。所以它是最小的单位，就像表格中的单元格。</p>
<p><img src="/images/CSS-layout/10.jpeg" alt="10"></p>
<p><strong>网格区域(Grid Area)</strong> 是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。</p>
<p><img src="/images/CSS-layout/11.jpeg" alt="11"></p>
<h3 id="使用grid布局"><a href="#使用grid布局" class="headerlink" title="使用grid布局"></a>使用grid布局</h3><p>使用 grid 布局很简单，通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小） 就可以了。</p>
<p>网格容器中的所有子元素就会自动变成网格项目（grid item），然后设置列（grid-template-columns）和 行（grid-template-rows）的大小，设置 grid-template-columns 有多少个参数，生成的 grid 列表就有多少 列。</p>
<p><strong>注：</strong>当元素设置了网格布局，column、float、clear、vertical-align属性无效。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://blog.csdn.net/zhuyunhe/article/details/45790527" target="_blank" rel="noopener">CSS定位——position、float小结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自&lt;a href=&quot;http://www.sohu.com/a/168143624_274163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS 常见布局方式 &lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>github pages自定义域名及DNS相关介绍</title>
    <link href="http://yoursite.com/2017/12/29/github-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <id>http://yoursite.com/2017/12/29/github-pages绑定域名/</id>
    <published>2017-12-29T06:49:39.000Z</published>
    <updated>2018-01-09T02:47:02.939Z</updated>
    
    <content type="html"><![CDATA[<p>在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！<br><a id="more"></a></p>
<h2 id="域名相关知识"><a href="#域名相关知识" class="headerlink" title="域名相关知识"></a>域名相关知识</h2><h3 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么"></a>域名是什么</h3><p>根据百度百科，域名（Domain Name），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称。用于在数据传输时标识计算机的电子方位。</p>
<p>对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。域名同时也仅限于ASCII字符的一个子集，这使得很多其他语言无法正确表示他们的名字和单词。</p>
<p>在域名中大小写是没有区分的。域名一般不能超过5级，从左到右域的级别变高，高的级域包含低的级域。域名在整个Internet中是唯一的，当高级子域名相同时，低级子域名不允许重复。一台服务器只能有一个IP地址，但是却可以有多个域名。</p>
<p>任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。这是基于13个全球范围的“根服务器”，其维护组织除了当中的3个以外，其他都位于美国。从这13个根服务器开始，余下的Internet DNS命名空间被委托给其他的DNS服务器， 这些服务器提供DNS名称空间中的特定部分。</p>
<h3 id="域名级别"><a href="#域名级别" class="headerlink" title="域名级别"></a>域名级别</h3><p>整个DNS系统是由许多域所组成，每个域下又细分更多的域，DNS域构成了层次树状结构，自上而下分别是根域、顶级域名、二级域名…，最后是主机名。</p>
<p>顶级域名（一级域名）——如：.com、.net、.edu、.gov、.cn等。二级域名我们常常能够申请到的域名，在顶级域名的左侧加上的一个自定义的文字段，例如shirley5li.me，通常所说申请的域名，往往指的是这个二级域名。</p>
<p>以www.sina.com.cn为例，该域名是三级域名，其中sina.com.cn为新浪Web服务器的【域名】，www不是域名的组成部分而是URL的组成部分。所以该例中， 一级域名.cn、二级域名.com.cn、三级域名.sina.com.cn。<br>主机名www（表示该主机所提供的服务为www服务，即Web服务器。</p>
<p>URL的构成——<a href="http://主机名" target="_blank" rel="noopener">http://主机名</a> . 域名（端口号、参数、查询等可选。 域名(Domain Name)可由若干部份组成,各部份之间用圆点分开，域名前加上【主机类型信息】（如：www、ftp）和【传输协议信息】就构成了网址（URL）<a href="http://www.xxxx.cn。" target="_blank" rel="noopener">http://www.xxxx.cn。</a></p>
<p><strong>子域名(sbudomain name)</strong></p>
<p>相对于上文所提到的“我们通常所说的域名”（二级域名）的基础上，又加入了子域名的概念，就是在一个域名的前面，加上新的字段，代表这个域名下的某个特定的主机或者协议。最常用的就是WWW协议，所以，我的子域名www.shirley5li.me就是shirley5li.me的WWW子域名。</p>
<h2 id="DNS相关知识"><a href="#DNS相关知识" class="headerlink" title="DNS相关知识"></a>DNS相关知识</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<p>例如，www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。</p>
<p>域名服务器分不同的组来负责各子系统的名字。系统中的每一层叫做一个域，每个域用一个点分开。所谓域名服务器（即Domain Name Server，简称Name Server、DNS）实际上就是装有域名系统的主机。它是一种分层结构数据库，能够执行名字解析（name resolution）。</p>
<p>DNS服务器上都存了些啥？最主要的就是能够完成域名解析的一些记录</p>
<h3 id="A记录（A-record"><a href="#A记录（A-record" class="headerlink" title="A记录（A record)"></a>A记录（A record)</h3><p>A记录在DNS中的意义就是，域名到ip地址的转换。所以，当我们在DNS服务器中添加一个A记录时，是告诉服务器，将某个特定的域名映射到一个ip地址。</p>
<h3 id="CNAME记录（CNAME-record"><a href="#CNAME记录（CNAME-record" class="headerlink" title="CNAME记录（CNAME record)"></a>CNAME记录（CNAME record)</h3><p>CNAME的意义，简单说就是别名，即将一个域名射到另一个域名（区别于A记录的ip）。所以，CNAME通常有两种用法:</p>
<p>(1)不同顶级域名之间的跳转。例如：我的域名是 shirley5li.me(顶级域名为me)。如果希望当访问这个域名的时候，实际上是访问的shirley5li.github.io（顶级域名为io）的主页时，虽然他们在不同的顶级域名，但是可以用CNAME记录映射。</p>
<p>(2)将一个子域名映射到域名。例如：你想当访问者输入www.shirley5li.me（一个WWW子域名）的时候，仍旧访问shirley5li.me这个域名所指向的内容时，可以将www.shirley5li.me利用CNAME记录映射到shirley5li.me。</p>
<h3 id="NS记录（Name-Server）"><a href="#NS记录（Name-Server）" class="headerlink" title="NS记录（Name Server）"></a>NS记录（Name Server）</h3><p>指定了负责解析我这个域名的服务器的地址。这条记录赋予我们一个特殊的能力，就是，我可以让自己指定的一个DNS解析服务器，而不一定是域名提供商自带的域名解析服务器。简单来说，就是在godaddy买的域名，默认是使用godaddy的域名服务器来进行域名解析的，但是如果我想让别的server解析（例如NDSPod），而不受godaddy服务器的限制呢？那就是更改这个NS记录的内容。一般来讲，是两条记录，一条主服务器，一条副服务器。</p>
<p>因此很多人推荐Godaddy注册购买域名，DNSpod负责解析，即修改NS记录。</p>
<h2 id="域名服务器哪家强"><a href="#域名服务器哪家强" class="headerlink" title="域名服务器哪家强"></a>域名服务器哪家强</h2><p>域名通过向域名注册商购买获得，如今有很多域名注册商，比如国内的<a href="https://wanwang.aliyun.com" target="_blank" rel="noopener">万网</a>以及国外的<a href="https://sg.godaddy.com" target="_blank" rel="noopener">GoDaddy</a>。<br>考虑各种因素，在GoDaddy上购买域名相比万网的好处是不需要各种审核，很多人推荐使用godaddy，Godaddy注册购买域名，DNSpod解析。雅蠛蝶，那我也用狗爹了~<a href="http://godaddy.idcspy.com/domain-regist" target="_blank" rel="noopener">2017年Godaddy域名注册教程</a></p>
<p>先来狗爹注册个账号，然后搜索想要的域名购买。这里又在选择什么样的域名后缀纠结半天，什么.me .cc .org .com，最后选择了shirley5li.me，因为价格最低。。。然后支付宝付款就好了。</p>
<h2 id="github-pages绑定域名详细步骤"><a href="#github-pages绑定域名详细步骤" class="headerlink" title="github pages绑定域名详细步骤"></a>github pages绑定域名详细步骤</h2><p>既然域名已经买完了，直接是没法用的，因为没有进行DNS解析，别人是没法正常通过域名访问你的界面的，这里使用DNS进行解析。</p>
<p>域名绑定的含义就是当你访问你的域名时，浏览器会自动跳转到刚才创建的 Github Pages(username.github.io)。实现绑定的关键在于设置 DNS 解析。在 GoDaddy 注册的域名，由于 GFW 的存在，需要使用第三方 DNS 服务来解析域名。推荐使用鹅厂的 DNSPOD。鹅厂的服务可靠性高同时也不会被墙。</p>
<p>域名购买完成后，回到Github项目上，即搭建博客那个项目，点击设置Settings，找到Custom domain，填入申请的域名，并保存。</p>
<p><img src="/images/github-pages绑定域名/1.png" alt="1"><br>这个操作等同于在项目根目录下创建一个名为CNAME的文件，文件内容为上述填写的域名。</p>
<p>回到GoDaddy的主页上，点击个人用户–&gt;管理域名。</p>
<p><img src="/images/github-pages绑定域名/2.png" alt="2"></p>
<p>再点击那三个点点（真的对用户超不友好，找半天！！！），选择管理DNS。</p>
<p><img src="/images/github-pages绑定域名/3.png" alt="3"></p>
<p>默认的DNS记录如下所示：</p>
<p><img src="/images/github-pages绑定域名/4.png" alt="4"></p>
<p>关于A记录的修改，在名称@这条记录中，将值改为Github博客的IP地址（由ping得到，即<code>151.101.77.147</code>。操作如下：</p>
<p><img src="/images/github-pages绑定域名/5.png" alt="5"></p>
<p>关于CNAME记录的修改，在名称www这条记录中，将值改为github博客默认的域名，即shirley5li.github.io。</p>
<p>该阶段修改后修的DNS管理记录如下：</p>
<p><img src="/images/github-pages绑定域名/6.png" alt="6"></p>
<p>上图中两条NS记录的值为狗爹默认的域名服务器的地址，为防止背墙以及速度等原因，采用第三方国内域名服务器NDSPod来解析我们在狗爹申请的域名。</p>
<p>接下来我们到<a href="https://www.dnspod.cn/" target="_blank" rel="noopener">NDSPod</a>来注册账号，注册完账号后，在DNSPOD首页–&gt;管理控制台–&gt;域名解析–&gt;添加域名，将在狗爹申请的域名填入，点确定。如下所示。</p>
<p><img src="/images/github-pages绑定域名/7.png" alt="7"></p>
<p>然后点击刚刚添加的域名，来管理DNS记录。DNS记录各参数含义：(1)主机记录， @：不通过任何前缀访问域名 ， www：通过www前缀访问域名。(2)记录类型， A：在记录值处写主机IP地址，NS：记录值是DNSPOD提供的Name Server地址，CNAME：记录值是域名的别名。</p>
<p>添加一条A记录，主机类型是@，记录值填ping Github博客得到的ip地址。再将狗爹上的两条CNAME记录添加上。最后DNSPOD上的DNS各条记录如下所示:</p>
<p><img src="/images/github-pages绑定域名/8.png" alt="8"></p>
<p>然后将上图中的两条NS记录值（DNSPOD默认的域名服务器地址），填入Godaddy的自定义域名服务器。<br>即：</p>
<p><img src="/images/github-pages绑定域名/9.png" alt="9"></p>
<p>狗爹更改后，再刷新一下，域名服务器如下：</p>
<p><img src="/images/github-pages绑定域名/10.png" alt="10"> </p>
<p>等待一段时间就可以成功用DNSPod解析域名到Github博客，在浏览器地址栏输入shirley5li.me，可以看到如下github pages博客主页：</p>
<p><img src="/images/github-pages绑定域名/11.png" alt="11"> </p>
<p>至此大功告成。</p>
<p>PS:参考一些博客，他们在域名注册成功后，在github博客本地目录source下创建CNAME文件，里面填入自己申请的域名即shirley5li.me，保存后<code>hexo g -d</code>上传至Github Repo中。此步骤相当于在搭建博客那个项目，点击设置Settings，在Custom domain，填入申请的域名的过程，因为上面已经操作了Custom domain填入申请域名的过程，所以没有此步骤也可以正常解析shirley5li.me，但再添加也无妨。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="noopener">域名–wikipedia</a></p>
<p><a href="http://blog.csdn.net/f87089/article/details/51480278" target="_blank" rel="noopener">怎么区分域名级别，举例说明更易懂</a></p>
<p><a href="http://winterttr.me/2015/10/23/from-dns-to-github-custom-domain/" target="_blank" rel="noopener">从DNS到github pages自定义域名 – 漫谈域名那些事</a></p>
<p><a href="http://www.laozuo.org/7198.html" target="_blank" rel="noopener">老左所理解的建站域名的选择以及域名投资的一些看法</a></p>
<p><a href="https://www.zhihu.com/question/19735598?sort=created&amp;page=1" target="_blank" rel="noopener">想注册一个作个人博客用的域名，应该使用哪个域名注册提供商？</a></p>
<p><a href="http://yanshengjia.com/2017/01/31/%E4%BD%BF%E7%94%A8Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">使用 Hexo + Github Pages 搭建独立博客</a></p>
<p><a href="https://www.jianshu.com/p/252b542b1abf" target="_blank" rel="noopener">Blog绑定域名——Godaddy + DNSPod</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！&lt;br&gt;
    
    </summary>
    
      <category term="github pages" scheme="http://yoursite.com/categories/github-pages/"/>
    
    
      <category term="github pages" scheme="http://yoursite.com/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>博文集锦</title>
    <link href="http://yoursite.com/2017/12/27/good-blog-post/"/>
    <id>http://yoursite.com/2017/12/27/good-blog-post/</id>
    <published>2017-12-27T02:58:05.000Z</published>
    <updated>2018-01-23T12:12:52.266Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。<br><a id="more"></a></p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a href="https://www.cnblogs.com/rainy-shurun/p/5603686.html" target="_blank" rel="noopener">浏览器内部工作原理</a></p>
<p><a href="http://blog.csdn.net/zll0927/article/details/11885239" target="_blank" rel="noopener">当在浏览器地址栏输入一个网址的时候，究竟发生了什么?</a></p>
<p><a href="https://www.cnblogs.com/myzhibie/p/4470065.html" target="_blank" rel="noopener">html5-websocket初探</a></p>
<p><a href="https://www.cnblogs.com/mracale/p/7170385.html" target="_blank" rel="noopener">移动端页面布局</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。&lt;br&gt;
    
    </summary>
    
      <category term="bolgPost" scheme="http://yoursite.com/categories/bolgPost/"/>
    
    
      <category term="blogPost" scheme="http://yoursite.com/tags/blogPost/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（3）学习笔记</title>
    <link href="http://yoursite.com/2017/12/25/JS%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ing/"/>
    <id>http://yoursite.com/2017/12/25/JS高程学习笔记-ing/</id>
    <published>2017-12-25T09:17:54.000Z</published>
    <updated>2018-01-09T02:47:02.934Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript学习笔记。<br><a id="more"></a></p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JS没有块级作用域，即在块语句中定义的变量，实际是在包含函数中创建的，而非在块语句中创建的。如下：</p>
<pre><code>function outputNumbers(count) {
    for( var i = 0; i &lt; count; i++) {
        console.log(i);
    }
    console.log(i);
}
outputNumbers(4);//打印值为0 1 2 3 4
</code></pre><p>在Java、C++等语言中，for循环中定义的变量i只存在于for循环语句块中，循环一旦结束，变量i就会被销毁。而在JS中，变量i是定义在outputNumbers()这个包含函数的活动对象中的，因此从它被定义开始，就可以在函数内部随处访问它。</p>
<p>即使在一个函数中重新声明同一个变量，也不会改变它的值。如下：</p>
<pre><code>function outputNumbers(count) {
    for( var i = 0; i &lt; count; i++) {
        console.log(i);
    }
    var i;
    console.log(i);
}
outputNumbers(4);//打印值为0 1 2 3 4
</code></pre><p>JS不会提醒是否多次声明了同一个变量，在此情况下，它对后续重复的变量声明视而不见，但会执行后续声明中的变量初始化。可以通过<strong>匿名函数模仿块级作用域</strong>来避免多次声明同一个变量的问题。</p>
<p>用作<strong>块级作用域（私有作用域）</strong>的匿名函数语法如下：</p>
<pre><code>(function() {
    //这里为块级作用域
})();
</code></pre><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。使用私有作用域如下：</p>
<pre><code>function outputNumbers(count) {
    (function() {
        for( var i = 0; i &lt; count; i++) {
        console.log(i);
        }
    })();
    console.log(i);//导致一个错误！！！
}
</code></pre><p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的。但有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部无法访问这些变量，包括函数参数、局部变量、在函数中定义的其他函数。</p>
<p>把有权访问上述私有变量和私有函数的公有方法称为<strong>特权方法</strong>，有两种在对象上创建特权方法的方式。</p>
<p><strong>第一种：在构造函数中定义特权方法</strong>，基本模式如下</p>
<pre><code>function MyObject() {
    //私有变量
    var privateVariable = 10;
    //私有函数
    function privateFunction() {
        return false;
    }

    //特权方法
    this.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
}
</code></pre><p>能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。</p>
<p>在创建构造函数实例后，除了使用特权方法，没有其他方式可以直接访问构造函数内部的私有变量和私有函数。</p>
<p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。</p>
<p>在构造函数中定义特权方法的缺点，就是必须使用构造函数模式来实现特权方法，而构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用<strong>静态私有变量</strong>来实现特权方法可以避免这一问题。</p>
<p><strong>第二种：使用静态私有变量实现特权方法</strong></p>
<p>通过在私有作用域中定义私有变量或函数，也可以创建特权方法。基本模式如下：</p>
<pre><code>(function() }{
    //私有变量
    var privateVariable = 10;
    //私有函数
    function privateFunction() {
        return false;
    }

    //构造函数
    MyObject = function() {
    };

    //公有方法/特权方法
    MyObject.prototype.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };

})();
</code></pre><p>公有方法是在构造函数原型上定义的，体现了典型的原型模式。注意：该模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，并不是我们想要的，因此也没有使用关键字var声明MyObject。初始化未经声明的变量，总会创建一个全局变量，因此MyObject就变成了一个全局变量，能够在私有作用域之外被访问到。但在严格模式下，给未经声明的变量赋值会导致错误。</p>
<p>该模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数由实例共享，在一个实例上调用公有方法，会影响所有实例。<br>以该方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。因此选择使用实例变量，还是静态私有变量，视具体需求而定。</p>
<h2 id="BOM-window对象"><a href="#BOM-window对象" class="headerlink" title="BOM-window对象"></a>BOM-window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的global对象。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例如：</p>
<pre><code>var age = 29;
function sayAge() {
    alert(this.age);
}
alert(window.age);   //29
sayAge();            //29
window.sayAge();     //29
</code></pre><p>全局变量会变为window对象的属性，定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。</p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS学习笔记01</title>
    <link href="http://yoursite.com/2017/12/08/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-ing/"/>
    <id>http://yoursite.com/2017/12/08/AngularJS学习笔记01-ing/</id>
    <published>2017-12-08T08:41:16.000Z</published>
    <updated>2018-01-09T02:47:02.932Z</updated>
    
    <content type="html"><![CDATA[<p> AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。<br><a id="more"></a><br> AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。Angular可以帮助你组织JavaScript代码，可以创建响应式网站（会对用户的请求产生快速的反应），Angular可以和JQuery很好的协调、方便测试（搭建可维护的应用）。</p>
<p>简单的解释Angular就是一个可以给HTML加上互动性的客户端JS框架。</p>
<p>关于传统网页请求和AngularJS网页请求之间的区别，参见博客<a href="http://blog.csdn.net/xiaoyao0909/article/details/51419078" target="_blank" rel="noopener">AngularJS系列——简介</a>。</p>
<h2 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h2><pre><code>AngularJS 通过 ng-directives 扩展了 HTML。
ng-app 指令定义一个 AngularJS 应用程序。
ng-model 指令把元素值（比如输入域的值）绑定到应用程序变量。
ng-bind 指令把应用程序数据绑定到 HTML 视图。
</code></pre><p>例如：</p>
<pre><code>&lt;body&gt;
    &lt;div ng-app=&quot;&quot;&gt;
        &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;
        &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>ng-app 指令告诉 AngularJS，<div\> 元素是 AngularJS 应用程序 的”所有者”。ng-model 指令把输入域的值绑定到应用程序变量 name。ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</div\></p>
<p>AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p>
<pre><code>AngularJS 把应用程序数据绑定到 HTML 元素。
AngularJS 可以克隆和重复 HTML 元素。
AngularJS 可以隐藏和显示 HTML 元素。
AngularJS 可以在 HTML 元素&quot;背后&quot;添加代码。
AngularJS 支持输入验证。
</code></pre><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>AngularJS 使用表达式把数据绑定到 HTML。</p>
<p>AngularJS 表达式写在双大括号内：。AngularJS表达式很像JavaScript表达式：它们可以包含文字、运算符和变量。</p>
<pre><code>&lt;body&gt;
    &lt;div ng-app=&quot;&quot;&gt;
        &lt;p&gt;我的第一个表达式: {{ 5 + 5 }}&lt;/p&gt;
    &lt;/div&gt; 
&lt;/body&gt;
</code></pre><p>AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。例如：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt;
    &lt;p&gt;总价： {{ quantity * cost }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>使用 ng-bind 的相同实例：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; 
    &lt;p&gt;总价： &lt;span ng-bind=&quot;quantity * cost&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre><p><strong>AngularJS表达式与JavaScript表达式比较</strong></p>
<pre><code>类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。
与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。
与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。
与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。
</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>AngularJS 通过<strong>指令</strong>新属性来扩展 HTML，指令带有前缀 ng-。</p>
<p>AngularJS 通过内置的指令来为应用添加功能，允许自定义指令。</p>
<pre><code>ng-app 指令初始化一个 AngularJS 应用程序。
ng-init 指令初始化应用程序数据。
ng-model 指令把元素值（比如输入域的值）绑定到应用程序。
ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素
</code></pre><p>例如：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&apos;John&apos;&quot;&gt;
     &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;
     &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt;
     &lt;p&gt;你输入的为： {{ firstName }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。<br>使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive。</p>
<pre><code>&lt;body ng-app=&quot;myApp&quot;&gt;
    &lt;runoob-directive&gt;&lt;/runoob-directive&gt;
    &lt;script&gt;
        var app = angular.module(&quot;myApp&quot;, []);
        app.directive(&quot;runoobDirective&quot;, function() {
            return {
                template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>你可以通过以下方式来调用指令：元素名、属性、类名、注释。</p>
<pre><code>&lt;runoob-directive&gt;&lt;/runoob-directive&gt;
&lt;div runoob-directive&gt;&lt;/div&gt;
&lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt;
&lt;!-- directive: runoob-directive --&gt;
</code></pre><h2 id="AngularJS模型-ng-model指令"><a href="#AngularJS模型-ng-model指令" class="headerlink" title="AngularJS模型 ng-model指令"></a>AngularJS模型 ng-model指令</h2><p>ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="http://yoursite.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://yoursite.com/tags/Angular/"/>
    
  </entry>
  
</feed>
