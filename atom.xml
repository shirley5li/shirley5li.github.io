<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shirley</title>
  <subtitle>一只自学成菜的仙女!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-09T02:47:03.156Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ShirleyLi</name>
    <email>1363814017@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>introduction about HTTP</title>
    <link href="http://yoursite.com/2018/01/09/introduction-about-HTTP/"/>
    <id>http://yoursite.com/2018/01/09/introduction-about-HTTP/</id>
    <published>2018-01-08T16:15:58.000Z</published>
    <updated>2018-01-09T02:47:03.156Z</updated>
    
    <content type="html"><![CDATA[<p>关于HTTP协议相关知识的学习总结。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World    Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP基于TCP/IP通信协议来传递数据。  </p>
<p>HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>（1）HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。   </p>
<p>（2）HTTP是媒体独立的：只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。   </p>
<p>（3）HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h2 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h2><p><img src="https://uploadfiles.nowcoder.com/files/20160727/213669_1469604624728_cgiarch.gif" alt="http协议通信流程图"></p>
<h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p>
<p>客户端请求消息：请求行、请求头部、空行和请求数据。<br>    GET /hello.txt HTTP/1.1<br>    User-Agent: curl/7.16.3 libcurl/7.16.3<br>    OpenSSL/0.9.7l zlib/1.2.3<br>    Host: www.example.com Accept-Language: en, mi<br>服务端响应消息：状态行、消息报头、空行和响应正文。<br>    HTTP/1.1 200 OK<br>    Date: Mon, 27 Jul 2009 12:28:53 GMT<br>    Server: Apache<br>    Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT<br>    ETag: “34aa387-d-1568eb00”<br>    Accept-Ranges: bytes<br>    Content-Length: 51<br>    Vary: Accept-Encoding<br>    Content-Type: text/plain</p>
<h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>​    GET 请求指定的页面信息，并返回实体主体。   </p>
<p>​    HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头   </p>
<p>​    POST   向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。     POST请求可能会导致新的资源的建立和/或已有资源的修改。   </p>
<p>​    PUT 从客户端向服务器传送的数据取代指定的文档的内容。   </p>
<p>​    DELETE  请求服务器删除指定的页面。   </p>
<p>​    CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。   </p>
<p>​    OPTIONS 允许客户端查看服务器的性能。   </p>
<p>​    TRACE   回显服务器收到的请求，主要用于测试或诊断</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p><strong>HTTP状态码分类</strong><br>​        1xx  信息，服务器收到请求，需要请求者继续执行操作<br>​        2xx 成功，操作被成功接收并处理<br>​        3xx 重定向，需要进一步的操作以完成请求<br>​        4xx 客户端错误，请求包含语法错误或无法完成请求<br>​        5xx 服务器错误，服务器在处理请求的过程中发生了错   </p>
<p><strong>HTTP状态码列表</strong><br>​    100 Continue    继续。客户端应继续其请求   </p>
<p>​    101 Switching Protocols      切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议   </p>
<p>​      200 OK  请求成功。一般用于GET与POST请求    </p>
<p>​    201 Created 已创建。成功请求并创建了新的资源   </p>
<p>​    202 Accepted    已接受。已经接受请求，但未处理完成   </p>
<p>​    203 Non-Authoritative Information        非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本   </p>
<p>​    204 No Content       无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档   </p>
<p>​    205 Reset Content        重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域   </p>
<p>​    206 Partial Content 部分内容。服务器成功处理了部分GET请求   </p>
<p>​    300 Multiple Choices         多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择   </p>
<p>​      301 Moved Permanently   永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替    </p>
<p>​    302 Found   临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI   </p>
<p>​    303 See Other   查看其它地址。与301类似。使用GET和POST请求查看   </p>
<p>​      304 Not Modified    未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源    </p>
<p>​    305 Use Proxy   使用代理。所请求的资源必须通过代理访问   </p>
<p>​    306 Unused  已经被废弃的HTTP状态码   </p>
<p>​      307 Temporary Redirect  临时重定向。与302类似。使用GET请求重定向    </p>
<p>​    400 Bad Request 客户端请求的语法错误，服务器无法理解   </p>
<p>​    401 Unauthorized    请求要求用户的身份认证   </p>
<p>​    402 Payment Required    保留，将来使用   </p>
<p>​    403 Forbidden   服务器理解请求客户端的请求，但是拒绝执行此请求   </p>
<p>​      404 Not Found   服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面    </p>
<p>​    405 Method Not Allowed  客户端请求中的方法被禁止   </p>
<p>​    406 Not Acceptable  服务器无法根据客户端请求的内容特性完成请求   </p>
<p>​    407 Proxy Authentication Required        请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权   </p>
<p>​    408 Request Time-out    服务器等待客户端发送的请求时间过长，超时   </p>
<p>​    409 Conflict    服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突   </p>
<p>​    410 Gone         客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置   </p>
<p>​    411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息   </p>
<p>​    412 Precondition Failed 客户端请求信息的先决条件错误   </p>
<p>​    413 Request Entity Too Large         由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息   </p>
<p>​    414 Request-URI Too Large   请求的URI过长（URI通常为网址），服务器无法处理   </p>
<p>​    415 Unsupported Media Type  服务器无法处理请求附带的媒体格式   </p>
<p>​    416 Requested range not satisfiable 客户端请求的范围无效   </p>
<p>​    417 Expectation Failed  服务器无法满足Expect的请求头信息   </p>
<p>​      500 Internal Server Error   服务器内部错误，无法完成请求    </p>
<p>​    501 Not Implemented 服务器不支持请求的功能，无法完成请求   </p>
<p>​    502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   </p>
<p>​    503 Service Unavailable      由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中   </p>
<p>​    504 Gateway Time-out    充当网关或代理的服务器，未及时从远端服务器获取请求   </p>
<p>​    505 HTTP Version not supported  服务器不支持请求的HTTP协议的版本，无法完成处理   </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于HTTP协议相关知识的学习总结。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>【interview questions about HTML】 from牛客网</title>
    <link href="http://yoursite.com/2018/01/08/interview-questions-about-HTML/"/>
    <id>http://yoursite.com/2018/01/08/interview-questions-about-HTML/</id>
    <published>2018-01-08T07:16:53.000Z</published>
    <updated>2018-01-13T06:45:50.930Z</updated>
    
    <content type="html"><![CDATA[<p>来自牛客网<a href="https://www.nowcoder.com/ta/review-frontend?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="external">前端面试常考知识点 HTML+CSS</a> 篇学习总结。<br><a id="more"></a></p>
<h3 id="浏览器页面有哪三层构成"><a href="#浏览器页面有哪三层构成" class="headerlink" title="浏览器页面有哪三层构成"></a>浏览器页面有哪三层构成</h3><p><strong>浏览器页面有哪三层构成，分别是什么，作用是什么?</strong><br>浏览器页面有结构层、表示层、行为层，三层构成，分别是HTML、CSS、JavaScript，作用是HTML实现页面结构(骨架)，CSS完成页面的表现与风格(肌肤)，JavaScript实现一些客户端的功能与业务(动作)，对用户事件作出反应。<br>不过，在这三种技术之间存在着一些潜在的<strong>重叠区域</strong>，如DOM技术可以用来改变网页的结构；CSS诸如<code>:hover</code>和<code>:focus</code>之类的class伪类，使我们可以根据用户触发事件来改变呈现效果。<br>改变元素的呈现效果当然是表示层的“势力范围”，但对用户触发事件做出反应却是行为层的领地。表示层和行为层的这种重叠形成了一个灰色地带。class伪类是 CSS 正在深入DOM领地证据，但 DOM在这方面也不是毫无作为，完全可以利用 DOM 技术把样式信息施加在HTML元素身上。<br>分离的效果要做到即使去掉表示层和行为层，文档的内容也依然可以访问，因为“内容才是一切”。而且网页的行为层(javascript)与其结构(HTML)是彼此互不干扰的，不能混杂在一起。还要给行为层“预留退路”，要考虑到如果你的用户禁用了Javascript会怎样？网页是否还可以正常运作。做到<strong>平稳退化，渐进增强</strong>。</p>
<h3 id="HTML5的优点与缺点"><a href="#HTML5的优点与缺点" class="headerlink" title="HTML5的优点与缺点"></a>HTML5的优点与缺点</h3><p><strong>HTML5是什么:</strong>  HTML5指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ，RIA），例如：AdobeFlash 、Microsoft Silverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 HTML 最新版本，2014 年10月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。<br><strong>为什么有HTML5的出现：</strong> HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合HTML5规范的浏览器功能将更加强大，减少了 Web应用对插件的依赖，让用户体验更好，让开发更加方便，另外W3C 从推出 HTML4.0到5.0之间共经历了17年，HTML的变化很小，这并不符合一个好产品的演进规则。<br><strong>优点：</strong></p>
<ul>
<li>网络标准统一<br>HTML5本身是由W3C推荐出来的，它的开发是通过谷歌、苹果，诺基亚、中国移动等几百家公司一起酝酿的技术，这个技术最大的好处在于它是一个公开的技术。换句话说，每一个公开的标准都可以根据W3C的资料库找寻根源。另一方面，W3C通过的HTML5标准也就意味着每一个浏览器或每一个平台都会去实现。</li>
<li>多设备跨平台，可移植性好<br>HTML5的优点主要在于，这个技术可以进行跨平台的使用。比如你开发了一款HTML5的游戏，你可以很轻易地移植到UC的开放平台、Opera的游戏中心、Facebook应用平台,甚至可以通过封装的技术发放到AppStore或GooglePlay上，所以它的跨平台性非常强大，这也是大多数人对HTML5有兴趣的主要原因。</li>
<li>自适应网页设计<br>即“一次设计，普遍适用”，让同一张网页自动适应不同大小的屏幕，根据屏幕宽度，自动调整布局(layout)。</li>
<li>即时更新<br>游戏客户端每次都要更新，很麻烦。可是更新HTML5游戏就好像更新页面一样，是马上的、即时的更新。</li>
<li>提高可用性和改进用户的友好体验</li>
<li>增加几个新的标签，这将有助于开发人员定义重要的内容</li>
<li>可以给站点带来更多的多媒体元素(视频和音频)</li>
<li>可以很好的替代FLASH和Silverlight<br>Silverlight是一个跨浏览器、跨平台的插件，为网络带来下一代基于.NET媒体体验，和丰富的交互式应用程序。</li>
<li>当涉及到网站的抓取和索引的时候，对于SEO很友好<br>SEO，即搜索引擎优化是一种利用搜索引擎的搜索规则来提高目前网站在有关搜索引擎内的自然排名的方式。</li>
<li><p>将被大量应用于移动应用程序和游戏<br><strong>缺点：</strong></p>
</li>
<li><p>安全方面<br>像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket这样的功能很容易被黑客利用，来盗取用户的信息和资料。</p>
</li>
<li>完善性方面<br>许多特性各浏览器的支持程度也不一样。</li>
<li>技术门槛方面<br>HTML5技术开发者工作的同时，有许多新的属性和API需要开发者学习，像<a href="http://blog.csdn.net/leledexixi/article/details/55210717" target="_blank" rel="external">web worker、web socket、web storage</a>等新特性，甚至后台及浏览器原理的知识。这是机遇的同时也是巨大的挑战。</li>
<li>性能方面<br>某些平台上的引擎问题导致HTML5性能低下.</li>
<li>浏览器兼容性方面<br>IE9以下浏览器几乎不支持。</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><p><strong>Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</strong><br>告诉浏览器应该用什么文档类型规范来解析这个文档。doctype不存在或格式不正确会导致文档以混杂模式呈现。严格模式的排版和js运作模式是以浏览器最高标准运行。混杂模式， 页面以宽松的向后兼容的形式展示。<br>参考博客<a href="http://blog.csdn.net/Vivian_jay/article/details/61933580" target="_blank" rel="external">DOCTYPE声明</a>。</p>
<h3 id="HTML5有哪些新特性、移除了哪些元素"><a href="#HTML5有哪些新特性、移除了哪些元素" class="headerlink" title="HTML5有哪些新特性、移除了哪些元素"></a>HTML5有哪些新特性、移除了哪些元素</h3><p>HTML5新增了27个元素，废弃了16个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性元素、级块性元素、行内语义性元素和交互性元素4大类。<br><strong>结构性元素</strong>主要负责web上下文结构的定义：<br><code>section</code>：在 web 页面应用中，该元素也可以用于区域的章节描述。<br><code>header</code>：页面主体上的头部， header 元素往往在一对 body 元素中。<br><code>footer</code>：页面的底部（页脚），通常会标出网站的相关信息。<br><code>nav</code>：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。<br><code>article</code>：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</p>
<p><strong>级块性元素</strong>主要完成web页面区域的划分，确保内容的有效分割。<br><code>aside</code>：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。<br><code>figure</code>：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。<br><code>code</code>：表示一段代码块。<br><code>dialog</code>：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</p>
<p><strong>行内语义性元素</strong>主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。<br><code>meter</code>：表示特定范围内的数值，可用于工资、数量、百分比等。<br><code>time</code>：表示时间值。<br><code>progress</code>：用来表示进度条，可通过对其 max 、min 、step 等属性进行控制，完成对进度的表示和监事。<br><code>video</code>：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。<br><code>audio</code>：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</p>
<p><strong>交互性元素</strong>主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。<br><code>details</code>：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。<br><code>datagrid</code>：用来控制客户端数据与显示，可以由动态脚本及时更新。<br><code>menu</code>：主要用于交互菜单（曾被废弃又被重新启用的元素）。<br><code>command</code>：用来处理命令按钮。 </p>
<p><strong>移除的元素</strong><br>纯表现的元素：<code>&lt;basefont&gt;</code> 默认字体，不设置字体，以此渲染; <code>&lt;font&gt;</code> 字体标签; <code>&lt;center&gt;</code>水平居中; <code>&lt;u&gt;</code>下划线; <code>&lt;big&gt;</code> 大字体; <code>&lt;strike&gt;</code>中横线; <code>&lt;tt&gt;</code>文本等宽;<br>框架集：<code>&lt;frameset&gt;</code> <code>&lt;noframes&gt;</code> <code>&lt;frame&gt;</code> </p>
<h3 id="HTML5行内元素、块级元素、空元素"><a href="#HTML5行内元素、块级元素、空元素" class="headerlink" title="HTML5行内元素、块级元素、空元素"></a>HTML5行内元素、块级元素、空元素</h3><p><strong>行内元素</strong><br><code>a</code> - 锚点<br><code>abbr</code> - 缩写<br><code>br</code> - 换行<br><code>em</code> - 强调<br><code>strong</code> - 粗体强调<br><code>i</code> - 斜体<br><code>cite</code> - 引用<br><code>code</code> - 计算机代码 ( 在引用源码的时候需要 )<br><code>img</code> - 图片<br><code>span</code> - 常用内联容器，定义文本内区块<br><code>input</code> - 输入框<br><code>textarea</code> - 多行文本输入框<br><code>label</code> - 表格标签<br><strong>块级元素</strong><br><code>div</code> - 常用块级容易，也是 css layout 的主要标签<br><code>p</code> - 段落<br><code>h1~h6</code> - 大标题<br><code>form</code> - 交互表单<br><code>table</code> - 表格<br><code>ol</code> - 排序表单<br><code>ul</code> - 非排序列表<br><code>address</code> - 地址<br><code>blockquote</code> - 块引用<br><strong>空元素</strong><br><code>&lt;br/&gt;</code> //换行<br><code>&lt;hr&gt;</code> //分隔线<br><code>&lt;input&gt;</code> //文本框等<br><code>&lt;img&gt; &lt;link&gt; &lt;meta&gt;</code></p>
<h3 id="浏览器的内核分类"><a href="#浏览器的内核分类" class="headerlink" title="浏览器的内核分类"></a>浏览器的内核分类</h3><p>IE: Trident 内核<br>Firefox： Gecko 内核(开源)<br>Safari: Webkit 内核(开源)<br>Chrome: Webkit<br>Opera: 以前是Presto内核，现已改用Blink内核(基于Webkit, Google与Opera Software共同开发)</p>
<h3 id="对WEB标准以及W3C的理解与认识"><a href="#对WEB标准以及W3C的理解与认识" class="headerlink" title="对WEB标准以及W3C的理解与认识"></a>对WEB标准以及W3C的理解与认识</h3><p>WEB标准 不是某一个标准，而是一系列标准的集合。网页主要由三部分组成：结构（Structure）、表现（Presentation）和行为（Behavior）。对应的标准也分三方面：结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。这些标准大部分由 万维网联盟 （W3C）起草和发布，也有一些是其他标准组织制订的标准，比如ECMA（European Computer Manufacturers Association）的ECMAScript标准。<br>标签闭合、标签小写、不乱嵌套—》XHTML；<br>提高搜索机器人搜索几率–》DOM；<br>使用外 链css和 js 脚本—》结构行为表现的分离；<br>文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问；<br>容易维护、改版方便；<br>提高网站易用性。</p>
<h3 id="什么是WebGL-它有什么优点"><a href="#什么是WebGL-它有什么优点" class="headerlink" title="什么是WebGL,它有什么优点"></a>什么是WebGL,它有什么优点</h3><p>WebGL(Web Graphics Library) 是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。<br>WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。<br>WebGL完美地解决了现有的 Web 交互式三维动画的两个问题：第一，它通过HTML脚本本身实现Web交互式三维动画的制作，无需任何浏览器插件支持;第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。<br>通俗的说WebGL是canvas绘图中的3D版本。因为原生的WebGL很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于 HTML5 游戏开发。 </p>
<h3 id="cookie，sessionStorage-和-localStorage-的区别"><a href="#cookie，sessionStorage-和-localStorage-的区别" class="headerlink" title="cookie，sessionStorage 和 localStorage 的区别"></a>cookie，sessionStorage 和 localStorage 的区别</h3><p>共同点：都是保存在浏览器端，且同源的。</p>
<p>区别：</p>
<ul>
<li>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
<li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。</li>
<li>存储大小限制也不同。cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>数据有效期不同。sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li>
<li>作用域不同。sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li>
<li>WebStorage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。<br>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在web请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。<br>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的。<br>cookies 会发送到服务器端。其余两个不会。<br>Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ）；所有域名的存储量有限制（各浏览器不同，大致 4K ）； 有个数限制（各浏览器不同）；会随请求发送到服务器。<br>LocalStorage 永久存储；单个域名存储量比较大（推荐 5MB ，各浏览器不同）；总体数量无限制。<br>SessionStorage 只在 Session 内有效；存储量更大（推荐没有限制，但是实际上各浏览器也不同）。</li>
</ul>
<h3 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h3><ul>
<li>什么是 HTML 语义化<br>&lt;基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 &gt;<br>根据<strong>内容的结构化</strong>（内容语义化），选择<strong>合适的标签</strong>（代码语义化）便于<strong>开发者阅读</strong>和写出更优雅的代码的同时<strong>让浏览器的爬虫和机器很好地解析</strong>。</li>
<li>为什么要语义化<br>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；<br>用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；<br>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重；<br>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；<br>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 </li>
<li>语义化标签<br><code>&lt;header&gt;&lt;/header&gt;</code> <code>&lt;footer&gt;&lt;/footer&gt;</code> <code>&lt;nav&gt;&lt;/nav&gt;</code> <code>&lt;section&gt;&lt;/section&gt;</code><br><code>&lt;article&gt;&lt;/article&gt;</code> 用来在页面中表示一套结构完整且独立的内容部分<br><code>&lt;aside&gt;&lt;/aside&gt;</code> 主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了<br><code>&lt;figure&gt;&lt;/figure&gt;</code> 媒体元素，比如一些视频，图片等等<br><code>&lt;datalist&gt;&lt;/datalist&gt;</code> 选项列表，与 input 元素配合使用，来定义 input 可能的值<br><code>&lt;details&gt;&lt;/details&gt;</code> 用于描述文档或者文档某个部分的细节</li>
</ul>
<h3 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h3><p>HTML代码link:<br><code>&lt;link rel=&#39;stylesheet&#39; rev=&#39;stylesheet&#39; href=&#39;CSS文件 &#39; type=&#39;text/css&#39; media=&#39;all&#39; /&gt;</code></p>
<p>HTML代码@import:</p>
<pre><code>&lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt;
@import url(&apos;CSS文件 &apos;);
&lt;/style&gt; 
</code></pre><ul>
<li>首先link和import语法结构不同，前者<link>是html标签，只能放入html源代码中使用，后者可看作为css样式，作用是引入css样式功能。</li>
<li>import在html使用时候需要<code>&lt;style type=&quot;text/css&quot;&gt;</code>标签，同时可以直接<code>@import url(CSS文件路径地址)</code>放入css文件或css代码里引入其它css文件。</li>
<li>本质上两者使用选择区别不大，但为了软件中编辑布局网页html代码，一般使用link较多，也推荐使用link。</li>
</ul>
<p>两者都是外部引用CSS的方式，但是存在一定的<strong>区别：</strong><br> 区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。<br>区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。<br>区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</p>
<h3 id="对SVG的理解"><a href="#对SVG的理解" class="headerlink" title="对SVG的理解"></a>对SVG的理解</h3><p>SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是 W3C 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。<br>特点：<br> (1)任意放缩：用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。<br> (2)文本独立：SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。<br> (3)较小文件： 总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。<br> (4)超强显示效果：SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。<br> (5)超级颜色控制：SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。<br> (6)交互 X 和智能化：SVG面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。<br>  Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的</p>
<h3 id="HTML全局属性-global-attribute-有哪些"><a href="#HTML全局属性-global-attribute-有哪些" class="headerlink" title="HTML全局属性(global attribute)有哪些"></a>HTML全局属性(global attribute)有哪些</h3><p>参考<a href="http://www.w3school.com.cn/tags/html_ref_standardattributes.asp" target="_blank" rel="external">HTML 全局属性</a>。例如<code>class</code>, <code>id</code>, <code>style</code>, <code>title</code>, <code>lang</code>等等。</p>
<h3 id="超链接target属性的取值和作用"><a href="#超链接target属性的取值和作用" class="headerlink" title="超链接target属性的取值和作用"></a>超链接target属性的取值和作用</h3><p>target属性指定所链接的页面在浏览器窗口中的打开方式。<br>参数值主要有：<br>_blank ：浏览器总在一个新打开、未命名的窗口中载入目标文档。<br>_parent ：在父框架集中打开被链接文档。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。<br>_self ：默认。在相同的框架中打开被链接文档。<br>_top ： 在整个窗口中打开被链接文档。这个目标使得文档载入包含这个超链接的窗口，用 _top 目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。<br>framename：在指定的框架中打开被链接文档。</p>
<h3 id="data-属性的作用"><a href="#data-属性的作用" class="headerlink" title="data- 属性的作用"></a>data- 属性的作用</h3><p>data-<em> 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。<br>data-</em> 属性用于存储页面或应用程序的私有自定义数据。<br>存储的（自定义）数据能够被页面的 JavaScript利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。</p>
<p><code>data-</code>为HTML5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 <code>dataset</code> 属性获取，不支持该属性的浏览器可以通过 <code>getAttribute</code> 方法获取：<br>需要注意的是：<code>data-</code>之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 所有主流浏览器都支持 data-* 属性。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 </p>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。<br><strong>渲染引擎：</strong>负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。<br>浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。<br><strong>JS引擎：</strong> 解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="iframe的缺点"><a href="#iframe的缺点" class="headerlink" title="iframe的缺点"></a>iframe的缺点</h3><ul>
<li>iframe会阻塞主页面的 Onload 事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO;</li>
<li>iframe和主页面共享<a href="blog.csdn.net/u012152619/article/details/46287419">连接池</a>，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li>
</ul>
<p>如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 </p>
<p>历史上，iframe 常被用于复用部分界面，但是多数情况下并不合适。<br>现在，应该使用 iframe 的例子如：</p>
<ol>
<li>沙箱隔离。参考 <a href="https://www.imooc.com/article/17353" target="_blank" rel="external">写js沙箱原来如此简单</a></li>
<li>引用第三方内容。</li>
<li>独立的带有交互的内容，比如幻灯片。</li>
<li>需要保持独立焦点和历史管理的子窗口，如复杂的Web应用。</li>
</ol>
<p>使用 iframe 是不是一个好的用法（good practice），不能一概而论，但是可以肯定是，现在的大部分网站避免采用这种方式的。<br>比较早期的网站使用iframe，主要是用于导航栏（navigator）。因为一个网站很多页面的导航栏部分是相同的，在避免切换页面的时候重复下载，将导航栏和正文分开在 iframe 中，是一个方便的做法。同时带来的不利是，默认情况下，使用了 iframe 的网站的URL不会随着页面的变化而变化。这就意味着一旦刷新，网站可能又回到首页。那么现在的网站是如何解决不同页面使用相同的 navigator 而避免重复编码呢？不同后台技术都有自己的方法，比如 ASP 有 SSI，PHP 有 require、require_once 或 include 函数，JSP 也有 include 指令。<br>iframe 一直是浏览器标准规范之一，只有很早期的浏览器不支持 iframe，现在几乎已绝迹。所以从兼容性上来说，iframe 是没问题的。<br>那么现在什么时候会用到 iframe 呢？<br>因为 iframe 的页面和父页面（parent）是分开的，所以它意味着，这是一个独立的区域，不受 parent 的 CSS 或者全局的 JavaScript 的影响。<br>典型的，比如所见即所得的网页编辑器（WYSIWYG Online HTML Editor），因为它们需要 reset 自己的 CSS 到自己的标准，而不被 parent CSS 的 override。 顺便说一下，知乎的这个编辑器不是用 iframe，它使用了一种叫 contentEditable 的属性，用来启用页面元素的编辑，在早期版本 IE 下不支持的。<br>正是因为刚刚提到的 iframe 等于新建了一个全新的，不受 parent 影响的页面上下文，所以在一定程度上，类似于沙箱隔离（sandbox）。除此之外，如果有可以不用 iframe 来解决的问题，还是避免使用 iframe。替代方案一般就是动态语言的 include 机制、ajax 动态填充内容，以及以后会普及的 <a href="http://www.w3school.com.cn/html5/att_global_contenteditable.asp" target="_blank" rel="external">contentEditable</a>。</p>
<h3 id="label标签的作用"><a href="#label标签的作用" class="headerlink" title="label标签的作用"></a>label标签的作用</h3><p>对鼠标用户而言增进了可用性。<br>label标签用来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p>
<pre><code>&lt;label for=&apos;Name&apos;&gt;Number:&lt;/label&gt;
&lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;Name&quot;/&gt;
</code></pre><p>注意:label的for属性值要与后面对应的input标签id属性值相同。</p>
<h3 id="浏览器内多个标签页之间的通信"><a href="#浏览器内多个标签页之间的通信" class="headerlink" title="浏览器内多个标签页之间的通信"></a>浏览器内多个标签页之间的通信</h3><p>调用localstorge、cookies等本地存储方式。<br>方法一：localstorge在一个标签页里被添加、修改或删除时，都会触发一个storage事件，通过在另一个标签页里监听storage事件，即可得到localstorge存储的值，实现不同标签页之间的通信。例如<br>标签页1：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
            localStorage.setItem(&quot;name&quot;, name);   
        });    
    });    
&lt;/script&gt;  
</code></pre><p>标签页2：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
            localStorage.setItem(&quot;name&quot;, name);   
        });    
    });    
&lt;/script&gt;  
</code></pre><p>方法二：使用cookie+setInterval，将要传递的信息存储在cookie中，每隔一定时间读取cookie信息，即可随时获取要传递的信息。<br>标签页1：</p>
<pre><code>&lt;input id=&quot;name&quot;&gt;  
&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;  
&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){    
        $(&quot;#btn&quot;).click(function(){    
            var name=$(&quot;#name&quot;).val();    
         document.cookie=&quot;name=&quot;+name;    
        });    
    });    
&lt;/script&gt;
</code></pre><p>标签页2：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;  
    $(function(){   
        function getCookie(key) {    
            return JSON.parse(&quot;{\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;}&quot;)[key];    
        }     
        setInterval(function(){    
            console.log(&quot;name=&quot; + getCookie(&quot;name&quot;));    
        }, 10000);    
    });  
&lt;/script&gt; 
</code></pre><h3 id="在页面上实现一个圆形的可点击区域"><a href="#在页面上实现一个圆形的可点击区域" class="headerlink" title="在页面上实现一个圆形的可点击区域"></a>在页面上实现一个圆形的可点击区域</h3><p>第一种 使用image map</p>
<pre><code>&lt;img id=&quot;blue&quot; class=&quot;click-area&quot; src=&quot;blue.gif&quot; usemap=&quot;#Map&quot; /&gt; 
&lt;map name=&quot;Map&quot; id=&quot;Map&quot; class=&quot;click-area&quot;&gt;
    &lt;area shape=&quot;circle&quot; coords=&quot;50,50,50&quot;/&gt;
&lt;/map&gt;
#blue{
    cursor:pointer;
    width:100px;
    height:100px;
</code></pre><p>}<br>第二种 使用CSS border-radius</p>
<pre><code>&lt;div id=&quot;red&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt;
#red{  
 cursor:pointer;
 background:red;  
 width:100px;  
 height:100px;  
 border-radius:50%;  
} 
</code></pre><p>第三种 使用js检测鼠标位置,获取鼠标点击位置坐标，判断其到圆点的距离是否不大于圆的半径，来判断点击位置是否在圆内。</p>
<pre><code>&lt;div id=&quot;yellow&quot; class=&quot;click-area&quot; &gt;&lt;/div&gt;
$(&quot;#yellow&quot;).on(&apos;click&apos;,function(e) {    
  var r = 50; 
  var x1 = $(this).offset().left+$(this).width()/2;            
  var y1 = $(this).offset().top+$(this).height()/2;   
  var x2= e.clientX;  
  var y2= e.clientY;    
  var distance = Math.abs(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));    
  if (distance &lt;= 50)  
    alert(&quot;Yes!&quot;);    
}); 
</code></pre><h3 id="title与h3、b与strong、及i与em的区别"><a href="#title与h3、b与strong、及i与em的区别" class="headerlink" title="title与h3、b与strong、及i与em的区别"></a>title与h3、b与strong、及i与em的区别</h3><p><code>&lt;strong&gt;</code> 表示html页面上的强调（emphasized text）， <code>&lt;em&gt;</code> 表示句子中的强调（即强调语义）<br><strong>1.b和strong的区别</strong><br>盲人朋友使用阅读设备阅读网络时：<code>&lt;strong&gt;</code>会重读，<code>&lt;b&gt;</code>不会。两者虽然在网页中显示效果一样，但实际目的不同。<br><code>&lt;b&gt;</code>这个标签对应 bold，即文本加粗，其目的仅仅是为了加粗显示文本，是一种样式／风格需求；<code>&lt;strong&gt;</code>这个标签意思是加强字符的语气，表示该文本比较重要，提醒读者／终端注意。为了达到这个目的，浏览器等终端将其加粗显示；<br>总结：<code>&lt;b&gt;</code>为了加粗而加粗，<code>&lt;strong&gt;</code>为了标明重点而加粗，也可以用其它方式来强调，比如下划线，比如字体加大，比如红色，等等，可以通过css来改变strong的具体表现。<br><strong>2.i和em的区别</strong><br>同样，I是Italic(斜体)，而em是emphasize(强调)。<br><strong>3.title与h1的联系与区别：</strong><br>从网站角度看，title更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。<br>从文章角度看，h1则是用于概括文章主题。用户进入内容页，想看到的当然就是文章的内容，h1文章标题就是最重要的。文章标题最好只有一个，多个h1会导致搜索引擎不知道这个页面哪个标题内容最重要，导致淡化这个页面的标题和关键词，起不到突出主题的效果。<br>区别：<br>h1突出文章主题，面对用户，更突出其视觉效果，突出网站标题或关键字用title。一篇文章，一个页面最好只用一个h1，多个h1会稀释主题。一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。</p>
<h3 id="不使用border画出1px高的线，考虑兼容性"><a href="#不使用border画出1px高的线，考虑兼容性" class="headerlink" title="不使用border画出1px高的线，考虑兼容性"></a>不使用border画出1px高的线，考虑兼容性</h3><p>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？ </p>
<pre><code>&lt;div style=&quot;width:100%;height:1px;background-color:black&quot;&gt;&lt;/div&gt;
</code></pre><h3 id="src属性与href属性的区别"><a href="#src属性与href属性的区别" class="headerlink" title="src属性与href属性的区别"></a>src属性与href属性的区别</h3><p>src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。<br>src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。<br><code>&lt;script src =&#39;js.js&#39;&gt;&lt;/script&gt;</code>，当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br> href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，如果我们在文档中添加<code>&lt;link href=&#39;common.css&#39; rel=&#39;stylesheet&#39;/&gt;</code>，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 </p>
<h3 id="对canvas的理解"><a href="#对canvas的理解" class="headerlink" title="对canvas的理解"></a>对canvas的理解</h3><p>canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。canvas标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。</p>
<h3 id="WebSocket与消息推送"><a href="#WebSocket与消息推送" class="headerlink" title="WebSocket与消息推送"></a>WebSocket与消息推送</h3><p>B/S架构的系统多使用HTTP协议。<br><strong>HTTP协议的特点：</strong> 1 无状态协议； 2 用于通过 Internet 发送请求消息和响应消息； 3 使用端口接收和发送消息，默认为80端口； 4 底层通信还是使用Socket<br><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484203855304_198713B681803E835F62D3D3E22D5BBB" alt="HTTP协议请求响应"><br>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏） , 一些变相的解决办法实现 双向通信与消息推送 ：<br><strong>轮询：</strong> 客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用<br><strong>长轮询：</strong> 客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求，耗费资小。<br>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，<br>实例：WebQQ、 Hi 网页版、 Facebook IM<br><strong>长连接：</strong> 在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求；管理起来也相对便。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天<br><strong>Flash Socket：</strong> 在页面中内嵌入一个使用了 Socket 类的 Flash 程序， JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。<br>优点：实现真正的即时通信，而不是伪即时。<br>缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。<br>实例：网络互动游戏。<br><strong>Websocket:</strong><br>WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。<br>特点:事件驱动；异步；使用 ws 或者 wss 协议的客户端 socket；能够实现真正意义上的推送功能<br>缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别<br><strong>参考文章：</strong><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="external">WebSocket 教程-阮一峰</a><br><a href="https://www.cnblogs.com/myzhibie/p/4470065.html" target="_blank" rel="external">html5-websocket初探</a></p>
<h3 id="img的title和alt的区别"><a href="#img的title和alt的区别" class="headerlink" title="img的title和alt的区别"></a>img的title和alt的区别</h3><p>alt 是给搜索引擎识别，在图像无法显示时的替代文本； alt属性有利于SEO，是搜索引擎搜录时判断图片与文字是否相关的重要依据。<br>title 是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。<br>参考文章：<a href="http://blog.csdn.net/playkid123/article/details/44562235" target="_blank" rel="external">img图片标签alt和title属性的区别</a></p>
<h3 id="表单的基本组成"><a href="#表单的基本组成" class="headerlink" title="表单的基本组成"></a>表单的基本组成</h3><p>组成：表单标签、表单域、表单按钮。<br> a、表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。<br>b、表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。<br>c、表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。<br>主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 </p>
<pre><code>&lt;form action=&quot;#&quot; method=&quot;post&quot; id=&quot;regForm&quot;&gt;  
    &lt;fieldset&gt;  
        &lt;legend&gt;个人基本信息&lt;/legend&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;userName&quot;&gt;名称：&lt;/label&gt;  
            &lt;input id=&quot;useName&quot; type=&quot;text&quot; /&gt;  
        &lt;/div&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;passWord&quot;&gt;密码：&lt;/label&gt;  
            &lt;input id=&quot;passWord&quot; type=&quot;password&quot; /&gt;  
        &lt;/div&gt;  
        &lt;div&gt;  
            &lt;label for=&quot;msg&quot;&gt;详细信息：&lt;/label&gt;  
            &lt;textarea id=&quot;msg&quot;&gt;&lt;/textarea&gt;  
         &lt;/div&gt;  
    &lt;/fieldset&gt;  
&lt;/form&gt; 
</code></pre><p><strong>form标签：</strong> <code>&lt;form action=&quot;表单提交的地址&quot;   method=&quot;表单提交的方法&quot;   id=&quot;&quot;  class=&quot;&quot;&gt;</code><br><strong>fieldset标签：</strong>作用是将表单内相关元素分组；将表单内容的一部分打包，生成一组表单的字段;在一个form表单中，可以有一个或者多个fielset标签。<br><strong>legend标签：</strong> 作用是为fieldset标签定义标题。<br><strong>label标签：</strong> 该标签在页面中使用不会为用户呈现任何特殊效果，但是却可以很好地为鼠标用户改进了可用性。其作用是为input元素定义标注，要注意的是label中的for属性应与input中的id属性一致，如上述代码所示。<br><strong>input标签：</strong> 输入框，其中可以根据type的属性值改变输入框的作用。例如：<code>&lt;input  type=&quot;text&quot;/&gt;</code> 是文本框，还可以是密码输入框、复选框、单选框等等。</p>
<h3 id="表单提交中Get和Post方式的区别"><a href="#表单提交中Get和Post方式的区别" class="headerlink" title="表单提交中Get和Post方式的区别"></a>表单提交中Get和Post方式的区别</h3><p><strong>原理性区别：</strong></p>
<ol>
<li>Http 定义的与服务器交互的四种基本方法，增删改查（ put delete post get ）；从定义而言 get 用于信息获取（状态不做迁移），而且是安全幂等的（不修改信息、同一 url 多次请求结果一致），但有时候并不严格遵循规定，比如腾讯新闻的刷新操作，因为从 server端来讲，数据状态并没有发生任何改变 ，所以也可以算成是幂等； post 可以修改服务器上的资源请求（资源的状态迁移），比如新闻评论的提交，提交前后资源被修改了。</li>
<li>关于幂等与否只是 http 的规定，实际中要看服务器端怎么写。<br><strong>表象上的区别：</strong></li>
<li>提交的安全性不同： Get 将表单中的数据按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用”? “连接，而各个变量之间使用”&amp;”连接（明文提交）； Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL （依照表单提交）。</li>
<li>Get 传输的数据量小（ 1024 字节），这主要是因为受 URL 长度限制； URL 长度在 http 协议中没有限制，只是 IE 对 URL 有长度限制，其他浏览器取决于操作系统，理论上没有限制。 Post 可以传输大量的数据（ 2M ），理论上 http 没有限制数据量长度，服务器处理程序的处理能力限制了表单域长度，而有限制</li>
<li>Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</li>
<li>传输信息所在 http 中的位置不同： Post 的信息作为 http 请求的内容，而 Get 是在 Http 头部传输的， get 请求可以有 body 但大多数服务器不会解析 get 请求的 body 。</li>
</ol>
<p>(1)、 get 是从服务器上获取数据， post 是向服务器传送数据。<br>(2)、 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。<br>(3)、对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。<br>(4)、 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。<br>(5)、 get 安全性低， post 安全性较高。</p>
<h3 id="关于HTML5标签的几个知识点"><a href="#关于HTML5标签的几个知识点" class="headerlink" title="关于HTML5标签的几个知识点"></a>关于HTML5标签的几个知识点</h3><p><strong><a href="http://www.w3school.com.cn/html5/html_5_form_elements.asp" target="_blank" rel="external">HTML5新增的表单元素：</a></strong><br><code>datalist</code> 元素：<br>datalist 元素规定输入域的选项列表；<br>列表是通过 datalist 内的 option 元素创建的,option 元素永远都要设置 value 属性；<br>如需把 datalist 绑定到输入域，请用输入域的 list 属性引用 datalist 的 id。<br><code>keygen</code> 元素:<br>keygen 元素的作用是提供一种验证用户的可靠方法;<br>keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。<br>目前，浏览器对此元素的糟糕的支持度不足以使其成为一种有用的安全标准。<br><code>output</code> 元素:<br>output 元素用于不同类型的输出，比如计算或脚本输出。<br><strong><a href="http://yanue.net/post-106.html" target="_blank" rel="external">HTML5废弃的标签：</a></strong><br>第一类：表现性元素<br><code>basefont</code> <code>big</code> <code>center</code> <code>font</code> <code>s</code> <code>strike</code> <code>tt</code> <code>u</code>等。<br>建议用语义正确的元素代替他们，并使用CSS来确保渲染后的效果<br>第二类：框架类元素<br>因框架有很多可用性及可访问性问题，HTML5规范将以下元素移除:<br><code>frame</code> <code>frameset</code> <code>noframes</code><br>但html5支持iframe。<br>第三类：属性类<br>很多表现性的属性也被新规范移除，如下：<br>align<br>body标签上的link、vlink、alink、text属性<br>bgcolor<br>height和width<br>iframe元素上的scrolling属性<br>valign<br>hspace和vspace<br>table标签上的cellpadding、cellspacing和border属性<br>header标签上的profile属性<br>img和iframe元素的longdesc属性<br>第四类：其他<br>abbr取代acronym（用于表示缩写）<br>object取代了applet<br>ul取代了dir<br><strong><a href="https://www.cnblogs.com/oneplace/p/5616197.html" target="_blank" rel="external">HTML5 标准提供的新API</a></strong><br>Media API：例如video audio,Using the Camera API<br>Text Track API: textTracks属性;返回代表可用文本字幕的TextTrackList对象<br>Application Cache API： 应用程序缓存<br>User Interaction ：新增的语义化元素，output元素等<br>Data Transfer API ：webSocket<br>Command API<br>Constraint Validation API<br>History API : session localStorage cookie<br><strong>HTML5 存储类型有什么区别</strong><br>HTML5 能够本地存储数据，在之前都是使用 cookie。 HTML5  提供了下面两种本地存储方案：<br>localStorage  用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。<br> sessionStorage  同一个会话中的页面才能访问并且当会话结束后数据也随之销毁，因此它不是一种持久化的本地存储，仅仅是会话级别的存储</p>
<p>cookies,seesionStorage,localStorage区别：<br>共同点：都是保存到浏览器端，都是同源。<br>区别：cookies会发给服务器。其他两个不会，只在本地保存，而且比cookie存储空间要大。seesionStroage,在窗口关闭前有效，不在不同浏览器窗口共享。 localStroage,始终有效，永久数据，所有同源窗口共享。 cookie:在过期前有效，所有同源窗口共享 。<br><strong><a href="https://www.cnblogs.com/xjchenhao/p/4032224.html" target="_blank" rel="external">HTML5 应用程序缓存和浏览器缓存的区别</a></strong><br>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。<br>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。<br>应用程序缓存为应用带来三个优势：离线浏览 - 用户可在应用离线时使用它们；<br>速度 - 已缓存资源加载得更快；减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</p>
<p>应用程序缓存是 HTML5  的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：</p>
<pre><code>&lt;!doctype html&gt;
&lt;html manifest=”example.appcache”&gt;
…..
&lt;/html&gt;
</code></pre><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。<br><strong>除了 audio 和 video，HTML5 还有哪些媒体标签</strong><br><code>&lt;embed&gt;</code> 标签，定义嵌入的内容，比如插件。</p>
<pre><code>&lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt;
</code></pre><p><code>&lt;source&gt;</code> 标签，对于定义多个数据源很有用。</p>
<pre><code> &lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
     &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
     &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt;
&lt;/video&gt;
</code></pre><p><code>&lt;track&gt;</code>标签，为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。</p>
<pre><code> &lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
     &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
     &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt;
     &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt;
      &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt;
&lt;/video&gt; 
</code></pre><p><strong>HTML5 中如何嵌入视频</strong><br>和音频类似，HTML5 支持 MP4 、WebM 和 Ogg 格式的视频，通过video标签嵌入视频，下面是简单示例：</p>
<pre><code>&lt;video width=” 450 ″ height= ” 340 ″ controls&gt;
  &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt;
   Your browser does’ nt support video embedding feature.
&lt;/video&gt;
</code></pre><p><strong>HTML5 中如何嵌入音频</strong><br>HTML5 支持 MP3 、Wav 和 Ogg 格式的音频，通过audio标签嵌入音频，示例如下：</p>
<pre><code>&lt;audio controls&gt;
    &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt;
    Your browser does’ nt support audio embedding feature.
&lt;/audio&gt;
</code></pre><p><strong>新的 HTML5 文档类型和字符集是什么</strong><br>HTML5 文档类型：<code>&lt;!doctype html&gt;</code><br>HTML5 使用 UTF-8 编码: <code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code> </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自牛客网&lt;a href=&quot;https://www.nowcoder.com/ta/review-frontend?query=&amp;amp;asc=true&amp;amp;order=&amp;amp;page=1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端面试常考知识点 HTML+CSS&lt;/a&gt; 篇学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="interview questions" scheme="http://yoursite.com/categories/interview-questions/"/>
    
    
      <category term="interview questions" scheme="http://yoursite.com/tags/interview-questions/"/>
    
  </entry>
  
  <entry>
    <title>在两台电脑上更新维护github pages + hexo博客</title>
    <link href="http://yoursite.com/2018/01/07/maintain%20github%20blog%20on%20two%20computer/"/>
    <id>http://yoursite.com/2018/01/07/maintain github blog on two computer/</id>
    <published>2018-01-07T13:10:12.000Z</published>
    <updated>2018-01-09T02:47:03.126Z</updated>
    
    <content type="html"><![CDATA[<p>之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。</p>
<a id="more"></a>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>主要思路利用git分支实现。利用Hexo框架生成的静态博客文件默认放在博客repo的master分支，即台式机上初次搭建好的本地博客环境Hexo文件夹下的public文件夹的内容对应github上博客repo的master分支内容。现在我们需要在博客repo新建一个hexo分支，用来放Hexo源文件，即放台式机上Hexo文件夹下的全部文件，而不只是public文件夹（public用来存放静态网站文件）。</p>
<p>现在我们的博客repo即xxxx.github.io这个仓库有了两个分支，一个master分支用来放Hexo生成的静态网站，一个hexo分支放Hexo的源文件。相当于用hexo分支备份了之前台式机上本地的Hexo环境，在笔记本上将hexo分支clone下来，然后写文章、更新博客到hexo分支（<code>git push</code>到hexo分支，使得备份源文件最新），保证hexo分支的内容最新，然后执行<code>hexo g -d</code>命令，生成的静态文件会被默认push到master分支，更新博客站点内容。</p>
<p>下面来叙述一下具体的操作步骤。</p>
<h2 id="原来台式机上的操作"><a href="#原来台式机上的操作" class="headerlink" title="原来台式机上的操作"></a>原来台式机上的操作</h2><ul>
<li>在Github的xxx.github.io仓库上新建一个hexo分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为hexo（之前的默认分支是master），save保存。</li>
</ul>
<ul>
<li>然后将该仓库克隆到本地，进入该xxx.github.io文件目录。在当前目录使用Git Bash，执行<code>git branch</code>命令查看当前文件夹下内容所在的分支，查询结果应为新建的分支hexo。</li>
</ul>
<ul>
<li>接下来，将本地博客的部署文件（<strong>Hexo目录下的全部文件</strong>，即Hexo源文件）全部拷贝进xxx.github.io文件目录中去。最后将xxx.github.io目录下的全部文件push到hexo分支，即完成了Hexo源文件的备份过程。</li>
</ul>
<p><strong>注意：</strong>将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。可能有人会问，删除了themes目录中的.git不就不能<code>git pull</code>更新主题了吗，很简单，需要更新主题时在另一个地方<code>git clone</code>下来该主题的最新版本，然后将内容拷到当前主题目录即可。</p>
<p>上面的注意点中的情形我没有遇到，直接把本地Hexo文件夹下的全部内容复制到新clone下来的xxx.github.io文件夹下，然后通过git命令push到博客repo的hexo分支。</p>
<p><strong>push到hexo分支的git命令介绍:</strong><code>git status</code>可以查看当前目录下哪些文件被改动过了，被改动过但还未被git管理的显示红色，被改动过但已经add添加到暂存区的显示绿色；<code>git add .</code>可以将当前目录下的全部改动文件添加到暂存区，以待被提交；<code>git commit -m &quot;back up hexo files&quot;</code>将暂存区的内容提交至HEAD，以待被push到远端；<code>git push</code>将HEAD内容push到远端github博客仓库的hexo分支。至此完成了台式机本地Hexo源文件备份到xxx.github.io仓库的hexo分支。</p>
<h2 id="新的笔记本上的操作"><a href="#新的笔记本上的操作" class="headerlink" title="新的笔记本上的操作"></a>新的笔记本上的操作</h2><p>由于上面过程已经完成了原来电脑上本地Hexo源文件的备份，所以博客现在可以在其他电脑上维护和更新了。</p>
<p>由于笔记本上没有安装node.js、git等，所以需要像初次搭建博客那样，先安装配置好环境。参考之前的文章<a href="http://shirley5li.me/2017/08/06/hello-world/" target="_blank" rel="external">基于hexo和github搭建个人博客概述</a>，先下载安装node.js，下载安装git。（如果电脑有这两个工具可以忽略这一步）</p>
<ul>
<li><p>将新电脑即笔记本生成的ssh key添加到GitHub账户上（因为通过SSH url方式，使用git客户端第一次git clone github.com代码需要验证ssh key），具体的添加SSH key方法参考<a href="http://blog.csdn.net/binyao02123202/article/details/20130891" target="_blank" rel="external">github设置添加SSH</a>。</p>
</li>
<li><p>在笔记本上克隆xxx.github.io仓库的hexo分支到本地，此时本地git仓库处于hexo分支，使用<code>git branch</code>命令查看。</p>
</li>
</ul>
<ul>
<li>切换到xxx.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录，所以需要install下)。</li>
</ul>
<p>另外可以看到仓库hexo分支themes/next主题文件夹是空的，所以clone到本地的next主题文件夹也是空的（原因还没搞清楚，为什么备份的时候单单next主题文件夹push不上去），所以只好将台式机上的next主题文件夹拷贝一份到笔记本上，替换clone下来的空next主题文件夹。这个地方算是遇到的一个坑，因为本地测试的时候提示无法渲染index.html，搜索了原因有人回答是不是主题文件没有，这才发现next文件夹是空的。</p>
<p>还有就是，由于还需要Hexo框架帮我们生成静态网站并push到master分支，而此时你有没有发现我们还忘记装Hexo了，没装Hexo我们怎么能用<code>hexo g -d</code>这样的命令呢。所以最后一步，把Hexo装上。Hexo的下载安装同样参考之前的博客<a href="http://shirley5li.me/2017/08/06/hello-world/" target="_blank" rel="external">基于hexo和github搭建个人博客概述</a>。之前我以为备份好Hexo源文件，再clone下来就自带Hexo环境，可以执行<code>hexo g</code>这样命令，我参考的那篇博文也没重装Hexo这一步，但当我试着写了文章执行本地<code>hexo s</code>测试时，提示找不到<code>hexo</code>这样的命令，然后我照初次搭建博客那样<code>$ npm install hexo --save</code>，又装了一下Hexo，就可以执行<code>hexo s</code>命令了，并测试了一下正确。</p>
<p>至此就可以在笔记本上写博客了。</p>
<p>在xxx.github.io目录下，执行<code>hexo new post &quot;the first post on laptop&quot;</code>，可以新建一篇文章，然后编辑撰写，或者改动以前的文章。</p>
<ul>
<li><p>然后用执行<code>git status</code>可以查看当前目录下哪些文件被改动过了，即新写的文章、添加的文件、修改的文件等；执行<code>git add .</code>将当前目录下的全部改动文件添加到暂存区，以待被提交；执行<code>git commit -m &quot;back up hexo files&quot;</code>将暂存区的内容提交至HEAD，以待被push到远端；执行<code>git push</code>将HEAD内容push到远端github博客仓库的hexo分支。至此完成了笔记本本地Hexo源文件备份到xxx.github.io仓库的hexo分支的过程，即不管是在台式机操作还是在笔记本操作，都要保证hexo分支的内容是最新的。</p>
</li>
<li><p>最后执行<code>hexo g -d</code>命令，即将本地编辑好的.md形式的文件生成静态博客文件并push到博客repo的master分支，这一步完成了博客站点的更新。</p>
</li>
</ul>
<h2 id="再回到台式机上更新博客时的操作"><a href="#再回到台式机上更新博客时的操作" class="headerlink" title="再回到台式机上更新博客时的操作"></a>再回到台式机上更新博客时的操作</h2><p><strong>注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先执行<code>git pull hexo</code>命令</strong>，即将远端最新的hexo分支拉到本地，使本地与远端达到同步。</p>
<p>另外看到一篇讲解<a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="external">Hexo的版本控制与持续集成</a>的文章，将本地push到hexo分支和利用hexo部署博客静态文件到master分支的两个步骤合二为一，使用GitHub进行版本控制，又能做到一键发布。即用到了持续集成，也就是用CI来完成一键发布：当有新的change push到Source Repo时，自动执行CI脚本，生成最新的静态网站发布到Content Repo。自己还没有实际操作过，等操作过后再作总结。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="external">利用Hexo在多台电脑上提交和更新github pages博客</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在台式机上通过GitHub pages 和Hexo搭建了静态博客，一直用台式机写文章更新博客，这几天想着是不是也可以用笔记本写文章维护下博客，毕竟笔记本带着方便啊。于是就看了一些博客，尝试着在笔记本上实现跟台式机一样的发博客过程，也遇到了一些问题，特将过程总结下来。这篇文章即在笔记本上完成的。&lt;/p&gt;
    
    </summary>
    
      <category term="github pages" scheme="http://yoursite.com/categories/github-pages/"/>
    
    
      <category term="github pages" scheme="http://yoursite.com/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画简介</title>
    <link href="http://yoursite.com/2018/01/03/CSS%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/01/03/CSS动画简介/</id>
    <published>2018-01-03T01:53:24.000Z</published>
    <updated>2018-01-09T02:47:02.933Z</updated>
    
    <content type="html"><![CDATA[<p>来自于NEXT十天训练营CSS篇关于动画的笔记。<br><a id="more"></a></p>
<h2 id="CSS动画分类"><a href="#CSS动画分类" class="headerlink" title="CSS动画分类"></a>CSS动画分类</h2><p>CSS动画主要有两类，即<strong>补间动画和帧动画</strong>。</p>
<p>补间动画只需定义一个开始状态和结束状态，其余中间状态由浏览器自动填充，使用transition属性实现。</p>
<p>帧动画不只要定义开始和结束状态，还需要定义中间过程的帧，使用animation属性实现。</p>
<p><img src="/images/CSS动画简介/1.png" alt="1"> <img src="/images/CSS动画简介/2.png" alt="2"></p>
<h2 id="transition动画"><a href="#transition动画" class="headerlink" title="transition动画"></a>transition动画</h2><p>transition动画只需定义动画的开始和结束状态，其余过渡状态由浏览器自动补全。示例代码如下：</p>
<p>HTML结构：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS样式：</p>
<pre><code>.box {
    width: 600px;
    height: 200px;
    border: 1px solid #ccc;
    background-color: #fff;
    margin: 200px auto;
}
.circle {
    width: 50px;
    height: 50px;
    /*定义开始状态小球的颜色和位置*/
    background-color: blue;
    border-radius: 50%;
    margin: 75px 0;
    /*注意transition有多个属性，此处为简写新形式，包括了两个属性*/
    /*即transition-property: all; transition-duration: 2s;*/

    /*transition-property设置过渡效果的CSS属性的名称*/
    /*transtion-property的值为all，表示background-color和transform都是过渡渐变属性，*/

    /*若此处transtion-property值为background-color，而transform不变，则只过渡渐变颜色，位置瞬移*/
    transition: all 2s;
}
/*定义结束状态小球的位置和颜色*/
.box:hover .circle {
    background-color: red;
    transform: translate(550px, 0);
}
</code></pre><p>实例效果见<a href="https://codepen.io/shirley5li/full/wpeLmw/" target="_blank" rel="external">codepen</a>。transition共有如下四个属性。</p>
<p><img src="/images/CSS动画简介/3.png" alt="3"></p>
<p>另外transition-property不支持动画的一些属性如下：</p>
<p><img src="/images/CSS动画简介/4.png" alt="4"></p>
<p>不支持将a图片过渡渐变为b图片；不支持float属性（即float属性从无到有）；不支持将width/height属性从无渐变为某个值，但支持从一个长度渐变为另一个长度；不支持display属性从无到有；不支持visibility属性；不支持poisition属性。</p>
<h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>animation动画通过关键帧来定义动画的变化状态。示例代码如下：</p>
<p>HTML结构：</p>
<pre><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre><p>CSS样式：</p>
<pre><code>.circle {
    width: 50px;
    height: 50px;
    background-color: blue;
    border-radius: 50%;
    margin: 75px 0;
    /*animation: circleRun 2s ease infinite;*/
    /*animation也是一个简写属性，即上一句包括如下属性*/
    animation-name: circleRun;
    animation-duration: 2s;
    animation-timing-function: ease;
    animation-iteration-count: infinite;
    /*此外animation还有如下几个属性*/
    animation-delay: 2s;
    animation-direction: normal;
    animation-fill-mode: none;
    animation-play-state: running;
}
/*定义中间状态小球的关键帧*/
@keyframes circleRun {
    from {
        transform: translate(0, 75px);
    }
    33% {
        transform: translate(150px, 75px);
    }
    66% {
        transform: translate(400px, -75px);
    }
    to {
        transform: translate(550px, 0);
        background-color: red;
    }
}
</code></pre><p>实例效果见<a href="https://codepen.io/shirley5li/full/baRXbE/" target="_blank" rel="external">codepen</a>。</p>
<p>使用animation实现页面正在loading的效果见<a href="https://codepen.io/shirley5li/full/dJRxzB/" target="_blank" rel="external">codepen demo-animationLoading</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自于NEXT十天训练营CSS篇关于动画的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>关于CSS几种布局方式的学习总结</title>
    <link href="http://yoursite.com/2018/01/02/CSS-layout/"/>
    <id>http://yoursite.com/2018/01/02/CSS-layout/</id>
    <published>2018-01-02T06:05:23.000Z</published>
    <updated>2018-01-09T02:47:02.933Z</updated>
    
    <content type="html"><![CDATA[<p>学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自<a href="http://www.sohu.com/a/168143624_274163" target="_blank" rel="external">CSS 常见布局方式 </a>。<br><a id="more"></a><br>CSS几种常见的布局方式如下图总结。</p>
<p><img src="/images/CSS-layout/1.jpeg" alt="1"></p>
<h2 id="传统盒模型布局方式"><a href="#传统盒模型布局方式" class="headerlink" title="传统盒模型布局方式"></a>传统盒模型布局方式</h2><p>传统布局方式就是通过盒模型，使用 display属性（文档流布局） + position属性（定位布局） + float属性（浮动布局）。</p>
<h3 id="文档流布局"><a href="#文档流布局" class="headerlink" title="文档流布局"></a>文档流布局</h3><p>最基本的布局方式，就是按照文档的顺序一个一个显示出来，块元素独占一行，行内元素共享一行。</p>
<h3 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h3><p>通过 <strong>position属性</strong>来进行定位。该属性有四种不同类型的定位，分别为static（默认定位）、relative（相对定位）、absolute（绝对定位）和fixed（固定定位）。</p>
<p><strong>static：</strong>若某元素的position属性的是默认static，那这个元素就在文档流中。</p>
<p><strong>relative：</strong>设置为相对定位的元素<strong>不脱离文档流</strong>，参考自身的位置通过top、bottom、left和right进行定位，让这个元素以自身原来的位置为基准进行移动，<strong>元素仍然保持其未定位前的形状，它原本所占的空间仍然保留</strong>（因为它没有脱离文档流）。因此，采用相对定位的元素有可能覆盖了其他元素，因为它其实占据了两个位置，一个是移动前的位置，一个是移动后的位置，若移动后的位置和别的元素冲突，就把别的元素覆盖了。</p>
<p>与relative（相对定位）不同，<strong>设置为absolute（绝对定位）和fixed（固定定位）的元素脱离了文档流</strong>，元素原先在正常文档流中所占的空间会关闭，就像该元素不存在一样。</p>
<p><strong>absolute:</strong> absolute（绝对定位）元素的位置相对于最近的已定位的祖先元素，若该元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。 </p>
<p><strong>fixed:</strong> fixed（固定定位）是相对于浏览器窗口的，即将设置为fixed（固定位置）的元素固定在浏览器的某个位置上，即使拖动浏览器的滚动条，该元素的位置也不会改变。</p>
<h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><p>使用 <strong>float属性</strong>，使元素脱离文档流，浮动起来。</p>
<p>在CSS中使用float属性用于改变块元素对象的默认显示方式。当块元素对象设置了float属性后，它将不再独占一行，而是可以浮动到左侧或右侧，直到浮动的框外缘碰到包含框或另一个浮动框的边框为止。</p>
<p><strong>注意：</strong>浮动框也不在文档流中，因此对文档流的中块框来说，浮动框就像不存在一样。这一点和absolute（绝对定位）属性类型有类似之处，但float和absolute还有以下<strong>不同：</strong></p>
<p>(1)absolute元素的位置相对于离它最近的已定位的祖先元素，它可以以父元素框的4个顶点为基准进行定位。而float属性定位时则是根据left或right属性值，以父元素的左上或右上为基准进行定位。</p>
<p>(2)采用absolute属性定位的元素不能被文本所包围，而采用float属性定位的元素可以被文本包围（float最初设计的用意就是这个，用以取代HTML中的align属性）。</p>
<p>(3)float的影响可控，absolute的影响不可控。<br>设置float和absolute属性的元素都脱离了文档流，因此它们都会影响到其下方的元素。但是，absolute是布局属性，使用它时没有一种有效的方法使之与其下方的元素不重合在一起。相反，若一个元素指定了float属性，当我们向其下方（或后面）的元素的应用了clear属性后（clear:left；clear:right；clear:both），其后的元素就不再受影响了。所以一般在网页布局时，更多的使用float属性。</p>
<h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>flex是一种新型的布局方式，使用该布局方式可以实现几乎所有你想要的效果。但是要注意其浏览器的兼容性，flex 只支持 ie 10+，所以还是要根据项目情况使用。</p>
<h3 id="使用flex布局"><a href="#使用flex布局" class="headerlink" title="使用flex布局"></a>使用flex布局</h3><p>只需要将其display属性设置为 flex 即可，也可以设置行内的 flex。 Webkit内核的浏览器，必须加上 -webkit 前缀。<strong>注意：</strong>设为flex布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p>
<p>Flexible Box模型如下：</p>
<p><img src="/images/CSS-layout/2.png" alt="2"></p>
<p>在flex中，最核心的概念就是<strong>容器和轴</strong>，所有的属性都是围绕容器和轴设置的。其中，容器分为父容器和子容器。轴分为主轴（main axis）和交叉轴（cross axis）（主轴默认为水平方向，方向向右，交叉轴为主轴顺时针旋转 90°）。</p>
<p>在使用 flex 的元素中，默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置称为 main start，主轴结束的位置称为 main end。交叉轴开始的位置称为 cross start，交叉轴结束的位置称为 cross end。</p>
<p>在使用 flex 的子元素中，占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p>
<h3 id="父容器属性"><a href="#父容器属性" class="headerlink" title="父容器属性"></a>父容器属性</h3><p>父容器上有六个属性：flex-direction：主轴的方向。 flex-wrap：超出父容器子容器的排列样式。 flex-flow：flex-direction 属性和 flex-wrap 属性的简写形式。 justify-content：子容器在主轴的排列方向。 align-items：子容器在交叉轴的排列方向。 align-content：多根轴线的对齐方式。</p>
<p><strong>flex-direction</strong> 属性决定主轴的方向（主轴的方向不一定是水平的，这个属性就是设置主轴的方向，主轴默认是水平方向，从左至右，如果主轴方向设置完毕，那么交叉轴就不需要设置，交叉轴永远是主轴顺时针旋转 90°）。</p>
<p><img src="/images/CSS-layout/3.jpeg" alt="3"></p>
<p><strong>flex-wrap</strong> 属性决定子容器如果在一条轴线排不下时，如何换行。</p>
<p><img src="/images/CSS-layout/4.jpeg" alt="4"></p>
<p><strong>flex-flow</strong> 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p>
<p><strong>justify-content</strong> 属性定义了子容器在主轴上的对齐方式。</p>
<p><img src="/images/CSS-layout/5.jpeg" alt="5"></p>
<p><strong>align-items</strong> 属性定义子容器在交叉轴上如何对齐,具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<p><img src="/images/CSS-layout/6.jpeg" alt="6"></p>
<p><strong>align-content</strong> 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p><img src="/images/CSS-layout/7.jpeg" alt="7"></p>
<h3 id="子容器属性"><a href="#子容器属性" class="headerlink" title="子容器属性"></a>子容器属性</h3><p>子容器也有 6 个属性：order：子容器的排列顺序。 flex-grow：子容器剩余空间的拉伸比例。 flex-shrink：子容器超出空间的压缩比例。 flex-basis：子容器在不伸缩情况下的原始尺寸。 子元素的 flex 属性是 flex-grow,flex-shrink 和 flex-basis 的简写。 align-self属性。</p>
<p><strong>order</strong> 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p>
<p><strong>flex-grow</strong> 属性定义子容器的伸缩比例。按照该比例给子容器分配空间。</p>
<p><strong>flex-shrink</strong> 属性定义了子容器弹性收缩的比例。例如，超出的部分按 1:2 的比例从给定子容器中减去。此属性要生效，父容器的 flex-wrap 属性要设置为 nowrap。</p>
<p><strong>flex-basis</strong> 属性定义了子容器在不伸缩情况下的原始尺寸，主轴为横向时代表宽度，主轴为纵向时代表高度。</p>
<p><strong>flex</strong> 属性是 flex-grow,flex-shrink 和 flex-basis 的简写，默认值为 0 1auto。后两个属性可选。</p>
<p><strong>align-self</strong> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父容器align-items 属性。默认值为 auto，表示继承父元素的 align-items属性，如果没有父元素，则等同于 stretch。</p>
<h2 id="grid网格布局"><a href="#grid网格布局" class="headerlink" title="grid网格布局"></a>grid网格布局</h2><p>flex 布局虽然强大，但是只能是一维布局，如果要进行二维布局，还需要使用 grid。</p>
<p>grid 布局又称为“网格布局”，可以实现二维布局方式，和之前的 表格table布局差不多，然而，这是使用 CSS 控制的，不是使用 HTML 控制的，同时还可以依赖于媒体查询根据不同的上下文得新定义布局。</p>
<p>网格布局还可以让我们摆脱现在布局中存在的文档流限制，换句话说，你的结构不需要根据设计稿从上往下布置了。这也意味着您可以自由地更改页面元素位置。这最适合你在不同的断点位置实现你最需要的布局，而不再需要为响应你的设计而担心HTML结构的问题。<br>和 table 布局不同的是，grid 布局不需要在 HTML 中使用特定的标签布局，所有的布局都是在 CSS 中完成的，你可以随意定义你的 grid 网格。</p>
<p>没有 HTML 结构的网格布局有助于使用流体、调整顺序等技术管理或更改布局。通过结合 CSS 的媒体查询属性，可以控制网格布局容器和他们的子元素，使用页面的布局根据不同的设备和可用空间调整元素的显示风格与定位，而不需要去改变文档结构的本质内容。</p>
<h3 id="grid-网格布局中的基本概念"><a href="#grid-网格布局中的基本概念" class="headerlink" title="grid 网格布局中的基本概念"></a>grid 网格布局中的基本概念</h3><p><strong>网格线(Grid Lines)</strong> 组成了网格，他是网格的水平和垂直的分界线。一个网格线存在行或列的两侧。我们可以引用它的数目或者定义的网格线名称。</p>
<p><img src="/images/CSS-layout/8.jpeg" alt="8"></p>
<p><strong>网格轨道(Grid Track)</strong>是就是相邻两条网格线之间的空间，就好比表格中行或列。所在在网格中其分为grid column和grid row。每个网格轨道可以设置一个大小，用来控制宽度或高度。</p>
<p><img src="/images/CSS-layout/9.jpeg" alt="9"></p>
<p><strong>网格单元格(Grid Cell)</strong> 是指四条网格线之间的空间。所以它是最小的单位，就像表格中的单元格。</p>
<p><img src="/images/CSS-layout/10.jpeg" alt="10"></p>
<p><strong>网格区域(Grid Area)</strong> 是由任意四条网格线组成的空间，所以他可能包含一个或多个单元格。相当于表格中的合并单元格之后的区域。</p>
<p><img src="/images/CSS-layout/11.jpeg" alt="11"></p>
<h3 id="使用grid布局"><a href="#使用grid布局" class="headerlink" title="使用grid布局"></a>使用grid布局</h3><p>使用 grid 布局很简单，通过display属性设置属性值为 grid 或 inline-grid 或者是 subgrid（该元素父元素为网格，继承父元素的行和列的大小） 就可以了。</p>
<p>网格容器中的所有子元素就会自动变成网格项目（grid item），然后设置列（grid-template-columns）和 行（grid-template-rows）的大小，设置 grid-template-columns 有多少个参数，生成的 grid 列表就有多少 列。</p>
<p><strong>注：</strong>当元素设置了网格布局，column、float、clear、vertical-align属性无效。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="http://blog.csdn.net/zhuyunhe/article/details/45790527" target="_blank" rel="external">CSS定位——position、float小结</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一段时间了，但对于CSS布局方法的掌握一直比较混乱，于是再来学习总结一遍。文章参考自&lt;a href=&quot;http://www.sohu.com/a/168143624_274163&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS 常见布局方式 &lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>github pages自定义域名及DNS相关介绍</title>
    <link href="http://yoursite.com/2017/12/29/github-pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D/"/>
    <id>http://yoursite.com/2017/12/29/github-pages绑定域名/</id>
    <published>2017-12-29T06:49:39.000Z</published>
    <updated>2018-01-09T02:47:02.939Z</updated>
    
    <content type="html"><![CDATA[<p>在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！<br><a id="more"></a></p>
<h2 id="域名相关知识"><a href="#域名相关知识" class="headerlink" title="域名相关知识"></a>域名相关知识</h2><h3 id="域名是什么"><a href="#域名是什么" class="headerlink" title="域名是什么"></a>域名是什么</h3><p>根据百度百科，域名（Domain Name），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称。用于在数据传输时标识计算机的电子方位。</p>
<p>对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。域名同时也仅限于ASCII字符的一个子集，这使得很多其他语言无法正确表示他们的名字和单词。</p>
<p>在域名中大小写是没有区分的。域名一般不能超过5级，从左到右域的级别变高，高的级域包含低的级域。域名在整个Internet中是唯一的，当高级子域名相同时，低级子域名不允许重复。一台服务器只能有一个IP地址，但是却可以有多个域名。</p>
<p>任何一个使用IP的计算机网络可以使用DNS来实现他自己的私有名称系统。这是基于13个全球范围的“根服务器”，其维护组织除了当中的3个以外，其他都位于美国。从这13个根服务器开始，余下的Internet DNS命名空间被委托给其他的DNS服务器， 这些服务器提供DNS名称空间中的特定部分。</p>
<h3 id="域名级别"><a href="#域名级别" class="headerlink" title="域名级别"></a>域名级别</h3><p>整个DNS系统是由许多域所组成，每个域下又细分更多的域，DNS域构成了层次树状结构，自上而下分别是根域、顶级域名、二级域名…，最后是主机名。</p>
<p>顶级域名（一级域名）——如：.com、.net、.edu、.gov、.cn等。二级域名我们常常能够申请到的域名，在顶级域名的左侧加上的一个自定义的文字段，例如shirley5li.me，通常所说申请的域名，往往指的是这个二级域名。</p>
<p>以www.sina.com.cn为例，该域名是三级域名，其中sina.com.cn为新浪Web服务器的【域名】，www不是域名的组成部分而是URL的组成部分。所以该例中， 一级域名.cn、二级域名.com.cn、三级域名.sina.com.cn。<br>主机名www（表示该主机所提供的服务为www服务，即Web服务器。</p>
<p>URL的构成——<a href="http://主机名" target="_blank" rel="external">http://主机名</a> . 域名（端口号、参数、查询等可选。 域名(Domain Name)可由若干部份组成,各部份之间用圆点分开，域名前加上【主机类型信息】（如：www、ftp）和【传输协议信息】就构成了网址（URL）<a href="http://www.xxxx.cn。" target="_blank" rel="external">http://www.xxxx.cn。</a></p>
<p><strong>子域名(sbudomain name)</strong></p>
<p>相对于上文所提到的“我们通常所说的域名”（二级域名）的基础上，又加入了子域名的概念，就是在一个域名的前面，加上新的字段，代表这个域名下的某个特定的主机或者协议。最常用的就是WWW协议，所以，我的子域名www.shirley5li.me就是shirley5li.me的WWW子域名。</p>
<h2 id="DNS相关知识"><a href="#DNS相关知识" class="headerlink" title="DNS相关知识"></a>DNS相关知识</h2><p>网域名称系统（DNS，Domain Name System，有时也简称为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<p>例如，www.wikipedia.org是一个域名，和IP地址208.80.152.2相对应。DNS就像是一个自动的电话号码簿，我们可以直接拨打wikipedia的名字来代替电话号码（IP地址）。我们直接调用网站的名字以后，DNS就会将便于人类使用的名字（如www.wikipedia.org）转化成便于机器识别的IP地址（如208.80.152.2）。</p>
<p>域名服务器分不同的组来负责各子系统的名字。系统中的每一层叫做一个域，每个域用一个点分开。所谓域名服务器（即Domain Name Server，简称Name Server、DNS）实际上就是装有域名系统的主机。它是一种分层结构数据库，能够执行名字解析（name resolution）。</p>
<p>DNS服务器上都存了些啥？最主要的就是能够完成域名解析的一些记录</p>
<h3 id="A记录（A-record"><a href="#A记录（A-record" class="headerlink" title="A记录（A record)"></a>A记录（A record)</h3><p>A记录在DNS中的意义就是，域名到ip地址的转换。所以，当我们在DNS服务器中添加一个A记录时，是告诉服务器，将某个特定的域名映射到一个ip地址。</p>
<h3 id="CNAME记录（CNAME-record"><a href="#CNAME记录（CNAME-record" class="headerlink" title="CNAME记录（CNAME record)"></a>CNAME记录（CNAME record)</h3><p>CNAME的意义，简单说就是别名，即将一个域名射到另一个域名（区别于A记录的ip）。所以，CNAME通常有两种用法:</p>
<p>(1)不同顶级域名之间的跳转。例如：我的域名是 shirley5li.me(顶级域名为me)。如果希望当访问这个域名的时候，实际上是访问的shirley5li.github.io（顶级域名为io）的主页时，虽然他们在不同的顶级域名，但是可以用CNAME记录映射。</p>
<p>(2)将一个子域名映射到域名。例如：你想当访问者输入www.shirley5li.me（一个WWW子域名）的时候，仍旧访问shirley5li.me这个域名所指向的内容时，可以将www.shirley5li.me利用CNAME记录映射到shirley5li.me。</p>
<h3 id="NS记录（Name-Server）"><a href="#NS记录（Name-Server）" class="headerlink" title="NS记录（Name Server）"></a>NS记录（Name Server）</h3><p>指定了负责解析我这个域名的服务器的地址。这条记录赋予我们一个特殊的能力，就是，我可以让自己指定的一个DNS解析服务器，而不一定是域名提供商自带的域名解析服务器。简单来说，就是在godaddy买的域名，默认是使用godaddy的域名服务器来进行域名解析的，但是如果我想让别的server解析（例如NDSPod），而不受godaddy服务器的限制呢？那就是更改这个NS记录的内容。一般来讲，是两条记录，一条主服务器，一条副服务器。</p>
<p>因此很多人推荐Godaddy注册购买域名，DNSpod负责解析，即修改NS记录。</p>
<h2 id="域名服务器哪家强"><a href="#域名服务器哪家强" class="headerlink" title="域名服务器哪家强"></a>域名服务器哪家强</h2><p>域名通过向域名注册商购买获得，如今有很多域名注册商，比如国内的<a href="https://wanwang.aliyun.com" target="_blank" rel="external">万网</a>以及国外的<a href="https://sg.godaddy.com" target="_blank" rel="external">GoDaddy</a>。<br>考虑各种因素，在GoDaddy上购买域名相比万网的好处是不需要各种审核，很多人推荐使用godaddy，Godaddy注册购买域名，DNSpod解析。雅蠛蝶，那我也用狗爹了~<a href="http://godaddy.idcspy.com/domain-regist" target="_blank" rel="external">2017年Godaddy域名注册教程</a></p>
<p>先来狗爹注册个账号，然后搜索想要的域名购买。这里又在选择什么样的域名后缀纠结半天，什么.me .cc .org .com，最后选择了shirley5li.me，因为价格最低。。。然后支付宝付款就好了。</p>
<h2 id="github-pages绑定域名详细步骤"><a href="#github-pages绑定域名详细步骤" class="headerlink" title="github pages绑定域名详细步骤"></a>github pages绑定域名详细步骤</h2><p>既然域名已经买完了，直接是没法用的，因为没有进行DNS解析，别人是没法正常通过域名访问你的界面的，这里使用DNS进行解析。</p>
<p>域名绑定的含义就是当你访问你的域名时，浏览器会自动跳转到刚才创建的 Github Pages(username.github.io)。实现绑定的关键在于设置 DNS 解析。在 GoDaddy 注册的域名，由于 GFW 的存在，需要使用第三方 DNS 服务来解析域名。推荐使用鹅厂的 DNSPOD。鹅厂的服务可靠性高同时也不会被墙。</p>
<p>域名购买完成后，回到Github项目上，即搭建博客那个项目，点击设置Settings，找到Custom domain，填入申请的域名，并保存。</p>
<p><img src="/images/github-pages绑定域名/1.png" alt="1"><br>这个操作等同于在项目根目录下创建一个名为CNAME的文件，文件内容为上述填写的域名。</p>
<p>回到GoDaddy的主页上，点击个人用户–&gt;管理域名。</p>
<p><img src="/images/github-pages绑定域名/2.png" alt="2"></p>
<p>再点击那三个点点（真的对用户超不友好，找半天！！！），选择管理DNS。</p>
<p><img src="/images/github-pages绑定域名/3.png" alt="3"></p>
<p>默认的DNS记录如下所示：</p>
<p><img src="/images/github-pages绑定域名/4.png" alt="4"></p>
<p>关于A记录的修改，在名称@这条记录中，将值改为Github博客的IP地址（由ping得到，即<code>151.101.77.147</code>。操作如下：</p>
<p><img src="/images/github-pages绑定域名/5.png" alt="5"></p>
<p>关于CNAME记录的修改，在名称www这条记录中，将值改为github博客默认的域名，即shirley5li.github.io。</p>
<p>该阶段修改后修的DNS管理记录如下：</p>
<p><img src="/images/github-pages绑定域名/6.png" alt="6"></p>
<p>上图中两条NS记录的值为狗爹默认的域名服务器的地址，为防止背墙以及速度等原因，采用第三方国内域名服务器NDSPod来解析我们在狗爹申请的域名。</p>
<p>接下来我们到<a href="https://www.dnspod.cn/" target="_blank" rel="external">NDSPod</a>来注册账号，注册完账号后，在DNSPOD首页–&gt;管理控制台–&gt;域名解析–&gt;添加域名，将在狗爹申请的域名填入，点确定。如下所示。</p>
<p><img src="/images/github-pages绑定域名/7.png" alt="7"></p>
<p>然后点击刚刚添加的域名，来管理DNS记录。DNS记录各参数含义：(1)主机记录， @：不通过任何前缀访问域名 ， www：通过www前缀访问域名。(2)记录类型， A：在记录值处写主机IP地址，NS：记录值是DNSPOD提供的Name Server地址，CNAME：记录值是域名的别名。</p>
<p>添加一条A记录，主机类型是@，记录值填ping Github博客得到的ip地址。再将狗爹上的两条CNAME记录添加上。最后DNSPOD上的DNS各条记录如下所示:</p>
<p><img src="/images/github-pages绑定域名/8.png" alt="8"></p>
<p>然后将上图中的两条NS记录值（DNSPOD默认的域名服务器地址），填入Godaddy的自定义域名服务器。<br>即：</p>
<p><img src="/images/github-pages绑定域名/9.png" alt="9"></p>
<p>狗爹更改后，再刷新一下，域名服务器如下：</p>
<p><img src="/images/github-pages绑定域名/10.png" alt="10"> </p>
<p>等待一段时间就可以成功用DNSPod解析域名到Github博客，在浏览器地址栏输入shirley5li.me，可以看到如下github pages博客主页：</p>
<p><img src="/images/github-pages绑定域名/11.png" alt="11"> </p>
<p>至此大功告成。</p>
<p>PS:参考一些博客，他们在域名注册成功后，在github博客本地目录source下创建CNAME文件，里面填入自己申请的域名即shirley5li.me，保存后<code>hexo g -d</code>上传至Github Repo中。此步骤相当于在搭建博客那个项目，点击设置Settings，在Custom domain，填入申请的域名的过程，因为上面已经操作了Custom domain填入申请域名的过程，所以没有此步骤也可以正常解析shirley5li.me，但再添加也无妨。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="external">域名–wikipedia</a></p>
<p><a href="http://blog.csdn.net/f87089/article/details/51480278" target="_blank" rel="external">怎么区分域名级别，举例说明更易懂</a></p>
<p><a href="http://winterttr.me/2015/10/23/from-dns-to-github-custom-domain/" target="_blank" rel="external">从DNS到github pages自定义域名 – 漫谈域名那些事</a></p>
<p><a href="http://www.laozuo.org/7198.html" target="_blank" rel="external">老左所理解的建站域名的选择以及域名投资的一些看法</a></p>
<p><a href="https://www.zhihu.com/question/19735598?sort=created&amp;page=1" target="_blank" rel="external">想注册一个作个人博客用的域名，应该使用哪个域名注册提供商？</a></p>
<p><a href="http://yanshengjia.com/2017/01/31/%E4%BD%BF%E7%94%A8Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">使用 Hexo + Github Pages 搭建独立博客</a></p>
<p><a href="https://www.jianshu.com/p/252b542b1abf" target="_blank" rel="external">Blog绑定域名——Godaddy + DNSPod</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在帆锅的启示下，试着给github pages买个域名，毕竟github.io还是有点长哦。以下域名购买、绑定设置，以及DNS的相关知识得益于帆锅给自己博客绑定域名的笔记以及各位大佬的博客，感谢！&lt;br&gt;
    
    </summary>
    
      <category term="github pages" scheme="http://yoursite.com/categories/github-pages/"/>
    
    
      <category term="github pages" scheme="http://yoursite.com/tags/github-pages/"/>
    
  </entry>
  
  <entry>
    <title>博文集锦</title>
    <link href="http://yoursite.com/2017/12/27/good-blog-post/"/>
    <id>http://yoursite.com/2017/12/27/good-blog-post/</id>
    <published>2017-12-27T02:58:05.000Z</published>
    <updated>2018-01-11T09:37:11.619Z</updated>
    
    <content type="html"><![CDATA[<p>以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。<br><a id="more"></a></p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a href="https://www.cnblogs.com/rainy-shurun/p/5603686.html" target="_blank" rel="external">浏览器内部工作原理</a></p>
<p><a href="http://blog.csdn.net/zll0927/article/details/11885239" target="_blank" rel="external">当在浏览器地址栏输入一个网址的时候，究竟发生了什么?</a></p>
<p><a href="https://www.cnblogs.com/myzhibie/p/4470065.html" target="_blank" rel="external">html5-websocket初探</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是一些关于WEB开发比较好的技术文章集锦，收集以待后面再看一遍。&lt;br&gt;
    
    </summary>
    
      <category term="bolgPost" scheme="http://yoursite.com/categories/bolgPost/"/>
    
    
      <category term="blogPost" scheme="http://yoursite.com/tags/blogPost/"/>
    
  </entry>
  
  <entry>
    <title>JS高程（3）学习笔记</title>
    <link href="http://yoursite.com/2017/12/25/JS%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ing/"/>
    <id>http://yoursite.com/2017/12/25/JS高程学习笔记-ing/</id>
    <published>2017-12-25T09:17:54.000Z</published>
    <updated>2018-01-09T02:47:02.934Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript学习笔记。<br><a id="more"></a></p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JS没有块级作用域，即在块语句中定义的变量，实际是在包含函数中创建的，而非在块语句中创建的。如下：</p>
<pre><code>function outputNumbers(count) {
    for( var i = 0; i &lt; count; i++) {
        console.log(i);
    }
    console.log(i);
}
outputNumbers(4);//打印值为0 1 2 3 4
</code></pre><p>在Java、C++等语言中，for循环中定义的变量i只存在于for循环语句块中，循环一旦结束，变量i就会被销毁。而在JS中，变量i是定义在outputNumbers()这个包含函数的活动对象中的，因此从它被定义开始，就可以在函数内部随处访问它。</p>
<p>即使在一个函数中重新声明同一个变量，也不会改变它的值。如下：</p>
<pre><code>function outputNumbers(count) {
    for( var i = 0; i &lt; count; i++) {
        console.log(i);
    }
    var i;
    console.log(i);
}
outputNumbers(4);//打印值为0 1 2 3 4
</code></pre><p>JS不会提醒是否多次声明了同一个变量，在此情况下，它对后续重复的变量声明视而不见，但会执行后续声明中的变量初始化。可以通过<strong>匿名函数模仿块级作用域</strong>来避免多次声明同一个变量的问题。</p>
<p>用作<strong>块级作用域（私有作用域）</strong>的匿名函数语法如下：</p>
<pre><code>(function() {
    //这里为块级作用域
})();
</code></pre><p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域。使用私有作用域如下：</p>
<pre><code>function outputNumbers(count) {
    (function() {
        for( var i = 0; i &lt; count; i++) {
        console.log(i);
        }
    })();
    console.log(i);//导致一个错误！！！
}
</code></pre><p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲，JS中没有私有成员的概念，所有对象属性都是公有的。但有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量，因为在函数外部无法访问这些变量，包括函数参数、局部变量、在函数中定义的其他函数。</p>
<p>把有权访问上述私有变量和私有函数的公有方法称为<strong>特权方法</strong>，有两种在对象上创建特权方法的方式。</p>
<p><strong>第一种：在构造函数中定义特权方法</strong>，基本模式如下</p>
<pre><code>function MyObject() {
    //私有变量
    var privateVariable = 10;
    //私有函数
    function privateFunction() {
        return false;
    }

    //特权方法
    this.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
}
</code></pre><p>能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。</p>
<p>在创建构造函数实例后，除了使用特权方法，没有其他方式可以直接访问构造函数内部的私有变量和私有函数。</p>
<p>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。</p>
<p>在构造函数中定义特权方法的缺点，就是必须使用构造函数模式来实现特权方法，而构造函数的缺点是针对每个实例都会创建同样一组新方法，而使用<strong>静态私有变量</strong>来实现特权方法可以避免这一问题。</p>
<p><strong>第二种：使用静态私有变量实现特权方法</strong></p>
<p>通过在私有作用域中定义私有变量或函数，也可以创建特权方法。基本模式如下：</p>
<pre><code>(function() }{
    //私有变量
    var privateVariable = 10;
    //私有函数
    function privateFunction() {
        return false;
    }

    //构造函数
    MyObject = function() {
    };

    //公有方法/特权方法
    MyObject.prototype.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };

})();
</code></pre><p>公有方法是在构造函数原型上定义的，体现了典型的原型模式。注意：该模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，并不是我们想要的，因此也没有使用关键字var声明MyObject。初始化未经声明的变量，总会创建一个全局变量，因此MyObject就变成了一个全局变量，能够在私有作用域之外被访问到。但在严格模式下，给未经声明的变量赋值会导致错误。</p>
<p>该模式与在构造函数中定义特权方法的主要区别在于，私有变量和函数由实例共享，在一个实例上调用公有方法，会影响所有实例。<br>以该方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。因此选择使用实例变量，还是静态私有变量，视具体需求而定。</p>
<h2 id="BOM-window对象"><a href="#BOM-window对象" class="headerlink" title="BOM-window对象"></a>BOM-window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的global对象。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。例如：</p>
<pre><code>var age = 29;
function sayAge() {
    alert(this.age);
}
alert(window.age);   //29
sayAge();            //29
window.sayAge();     //29
</code></pre><p>全局变量会变为window对象的属性，定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。</p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript学习笔记。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS学习笔记01</title>
    <link href="http://yoursite.com/2017/12/08/AngularJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001-ing/"/>
    <id>http://yoursite.com/2017/12/08/AngularJS学习笔记01-ing/</id>
    <published>2017-12-08T08:41:16.000Z</published>
    <updated>2018-01-09T02:47:02.932Z</updated>
    
    <content type="html"><![CDATA[<p> AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。<br><a id="more"></a><br> AngularJS 是一个为动态WEB应用设计的结构框架，提供给大家一种新的开发应用方式，这种方式可以让你扩展HTML的语法，以弥补在构建动态WEB应用时静态文本的不足，从而在web应用程序中使用HTML声明动态内容。Angular可以帮助你组织JavaScript代码，可以创建响应式网站（会对用户的请求产生快速的反应），Angular可以和JQuery很好的协调、方便测试（搭建可维护的应用）。</p>
<p>简单的解释Angular就是一个可以给HTML加上互动性的客户端JS框架。</p>
<p>关于传统网页请求和AngularJS网页请求之间的区别，参见博客<a href="http://blog.csdn.net/xiaoyao0909/article/details/51419078" target="_blank" rel="external">AngularJS系列——简介</a>。</p>
<h2 id="AngularJS简介"><a href="#AngularJS简介" class="headerlink" title="AngularJS简介"></a>AngularJS简介</h2><pre><code>AngularJS 通过 ng-directives 扩展了 HTML。
ng-app 指令定义一个 AngularJS 应用程序。
ng-model 指令把元素值（比如输入域的值）绑定到应用程序变量。
ng-bind 指令把应用程序数据绑定到 HTML 视图。
</code></pre><p>例如：</p>
<pre><code>&lt;body&gt;
    &lt;div ng-app=&quot;&quot;&gt;
        &lt;p&gt;名字 : &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;/p&gt;
        &lt;h1&gt;Hello {{name}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>ng-app 指令告诉 AngularJS，<div\> 元素是 AngularJS 应用程序 的”所有者”。ng-model 指令把输入域的值绑定到应用程序变量 name。ng-bind 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</div\></p>
<p>AngularJS 使得开发现代的单一页面应用程序（SPAs：Single Page Applications）变得更加容易。</p>
<pre><code>AngularJS 把应用程序数据绑定到 HTML 元素。
AngularJS 可以克隆和重复 HTML 元素。
AngularJS 可以隐藏和显示 HTML 元素。
AngularJS 可以在 HTML 元素&quot;背后&quot;添加代码。
AngularJS 支持输入验证。
</code></pre><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>AngularJS 使用表达式把数据绑定到 HTML。</p>
<p>AngularJS 表达式写在双大括号内：。AngularJS表达式很像JavaScript表达式：它们可以包含文字、运算符和变量。</p>
<pre><code>&lt;body&gt;
    &lt;div ng-app=&quot;&quot;&gt;
        &lt;p&gt;我的第一个表达式: {{ 5 + 5 }}&lt;/p&gt;
    &lt;/div&gt; 
&lt;/body&gt;
</code></pre><p>AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。例如：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt;
    &lt;p&gt;总价： {{ quantity * cost }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>使用 ng-bind 的相同实例：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;quantity=1;cost=5&quot;&gt; 
    &lt;p&gt;总价： &lt;span ng-bind=&quot;quantity * cost&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre><p><strong>AngularJS表达式与JavaScript表达式比较</strong></p>
<pre><code>类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。
与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。
与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。
与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。
</code></pre><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>AngularJS 通过<strong>指令</strong>新属性来扩展 HTML，指令带有前缀 ng-。</p>
<p>AngularJS 通过内置的指令来为应用添加功能，允许自定义指令。</p>
<pre><code>ng-app 指令初始化一个 AngularJS 应用程序。
ng-init 指令初始化应用程序数据。
ng-model 指令把元素值（比如输入域的值）绑定到应用程序。
ng-repeat 指令对于集合中（数组中）的每个项会 克隆一次 HTML 元素
</code></pre><p>例如：</p>
<pre><code>&lt;div ng-app=&quot;&quot; ng-init=&quot;firstName=&apos;John&apos;&quot;&gt;
     &lt;p&gt;在输入框中尝试输入：&lt;/p&gt;
     &lt;p&gt;姓名：&lt;input type=&quot;text&quot; ng-model=&quot;firstName&quot;&gt;&lt;/p&gt;
     &lt;p&gt;你输入的为： {{ firstName }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p>使用 .directive 函数来添加自定义的指令。要调用自定义指令，HTML 元素上需要添加自定义指令名。<br>使用驼峰法来命名一个指令， runoobDirective, 但在使用它时需要以 - 分割, runoob-directive。</p>
<pre><code>&lt;body ng-app=&quot;myApp&quot;&gt;
    &lt;runoob-directive&gt;&lt;/runoob-directive&gt;
    &lt;script&gt;
        var app = angular.module(&quot;myApp&quot;, []);
        app.directive(&quot;runoobDirective&quot;, function() {
            return {
                template : &quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot;
            };
        });
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><p>你可以通过以下方式来调用指令：元素名、属性、类名、注释。</p>
<pre><code>&lt;runoob-directive&gt;&lt;/runoob-directive&gt;
&lt;div runoob-directive&gt;&lt;/div&gt;
&lt;div class=&quot;runoob-directive&quot;&gt;&lt;/div&gt;
&lt;!-- directive: runoob-directive --&gt;
</code></pre><h2 id="AngularJS模型-ng-model指令"><a href="#AngularJS模型-ng-model指令" class="headerlink" title="AngularJS模型 ng-model指令"></a>AngularJS模型 ng-model指令</h2><p>ng-model 指令用于绑定应用程序数据到 HTML 控制器(input, select, textarea)的值。ng-model 指令可以将输入域的值与 AngularJS 创建的变量绑定。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; AngularJS是Google开源的一款JavaScript MVC的前端框架，弥补了HTML在构建应用方面的不足，其通过使用指令（directives）结构来扩展HTML词汇，且通过表达式绑定数据到 HTML，使开发者可以使用HTML来声明动态内容，从而使得Web开发和测试工作变得更加容易。&lt;br&gt;
    
    </summary>
    
      <category term="Angular" scheme="http://yoursite.com/categories/Angular/"/>
    
    
      <category term="Angular" scheme="http://yoursite.com/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>freeCodeCamp JavaScript高级算法编程学习总结</title>
    <link href="http://yoursite.com/2017/11/26/freeCodeCamp-%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/26/freeCodeCamp-高级算法编程/</id>
    <published>2017-11-26T03:07:43.000Z</published>
    <updated>2018-01-09T02:47:02.938Z</updated>
    
    <content type="html"><![CDATA[<p>几个 freeCodeCamp JS高级算法编程例题的学习总结。<br><a id="more"></a></p>
<h2 id="Validate-US-Telephone-Numbers"><a href="#Validate-US-Telephone-Numbers" class="headerlink" title="Validate US Telephone Numbers"></a>Validate US Telephone Numbers</h2><p><strong>题目：</strong>如果传入字符串是一个有效的美国电话号码，则返回 true.</p>
<p>用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法):</p>
<pre><code>555-555-5555
(555)555-5555
(555) 555-5555
555 555 5555
5555555555
1 555 555 5555
</code></pre><p>在本节中你会看见如 800-692-7753 or 8oo-six427676;laskdjf这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 1. 如果号码有效就返回 true ; 否则返回 false.</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">RegExp</a></p>
<p><strong>实现</strong></p>
<pre><code>function telephoneCheck(str) {
  //^1?表示以1开头，1匹配0次或1次
  //\s?表示空白字符匹配0次或1次
  //\d{3}匹配一个0-9的数字三次
  //\(\d{3}\)匹配（一个0-9的数字三次），比上面多一个括号，左右括号分别需要加上转义字符\
  //[ -]?表示空格或者连字符-匹配0次或1次
  //\d{4}$表示已4位数字结尾($)
  var re=/^1?\s?(\d{3}|\(\d{3}\))[ -]?\d{3}[ -]?\d{4}$/;
  return re.test(str);
}
telephoneCheck(&quot;1 555)555-5555&quot;);//返回false
</code></pre><h2 id="Symmetric-Difference"><a href="#Symmetric-Difference" class="headerlink" title="Symmetric Difference"></a>Symmetric Difference</h2><p><strong>题目：</strong>创建一个函数，接受两个或多个数组，返回所给数组的 对等差分(symmetric difference) (△ or ⊕)数组.</p>
<p>给出两个集合 (如集合 A = {1, 2, 3} 和集合 B = {2, 3, 4}), 而数学术语 “对等差分” 的集合就是指由所有只在两个集合其中之一的元素组成的集合(A △ B = C = {1, 4}). 对于传入的额外集合 (如 D = {2, 3}), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (C △ D = {1, 4} △ {2, 3} = {1, 2, 3, 4}).</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">Array.reduce()</a></p>
<p><strong>实现</strong></p>
<pre><code>function sym(args) {
  //将多个参数合并为一个数组arr
  var arr = [];
  for(var i = 0; i &lt; arguments.length; i++) {
    arr.push(arguments[i]);
  }
  //也可以使用Array.from()将输入参数合并为一个数组
  //var arr = Array.from(arguments);

  //temp为所有项都没同时出现在两个相邻数组的数组，但temp内部可能有重复元素，因为单个数组内部可能元素重复
  //pre是前一个数组，cur是当前数组
  var temp = arr.reduce(function(prev, cur, index) {
    //a数组由prev数组在cur中没有出现过的元素组成
    var a = prev.filter(function(item) {
      return cur.indexOf(item) &lt; 0;
    });
    //b数组由cur数组在prev中没有出现过的元素组成
    var b = cur.filter(function(item){
      return prev.indexOf(item) &lt; 0;
    });
    //合并a和b作为新的prev
    return a.concat(b);
  });
  //对temp去重
  return temp.filter(function(item, index, array){
    return array.indexOf(item) == index;
  });
}
sym([1, 2, 3], [5, 2, 1, 4]);
</code></pre><h2 id="Exact-Change"><a href="#Exact-Change" class="headerlink" title="Exact Change"></a>Exact Change</h2><p><strong>题目：</strong>设计一个收银程序 checkCashRegister() ，其把购买价格(price)作为第一个参数 , 付款金额 (cash)作为第二个参数, 和收银机中零钱 (cid) 作为第三个参数.</p>
<p>cid 是一个二维数组，存着当前可用的找零.</p>
<p>当收银机中的钱不够找零时返回字符串 “Insufficient Funds”. 如果正好则返回字符串 “Closed”.否则, 返回应找回的零钱列表,且由大到小存在二维数组中.</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Global Object</a></p>
<p><strong>思路：</strong>输入为商品价格，实际付款，收银机零钱的余额。然后返回值有三种，如果找不开返回”Insufficient Funds”；如果正好找开，收银机余额空了，返回”Closed”；其余则返回找零的数组。</p>
<p>先将美元的各面额存入数组，对面额数组由大到小遍历，如果待找零钱大于该面额且该面额在收银机中存在的话，则进行该面额的找零操作，否则进入下一面额的找零操作。本面额的找零操作过程为：先根据待找零钱计算出该面额需要的张数，如果待找零钱&gt;=该面额的总值，则将该面额的钱全部给出，然后待找零钱更新，将该面额的找零结果输出；如果待找零钱小于该面额的总值，则从该面额总值中给出需要找出的那几张，然后更新待找零钱，输出该面额的找零结果。</p>
<p><strong>实现</strong></p>
<pre><code>function checkCashRegister(price, cash, cid) {
  var change = cash - price;//待找零钱数目
  var denominationArr = [0.01, 0.05, 0.1, 0.25, 1, 5, 10, 20, 100];//将不同面额存入数组，对应于cid[i][0]
  var total = 0;//用来记录收银机总共的零钱数
  var money = change;//将待找零钱数change备份，因为下面找零过程中会更新change
  var resultArr = [];//用来输出找零列表
  //从大面额到小面额遍历
  for(var i = cid.length - 1; i &gt;= 0; i--) {
    total += cid[i][1];//记录收银机的总钱数
    //如果待找零钱大于等于某个面额，并且该面额的钱数大于0，则需要给出该面额的零钱
    if(change &gt; denominationArr[i] &amp;&amp; cid[i][1] &gt; 0) {//denominationArr[i] 表示第i种面额钱的面值，cid[i][1]表示收银机中该面额的总额
      //num表示需要给出的该面额的数量   
      var num = parseInt(change / denominationArr[i]);
      //如果change需要的第i种面额的钱数大于等于收银机中该面额的实际钱数，则将收银机中该面额的钱全部给出,更新change和resultArr
      if(denominationArr[i] * num &gt;= cid[i][1]) {
        change -= cid[i][1];
        resultArr.push(cid[i]);
      } else {
        //否则change需要的第i种面额的钱小于收银机中该面额的实际钱数，则找出change需要的该面额数目，更新change和resultArr
        change -= denominationArr[i] * num;
        resultArr.push([cid[i][0], denominationArr[i] * num]);
      }
      //操作过程中会使得change变为一个无限小数，因此使用.toFixed(2)方法保留两位小数
      change = change.toFixed(2);//四舍五入保留两位小数
    }
  }  
  //如果收银机中的总钱数正好等于待找零钱数，返回&quot;Closed&quot; 
  if(total=== money) {
     return &quot;Closed&quot;;
  }
  //如果收银机中的总钱数不够找，或者不能正好找整即change不能最后更新到0，则返回&quot;Insufficient Funds&quot;
  else if(total &lt; money || (change-0) !== 0) { //使用(cahnge-0)将0.00转化为0   
    return &quot;Insufficient Funds&quot;;
    }
  return resultArr;
}
checkCashRegister(3.26, 100.00, [[&quot;PENNY&quot;, 1.01], [&quot;NICKEL&quot;, 2.05], [&quot;DIME&quot;, 3.10], [&quot;QUARTER&quot;, 4.25], [&quot;ONE&quot;, 90.00], [&quot;FIVE&quot;, 55.00], [&quot;TEN&quot;, 20.00], [&quot;TWENTY&quot;, 60.00], [&quot;ONE HUNDRED&quot;, 100.00]]);
//返回[[&quot;TWENTY&quot;, 60.00], [&quot;TEN&quot;, 20.00], [&quot;FIVE&quot;, 15], [&quot;ONE&quot;, 1], [&quot;QUARTER&quot;, 0.50], [&quot;DIME&quot;, 0.20], [&quot;PENNY&quot;, 0.04]]
</code></pre><p><strong>注意：</strong> js计算浮点数精度不准确容易导致一些小问题，老是有几个测试例子通不过，使用.toFixed(2)方法四舍五入保留两位小数，但该方法也不严谨。具体见博客<a href="https://www.cnblogs.com/xinggood/p/6639022.html" target="_blank" rel="external">关于js浮点数计算精度不准确问题的解决办法</a>。</p>
<p>另外由于<code>change = change.toFixed(2)</code>，使得找零完毕后<code>change=&quot;0.00&quot;</code>，因此使用(cahnge-0)将0.00转化为0，否则使用严格不等<code>change！==0</code>是错误的，因为0.00和0不完全相等。当然若不使用 <code>(change-0) !== 0</code>，也可以使用不严格不等<code>change != 0</code>。</p>
<h2 id="Inventory-Update"><a href="#Inventory-Update" class="headerlink" title="Inventory Update"></a>Inventory Update</h2><p><strong>题目：</strong>依照一个存着新进货物的二维数组，更新存着现有库存(在 arr1 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列.</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">Global Array Object</a></p>
<p><strong>实现</strong></p>
<pre><code>function updateInventory(arr1, arr2) {
   //将现有库存的货物名称存入数组curGoodsArr
  var curGoodsArr = [];
  for(var i = 0; i &lt; arr1.length; i++) {
    curGoodsArr.push(arr1[i][1]);
  }
  for(var j = 0; j &lt; arr2.length; j++) {
    //若现有库存中没有新进货物类型，则将新货物名称和数量一并添加到库存数组，名称需按字母顺序排序
    //将新货物名称追加到数组curGoodsArr,再对数组排序。sort()方法在原数组上排序，不生成副本
    if(curGoodsArr.indexOf(arr2[j][1]) === -1) {
      //注意push()方法可向数组的末尾添加一个或多个元素，返回新的长度。注意是长度，不是返回新的数组！！！
      curGoodsArr.push(arr2[j][1]);
      //给货物名称按字母排序
      curGoodsArr.sort();
      //找到该新货物名称在排序后出现在curGoodsArr数组中的索引，该索引值也是新货物应该出现在库存数组中的顺序
      var indexNewGoods = curGoodsArr.indexOf(arr2[j][1]);
      //将新货物名称和数量一并插入到库存数组,使用.splice()方法,该方法会改变原始数组
      arr1.splice(indexNewGoods, 0, [arr2[j][0], arr2[j][1]]);
    }
    //如果现有库存货物中已经新进货物的类型，则更新库存数量
    else {
      //index为已有货物在库存货物名称数组中的索引，也即货物在库存数组中出现的顺序
      var index = curGoodsArr.indexOf(arr2[j][1]);
      //更新库存数量，即等于原来的库存数量+新进的数量
      arr1[index][0] =arr1[index][0] + arr2[j][0];
    }    
  }  
    return arr1;
}
// 仓库库存示例
var curInv = [
    [21, &quot;Bowling Ball&quot;],
    [2, &quot;Dirty Sock&quot;],
    [1, &quot;Hair Pin&quot;],
    [5, &quot;Microphone&quot;]
];
var newInv = [
    [2, &quot;Hair Pin&quot;],
    [3, &quot;Half-Eaten Apple&quot;],
    [67, &quot;Bowling Ball&quot;],
    [7, &quot;Toothpaste&quot;]
];
updateInventory(curInv, newInv);//返回[[88, &quot;Bowling Ball&quot;], [2, &quot;Dirty Sock&quot;], [3, &quot;Hair Pin&quot;], [3, &quot;Half-Eaten Apple&quot;], [5, &quot;Microphone&quot;], [7, &quot;Toothpaste&quot;]]
</code></pre><h2 id="No-repeats-please"><a href="#No-repeats-please" class="headerlink" title="No repeats please"></a>No repeats please</h2><p><strong>题目：</strong>把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准。</p>
<p>例如, aab 应该返回 2 因为它总共有6中排列 (aab, aab, aba, aba, baa, baa), 但是只有两个 (aba and aba)没有连续重复的字符 (在本例中是 a).</p>
<p><strong>考察全排列</strong></p>
<p><strong>tips:</strong><a href="https://www.mathsisfun.com/combinatorics/combinations-permutations.html" target="_blank" rel="external">Permutations</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">RegExp</a> <a href="https://www.cnblogs.com/nokiaguy/archive/2008/05/11/1191914.html" target="_blank" rel="external">全排列算法原理和实现</a></p>
<p><strong>实现</strong></p>
<pre><code>//求一个字符串的全排列字符串中，不含连续重复字符的字符串个数
function permAlone(str) {
  //将输入字符串转化为数组
  strArr = str.split(&quot;&quot;);
  //求该字符串数组的全排列形式
  permResultArr = [];
  perm(strArr, 0, strArr.length-1);
  //找出全排列后非连续重复的字符串个数
  var count = 0;
  for(var i = 0; i &lt; permResultArr.length; i++) {
    if(conRepCharacter(permResultArr[i])) {
      count += 1;
    }
  }
  return count;
}

//判断一个字符串是否含连续重复的字符，若不包含连续重复字符，则返回true
function conRepCharacter(str) {
  if(str.length === 1) {
    return true;
  }
  for(var i = 0; i &lt; str.length-1; i++) {
    if(str[i+1] === str[i]) {
      return false;
    }
  }
  return true;
}

//交换数组中两个字符的位置
function swapCharacter(arr, i, j) {
  var temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
  return arr;
}

//求给定字符串数组的全排列,其中strArr表示输入字符串转化成的数组，flag表示递归到哪一位，end表示递归结束的位即字符串长度减1
function perm(strArr, flag, end) {
  //递归结束输出结果
  if(flag === end) {
    permResultArr.push(strArr.join(&quot;&quot;));
  }
  for(var i = flag; i &lt;= end; i++) {
    //将字符串中的所有字母分别与第一个字母交换
    strArr = swapCharacter(strArr, flag, i);
    //对交换后的字符串继续递归排列，由于第一个字母已经排列，因此从一个字母开始排列，即flag+1
    perm(strArr, flag+1, end);
    //由于在进入到下一次循环时序列是被改变了，可如果要假定第一个字母的所有可能性的话，必须是建立在这些序列的初始状态一致的情况下
    //因此通过再次交换恢复之前的排列顺序
     strArr = swapCharacter(strArr, flag, i);  
  }
  return permResultArr;
}
permAlone(&quot;abc&quot;);//返回6
</code></pre><h2 id="Friendly-Date-Ranges"><a href="#Friendly-Date-Ranges" class="headerlink" title="Friendly Date Ranges"></a>Friendly Date Ranges</h2><p><strong>题目：</strong>把常见的日期格式如：YYYY-MM-DD 转换成一种更易读的格式。<br>易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (1st 代替 1).</p>
<p>如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了；在这种情况下，如果月份开始和结束日期如果在同一个月，则结束日期月份也不用写了。另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。</p>
<p>例如:包含当前年份和相同月份的时候，makeFriendlyDates([“2017-01-02”, “2017-01-05”]) 应该返回 [“January 2nd”,”5th”]。不包含当前年份，makeFriendlyDates([“2003-08-15”, “2009-09-21”]) 应该返回 [“August 15th, 2003”, “September 21st, 2009”]。</p>
<p>考虑清楚所有可能出现的情况，包括传入的日期区间是否合理。对于不合理的日期区间，直接返回 undefined 即可。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external">String.split()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="external">String.substr()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt" target="_blank" rel="external">parseInt()</a></p>
<p><strong>实现</strong></p>
<pre><code>function makeFriendlyDates(arr) {
  var resultArr = [];
  //开始日期数组
  var startArr = arr[0].split(&quot;-&quot;);
  //结束日期数组
  var endArr = arr[1].split(&quot;-&quot;);

  //开始日期的年月日
  var sYear = parseInt(startArr[0], 10);
  var sMonth = parseInt(startArr[1], 10);
  var sDay = parseInt(startArr[2], 10);
  //结束日期的年月日
  var eYear = parseInt(endArr[0], 10);
  var eMonth = parseInt(endArr[1], 10);
  var eDay = parseInt(endArr[2], 10);

  //开始日期与结束日期之间相差的天数
  var distDays = (eYear-sYear)*365 + (eMonth-sMonth)*30 + eDay-sDay;

  //获取当前日期的年份
  var currDate = new Date();
  var currYear = currDate.getFullYear();

  //月份字符串数组
  var monthsArr = [&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;];
  //日字符串数组
  var daysArr = [&quot;1st&quot;,&quot;2nd&quot;,&quot;3rd&quot;,&quot;4th&quot;,&quot;5th&quot;,&quot;6th&quot;,&quot;7th&quot;,&quot;8th&quot;,&quot;9th&quot;,&quot;10th&quot;,&quot;11th&quot;,&quot;12th&quot;,&quot;13th&quot;,&quot;14th&quot;,&quot;15th&quot;,&quot;16th&quot;,&quot;17th&quot;,&quot;18th&quot;,&quot;19th&quot;,&quot;20th&quot;,&quot;21st&quot;,&quot;22nd&quot;,&quot;23rd&quot;,&quot;24th&quot;,&quot;25th&quot;,&quot;26th&quot;,&quot;27th&quot;,&quot;28th&quot;,&quot;29th&quot;,&quot;30th&quot;,&quot;31st&quot;];
  //先判断日期区间是否合理,若不合理返回undefined
  if(distDays &lt; 0) {
    return &quot;undefined&quot;;
  }
  //如果开始日期和结束日期一样，则返回一个
  if(sYear === eYear &amp;&amp; sMonth === eMonth &amp;&amp; sDay === eDay) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear];
    return resultArr;
  }
  //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期如果在同一个月，则开始日期年份、结束日期年份和月份也不用写了
  if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth === eMonth) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot;+ daysArr[sDay-1], daysArr[eDay-1]];
    return resultArr;
  }
  //如果开始日期年份是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则开始日期年份、结束日期年份不用写了
  if(currYear === sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sMonth !== eMonth) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1], monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]];
    return resultArr;
  }
  //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期在同一个月,则结束日期年份和月份不用写了
  if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear === eYear &amp;&amp; sMonth === eMonth) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, daysArr[eDay-1]];
    return resultArr;
  }
  //如果开始日期年份不是当前年份,结束日期与开始日期相差小于一年，月份开始和结束日期不在同一个月,则结束日期年份不用写了
  if(currYear !== sYear &amp;&amp; distDays &lt; 365 &amp;&amp; sYear !== eYear &amp;&amp; distDays &gt; 30) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1]];
    return resultArr;
  }
   //如果开始日期年份不是当前年份,结束日期与开始日期相差大于等于一年
  if(distDays &gt;= 365) {
    resultArr = [monthsArr[sMonth-1] + &quot; &quot; + daysArr[sDay-1] + &quot;, &quot; + sYear, monthsArr[eMonth-1] + &quot; &quot; + daysArr[eDay-1] + &quot;, &quot; + eYear];
    return resultArr;
  }

}
makeFriendlyDates([&quot;2001-12-20&quot;, &quot;2001-12-20&quot;]);//返回[&quot;December 20th, 2001&quot;]
</code></pre><h2 id="Make-a-Person"><a href="#Make-a-Person" class="headerlink" title="Make a Person"></a>Make a Person</h2><p><strong>题目：</strong>用下面给定的方法构造一个对象.</p>
<p>方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast).</p>
<p>所有有参数的方法只接受一个字符串参数.所有的方法只与实体对象交互.</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">Closures</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" target="_blank" rel="external">Details of the Object Model</a></p>
<p><strong>实现</strong></p>
<pre><code>var Person = function(firstAndLast) {
  this.getFirstName = function() {
    var arr = firstAndLast.split(&quot; &quot;);
    return arr[0];
  };
  this.getLastName = function() {
    var arr = firstAndLast.split(&quot; &quot;);
    return arr[1];
  };
  this.getFullName = function() {
    return firstAndLast;
  };
  this.setFirstName = function(first) {
    var arr = firstAndLast.split(&quot; &quot;);
    arr[0] = first;
    firstAndLast = arr.join(&quot; &quot;);
  };
  this.setLastName = function(last) {
    var arr = firstAndLast.split(&quot; &quot;);
    arr[1] = last;
    firstAndLast = arr.join(&quot; &quot;);
  };
  this.setFullName = function(firstAndLast2) {
    firstAndLast = firstAndLast2;
  };

};
var bob = new Person(&apos;Bob Ross&apos;);
bob.getFirstName();//返回&quot;Bob&quot;
</code></pre><h2 id="Map-the-Debris"><a href="#Map-the-Debris" class="headerlink" title="Map the Debris"></a>Map the Debris</h2><p><strong>题目：</strong>返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期.原数组中会包含格式化的对象内容，像这样 {name: ‘name’, avgAlt: avgAlt}.</p>
<p>求得的值应该是一个与其最接近的整数，轨道是以地球为基准的.</p>
<p>地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/pow" target="_blank" rel="external">Math.pow()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/round" target="_blank" rel="external">Math.round()</a></p>
<p><strong>实现</strong></p>
<pre><code>function orbitalPeriod(arr) {
  var GM = 398600.4418;
  var earthRadius = 6367.4447;

  //轨道周期公式 T=2π√(a^3/GM)
  for(var i = 0; i &lt; arr.length; i++) {
    //a为轨道半径，等于地球半径加平均海拔
    var  a = earthRadius + arr[i].avgAlt;
    var T1 = Math.sqrt(4 * Math.pow(Math.PI, 2) * Math.pow(a, 3) / GM);
    //将求得的周期转化为整数
    var T = Math.round(T1);
    //删除原有属性海拔
    delete arr[i].avgAlt;
    //添加新的属性轨道周期
    arr[i].orbitalPeriod = T;
  }  
  return arr;
}
orbitalPeriod([{name : &quot;sputnik&quot;, avgAlt : 35873.5553}]);//返回[{name: &quot;sputnik&quot;, orbitalPeriod: 86400}]
</code></pre><h2 id="Pairwise"><a href="#Pairwise" class="headerlink" title="Pairwise"></a>Pairwise</h2><p><strong>题目：</strong>举个例子：有一个能力数组[7,9,11,13,15]，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。</p>
<p>所以我们说函数：pairwise([7,9,11,13,15],20) 的返回值应该是0+3+1+2的和，即6。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">Array.reduce()</a>自己没有用上reduce()方法</p>
<p><strong>实现</strong></p>
<pre><code>function pairwise(arr, arg) {
  var sumIndex = 0;
  for(var i = 0; i &lt; arr.length; i++) {
    //与当前元素应该配对的元素值
    var pairVal = arg - arr[i];
    //配对元素应有的索引值,配对元素不能为自己
    var pairIndex = arr.indexOf(pairVal);
    //如果找到与当前元素配对的，则将这一对的索引值累加，并将当前元素和与之配对的元素值置为-1
    if(pairIndex !== -1 &amp;&amp; pairIndex !== i) {
      arr[i] = -1;
      arr[pairIndex] = -1;
      sumIndex += i + pairIndex;
    }
  }
  return sumIndex;
}
pairwise([1, 3, 2, 4], 4);//返回1
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个 freeCodeCamp JS高级算法编程例题的学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>react-demos学习笔记</title>
    <link href="http://yoursite.com/2017/11/20/react-demos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/11/20/react-demos学习笔记/</id>
    <published>2017-11-20T02:35:43.000Z</published>
    <updated>2018-01-09T02:47:02.942Z</updated>
    
    <content type="html"><![CDATA[<p>来自阮一峰的博客<a href="http://www.ruanyifeng.com/blog/2015/03/react.html" target="_blank" rel="external">React 入门实例教程</a>学习。<br><a id="more"></a></p>
<h2 id="JSX语法简介"><a href="#JSX语法简介" class="headerlink" title="JSX语法简介"></a>JSX语法简介</h2><p>React的核心机制之一就是可以在内存中创建虚拟的DOM元素。React利用虚拟DOM来减少对实际DOM的操作从而提升性能。</p>
<p><strong>JSX</strong> 就是Javascript和XML结合的一种格式。React发明了JSX，利用HTML语法来创建虚拟DOM。当遇到 <code>&lt;</code>，JSX就当HTML解析，遇到 <code>{</code> 就当JavaScript解析。</p>
<p>JS语法</p>
<pre><code>var child1 = React.createElement(&apos;li&apos;, null, &apos;First Text Content&apos;);
var child2 = React.createElement(&apos;li&apos;, null, &apos;Second Text Content&apos;);
var root = React.createElement(&apos;ul&apos;, { className: &apos;my-list&apos; }, child1, child2);
</code></pre><p>JSX语法</p>
<pre><code>var root =(
  &lt;ul className=&quot;my-list&quot;&gt;
    &lt;li&gt;First Text Content&lt;/li&gt;
    &lt;li&gt;Second Text Content&lt;/li&gt;
  &lt;/ul&gt;
);
</code></pre><p>JSX将XML语法直接加入JS中,通过代码而非模板来高效的定义界面。之后JSX通过翻译器转换为纯JS再由浏览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，JSX的语法不会带来任何性能影响。</p>
<p>另外，由于JSX只是一种语法，因此JavaScript的关键字class, for等也不能出现在XML中，而要如例子中所示，使用className, htmlFor代替，这和原生DOM在JavaScript中的创建也是一致的。JSX只是创建虚拟DOM的一种语法格式而已,除了用JSX,我们也可以用JS代码来创建虚拟DOM.</p>
<p>一篇简要介绍JSX语法的文章<a href="http://www.infoq.com/cn/articles/react-jsx-and-component" target="_blank" rel="external">深入浅出React（三）：理解JSX和组件</a>。</p>
<h2 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h2><p>使用 React 的网页源码，结构大致如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      // starts here
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>最后一个 <script\> 标签的 type 属性为 text/babel ,因为 React 独有的 JSX 语法，跟 JavaScript 不兼容。<strong>凡是使用 JSX 的地方，都要加上 type=”text/babel”</strong>。</script\></p>
<p>上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>
<h2 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render()"></a>ReactDOM.render()</h2><p>React最基本的方法，用于将模板转为 HTML 语言，并插入到指定的 DOM 节点。</p>
<pre><code>ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&apos;example&apos;)
);
</code></pre><p>上面代码将一个 h1 标题，插入到 example 节点。代码执行结果如下：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;../build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;../build/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;
      &lt;h1 data-reactroot=&quot;&quot;&gt;Hello, world!&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      ReactDOM.render(
        &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        document.getElementById(&apos;example&apos;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h2><p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写。</p>
<pre><code>&lt;body&gt;
   &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
   &lt;script type=&quot;text/babel&quot;&gt;
     var names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;];

     ReactDOM.render(
       &lt;div&gt;
       {
         names.map(function (name, index) {
           return &lt;div key={index}&gt;Hello, {name}!&lt;/div&gt;
         })
       }
       &lt;/div&gt;,
       document.getElementById(&apos;example&apos;)
     );
   &lt;/script&gt;
 &lt;/body&gt;
</code></pre><p>JSX 的基本语法规则：遇到 HTML 标签（以 <code>&lt;</code>开头），就用 HTML 规则解析；遇到代码块（以<code>{</code>开头），就用 JavaScript 规则解析。上述代码执行结果如下所示。</p>
<p><img src="/images/react-demo学习/1.png" alt="1"></p>
<p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员。</p>
<pre><code>var arr = [
  &lt;h1&gt;Hello world!&lt;/h1&gt;,
  &lt;h2&gt;React is awesome&lt;/h2&gt;,
];
ReactDOM.render(
  &lt;div&gt;{arr}&lt;/div&gt;,
  document.getElementById(&apos;example&apos;)
);
</code></pre><p>上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板，结果如下。</p>
<p><img src="/images/react-demo学习/2.png" alt="2"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。<strong>React.createClass()</strong> 方法就用于生成一个组件类。</p>
<pre><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
  }
});

ReactDOM.render(
  &lt;HelloMessage name=&quot;John&quot; /&gt;,
  document.getElementById(&apos;example&apos;)
);
</code></pre><p>上述代码中，变量 <strong>HelloMessage</strong> 就是一个组件类。模板插入 <hellomessage> 时，会自动生成 HelloMessage 的一个实例（下文的”组件”都指组件类的实例）。所有组件类都必须有自己的 render 方法，用于输出组件。执行结果如下所示。</hellomessage></p>
<p><img src="/images/react-demo学习/3.png" alt="3"></p>
<p><strong>组件的用法</strong>与原生的 HTML 标签完全一致，可以任意加入属性，比如 <code>&lt;HelloMessage name=&quot;John&quot;&gt;</code> ，就是 <code>HelloMessage</code> 组件加入一个 <code>name</code> 属性，值为 <code>John</code>。</p>
<p>组件的属性可以在组件类的 <code>this.props</code> 对象上获取，比如 <code>name</code> 属性就可以通过 <code>this.props.name</code> 读取。</p>
<p><strong>添加组件属性</strong>，需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。即在组件类中通过js获取组件的class属性时，需要使用<code>this.props.className</code>。</p>
<p><strong>注意</strong>，组件类的<strong>第一个字母必须大写</strong>，否则会报错，比如<code>HelloMessage</code>不能写成helloMessage。另外，组件类只能包含一个顶层标签，否则也会报错。</p>
<pre><code>var HelloMessage = React.createClass({
  render: function() {
    return &lt;h1&gt;
      Hello {this.props.name}
    &lt;/h1&gt;&lt;p&gt;   //错误，包含了两个顶层标签，h1和p
      some text
    &lt;/p&gt;;
  }
});
</code></pre><p>上面代码会报错，因为<code>HelloMessage</code>组件包含了两个顶层标签：<code>h1</code>和<code>p</code>。</p>
<h2 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a>this.props.children</h2><p>this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。它表示组件的所有子节点。</p>
<pre><code>var NotesList = React.createClass({
  render: function() {
    return (
      &lt;ol&gt;
      {
        React.Children.map(this.props.children, function (child) {
          return &lt;li&gt;{child}&lt;/li&gt;;
        })
      }
      &lt;/ol&gt;
    );
  }
});

ReactDOM.render(
  &lt;NotesList&gt;
    &lt;span&gt;hello&lt;/span&gt;
    &lt;span&gt;world&lt;/span&gt;
  &lt;/NotesList&gt;,
  document.body
);
</code></pre><p>上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取。执行结果如下所示。</p>
<p><img src="/images/react-demo学习/4.png" alt="4"></p>
<p><strong>注意</strong>， <code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。</p>
<p>React 提供一个工具方法 <strong>React.Children</strong> 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法。</p>
<h2 id="PropTypes组件属性"><a href="#PropTypes组件属性" class="headerlink" title="PropTypes组件属性"></a>PropTypes组件属性</h2><p>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。</p>
<p>组件类的<strong>PropTypes</strong>属性，就是用来验证组件实例的属性是否符合要求。例如：</p>
<pre><code>var MyTitle = React.createClass({
  propTypes: {
    title: React.PropTypes.string.isRequired,
  },

  render: function() {
     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
   }
});
</code></pre><p>上述代码中，Mytitle组件类有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。假如设置title属性的值是number类型就会报错，如下：</p>
<pre><code>var data = 123;

ReactDOM.render(
  &lt;MyTitle title={data} /&gt;,
  document.body
);
</code></pre><p>title属性就通不过验证了。控制台会显示一行警告信息，如下所示：</p>
<p><img src="/images/react-demo学习/5.png" alt="5"></p>
<p><img src="/images/react-demo学习/6.png" alt="6"></p>
<p><strong>getDefaultProps</strong> 方法可以用来设置组件属性的默认值.</p>
<pre><code>var MyTitle = React.createClass({
  getDefaultProps : function () {
    return {
      title : &apos;Hello World&apos;
    };
  },

  render: function() {
     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
   }
});

ReactDOM.render(
  &lt;MyTitle /&gt;,
  document.body
);
</code></pre><p>上面代码会输出”Hello World”。    </p>
<h2 id="获取真实的DOM节点"><a href="#获取真实的DOM节点" class="headerlink" title="获取真实的DOM节点"></a>获取真实的DOM节点</h2><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做<strong>虚拟 DOM</strong> （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM <a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="external">diff</a> ，它可以极大提高网页的性能表现。</p>
<p>但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 <code>ref</code> 属性。</p>
<pre><code>var MyComponent = React.createClass({
  handleClick: function() {
    this.refs.myTextInput.focus();
  },
  render: function() {
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot; /&gt;
        &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick={this.handleClick} /&gt;
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;MyComponent /&gt;,
  document.getElementById(&apos;example&apos;)
);
</code></pre><p>上述代码中，组件类 <code>MyComponent</code> 的子节点有一个文本输入框，用于获取用户的输入，这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为此，文本输入框必须有一个 <code>ref</code> 属性，然后 <code>this.refs.[refName]</code> 就会返回这个真实的 DOM 节点。</p>
<p><strong>注意</strong>，由于 <code>this.refs.[refName]</code> 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数 <code>handleClick</code>，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 <code>this.refs.[refName]</code> 属性。</p>
<p>React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看<a href="https://reactjs.org/docs/events.html#supported-events" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="this-state"><a href="#this-state" class="headerlink" title="this.state"></a>this.state</h2><p>组件免不了要与用户互动，React 的一大创新，就是<strong>将组件看成是一个状态机</strong>，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 。</p>
<pre><code>var LikeButton = React.createClass({
  getInitialState: function() {  //初始状态
    return {liked: false};
  },
  handleClick: function(event) {
    this.setState({liked: !this.state.liked});
  },
  render: function() {
    var text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;;
    return (
      &lt;p onClick={this.handleClick}&gt;
        You {text} this. Click to toggle.
      &lt;/p&gt;
    );
  }
});

ReactDOM.render(
  &lt;LikeButton /&gt;,
  document.getElementById(&apos;example&apos;)
);
</code></pre><p>上述组件类的 <strong>getInitialState</strong> 方法用于定义初始状态，也就是一个对象，这个对象可以通过 <code>this.state</code> 属性读取。</p>
<p>当用户点击组件， 调用Click 事件的回调函数 <code>handleClick</code>，导致状态变化。 <code>this.setState</code> 方法用于修改状态值，每次修改以后，自动调用 <code>this.render</code> 方法，再次渲染组件。</p>
<p>由于 <code>this.props</code> 和 <code>this.state</code> 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，<code>this.props</code> 表示那些一旦定义，就不再改变的特性，而 <code>this.state</code> 是会随着用户互动而产生变化的特性。</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。</p>
<pre><code>var Input = React.createClass({
  getInitialState: function() {
    return {value: &apos;Hello!&apos;};
  },
  handleChange: function(event) {
    this.setState({value: event.target.value});
  },
  render: function () {
    var value = this.state.value;
    return (
      &lt;div&gt;
        &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;
        &lt;p&gt;{value}&lt;/p&gt;
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(&lt;Input/&gt;, document.body);
</code></pre><p>文本输入框的值，不能用 <code>this.props.value</code> 读取，而要定义一个 <code>onChange</code> 事件的回调函数，通过 <code>event.target.value</code> 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><a href="https://reactjs.org/docs/refs-and-the-dom.html#component-lifecycle" target="_blank" rel="external">组件的生命周期</a>分成三个状态：</p>
<pre><code>Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM
</code></pre><p>React 为每个状态都提供了两种处理函数，<code>will</code> 函数在进入状态之前调用，<code>did</code> 函数在进入状态之后调用，三种状态共计五种处理函数。</p>
<pre><code>componentWillMount()
componentDidMount()
componentWillUpdate(object nextProps, object nextState)
componentDidUpdate(object prevProps, object prevState)
componentWillUnmount()     
</code></pre><p>此外，React 还提供两种特殊状态的处理函数。</p>
<pre><code>componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用
shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用
</code></pre><p>栗子:</p>
<pre><code>var Hello = React.createClass({
  getInitialState: function () {
    return {
      opacity: 1.0
    };
  },

  componentDidMount: function () {
    this.timer = setInterval(function () {
      var opacity = this.state.opacity;
      opacity -= .05;
      if (opacity &lt; 0.1) {
        opacity = 1.0;
      }
      this.setState({
        opacity: opacity
      });
    }.bind(this), 100);
  },

  render: function () {
    return (
      &lt;div style={{opacity: this.state.opacity}}&gt;
        Hello {this.props.name}
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;Hello name=&quot;world&quot;/&gt;,
  document.body
);
</code></pre><p>上述代码在Hello组件加载以后，通过 <code>componentDidMoun</code>t 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。执行结果如下所示：</p>
<p><img src="/images/react-demo学习/7.png" alt="7"></p>
<p><strong>注意：</strong>组件的style属性的设置方式也值得注意，不能写成 </p>
<pre><code>style=&quot;opacity:{this.state.opacity};&quot;
</code></pre><p>要写成</p>
<pre><code>style={{opacity: this.state.opacity}}
</code></pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 <strong>componentDidMount 方法设置 Ajax 请求</strong>，等到请求成功，再用 this.setState 方法重新渲染 UI。</p>
<pre><code>var UserGist = React.createClass({
  getInitialState: function() {
    return {
      username: &apos;&apos;,
      lastGistUrl: &apos;&apos;
    };
  },

  componentDidMount: function() {
    $.get(this.props.source, function(result) {
      var lastGist = result[0];
      if (this.isMounted()) {
        this.setState({
          username: lastGist.owner.login,
          lastGistUrl: lastGist.html_url
        });
      }
    }.bind(this));
  },

  render: function() {
    return (
      &lt;div&gt;
        {this.state.username}&apos;s last gist is
        &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,
  document.body
);
</code></pre><p>上面代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。<strong>React 本身没有任何依赖</strong>，完全可以不用jQuery，而使用其他库。</p>
<p>我们甚至可以把一个<code>promise</code>对象传入组件。</p>
<pre><code>ReactDOM.render(
  &lt;RepoList
    promise={$.getJSON(&apos;https://api.github.com/search/repositories?q=javascript&amp;sort=stars&apos;)}
  /&gt;,
  document.body
);
</code></pre><p>上面代码从Github的API抓取数据，然后将promise对象作为属性，传给RepoList组件。</p>
<p>如果promise对象正在抓取数据（pending状态），组件显示”正在加载”；如果promise对象报错（rejected状态），组件显示报错信息；如果promise对象抓取数据成功（fulfilled状态），组件显示获取的数据。</p>
<pre><code>var RepoList = React.createClass({
  getInitialState: function() {
    return { loading: true, error: null, data: null};
  },

  componentDidMount() {
    this.props.promise.then(
      value =&gt; this.setState({loading: false, data: value}),
      error =&gt; this.setState({loading: false, error: error}));
  },

  render: function() {
    if (this.state.loading) {
      return &lt;span&gt;Loading...&lt;/span&gt;;
    }
    else if (this.state.error !== null) {
      return &lt;span&gt;Error: {this.state.error.message}&lt;/span&gt;;
    }
    else {
      var repos = this.state.data.items;
      var repoList = repos.map(function (repo) {
        return (
          &lt;li&gt;
            &lt;a href={repo.html_url}&gt;{repo.name}&lt;/a&gt; ({repo.stargazers_count} stars) &lt;br/&gt; {repo.description}
          &lt;/li&gt;
        );
      });
      return (
        &lt;main&gt;
          &lt;h1&gt;Most Popular JavaScript Projects in Github&lt;/h1&gt;
          &lt;ol&gt;{repoList}&lt;/ol&gt;
        &lt;/main&gt;
      );
    }
  }
});
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自阮一峰的博客&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/03/react.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React 入门实例教程&lt;/a&gt;学习。&lt;br&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>freeCodeCamp JavaScript中级算法编程学习总结</title>
    <link href="http://yoursite.com/2017/11/16/freeCodeCamp-%E4%B8%AD%E7%BA%A7%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/11/16/freeCodeCamp-中级算法编程/</id>
    <published>2017-11-16T13:49:52.000Z</published>
    <updated>2018-01-09T02:47:02.938Z</updated>
    
    <content type="html"><![CDATA[<p>几个 freeCodeCamp JS中级算法编程例题的学习总结。<br><a id="more"></a></p>
<h2 id="Sum-All-Numbers-in-a-Range"><a href="#Sum-All-Numbers-in-a-Range" class="headerlink" title="Sum All Numbers in a Range"></a>Sum All Numbers in a Range</h2><p><strong>题目：</strong>传递给一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。（最小的数字并非总在最前面。）</p>
<p><strong>tips:</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max" target="_blank" rel="external">Math.max()</a> &nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min" target="_blank" rel="external">Math.min()</a>&nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">Array.reduce()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function sumAll(arr) {
  //获取两个数中的最小值
  var min = Math.min(arr[0], arr[1]);
  //获取两个数中的最大值
  var max = Math.max(arr[0], arr[1]);
  //将区间里的整数顺序添加到数组里
  var array = [];
  for (i = min; i &lt; max + 1; i++) {
    array.push(i);
  }
  //利用.reduce()方法累加数组中的元素并返回
  var total = array.reduce(function(sum,val) {
    return sum += val;

  });
  return total;
}

sumAll([1, 4]);
</code></pre><p><strong>实现2</strong></p>
<pre><code>function sumAll(arr) {  
  var max = Math.max(arr[0],arr[1]);  
  var min = Math.min(arr[0],arr[1]);  
  var total = 0;
  //不使用.reduce()方法实现累加，直接使用for循环实现累加  
  for(var i = min; i &lt; max + 1; i++) {  
    total += i;  
  }  
  return total;  
} 
</code></pre><h2 id="Diff-Two-Arrays"><a href="#Diff-Two-Arrays" class="headerlink" title="Diff Two Arrays"></a>Diff Two Arrays</h2><p><strong>题目：</strong>比较两个数组，然后返回一个新数组，该数组的元素为两个给定数组中所有独有的数组元素。换言之，返回两个数组的差异。</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" target="_blank" rel="external">Comparison Operators</a> &nbsp;<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="external">Array.slice()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">Array.filter()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="external">Array.indexOf()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" target="_blank" rel="external">Array.concat()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function diff(arr1, arr2) {
  var newArr = [];
  //比较两个数组大小，判断较长的数组中的每个元素是否在短数组中出现过，若没有出现过则.indexOf()方法返回-1
  if (arr1.length &gt;= arr2.length) {  
    for (i = 0; i &lt; arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) === -1) {
        newArr.push(arr1[i]);
      }
    }
  }
  for (i = 0; i &lt; arr2.length; i++) {
    if (arr1.indexOf(arr2[i]) === -1) {
      newArr.push(arr2[i]);
    }
  }

  return newArr;
}
//测试，返回4
diff([1, 2, 3, 5], [1, 2, 3, 4, 5]);
</code></pre><p><strong>实现2</strong></p>
<pre><code>function diff(arr1, arr2) {  
  var newArr = [];  
  var arr3 = [];  
  for (var i=0;i&lt;arr1.length;i++) {  
    if(arr2.indexOf(arr1[i]) === -1)     
      arr3.push(arr1[i]);  
  }  
   var arr4 = [];  
  for (var j=0;j&lt;arr2.length;j++) {  
    if(arr1.indexOf(arr2[j]) === -1)  
      arr4.push(arr2[j]);  
  }  
   newArr = arr3.concat(arr4);  
  return newArr;  
} 
</code></pre><p>实现1是自己的想法，只用一次for循环即可得到比较结果。实现2是看到部分博主用的方法。</p>
<h2 id="Roman-Numeral-Converter"><a href="#Roman-Numeral-Converter" class="headerlink" title="Roman Numeral Converter"></a>Roman Numeral Converter</h2><p><strong>题目：</strong>将给定的数字转换成罗马数字。</p>
<p><strong>tips：</strong><a href="http://www.shuxuele.com/roman-numerals.html" target="_blank" rel="external">Roman Numerals</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="external">Array.splice()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="external">Array.indexOf()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank" rel="external">Array.join()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function convert(num) {
  //只转换小于4000的数字为罗马数字，大于4000的罗马数字上面要加横线，在此暂不考虑转换
  if (num &gt;= 4000) {
    console.log(&quot;please convert a number less than 4000!&quot;);
  }
  //将num的各位提取出来，即num = thousands * 1000 + hundreds * 100 + tens * 10 + units;
  var thousands = Math.floor(num / 1000) ;
  var hundreds = Math.floor((num % 1000) / 100);
  var tens = Math.floor((num % 100) / 10);
  var units = num % 10;
  var roman = [];
  //当千位不为0时，将千位转化为罗马数字
  while (thousands !== 0) {
    switch(thousands) {
      case 1: roman.splice(0, 0, &quot;M&quot;);
        break;
      case 2: roman.splice(0, 0, &quot;M&quot;,&quot;M&quot;);
        break;
      case 3: roman.splice(0, 0, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;);
        break;
    }
    thousands = 0;    
  }
  // 当百位不为0时，将百位转化为罗马数字
  while (hundreds !== 0) {
    // 记录最后一个千位罗马数字索引加一
    var lastIdxT = roman.length;
    switch(hundreds) {
      case 1: roman.splice(lastIdxT, 0, &quot;C&quot;);
        break;
      case 2: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;);
        break;
      case 3: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;);
        break;
      case 4: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;D&quot;);
        break;
      case 5: roman.splice(lastIdxT, 0, &quot;D&quot;);
        break;
      case 6: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;);
        break;
      case 7: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;);
        break;
      case 8: roman.splice(lastIdxT, 0, &quot;D&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;);
        break;
      case 9: roman.splice(lastIdxT, 0, &quot;C&quot;, &quot;M&quot;);
        break;
    }
    hundreds = 0;
  }
  // 当十位不为0时，将十位转化为罗马数字
  while(tens !== 0) {
    // 记录最后一个百位罗马数字索引加一
    var lastIdxH = roman.length;
    switch(tens) {
      case 1: roman.splice(lastIdxH, 0, &quot;X&quot;);
        break;
      case 2: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;);
        break;
      case 3: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;);
        break;
      case 4: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;L&quot;);
        break;
      case 5: roman.splice(lastIdxH, 0, &quot;L&quot;);
        break;
      case 6: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;);
        break;
      case 7: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;);
        break;
      case 8: roman.splice(lastIdxH, 0, &quot;L&quot;, &quot;X&quot;, &quot;X&quot;, &quot;X&quot;);
        break;
      case 9: roman.splice(lastIdxH, 0, &quot;X&quot;, &quot;C&quot;);
        break;
    }
    tens = 0;
  }
  // 记录最后一个十位罗马数字索引加一
  var lastIdxTen = roman.length; 
  switch(units) {
    case 1: roman.splice(lastIdxTen, 0, &quot;I&quot;);
      break;
    case 2: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;);
      break;
    case 3: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;);
      break;
    case 4: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;V&quot;);
      break;
    case 5: roman.splice(lastIdxTen, 0, &quot;V&quot;);
      break;
    case 6: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;);
      break;
    case 7: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;);
      break;
    case 8: roman.splice(lastIdxTen, 0, &quot;V&quot;, &quot;I&quot;, &quot;I&quot;, &quot;I&quot;);
      break;
    case 9: roman.splice(lastIdxTen, 0, &quot;I&quot;, &quot;X&quot;);
      break;
  }
 return roman.join(&quot;&quot;); 
}
convert(36);
</code></pre><p><strong>实现2</strong></p>
<pre><code>function convert(num) { 
  //将分割数和对应的罗马字符分别存入两个数组 
  var nums = [1000,900,500,400,100,90,50,40,10,9,5,4,1];  
  var romans =[&quot;m&quot;,&quot;cm&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;c&quot;,&quot;xc&quot;,&quot;l&quot;,&quot;xl&quot;,&quot;x&quot;,&quot;ix&quot;,&quot;v&quot;,&quot;iv&quot;,&quot;i&quot;];  
  var str = &quot;&quot;;  
  nums.forEach(function(item,index,array){  
    while(num &gt;= item){  
      str += romans[index];  
      num -= item;  
    }  
  });         
 return str.toUpperCase();  
}        
convert(36);  
</code></pre><p>实现2是来自一位博主<a href="http://blog.csdn.net/qq_37399074/article/details/68922119" target="_blank" rel="external">将给定的数字转换为罗马数字</a>，代码精简易懂，自己的实现看起来冗长幼稚，需要学习的还很多哇！</p>
<h2 id="Where-art-thou"><a href="#Where-art-thou" class="headerlink" title="Where art thou"></a>Where art thou</h2><p><strong>题目：</strong>写一个 function，它遍历一个对象数组（第一个参数）并返回一个包含相匹配的属性-值对（第二个参数）的所有对象的数组。如果返回的数组中包含 source 对象的属性-值对，那么此对象的每一个属性-值对都必须存在于 collection 的对象中。</p>
<p>例如，如果第一个参数是 <code>[{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]</code>，第二个参数是 <code>{ last: &quot;Capulet&quot; }</code>，那么你必须从数组（第一个参数）返回其中的第三个对象，因为它包含了作为第二个参数传递的属性-值对。</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="external">Global Object</a>&nbsp;  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" target="_blank" rel="external">Object.hasOwnProperty()</a> &nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="external">Object.keys()</a>&nbsp; <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">Array.prototype.filter()</a></p>
<p><strong>实现</strong></p>
<pre><code>function where(collection, source) {
var arr = [];
//获取source对象的所有属性名并保存在数组keys中 
var keys = Object.keys(source);
//filter() 方法创建一个新数组, 其包含通过所提供函数测试的所有元素,callback用来测试数组的每个元素，返回true则保留该元素
arr = collection.filter(function(element) {
  for(var i = 0; i &lt; keys.length; i++) {
    if(!element.hasOwnProperty(keys[i]) || element[keys[i]] !== source[keys[i]]) return false;
  }
  return true;
});
return arr;
}
//返回 [{ first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }]
where([{ first: &quot;Romeo&quot;, last: &quot;Montague&quot; }, { first: &quot;Mercutio&quot;, last: null }, { first: &quot;Tybalt&quot;, last: &quot;Capulet&quot; }], { last: &quot;Capulet&quot; });
</code></pre><h2 id="Search-and-Replace"><a href="#Search-and-Replace" class="headerlink" title="Search and Replace"></a>Search and Replace</h2><p><strong>题目：</strong>使用给定的参数对句子执行一次查找和替换，然后返回新句子。</p>
<p>第一个参数是将要对其执行查找和替换的句子。</p>
<p>第二个参数是将被替换掉的单词（替换前的单词）。</p>
<p>第三个参数用于替换第二个参数（替换后的单词）。</p>
<p>注意：替换时保持原单词的大小写。例如，如果你想用单词 “dog” 替换单词 “Book” ，你应该替换成 “Dog”。</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="external">Array.splice()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">String.replace()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank" rel="external">Array.join()</a></p>
<p><strong>实现</strong></p>
<pre><code>function myReplace(str, before, after) {
  //获取需被替换的单词before的首字母的位置index，indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。  
  var index = str.indexOf(before);      
  //判断before首字母是否为大写，若为大写，则让after首字母也大写  
  if(str[index]===str[index].toUpperCase()){  
    after = after[0].toUpperCase() + after.substring(1);  //也可以用slice(1)  
  }
  //替换，stringObject.replace(regexp/substr,replacement)
  return str.replace(before, after);  
}
/***
判断字母是否为大写
function isUpperCase(ch){
    return ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;;
}
判断字母是否为小写
function isLowerCase(ch){
    return ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;;
}
将单词的首字母大写
function firstUpperCase(str) {
  var afterStr = str.toLowerCase().replace(/^\w/g,function(s){return s.toUpperCase();});
  return afterStr;
}
***/
// charAt()方法可返回字符串指定位置的字符，stringObject.charAt(index)
myReplace(&quot;A quick brown fox jumped over the lazy dog&quot;, &quot;jumped&quot;, &quot;leaped&quot;);
</code></pre><h2 id="Pig-Latin"><a href="#Pig-Latin" class="headerlink" title="Pig Latin"></a>Pig Latin</h2><p><strong>题目：</strong>把指定的字符串翻译成 pig latin。</p>
<p><a href="https://en.wikipedia.org/wiki/Pig_Latin" target="_blank" rel="external">Pig Latin</a> 把一个英文单词的第一个辅音或辅音丛（consonant cluster）移到词尾，然后加上后缀 “ay”。</p>
<p>如果单词以元音开始，你只需要在词尾添加 “way” 就可以了。</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" target="_blank" rel="external">Array.indexOf()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="external">Array.push()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join" target="_blank" rel="external">Array.join()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/substr" target="_blank" rel="external">String.substr()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external">String.split()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function translate(str) {
  // 元音
  var vowel = [&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;];
  // 如果单词首字母以元音开头，直接在单词后面加&apos;way&apos;
  if(vowel.indexOf(str.substr(0,1)) !== -1) {
    return str + &quot;way&quot;;
  }
  /*** 只要单词是以辅音或辅音丛开始，将该辅音移到后面，最后加&apos;ay&apos;。
  while循环每次都检查移动辅音后的单词，移动一个辅音字母后若还不是元音字母，继续移动，移完后再加&quot;ay&quot;***/
  while(vowel.indexOf(str.substr(0,1)) == -1) {
    str = str.substr(1) + str.substr(0,1);
  }
  return str + &quot;ay&quot;;
}
translate(&quot;glove&quot;);//测试数据&quot;california&quot;，&quot;paragraphs&quot;，&quot;algorithm&quot;，&quot;eight&quot;
</code></pre><p><strong>实现2</strong></p>
<pre><code>function translate(str) {
    var tempArr = [];
    var answer;
    tempArr = str.split(&apos;&apos;);//将str分解为单个字符存入数组
    var i = 0;
    //如果首个字符不是元音则 i++，如果首个字符是元音则退出while循环
    while (tempArr[i] != &apos;a&apos; &amp;&amp; tempArr[i] != &apos;o&apos; &amp;&amp; tempArr[i] != &apos;i&apos; &amp;&amp; tempArr[i] != &apos;e&apos; &amp;&amp; tempArr[i] != &apos;u&apos;) {
      i++;
    }
    answer = str.substr(i);//将str辅音或辅音丛后面的部分提取出来
    answer += str.substr(0,i);//再将辅音或辅音丛部分追加在answer后
    //i=0时，首字母为元音，在变换之后加&quot;way&quot;
    if(i === 0) {
      answer += &quot;way&quot;;
    }
    //i不为0时，首字母为辅音或辅音丛，在变换后加&quot;ay&quot;
    else {
      answer += &quot;ay&quot;;
    }
    return answer;
}
</code></pre><h2 id="DNA-Pairing"><a href="#DNA-Pairing" class="headerlink" title="DNA Pairing"></a>DNA Pairing</h2><p><strong>题目：</strong>DNA 链缺少配对的碱基。依据每一个碱基，为其找到配对的碱基，然后将结果作为第二个数组返回。</p>
<p><a href="https://en.wikipedia.org/wiki/Base_pair" target="_blank" rel="external">Base pairs（碱基对）</a> 是一对 AT 和 CG，为给定的字母匹配缺失的碱基。</p>
<p>在每一个数组中将给定的字母作为第一个碱基返回。字母和与之配对的字母在一个数组内，然后所有数组再被组织起来封装进一个数组。例如，对于输入的 GCG，相应地返回 [[“G”, “C”], [“C”,”G”],[“G”, “C”]]</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="external">Array.push()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="external">String.split()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function pair(str) {
  var inputArr = [];
  var resultArr = [];
  //将输入字符串按单个字母拆分为数组
  inputArr = str.split(&apos;&apos;);
  //对输入数组的每一种情况配对，GC,CG,AT,TA
  inputArr.forEach(function(item, index) {
    switch(item) {
      case &quot;G&quot;:
        resultArr.push([&quot;G&quot;,&quot;C&quot;]);
        break;
      case &quot;C&quot;:
        resultArr.push([&quot;C&quot;,&quot;G&quot;]);
        break;
      case &quot;A&quot;:
        resultArr.push([&quot;A&quot;,&quot;T&quot;]);
        break;
      case &quot;T&quot;:
        resultArr.push([&quot;T&quot;,&quot;A&quot;]);
        break;        
    }
  });  
  return resultArr;
}
pair(&quot;GCG&quot;);//返回 [[&quot;G&quot;, &quot;C&quot;], [&quot;C&quot;,&quot;G&quot;],[&quot;G&quot;, &quot;C&quot;]]
</code></pre><p>实现2和实现3来自<a href="http://blog.csdn.net/wangmc0827/article/details/72630469" target="_blank" rel="external">博客</a>。</p>
<p><strong>实现2</strong></p>
<p>解题思路：把字符串进行匹配和对应关系进行匹配，将匹配到的字符推入该数组。最后将所有的数组推入一个新的数组。</p>
<p>匹配方式：用对象存储对应关系。</p>
<pre><code>function pair(str) {  
  var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;};  
  var arr = [];  
  for(var i in str){  
    arr.push([str[i],obj[str[i]]]);  
  }  
  return arr;  
}        
pair(&quot;GCG&quot;); 
</code></pre><p><strong>实现3</strong></p>
<p>用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">map</a>函数来进行优化,其实就是简化了写法。map函数可以改变原有的数组，给予指定的方法就可以了。</p>
<pre><code>function pair(str) {  
  var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;};  
  //ES6 的写法 
  return str.split(&apos;&apos;).map(e =&gt; [e,obj[e]]);  
}        
pair(&quot;GCG&quot;);
</code></pre><p>ES5 的写法</p>
<pre><code>function pair(str) {  
  var obj = {&apos;A&apos;:&apos;T&apos;,&apos;T&apos;:&apos;A&apos;,&apos;G&apos;:&apos;C&apos;,&apos;C&apos;:&apos;G&apos;};  
  return str.split(&apos;&apos;).map(function(e){   
    return [e,obj[e]];  
  });  
}        
pair(&quot;GCG&quot;); 
</code></pre><h2 id="Missing-letters"><a href="#Missing-letters" class="headerlink" title="Missing letters"></a>Missing letters</h2><p><strong>题目：</strong>从传递进来的字母序列中找到缺失的字母并返回它。如果所有字母都在序列中，返回 undefined。</p>
<p><strong>tips：</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt" target="_blank" rel="external">String.charCodeAt()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode" target="_blank" rel="external">String.fromCharCode()</a></p>
<p><strong>实现</strong></p>
<pre><code>function fearNotLetter(str) {
  var resultStr = &quot;&quot;;
  //先判断所有字母是否都在序列中,若都在则返回undefined
  if((str.charCodeAt(0) + str.length - 1) === str.charCodeAt(str.length - 1) ) {
    return undefined;
  } else {
    //若不然，则根据str每个字母的编码是否连续来返回缺失字母
    for (i = 0; i &lt; str.length - 1; i++) { 
      var startCode = str.charCodeAt(i);
      var nextCode = str.charCodeAt(i + 1);
      //如果相邻两个字母之间的编码不连续，则将两个字母之间缺失的字母追加到resultStr中
      while ( nextCode - startCode !== 1) {
         resultStr += String.fromCharCode(startCode + 1);
        startCode ++;
      }     
    }
  }  
  return resultStr;
}
fearNotLetter(&quot;abce&quot;);//返回&quot;d&quot;
fearNotLetter(&quot;abch&quot;);//返回&quot;defg&quot;
</code></pre><p>关于此题目的回答，比较了一些博主的答案，他们的答案大多只满足两个输入相邻字母之间只缺少一个字母的情况，对于缺失多个字母的情况没有考虑。自己的回答考虑到了两个相邻字母之间缺失多个字母的情况。</p>
<h2 id="Boo-who"><a href="#Boo-who" class="headerlink" title="Boo who"></a>Boo who</h2><p><strong>题目：</strong>检查一个值是否是基本布尔类型，并返回 true 或 false。基本布尔类型即 true 和 false。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean" target="_blank" rel="external">Boolean Objects</a></p>
<p><strong>补充：</strong>5种简单数据类型（基本数据类型）：Undefined、Null、Boolean、Number、String。 1种复杂数据类型Object（包括Function、Array、Date等）。</p>
<pre><code>typeof操作符返回下列某个字符串：
&quot;undefined&quot;---未定义
&quot;boolean&quot;---布尔值
&quot;string&quot;---字符串
&quot;number&quot;---数值
&quot;object&quot;---对象或null
&quot;function&quot;---函数
</code></pre><p><strong>实现</strong></p>
<pre><code>function boo(bool) {
  //使用typeof操作符检测数据类型
  return typeof(bool) === &quot;boolean&quot; ? true : false;//可直接写为 return typeof bool===&apos;boolean&apos;;  
}
boo(null);//返回false
</code></pre><h2 id="Sorted-Union"><a href="#Sorted-Union" class="headerlink" title="Sorted Union"></a>Sorted Union</h2><p><strong>题目：</strong>写一个 function，传入两个或两个以上的数组，返回一个以给定的原始数组排序的但不包含重复值的新数组。</p>
<p>换句话说，新数组中的所有值都应该以原始顺序被包含在内，但是不包含重复值。即非重复的数字应该以它们原始的顺序排序。例如unite([1, 3, 2], [5, 2, 1, 4], [2, 1]) 应该返回 [1, 3, 2, 5, 4]。unite([1, 3, 2], [1, [5]], [2, [4]]) 应该返回 [1, 3, 2, [5], [4]]。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">Arguments object</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">Array.reduce()</a></p>
<p><strong>实现1</strong></p>
<pre><code>function unite(arr1, arr2, arr3) {
  //unite函数的输入参数类对象数组arguments
  for(i = 1; i &lt; arguments.length; i ++) {
    for (j = 0; j &lt; arguments[i].length; j ++) {
      //若第i个输入数组的第j个数字在第一个数组中没出现过，则追加到第一个数组中，否则什么也不做
      if (arr1.indexOf(arguments[i][j]) == -1) {
        arr1.push(arguments[i][j]);
      }
    }
  }
  return arr1;
}
unite([1, 3, 2], [5, 2, 1, 4], [2, 1]);//返回[1,3,2,5,4]
</code></pre><p><strong>实现2</strong></p>
<p>思路：先将多个输入参数（数组）合并，再去重。来源于<a href="http://www.jianshu.com/p/51301859043c" target="_blank" rel="external">简书</a>。</p>
<pre><code>function unite(arr1, arr2, arr3) {
  //Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例，即返回[arr1, arr2, arr3]的形式
  var args = Array.from(arguments);
  //reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其减少为单个值。
  var arr = args.reduce(function(accumulator,cur){
    //将多个输入数组合并为一个数组arr,即返回[1,3,2,5,2,1,4,2,1]的形式
    return accumulator.concat(cur);
  });
  var resultArr = [];
  //对合并后的数组arr去重
  return resultArr = arr.filter(function(item,index){
    //返回true则filter到结果数组，indexOf()方法返回第一个匹配元素的index，
    //后面重复元素的indexOf返回值为该元素第一次出现时的index（比如对第二个2应用indexOf返回2）
    return arr.indexOf(item) === index;
  });
}
</code></pre><h2 id="Convert-HTML-Entities"><a href="#Convert-HTML-Entities" class="headerlink" title="Convert HTML Entities"></a>Convert HTML Entities</h2><p><strong>题目：</strong>将字符串中的字符 &amp;、&lt;、&gt;、” （双引号）, 以及 ‘ （单引号）转换为它们对应的 HTML 实体。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">RegExp</a> <a href="https://dev.w3.org/html5/html-author/charref" target="_blank" rel="external">HTML Entities</a></p>
<p><strong>实现</strong></p>
<pre><code>function convert(str) {
  //替换规则映射对象
  var entityMap = {  
    &apos;&amp;&apos; : &apos;&amp;amp;&apos;, 
    &apos;&lt;&apos; : &apos;&amp;lt;&apos;,  
    &apos;&gt;&apos; : &apos;&amp;gt;&apos;,  
    &apos;\&quot;&apos; : &apos;&amp;quot;&apos;,  
    &apos;\&apos;&apos; : &apos;&amp;apos;&apos; ,
  };
  //使用string的replace规则，将匹配到的字符根据替换规则替换掉
  return str.replace(/[&amp;&lt;&gt;&quot;&apos;]/g, function(matched) {
    return entityMap[matched];
  });  
}  
convert(&quot;Dolce &amp; Gabbana&quot;);//输出结果&quot;Dolce &amp;amp; Gabbana&quot;
</code></pre><h2 id="Spinal-Tap-Case"><a href="#Spinal-Tap-Case" class="headerlink" title="Spinal Tap Case"></a>Spinal Tap Case</h2><p><strong>题目：</strong>将字符串转换为 spinal case。Spinal case 是 all-lowercase-words-joined-by-dashes 这种形式的，也就是以连字符连接所有小写单词。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp" target="_blank" rel="external">RegExp</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">String.replace()</a></p>
<p><strong>实现</strong></p>
<pre><code>function spinalCase(str) {
  //将str分为两类，一类是以空格、下划线、短横线连接的字符串；一类是驼峰形式的字符串
  //驼峰形式的字符串
  if(str.split(/\W|_/).length === 1) {
    for (i = 0; i &lt; str.length; i++) {
      //找到所有单词的首写大写字母，并用短横线和对应小写替换
      if (str[i].toUpperCase() === str[i]) {
        str = str.replace(str[i], &quot;-&quot;+str[i].toLowerCase());
      }
    }
  }
  //以空格、下划线、短横线连接的字符串，先转换为小写再替换
  else {
    //注意匹配模式加上全局标志，否则只会找到第一个匹配
    str = str.toLowerCase().replace(/\W|_/g, &quot;-&quot;);    
  }
  return str;
}
spinalCase(&apos;This Is Spinal Tap&apos;);//返回 &quot;this-is-spinal-tap&quot;
spinalCase(&quot;The_Andy_Griffith_Show&quot;);//返回 &quot;the-andy-griffith-show&quot;
spinalCase(&quot;Teletubbies say Eh-oh&quot;);//返回 &quot;teletubbies-say-eh-oh&quot;
spinalCase(&quot;thisIsSpinalTap&quot;);//返回 &quot;this-is-spinal-tap&quot;
</code></pre><h2 id="Sum-All-Odd-Fibonacci-Numbers"><a href="#Sum-All-Odd-Fibonacci-Numbers" class="headerlink" title="Sum All Odd Fibonacci Numbers"></a>Sum All Odd Fibonacci Numbers</h2><p><strong>题目：</strong>给一个正整数num，返回小于或等于num的斐波纳契奇数之和。</p>
<p>斐波纳契数列中的前几个数字是 1、1、2、3、5 和 8，随后的每一个数字都是前两个数字之和。</p>
<p>例如，sumFibs(4)应该返回 5，因为斐波纳契数列中所有小于4的奇数是 1、1、3。</p>
<p>提示：此题不能用递归来实现斐波纳契数列。因为当num较大时，内存会溢出，推荐用数组来实现。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_(.25" target="_blank" rel="external">Remainder</a>) <a href="http://www.cnblogs.com/meteoric_cry/archive/2010/11/29/1891241.html" target="_blank" rel="external">参考文档</a></p>
<p><strong>实现</strong></p>
<pre><code>function sumFibs(num) {
  //先找到所有小于num的斐波那契数，并存在数组fibsArr中
  var fibsArr = [1, 1, 2];
  for(i = 2; i &lt; num; i++) {
    if (fibsArr[i] + fibsArr[i-1] &lt;= num) {
      fibsArr.push(fibsArr[i] + fibsArr[i-1]);
    }
  }
  //筛选出fibsArr中的奇数并求和
  var sum = fibsArr.filter(function(element, index) {
    //若为奇数则返回
    return element % 2 !== 0;
  }).reduce(function(prev, curr) {
    return prev += curr;
  });
  return sum;
}
sumFibs(1);//返回2
</code></pre><h2 id="Sum-All-Primes"><a href="#Sum-All-Primes" class="headerlink" title="Sum All Primes"></a>Sum All Primes</h2><p><strong>题目：</strong>求小于等于给定数值的质数之和。 给定的数不一定是质数。</p>
<p>只有 1 和它本身两个约数的数叫质数。例如，2 是质数，因为它只能被 1 和 2 整除。1 不是质数，因为它只能被自身整除。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for" target="_blank" rel="external">For Loops</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="external">Array.push()</a></p>
<p><strong>实现</strong></p>
<pre><code>//判断一个数是不是素数
function isPrime(num) {
  //判断输入是否为number类型，是否为整数
  if(typeof(num) !== &apos;number&apos; || !Number.isInteger(num)) {
    return false;
  }
  //num小于2时，不是素数
  if(num &lt; 2) {return false;}
  //num等于2时，是素数
  if(num === 2) {return true;}
  //num大于2时，如果num可以被2整除（即num为偶数），不是素数
   else if(num % 2 === 0) {return false;}
  //num大于2时，依次判断num能否被奇数整除，最大循环为num的开方 
  var range = Math.ceil(Math.sqrt(num));
  for(var i = 3; i &lt;= range; i+=2) {
  if(num % i === 0) {return false;}
  }
  return true;
}
//求小于等于给定数值的质数之和
function sumPrimes(num) {
  var sum = 0;
  for(var i = 0; i &lt;= num; i ++) {
    //对于小于num的每个数先判断是否为素数，若为素数则叠加
    if(isPrime(i)) {
      sum += i;
    }
  }
  return sum;
}
sumPrimes(977);//返回73156
</code></pre><h2 id="Smallest-Common-Multiple"><a href="#Smallest-Common-Multiple" class="headerlink" title="Smallest Common Multiple"></a>Smallest Common Multiple</h2><p><strong>题目：</strong>找出能被两个给定参数和它们之间的连续数字整除的最小公倍数。</p>
<p>范围是两个数字构成的数组，两个数字不一定按数字顺序排序。</p>
<p>例如对 1 和 3 —— 找出能被 1 和 3 和它们之间所有数字整除的最小公倍数。</p>
<p><strong>tips:</strong><a href="https://www.mathsisfun.com/least-common-multiple.html" target="_blank" rel="external">Smallest Common Multiple</a> <a href="https://baike.baidu.com/item/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/4625352?fr=aladdin" target="_blank" rel="external">辗转相除法</a></p>
<p><strong>思路：</strong>最小公倍数 = 两个数的积 / 最大公约数</p>
<p>最大公约数用辗转相除法（欧几里得算法）求得，即当 <code>a mod b=0</code>时，<code>gcd(a,b)=0</code>,否则<code>gcd(a,b)=gcd(b,a mod b)</code>。</p>
<p>求连续几个数的最小公倍数，可以先求得边界两个数的最小公倍数，再用此最小公倍数依次和中间的数值求最小公倍数，从而得到所有数的最小公倍数。</p>
<p><strong>实现</strong></p>
<pre><code>function smallestCommons(arr) {
  //首先对两个给定参数排序,按从小到大排序
  arr.sort(function(a, b) {
    return a - b;
  });
  //求a和b的最小公倍数
  var a = arr[0];
  var b = arr[1];
  //flag表示边界两个数的最小公倍数
  var flag = smallestCommonMultiple(a, b);
  //用flag依次和中间的数值求最小公倍数，即得最终的最小公倍数
  for(var i = a +1; i &lt; b; i ++) {
    flag = smallestCommonMultiple(flag, i);
  }
  return flag;
}
//欧几里得算法求两个数的最大公约数,a&lt;=b
function gcd (a, b) {
  //当除数为零时，最大公约数为被除数a
  if(!b) {return a;}
  //否则辗转相除
  return gcd(b, a%b);
}
//求两个数的最小公倍数
function smallestCommonMultiple(a, b) {
  return a * b / gcd(a, b);
}
smallestCommons([1,5]);//返回60
</code></pre><h2 id="Finders-Keepers"><a href="#Finders-Keepers" class="headerlink" title="Finders Keepers"></a>Finders Keepers</h2><p><strong>题目：</strong>写一个 function，它遍历数组 arr，并返回数组中第一个满足 func 返回值的元素。举个例子，如果 arr 为 [1, 2, 3]，func 为 function(num) {return num === 2; }，那么 find 的返回值应为 2。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">Array.filter()</a></p>
<p><strong>实现</strong></p>
<pre><code>function find(arr, func) {
  var num = 0;
  //注意filter()方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
  //而我们只需要返回第一个满足func的元素
  num = arr.filter(func).length === 0 ? undefined : arr.filter(func)[0];
  return num;
}
find([1, 2, 3, 4], function(num){ return num % 2 === 0; });//返回2
</code></pre><h2 id="Drop-it"><a href="#Drop-it" class="headerlink" title="Drop it"></a>Drop it</h2><p><strong>题目：</strong>丢弃数组(arr)的元素，从左边开始，直到回调函数return true就停止。</p>
<p>第二个参数，func，是一个函数。用来测试数组的第一个元素，如果返回fasle，就从数组中抛出该元素(注意：此时数组已被改变)，继续测试数组的第一个元素，如果返回fasle，继续抛出，直到返回true。</p>
<p>最后返回数组的剩余部分，如果没有剩余，就返回一个空数组。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">Arguments object</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" target="_blank" rel="external">Array.shift()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="external">Array.slice()</a></p>
<p><strong>实现</strong></p>
<pre><code>function drop(arr, func) {
  //只要func返回false就左移抛出该元素，继续判断左移后的第一个元素是否满足条件
    while(!func(arr[0])) {
      //shift() 方法从数组中删除第一个元素，并返回该元素的值。shift()方法会改变原数组
      arr.shift();
    }    
  return arr;
}
drop([1, 2, 3], function(n) {return n &lt; 3; });
</code></pre><h2 id="Steamroller"><a href="#Steamroller" class="headerlink" title="Steamroller"></a>Steamroller</h2><p><strong>题目：</strong>对嵌套的数组进行扁平化处理。你必须考虑到不同层级的嵌套。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="external">Array.isArray()</a></p>
<p><strong>实现</strong></p>
<pre><code>function steamroller(arr) {
  //扁平化处理后的数组
  var afterArr = [];
  for(var i = 0; i &lt; arr.length; i ++) {
    //依次判断数组中元素类型是否为数组
    //如果元素是数组类型，继续对该元素做数组扁平化处理
    if(Array.isArray(arr[i])) {
      var midArr = steamroller(arr[i]);
      afterArr = afterArr.concat(midArr);
     //如果不是数组类型，则将该元素push进afterArr储存 
    }else {
      afterArr.push(arr[i]);        
      }
    } 
  return afterArr;
}
steamroller([1, [2], [3, [[4]]]]);//返回[1,2,3,4]
</code></pre><h2 id="Binary-Agents"><a href="#Binary-Agents" class="headerlink" title="Binary Agents"></a>Binary Agents</h2><p><strong>题目：</strong>传入二进制字符串，翻译成英语句子并返回。二进制字符串是以空格分隔的。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt" target="_blank" rel="external">String.charCodeAt()</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode" target="_blank" rel="external">String.fromCharCode()</a></p>
<p><strong>实现</strong></p>
<pre><code>function binaryAgent(str) {
  var strToArr = [];
  var afterTrans = &quot;&quot;;
  //将二进制字符串按空格划分为字符串数组，并转化为number类型，十进制形式
  str.split(&quot; &quot;).forEach(function(item,index) {
    //将二进制形式转化为十进制形式
    strToArr.push(parseInt(item, 2));
  });
  afterTrans = strToArr.reduce(function(prev, curr) {
    //将数组中的十进制Unicode码通过String.fromCharCode()方法转换为字母，利用reduce()方法依次处理数组元素并拼接成字符串
    return prev + String.fromCharCode(curr);
  },&quot;&quot;);
  return afterTrans;
}
binaryAgent(&quot;01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001&quot;);//返回&quot;I love FreeCodeCamp!&quot;
</code></pre><h2 id="Everything-Be-True"><a href="#Everything-Be-True" class="headerlink" title="Everything Be True"></a>Everything Be True</h2><p><strong>题目：</strong>完善编辑器中的every函数，如果集合(collection)中的所有对象都存在对应的属性(pre)，并且属性(pre)对应的值为真。函数返回ture。反之，返回false。</p>
<p>记住：你只能通过中括号来访问对象的变量属性(pre)。</p>
<p><strong>tips:</strong>可以有多种实现方式，最简洁的方式莫过于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">Array.prototype.every()</a></p>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。</p>
<p>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</p>
<p><strong>实现</strong></p>
<pre><code>function every(collection, pre) {
  //使用every() 方法测试数组的所有元素是否都通过了指定函数的测试。
  var flag = collection.every(function(item, index) {
    //如果对象不存在pre属性，则返回false
    if(!item.hasOwnProperty(pre)) {return false;}
    //测试pre属性的值是否为true
    if(!item[pre]) {return false;}
    return true;    
  });
  return flag;
}
every([{&quot;user&quot;: &quot;Tinky-Winky&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Dipsy&quot;, &quot;sex&quot;: &quot;male&quot;}, {&quot;user&quot;: &quot;Laa-Laa&quot;, &quot;sex&quot;: &quot;female&quot;}, {&quot;user&quot;: &quot;Po&quot;, &quot;sex&quot;: &quot;female&quot;}], &quot;sex&quot;);//返回true
</code></pre><p>换一种简洁的写法：</p>
<pre><code>function every(collection, pre) {
  return collection.every(function(elements){
    return elements.hasOwnProperty(pre) &amp;&amp; Boolean(elements[pre]);
  });
}
</code></pre><h2 id="Arguments-Optional"><a href="#Arguments-Optional" class="headerlink" title="Arguments Optional"></a>Arguments Optional</h2><p><strong>题目：</strong>创建一个计算两个参数之和的 function。如果只有一个参数，则返回一个 function，该 function 请求一个参数然后返回求和的结果。</p>
<p>例如，<code>add(2, 3)</code> 应该返回 5，而 add(2) 应该返回一个 function。调用这个有一个参数的返回的 function，返回求和的结果：<code>var sumTwoAnd = add(2)</code>;<code>sumTwoAnd(3)</code> 返回 5。如果两个参数都不是有效的数字，则返回 undefined。</p>
<p><strong>tips:</strong><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="external">Closures</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external">Arguments object</a></p>
<p><strong>实现</strong></p>
<pre><code>function add() {
    //如果add有两个参数，则返回两个参数的和
    if(arguments.length === 2 &amp;&amp; typeof arguments[0] === &quot;number&quot; &amp;&amp; typeof arguments[1] === &quot;number&quot;) {
      return arguments[0] + arguments[1];
    }
    //如果add有一个参数，则通过闭包方式返回一个函数
    if(arguments.length === 1 &amp;&amp; typeof arguments[0] === &quot;number&quot;) {
      var x = arguments[0];
      //通过闭包方式返回只有一个参数的函数
      return function(y) {
        if(typeof y === &quot;number&quot;) {
          return x + y;}
        return undefined;
        };
    }    
  return undefined;
}
add(2,3);//返回5
add(2)(3);//返回5
add(2)([3]);//返回undefined
add(2, &quot;3&quot;);//返回undefined
add(&quot;http://bit.ly/IqT6zt&quot;);//返回undefined
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个 freeCodeCamp JS中级算法编程例题的学习总结。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSONP简要了解</title>
    <link href="http://yoursite.com/2017/11/15/JSONP%E7%AE%80%E8%A6%81%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/11/15/JSONP简要了解/</id>
    <published>2017-11-15T13:08:22.000Z</published>
    <updated>2018-01-09T02:47:02.934Z</updated>
    
    <content type="html"><![CDATA[<p>在freeCodeCamp上学习使用twith TV API获取频道信息时，在freeCodeCamp的指导中提到若使用<code>$.getJSON(()</code>方法会因为跨域资源共享(CORS)问题发生错误信息。<a href="https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-how-to-use-the-twitchtv-api/19541" target="_blank" rel="external"> freeCodeCamp Challenge Guide: How to Use the TwitchTV API </a>中建议使用jQuery的JSONP方法来解决CORS问题。<br><a id="more"></a></p>
<h2 id="JSONP的诞生"><a href="#JSONP的诞生" class="headerlink" title="JSONP的诞生"></a>JSONP的诞生</h2><p>传统ajax无法跨域，而<script\>标签的src属性是可以跨域的,可以通过把跨域服务器写成<strong>调用本地的函数</strong> ，回调数据回来。</script\></p>
<p>json刚好被js支持（<strong>object</strong>）</p>
<p>调用跨域服务器上动态生成的js格式文件（<strong>不管是什么类型的地址，最终生成的返回值都是一段js代码</strong>）</p>
<p>这种获取远程数据的方式看起来非常像ajax，但其实并不一样，便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作<strong>JSONP</strong>。</p>
<p>传递一个<strong>callback参数</strong>给跨域服务端，然后跨域服务端返回数据时会将这个callback参数作为函数名来包裹住json数据即可。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>（1）<strong>跨域服务器</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：<strong>remote.js</strong></p>
<pre><code>alert(&quot;我是远程文件&quot;);
</code></pre><p><strong>本地</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt;
</code></pre><p>在本地<script\>标签直接引入一个js文件，页面将会弹出警告框。</script\></p>
<p>（2）<strong>跨域服务器</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：<strong>remote.js</strong></p>
<pre><code>localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});
</code></pre><p><strong>本地</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt; 
    var localHandler = function(data){
        alert(&apos;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&apos; + data.result); 
    }; 
&lt;/script&gt; 
&lt;script type=&quot;text/javascript&quot; src=&quot;跨域服务器/remote.js&quot;&gt;&lt;/script&gt;
</code></pre><p>该例子中在本地定义了一个函数<code>localHandler</code>，在本地通过<script\>标签的<code>src</code>属性引入了跨域服务器上的一个js文件<code>remote.js</code>，在引入的js文件里调用了本地定义的函数<code>localHandler</code>。</script\></p>
<p><strong>问题</strong>：如何让远程js文件知道它应该调用的本地函数的名字呢？毕竟jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同。</p>
<p>（3）<strong>跨域服务器</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文件：<strong>flightResult.php</strong></p>
<pre><code>flightHandler({
    &quot;code&quot;:&quot;CA1998&quot;,
    &quot;price&quot;: 1780,
    &quot;tickets&quot;: 5
});
</code></pre><p><strong>本地</strong></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt; 
    // 得到航班信息查询结果后的回调函数 
    var flightHandler = function(data){
        alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;);
    }; 
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） 
    var url = &quot;跨域服务器/flightResult.php?code=CA1998&amp;callback=flightHandler&quot;;
    // 创建script标签，设置其属性 
    var script = document.createElement(&apos;script&apos;); 
    script.setAttribute(&apos;src&apos;, url); 
    // 把script标签加入head，此时调用开始 
    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); 
&lt;/script&gt;
</code></pre><p>在该例中动态创建<script\>标签（动态创建脚本）； url中传递了一个code参数，服务器去做查询CA1998次航班的信息，callback参数告诉服务器，我的本地回调函数叫做flightHandler； 跨域服务端调用这个函数flightHandler，页面将会弹出一个提示窗体，显示出票价和余票。</script\></p>
<h2 id="JSONP方法中服务器做的事情"><a href="#JSONP方法中服务器做的事情" class="headerlink" title="JSONP方法中服务器做的事情"></a>JSONP方法中服务器做的事情</h2><pre><code>// 数据
$data = [
    &quot;name&quot;:&quot;anonymous66&quot;,
    &quot;age&quot;:&quot;18&quot;,
    &quot;like&quot;:&quot;jianshu&quot;
];
// 接收callback函数名称
$callback = $_GET[&apos;callback&apos;];
// 输出
echo $callback . &quot;(&quot; . json_encode($data) . &quot;)&quot;;
</code></pre><p>服务器端做的就是获取url中的callback参数，并将callback参数作为函数名来包裹json数据，动态生成js文件，再返回给客户端。</p>
<h2 id="JSONP与AJAX的区别"><a href="#JSONP与AJAX的区别" class="headerlink" title="JSONP与AJAX的区别"></a>JSONP与AJAX的区别</h2><p>ajax的核心是通过XMLHttpRequest获取非本页内容。</p>
<p>jsonp的核心则是动态添加<script\>标签来调用服务器提供的js脚本。</script\></p>
<h2 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h2><p>优点：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都 可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>
<p>缺点：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。JSONP是一种脚本注入(Script Injection)行为，所以有一定的安全隐患。</p>
<p>转自：segmentfault专栏<a href="https://segmentfault.com/a/1190000007935557" target="_blank" rel="external">JSONP是什么</a></p>
<p>参考：<a href="http://blog.csdn.net/z69183787/article/details/19191385" target="_blank" rel="external">JSONP原理优缺点(只能GET不支持POST) </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在freeCodeCamp上学习使用twith TV API获取频道信息时，在freeCodeCamp的指导中提到若使用&lt;code&gt;$.getJSON(()&lt;/code&gt;方法会因为跨域资源共享(CORS)问题发生错误信息。&lt;a href=&quot;https://forum.freecodecamp.org/t/freecodecamp-challenge-guide-how-to-use-the-twitchtv-api/19541&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; freeCodeCamp Challenge Guide: How to Use the TwitchTV API &lt;/a&gt;中建议使用jQuery的JSONP方法来解决CORS问题。&lt;br&gt;
    
    </summary>
    
      <category term="jsonp" scheme="http://yoursite.com/categories/jsonp/"/>
    
    
      <category term="jsonp" scheme="http://yoursite.com/tags/jsonp/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>ajax-imooc</title>
    <link href="http://yoursite.com/2017/11/06/ajax-imooc/"/>
    <id>http://yoursite.com/2017/11/06/ajax-imooc/</id>
    <published>2017-11-06T08:13:39.000Z</published>
    <updated>2018-01-09T02:47:02.936Z</updated>
    
    <content type="html"><![CDATA[<p>ajax,即异步JavaScript和XML，通过在后台和服务器少量的数据交换实现页面的异步局部加载更新。<br>ajax中一个关键的对象 <strong>XMLHttpRequest</strong>对象，作为网页和服务器之间交换数据的桥梁，来实现网页的异步请求、局部刷新。<br><a id="more"></a></p>
<h2 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h2><p>在现代浏览器中创建XMLHttpRequest对象</p>
<pre><code>var request = new XMLHttpRequest();//现代浏览器
</code></pre><p>若在早期老版本浏览器中，考虑兼容性，创建XMLHttpRequest对象方式如下：</p>
<pre><code>var request;
if(window.XMLHttpRequest) {
request = new XMLHttpRequest();
} else {
request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE6,IE5
}
</code></pre><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP是一种无状态协议。一个HTTP请求包括以下7个步骤：</p>
<ul>
<li>建立TCP连接</li>
<li>WEB浏览器向WEB服务器发送请求命令</li>
<li>WEB浏览器发送请求头信息</li>
<li>WEB服务器应答</li>
<li>WEB服务器发送应答头信息</li>
<li>WEB服务器向浏览器发送数据</li>
<li>WEB服务器关闭TCP连接</li>
</ul>
<p><strong>HTTP请求</strong><br>一个HTTP请求一般由四部分组成：</p>
<ul>
<li>HTTP请求的方法和动作，比如GET或POST请求</li>
<li>正在请求的URL</li>
<li>请求头，包含一些客户端环境信息、身份验证信息等</li>
<li>请求体，即请求正文，包含客户提交的查询字符串信息、表单信息等<br>一般来说请求头和请求正文之间有一个空行，表示请求头结束。<br><a href="http://blog.csdn.net/findsafety/article/details/47129021" target="_blank" rel="external">一篇关于GET、POST请求的博文详解</a><br><strong>GET:</strong>一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符。(用于查询，一般不用于新建和修改。默认为GET提交)<br><strong>POST:</strong>一般用于修改服务器上的资源，对所发送信息的数量无限制。<br><strong>HTTP响应</strong><br>一个HTTP响应一般由三部分组成：</li>
<li>一个数字和文字组成的状态码，表示请求成功还是失败</li>
<li>响应头，包含服务器类型、日期时间、内容类型、长度等</li>
<li>响应体，即响应正文<br>HTTP状态码的类型：<br><img src="/images/ajax-imooc/1.png" alt="1"></li>
</ul>
<h2 id="XMLHttpRequest发送请求"><a href="#XMLHttpRequest发送请求" class="headerlink" title="XMLHttpRequest发送请求"></a>XMLHttpRequest发送请求</h2><p>两个方法，open和send</p>
<ul>
<li>open(method, url, async)</li>
<li><p>send(string)<br>open方法用于设置请求，第一个参数method表示请求的类型，即GET或POST；第二个参数url即请求的地址，绝对地址或相对地址；第三个参数表示是否异步请求，默认为true。<br>send方法用于发送请求，当使用get请求时，send可不给出参数，而使用post请求时必须有参数。<br>例如：</p>
<p> request.open(“POST”,”create.php”,true);<br> request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded “)//设置HTTP头信息，一定要写在open()和send()之间<br> request.send(“name=xxxx&amp;sex=xxx”);</p>
</li>
</ul>
<h2 id="XMLHttpRequest取得响应"><a href="#XMLHttpRequest取得响应" class="headerlink" title="XMLHttpRequest取得响应"></a>XMLHttpRequest取得响应</h2><p><img src="/images/ajax-imooc/2.png" alt="2"><br>通过监听XMLHttpRequest对象readyState属性的变化，判断服务器的状态变化信息。<br><img src="/images/ajax-imooc/3.png" alt="3"><br>通过.onreadystatechange()方法监听readyState属性的变化，当readyState为4（响应完成）并且status为200(请求成功)时，再对响应数据做处理：</p>
<pre><code>var request = new XMLHttpRequest();
request.open(&quot;POST&quot;,&quot;get.php&quot;,true);
request.send();
request.onreadystatechange = function() {
  if(request.readyState == 4 &amp;&amp; request.status == 200) {
  //做一些处理，例如request.responseText
 }
}
</code></pre><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p><img src="/images/ajax-imooc/4.png" alt="4"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ajax,即异步JavaScript和XML，通过在后台和服务器少量的数据交换实现页面的异步局部加载更新。&lt;br&gt;ajax中一个关键的对象 &lt;strong&gt;XMLHttpRequest&lt;/strong&gt;对象，作为网页和服务器之间交换数据的桥梁，来实现网页的异步请求、局部刷新。&lt;br&gt;
    
    </summary>
    
      <category term="ajax" scheme="http://yoursite.com/categories/ajax/"/>
    
    
      <category term="ajax" scheme="http://yoursite.com/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>planeGame-H5 Canvas小游戏未完成的问题</title>
    <link href="http://yoursite.com/2017/10/30/planeGameQuestion/"/>
    <id>http://yoursite.com/2017/10/30/planeGameQuestion/</id>
    <published>2017-10-30T08:31:25.000Z</published>
    <updated>2018-01-09T02:47:02.941Z</updated>
    
    <content type="html"><![CDATA[<p>H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。<br><a id="more"></a></p>
<h2 id="未完成内容"><a href="#未完成内容" class="headerlink" title="未完成内容"></a>未完成内容</h2><h3 id="游戏设置部分"><a href="#游戏设置部分" class="headerlink" title="游戏设置部分"></a>游戏设置部分</h3><p>音乐设置（HTML5 audio相关的学习，包括设置游戏背景音乐以及各种子弹、爆炸等声音，以及切换声音的开启和关闭）</p>
<p>背景设置（即切换背景图片）</p>
<p>战机设置（即切换战机plane的icon图片）</p>
<h3 id="存在问题的地方"><a href="#存在问题的地方" class="headerlink" title="存在问题的地方"></a>存在问题的地方</h3><p>点击“再玩一次”之后，敌机以及子弹的速度会越来越快，差不多第三次重玩就无法进行了。感觉是因为上一次游戏过程中的一些数据没有清除，怀疑过是不是setInterval()的原因，百度了查了好多，在end处添加了window.clearInterval()，但也是无济于事。特将此问题记录，以待后面将js学深了再来解决。</p>
<h3 id="可以改进的地方"><a href="#可以改进的地方" class="headerlink" title="可以改进的地方"></a>可以改进的地方</h3><p>游戏结束以后，除了“再玩一次”，再添加一个“退出游戏”功能，使页面切换到index状态。</p>
<p>适应手机端的，试了下在电脑上战机移动不了，应该是手指移动事件那里还未考虑鼠标移动来兼容电脑浏览器。</p>
<h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p>主页面如下：</p>
<p><img src="/images/planeGameQuestion/1.png" alt="1"></p>
<p>游戏结束，“再玩一次”界面</p>
<p><img src="/images/planeGameQuestion/2.png" alt="2"></p>
<h2 id="github源码"><a href="#github源码" class="headerlink" title="github源码"></a>github源码</h2><p>github仓库地址：<a href="https://github.com/shirley5li/demo-planegame" target="_blank" rel="external">demo-planegame</a></p>
<p>放在gh-pages上的样子，电脑端战机移动不了。<a href="https://shirley5li.github.io/demo-planegame/" target="_blank" rel="external">demo展示</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;H5 Canvas打飞机游戏中未完成以及存在疑惑的地方。&lt;br&gt;
    
    </summary>
    
      <category term="Canvas" scheme="http://yoursite.com/categories/Canvas/"/>
    
    
      <category term="HTML5" scheme="http://yoursite.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>JS笔记(二)DOM操作--from next十天训练营</title>
    <link href="http://yoursite.com/2017/10/20/next-js2/"/>
    <id>http://yoursite.com/2017/10/20/next-js2/</id>
    <published>2017-10-20T12:21:29.000Z</published>
    <updated>2018-01-09T02:47:02.941Z</updated>
    
    <content type="html"><![CDATA[<p>JS调用DOM接口修改样式。<br><a id="more"></a></p>
<h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><p><img src="/images/next-js2/1.png" alt="1"></p>
<p>上图是一张网页的生成过程，大致分为五步：</p>
<p>（1）html代码转化为DOM树</p>
<p>（2）CSS代码转化成CSSOM（CSS Object Model）</p>
<p>（3）结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）</p>
<p>（4）生成布局（layout），即将所有渲染树的所有节点进行平面合成</p>
<p>（5）将布局绘制（paint）在屏幕上</p>
<p>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。</p>
<p>其中，在html文档生成DOM树后，JS可以通过DOM提供的接口来添加、删除、修改元素和样式。</p>
<h2 id="DOM查找"><a href="#DOM查找" class="headerlink" title="DOM查找"></a>DOM查找</h2><p>查找API:</p>
<pre><code>document.getElementById()//通过元素id查找，查找一个元素

[document|Element].getElementsByClassName()//通过元素类名查找，查找一组元素，得到一个类数组(html collection)

[document|Element].getElementsByTagName()//通过元素标签名查找,查找一组元素，得到一个类数组

[document|Element].querySelector()//通过CSS选择器查找，例如 var qId = document.querySelector(&apos;#id&apos;);

[document|Element].querySelectorAll()//通过CSS选择器查找
</code></pre><p>后两者常用。</p>
<h2 id="DOM新增和删除"><a href="#DOM新增和删除" class="headerlink" title="DOM新增和删除"></a>DOM新增和删除</h2><p>（1）新增节点<br>新增一个元素时，包括插入和追加。前面插入用insertBefore()，后面追加用appendChild()。</p>
<pre><code>parent.appendChild(element)//新增节点到父元素的末尾

parentElement.insertBefore(newElement, targetElement)//新增节点到targetElement元素的前面
</code></pre><p>注意：使用.insertBefore()方法时，不必搞清楚父元素到底是哪个，因为targetElement元素的parentNode属性值就是它。所以可以通过<code>targetElement.parentNode.insertBefore(newElement, targetElement)</code>来插入。</p>
<p>新增多个元素时，可以利用上述两个方法结合循环实现，但循环会导致一个问题，因为直接操作DOM会导致浏览器反复渲染。利用DocumentFragment节点解决这个反复渲染问题。</p>
<p><strong>DocumentFragment</strong>文档片段，可以理解为“轻量级”的节点。有两个属性，分别为：nodeType = 11, nodeName = #document-fragment。<br>DocumentFragment作为仓库来使用，不在DOM树中，游离在DOM树之外。当增加多个节点时，可将这多个节点临时存放在DocumentFragment仓库中，最后再一次性插入DOM树中，就解决了浏览器反复渲染的问题。</p>
<p>（2）删除节点<br>删除节点使用removeChild()</p>
<p>（3）创建节点</p>
<p>此时创建出的节点即为DocumentFragment文档碎片，创建完以后再插入或者追加到DOM树中。</p>
<pre><code>document.createElement(nodeName)//创建元素节点,nodeName即为h1,h2,li,p,....

document.creatTextNode(text)//创建文本节点
</code></pre><p><strong>练习题</strong></p>
<p>题目要求:现有 HTML 代码如下,</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;按要求新增元素&lt;/h1&gt;
&lt;/body&gt;
</code></pre><p>在h1元素的后面新增一个ul元素，ul元素中有一百个li元素，li的内容就是 1-100 ，如下所示：</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;按要求新增元素&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;1&lt;/li&gt;
        &lt;li&gt;2&lt;/li&gt;
        &lt;li&gt;3&lt;/li&gt;
        ......
        &lt;li&gt;98&lt;/li&gt;
        &lt;li&gt;99&lt;/li&gt;
        &lt;li&gt;100&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre><p>js代码如下：</p>
<pre><code>var len = 100;
var ul = document.createElement(&apos;ul&apos;);
var body = document.getElementsByTagName(&apos;body&apos;)[0];
for(var i = 0; i &lt; len; i++){
    var li = document.createElement(&apos;li&apos;);
    var liText = document.createTextNode(i+1);
    li.appendChild(liText);
    ul.appendChild(li);

} 
body.appendChild(ul);
</code></pre><h2 id="DOM修改样式"><a href="#DOM修改样式" class="headerlink" title="DOM修改样式"></a>DOM修改样式</h2><p>两种方式修改元素样式：通过元素style属性修改；通过元素class属性修改。</p>
<p>（1）style属性</p>
<p>style属性包含着元素诸如颜色大小等样式，style属性是一个对象。如访问style对象的color属性：<code>element.style.color</code>。</p>
<p>注意：当引用一个中间带减号的CSS属性时，DOM要求用驼峰命名法。CSS属性font-family变为了DOM属性fontFamily：<code>element.style.fontFamily</code>。这是因为减号和加号之类的操作符是保留字，不允许用在函数或变量的名字里，意味着也不能用在方法和属性的名字里。</p>
<p>缺点：style属性只能返回内嵌样式。即只有把CSS style属性插入到标记里，才可以用DOM style属性去获取那些属性信息。DOM style属性不能用来检索外部CSS文件里声明的样式。</p>
<p>（2）class属性</p>
<p>利用DOM修改元素的class属性（比如新增一个class或者删除一个class），使得利用外部CSS文件中的设置的样式改变元素的样式，而不是用DOM直接操作style属性修改样式。</p>
<p>例如要给要给elem元素设置class属性为intro，方法如下：</p>
<p><strong>a.</strong>利用setAttribute()方法, <code>elem.setAttribute(&quot;class&quot;,&quot;intro&quot;)</code></p>
<p><strong>b.</strong>通过更新className属性。className属性是一个可读可写的属性，凡是元素节点都有这个属性。可以用className属性获取一个元素的class属性，<code>element.className</code>。</p>
<p>用className属性和赋值操作符设置一个元素的class属性：<code>element.className = value</code></p>
<p>该方法的<strong>不足</strong>，通过className属性设置某个元素的class属性时将替换该元素原有的属性（而不是追加）。</p>
<p><strong>在需要给一个元素追加新的class时，可以按照以下思路：</strong></p>
<p>检查className属性的是否为null；</p>
<p>如果是，把新的class设置值直接赋值给className属性；</p>
<p>若不是，把一个空格和新的class设置值追加到className属性上去。</p>
<p>把上述步骤封装为一个函数addClass,该函数有两个参数，第一个为需要添加的新class的元素，第二个是新的class设置值。</p>
<pre><code>function addClass(element, value){
    if(!element.className){
        element.className = value;
    }else{
        newClassName = element.className;
        newClassName+= &quot; &quot;;
        newClassName+=value;
        element.className = newClassName;
    }
}
</code></pre><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><pre><code>&lt;!DOCTTYPE html&gt;
&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;事件简介&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;section&gt;
        &lt;button id=&quot;button&quot;&gt;点击切换背景颜色&lt;/button&gt;
    &lt;/section&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>针对上述代码，当点击了button后事件反应机制有两种(这两种是上古时代的做法 。 。)</p>
<p>第一种是点击button后，button将事件传递到section，再传递到body，再传递到html，再传递到document。该种方式即为事件冒泡机制。<br>如下图所示：</p>
<p><img src="/images/next-js2/2.png" alt="2"></p>
<p>第二种是点击button后，从document开始一层层捕获，即为事件捕获机制。如下图所示。</p>
<p><img src="/images/next-js2/3.png" alt="3"></p>
<p>目前<strong>标准的DOM事件流</strong>做法分为三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。</p>
<p>事件捕获阶段的结束阶段为目标元素的父元素，然后是处于目标阶段，接下来是事件冒泡阶段。在实际开发过程中，由于浏览器兼容问题，事件捕获过程基本不用，会频繁使用目标和事件冒泡。流程如下所示。</p>
<p><img src="/images/next-js2/4.png" alt="4"></p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p><strong>添加</strong>事件处理程序：</p>
<pre><code>element.addEventListener(type, handle, false)//type表示事件类型，handle为事件处理函数，false表示采用冒泡机制
</code></pre><p><strong>删除</strong>事件处理程序：</p>
<pre><code>element.removeEventListener(type, handle)
</code></pre><p>例如：</p>
<pre><code>h1.addEventListener(&apos;click&apos;, function(){
    console.log(this);//this指向绑定事件处理函数的对象，即h1元素
}, false);
</code></pre><p><strong>事件对象</strong></p>
<p>事件对象包含着所有与事件相关的信息。</p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   //event即为事件处理对象，包括了触发点击事件时鼠标的位置等等信息
    console.log(&apos;event&apos;, event);  //将event对象打印出来并查看event对象包含哪些信息
}
h1.addEventListener(&apos;click&apos;, handle, false);
</code></pre><p><strong>事件冒泡</strong></p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   
    console.log(&apos;event&apos;, event);  
}
document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上
</code></pre><p>虽然点击事件绑定在body上，但此时点击h1元素，仍会触发事件打印event对象。此为事件冒泡。</p>
<p>流程：当点击目标元素h1，先找h1上有没有点击事件，有则触发，没有则按照冒泡机制一层层往上找，看有没有点击事件，直到冒泡到document。</p>
<p>阻止事件冒泡：</p>
<pre><code>var h1 = document.querySelector(&apos;h1&apos;);
var handle = function(event) {   
    console.log(&apos;event&apos;, event);  
}
document.body.addEventListener(&apos;click&apos;, handle, false);//将点击事件函数绑定在body上
h1.addEventListener(&apos;click&apos; function(event) {
event.stopPropagation();//阻止事件冒泡，当点击h1元素时，不会触发点击事件
}, false);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JS调用DOM接口修改样式。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS笔记(一)--from next十天训练营</title>
    <link href="http://yoursite.com/2017/10/20/next-js/"/>
    <id>http://yoursite.com/2017/10/20/next-js/</id>
    <published>2017-10-20T01:21:29.000Z</published>
    <updated>2018-01-09T02:47:02.940Z</updated>
    
    <content type="html"><![CDATA[<p>NEXT十天训练营有关JS学习的笔记。<br><a id="more"></a></p>
<h2 id="认识JavaScript"><a href="#认识JavaScript" class="headerlink" title="认识JavaScript"></a>认识JavaScript</h2><p>JS是目前主流浏览器唯一支持的脚本语言，由以下三部分组成：</p>
<p>（1）ECMAScript:语言基础（核心）。</p>
<p>ECMA-262标准规定了ECMAScript这门语言的组成部分，例如语法、类型、语句、关键字、保留字、操作符、对象。</p>
<p>Web浏览器只是ECMAScript实现可能的宿主环境之一，其他宿主环境还包括Node(一种服务端JavaScript平台)和Adobe Flash。</p>
<p>（2）DOM（Document Object Model,文档对象模型）</p>
<p>通过DOM可以操作HTML元素，包括删除、添加、替换、修改节点等。DOM将整个HTML文档映射为一个多层节点结构，即DOM树。</p>
<p>（3）BOM（Browser Object Model,浏览器对象模型）</p>
<p>通过BOM获取一些浏览器的信息，以及控制浏览器的一些行为。</p>
<h2 id="引入JavaScript"><a href="#引入JavaScript" class="headerlink" title="引入JavaScript"></a>引入JavaScript</h2><p>有三种方式可以在HTML文档里引入JavaScript。</p>
<p>（1）行内方式。即直接在HTML元素的属性上应用js代码。</p>
<p>例如以下代码中button元素的onclick属性，点击button就会弹出消息框并显示“hello”。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot; onclick=&quot;alert(&apos;hello&apos;);&quot;&gt;点击弹出消息框&lt;/button&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>但这种方式不建议使用。一是因为这种方式针对一些用户的事件触发js执行，局限性较大。二是html文档中掺杂js代码会显得文档很乱，背离了结构应与样式、行为相分离的原则。</p>
<p>（2）内嵌方式。即通过一对<script></script>标签在html文档中插入js代码。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot; &gt;点击弹出消息框&lt;/button&gt;
    &lt;sript&gt;
        var helloBtn = documnet.getElementById(&quot;helloBtn&quot;);
        helloBtn.onclick = function() {
            alert(&quot;hello&quot;);
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>此种方式也有缺点。例如在不同页面使用上述<script></script>标签之间这段js代码时，即在不同页面使用同一段js代码会有冗余。根据场景判断是否使用该方式。</p>
<p>（3）外链方式。即将js代码从html文档中提取出来单独形成一个.js文件，并在html文档中引入这个.js文件。</p>
<p>例如将方法（2）中<script></script>标签之间这段js代码提取出来，保存在一个hello.js文件中，并在html文件中引入。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;/&gt;
    &lt;title&gt;JavaScript引入&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;button id=&quot;helloBtn&quot;&gt;点击弹出消息框&lt;/button&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;hello.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>根据场景判断是否使用该方式。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>（1）语法:</p>
<pre><code>var 变量名
</code></pre><p>变量名区分大小写，首字母必须是字母、下划线或者$，非关键字和保留字。<br>例如，<code>var name = &quot;bottle&quot;;</code></p>
<p>（2）全局变量和局部变量：</p>
<p>使用var定义的变量可能是全局变量也可能是局部变量，取决于是否在一个function中。如在function中使用var定义一个变量message，此变量即为一个局部变量。局部变量在function外面访问不到。若在function内不使用var定义变量message，则在函数外可以访问到该变量。</p>
<p>使用var定义</p>
<pre><code>function test() {
    var message = &quot;hi&quot;;//定义一个局部变量
}
test();
alert(message);//错误，找不到变量message
</code></pre><p>不使用var定义</p>
<pre><code>function test() {
    message = &quot;hi&quot;;//定义一个全局变量
}
test();
alert(message);//hi
</code></pre><p>使用控制台console来调试js代码。alert()弹出一个提示框。console.log()打印。</p>
<p>利用sources里面的snippets来观察变量。如下所示。</p>
<p><img src="/images/next-js/1.png" alt="1"></p>
<p>局部变量测试结果如下所示。</p>
<p><img src="/images/next-js/2.png" alt="2"></p>
<p><img src="/images/next-js/3.png" alt="3"></p>
<p>全局变量测试结果如下所示。</p>
<p><img src="/images/next-js/4.png" alt="4"></p>
<p><img src="/images/next-js/5.png" alt="5"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>1、基本数据类型</p>
<p>（1）字符串类型String</p>
<p>（2）数字类型Number</p>
<p>（3）布尔类型Boolean ,取值true或false</p>
<p>（4）Null</p>
<p>（5）Undefined</p>
<p>2、复杂数据类型/引用数据类型 Object</p>
<p><strong>怎样判断数据类型</strong></p>
<p>在浏览器控制台可使用type of 操作符来判断以下数据类型。</p>
<pre><code>typeof 1//&quot;number&quot;
typeof &apos;a&apos;//&quot;string&quot;
typeof true//&quot;boolean&quot;
typeof undefined//&quot;undefined&quot;
typeof null//&quot;object&quot; (这个比较特殊)
typeof {}//&quot;object&quot;
typeof function(){};//&quot;function&quot;
</code></pre><p>判断数据类型的几个例子如下。</p>
<p><img src="/images/next-js/6.png" alt="6"></p>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><p>1、创建对象</p>
<p>（1）使用对象字面量{}创建杯子对象。（推荐，简洁明了）</p>
<pre><code>var bottle = {
    name: &quot;bottle&quot;, //key: value
    price: 49, 
    isKeepWarm: true 
}
</code></pre><p>对象的每一个属性都可以用对应的键值对(key: value)来描述，其中key为任一合法字符，value为任意数据类型。如果属性名包含多个中间含空格的字符，要用引号包含起来。</p>
<p>（2）使用Object构造函数创建杯子对象。</p>
<pre><code>var bottle = new Object();
bottle.name = &quot;bottle&quot;;
bottle.price = 49;
bottle.isKeepWarm = true;
</code></pre><p>2、对象属性读操作</p>
<p>（1）使用点操作符 <code>console.log(bottle.name);//&quot;bottle&quot;</code>（推荐）</p>
<p>（2）使用中括号操作符 <code>console.log(bottle[&quot;name&quot;]);//&quot;bottle&quot;</code>（如果对象属性名即key包含空格时，必须使用中括号操作符）</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1、函数的定义</p>
<p>（1）函数声明</p>
<pre><code>function 函数名（参数1，参数2，...）{
    函数体
    return ;
}
</code></pre><p>函数声明的特点，在相同作用域下，不管在何处声明都可以调用的到。即使声明在调用之后。</p>
<p>（2）函数表达式</p>
<pre><code>var 变量 = function(参数1，参数2，...){
    函数体
    return ;
}
</code></pre><p>函数表达式的调用必须在函数表达式声明之后。这是区别于函数声明的地方。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><img src="/images/next-js/7.png" alt="7"></p>
<p>如上图所示，bottles是在函数之外声明的，是全局作用域的一个变量，所以在函数内部可以访问到bottles。而函数内部（函数作用域）声明的num为局部变量，只可以在函数内部被访问到，在函数外部无法获取。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>（1）if语句</p>
<pre><code>if(条件) {
    执行语句1;
}
else{
    执行语句2;
}
</code></pre><p>（2）switch语句</p>
<pre><code>swith(n){
    case 0: 执行语句1；
    case 1: 执行语句2;
    ...

}
</code></pre><h2 id="字符串的有关操作"><a href="#字符串的有关操作" class="headerlink" title="字符串的有关操作"></a>字符串的有关操作</h2><h3 id="分割字符串-split"><a href="#分割字符串-split" class="headerlink" title="分割字符串 split"></a>分割字符串 split</h3><p>split()方法可以把字符串分割为字符串数组。</p>
<pre><code>&quot;2:3:4:5&quot;.split(&quot;:&quot;)    // 将返回 [&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]

&quot;|a|b|c&quot;.split(&quot;|&quot;)    // 将返回 [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h3 id="截取字符串-substring"><a href="#截取字符串-substring" class="headerlink" title="截取字符串 substring"></a>截取字符串 substring</h3><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。语法：<code>str.substring(indexStart, [indexEnd])</code></p>
<pre><code>var str = &apos;Hello World!&apos;;
console.log(str.substring(3)); // 将返回 lo world!
</code></pre><h3 id="字符串转换大写-toUpperCase"><a href="#字符串转换大写-toUpperCase" class="headerlink" title="字符串转换大写 toUpperCase()"></a>字符串转换大写 toUpperCase()</h3><p>toUpperCase() 方法用于把字符串转换为大写。</p>
<pre><code>var str = &apos;Hello World!&apos;;
console.log(str.toUpperCase()); // 将返回 HELLO WORLD!
</code></pre><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>完善函数 convertToCamelCase 的功能。函数 convertToCamelCase 会转换传入的字符串参数 string 为驼峰格式，并返回转换后的字符串。具体要求如下：</p>
<ul>
<li><p>参数 string 是以中划线（-）连接单词的字符串，需将第二个起的非空单词首字母转为大写，如 -webkit-border-radius 转换后的结果为 webkitBorderRadius。</p>
</li>
<li><p>返回转换后的字符串</p>
</li>
</ul>
<p>解决方法：</p>
<pre><code>function convertToCamelCase(str){
    var strSplit = str.split(&quot;-&quot;);//转换为字符串数组
    if(strSplit[0] === &quot;&quot;){ //如果第一个字符串为空的话，左移删掉，否则的话不变
        strSplit.shift();
    }
    for(var i = 1; i &lt; strSplit.length; i++){
            var letter = strSplit[i].charAt(0);//取得字符串数组中每个字符串的首字母
            //使用replace方法将每个字符串的首写字母大写
            strSplit[i] = strSplit[i].replace(letter, function replace(letter){
                return letter.toUpperCase();
            });

    }  
    return strSplit.join(&quot;&quot;);//join方法串接起字符串
}
convertToCamelCase(&quot;-ni-hao-a&quot;);
</code></pre><p>还可以使用<strong>正则表达式</strong>的方法。</p>
<pre><code>function convertToCamelCase(str) {
  return str.replace(/\-[a-z]/g , function(a, b){
      return b == 0 ? a.replace(&apos;-&apos;,&apos;&apos;) : a.replace(&apos;-&apos;,&apos;&apos;).toUpperCase();
  });
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NEXT十天训练营有关JS学习的笔记。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>PS切图笔记from慕课网</title>
    <link href="http://yoursite.com/2017/10/18/PS%E5%88%87%E5%9B%BE%E7%AC%94%E8%AE%B0-ing/"/>
    <id>http://yoursite.com/2017/10/18/PS切图笔记-ing/</id>
    <published>2017-10-18T08:19:00.000Z</published>
    <updated>2018-01-09T02:47:02.935Z</updated>
    
    <content type="html"><![CDATA[<p>在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接<a href="http://www.imooc.com/learn/506" target="_blank" rel="external">前端工程师必备的PS技能——切图篇</a>。<br><a id="more"></a></p>
<h2 id="Photoshop界面设置"><a href="#Photoshop界面设置" class="headerlink" title="Photoshop界面设置"></a>Photoshop界面设置</h2><p>使用的photoshop版本为photoshop cc 2015。</p>
<h3 id="新建设置"><a href="#新建设置" class="headerlink" title="新建设置"></a>新建设置</h3><p>文件–&gt;新建–&gt;文档类型（自定）–&gt;宽度一般固定（1920像素）–&gt;高度一般不定(此时设为2000像素)–&gt;分辨率72像素/英寸–&gt;背景内容(透明)。</p>
<p>再点击“确定”即可生成一张新的界面。此时还可点击“存储预设为”将本次自定义设置预设，留作以后使用该设置参数时使用。参数设置即生成图片分别为下列两图所示。</p>
<p><img src="/images/PS切图笔记/1.png" alt="1"></p>
<p><img src="/images/PS切图笔记/2.png" alt="2"></p>
<p>不知道是不是我下载的破解版的原因，键盘在中文输入法状态下时，左侧导航栏的工具图标不显示提示名称，切换到英文输入状态时就会显示。。</p>
<h3 id="移动工具设置"><a href="#移动工具设置" class="headerlink" title="移动工具设置"></a>移动工具设置</h3><p>第一个工具图标为：移动工具，快捷键V。 如下图所示。</p>
<p><img src="/images/PS切图笔记/3.png" alt="3"></p>
<p>选择移动工具–不勾选自动选择–选择图层–按住ctrl+鼠标左键可以自由选择想要的图层，会在右侧图层显示信息栏为你筛选出当前鼠标左键选择的图层。如下图所示。</p>
<p><img src="/images/PS切图笔记/4.png" alt="4"></p>
<h3 id="视图设置"><a href="#视图设置" class="headerlink" title="视图设置"></a>视图设置</h3><p>勾选两个功能：（1）视图–&gt;显示–&gt;智能参考线  （2）视图–&gt;标尺<br>可以在窗口–&gt;库，颜色，路径，通道， 把这几个功能关掉。</p>
<p>窗口–&gt;历史记录，信息，图层，三个功能模块打开。</p>
<p>最后在右侧区域一共用到四个功能，即信息，字符，图层，历史纪录。见下图。</p>
<p><img src="/images/PS切图笔记/5.png" alt="5"></p>
<p>信息面板设置如下：</p>
<p><img src="/images/PS切图笔记/6.png" alt="6"></p>
<p>在编辑–&gt;首选项–&gt;单位与标尺，将单位改为像素。</p>
<h2 id="Photoshop基本操作"><a href="#Photoshop基本操作" class="headerlink" title="Photoshop基本操作"></a>Photoshop基本操作</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在慕课网学习的简单的关于PS切图的基本使用。下面是慕课网的视频学习链接&lt;a href=&quot;http://www.imooc.com/learn/506&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端工程师必备的PS技能——切图篇&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="PS" scheme="http://yoursite.com/categories/PS/"/>
    
    
      <category term="PS" scheme="http://yoursite.com/tags/PS/"/>
    
  </entry>
  
  <entry>
    <title>有默认margin，padding值的html标签</title>
    <link href="http://yoursite.com/2017/10/18/%E9%BB%98%E8%AE%A4margin%E5%80%BC%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2017/10/18/默认margin值元素/</id>
    <published>2017-10-18T05:00:44.000Z</published>
    <updated>2018-01-09T02:47:02.943Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。<br><a id="more"></a></p>
<h2 id="h1-h6标签"><a href="#h1-h6标签" class="headerlink" title="h1~h6标签"></a>h1~h6标签</h2><p>有默认margin（top,bottom且相同）值，没有默认padding值。</p>
<pre><code>在chrome中：16,15,14,16,17,19;

在firefox中：16,15,14,16,17,20;

在safari中：16,15,14,16,17,19;

在opera中：16,15,14,14,17,21;

在maxthon中：16,14,14,15,16,18;

在IE6.0中：都是19；

在IE7.0中：都是19；

在IE8.0中：16,15,14,16,17,19;
</code></pre><h2 id="dl标签"><a href="#dl标签" class="headerlink" title="dl标签"></a>dl标签</h2><p>有默认margin（top,bottom且相同）值，没有默认padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><p>dd标签有默认margin-left：40px;(在所有上述浏览器中)。</p>
<h2 id="ol-ul标签"><a href="#ol-ul标签" class="headerlink" title="ol,ul标签"></a>ol,ul标签</h2><p>有默认margin-（top,bottom且相同）值，有默认padding-left值</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><p>默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。</p>
<h2 id="th-td标签"><a href="#th-td标签" class="headerlink" title="th,td标签"></a>th,td标签</h2><p>th,td标签没有默认的margin值，有默认的padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon中：padding：1px;

在IE8.0中：padding：0px 1px 1px;

在IE7.0中：padding：0px 1px；
</code></pre><p>相同内容th的宽度要比td宽，因为th字体有加粗效果。</p>
<p><strong>注意 ：table标签没有默认的margin,padding值。</strong></p>
<h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><p>form标签在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中没有默认的margin,padding值，但在IE6.0,7.0中有默认的margin：19px 0px;</p>
<h2 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a>p标签</h2><p>p标签有默认margin(top,bottom)值,没有默认padding值。</p>
<pre><code>在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;

在IE6.0,7.0中：margin:19px 0px;
</code></pre><h2 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h2><p>textarea标签在上述所有浏览器中：margin:2px；padding:2px；</p>
<h2 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h2><p>select标签在Chrome,Safari,Maxthon中有默认的margin：2px；在Opera,Firefox,IE6.0,7.0,8.0没有默认的margin值。</p>
<h2 id="option标签"><a href="#option标签" class="headerlink" title="option标签"></a>option标签</h2><p>option标签只有在firefox中有默认的padding-left：3px；</p>
<h2 id="CSS-reset"><a href="#CSS-reset" class="headerlink" title="CSS reset"></a>CSS reset</h2><pre><code>/*CSS style init*/
body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,option,textarea,form,th,td{margin: 0; padding: 0;}
body{font:14px/1.5 &quot;宋体&quot;;}
img{border:none;}
li{list-style:none;}
input,select,textarea{outline:none;border:none;background:none;}
textarea{resize:none;}
a{text-decoration:none;}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下那些有默认margin及padding值的html标签，在CSS reset时，最好将这些元素的padding和margin值初始化为0，以实现不同浏览器下的样式兼容，避免后期团队开发过程因不同浏览器下默认样式不同而造成混乱。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>CSS清除浮动的几种方法</title>
    <link href="http://yoursite.com/2017/10/17/clearfix/"/>
    <id>http://yoursite.com/2017/10/17/clearfix/</id>
    <published>2017-10-17T08:09:35.000Z</published>
    <updated>2018-01-09T02:47:02.937Z</updated>
    
    <content type="html"><![CDATA[<p>几种定位方式，以及CSS清除浮动的几种方法。<br><a id="more"></a></p>
<h1 id="几种定位方式"><a href="#几种定位方式" class="headerlink" title="几种定位方式"></a>几种定位方式</h1><h2 id="普通流定位-static"><a href="#普通流定位-static" class="headerlink" title="普通流定位 static"></a>普通流定位 static</h2><p>普通流定位即文档流定位，是页面元素的默认定位方式。按照元素在文档流中的出现顺序以默认形式呈现元素。</p>
<pre><code>页面中的块级元素：按照从上到下的方式逐个排列 。
页面中的行内元素：按照从左到右的方式逐个排列 。
</code></pre><p>此时考虑如何让多个块级元素显示在一行，就引出了浮动的概念。</p>
<h2 id="浮动定位-float"><a href="#浮动定位-float" class="headerlink" title="浮动定位 float"></a>浮动定位 float</h2><p>float属性取值为 left/right。这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕。</p>
<h2 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 relative"></a>相对定位 relative</h2><p>元素会相对于它原来的位置偏移某个距离。<strong>使元素偏离原来位置后，元素原本的空间依然会被保留</strong>。</p>
<pre><code>语法
属性：position
取值：relative
再配合 偏移属性top/right/bottom/left实现位置改变
</code></pre><h2 id="绝对定位-absolute"><a href="#绝对定位-absolute" class="headerlink" title="绝对定位 absolute"></a>绝对定位 absolute</h2><p>若元素被设置为绝对定位，具备以下几个特征：</p>
<pre><code>1、脱离文档流-不占据页面空间
2、通过偏移属性固定元素位置
3、相对于 最近的已定位的祖先元素实现位置固定
4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定 
语法
属性：position
取值：absolute
再配合 偏移属性(top/right/bottom/left)实现位置的固定
</code></pre><h2 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 fixed"></a>固定定位 fixed</h2><p>将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动。</p>
<pre><code>语法
属性：position
取值：fixed
配合着 偏移属性(top/right/bottom/left)实现位置的固定
</code></pre><h1 id="浮动的效果"><a href="#浮动的效果" class="headerlink" title="浮动的效果"></a>浮动的效果</h1><pre><code>1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位
2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动)
3、浮动元素依然位于父元素之内
4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 
注意
1、一行内，显示不下所有的已浮动元素时，最后一个将换行
2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定)
3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大（块级元素：允许修改尺寸；行内元素：不允许修改尺寸 ） 
4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素
</code></pre><p>浮动的影响：由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）。</p>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>直接设置父元素的高度。<br>优势：极其简单；<br>弊端：必须要知道父元素高度是多少</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>在父元素中，追加空子元素，并设置其clear属性为both。clear是css中专用于清除浮动的属性。<br>作用：清除当前元素前面的元素浮动所带来的影响</p>
<pre><code>取值：
1、none
默认值，不做任何清除浮动的操作
2、left
清除前面元素左浮动带来的影响
3、right
清除前面元素右浮动带来的影响
4、both
清除前面元素所有浮动带来的影响
</code></pre><p>优势：代码量少 容易掌握 简单易懂<br>弊端：会添加许多无意义的空标签，有违结构与表现的分离，不便于后期的维护</p>
<h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p>设置父元素浮动。</p>
<p>优势：简单，代码量少，没有结构和语义化问题；<br>弊端：对后续元素会有影响 </p>
<h2 id="方法4"><a href="#方法4" class="headerlink" title="方法4"></a>方法4</h2><p>为父元素设置overflow属性。</p>
<pre><code>取值：hidden 或 auto
</code></pre><p>优势：简单，代码量少<br>弊端：如果有内容要溢出显示(弹出菜单)，也会被一同隐藏</p>
<h2 id="方法5"><a href="#方法5" class="headerlink" title="方法5"></a>方法5</h2><p>父元素设置display:table.</p>
<p>优势：不影响结构与表现的分离，语义化正确，代码量少；<br>弊端：盒模型属性已经改变，会造成其他问题</p>
<h2 id="方法6"><a href="#方法6" class="headerlink" title="方法6"></a>方法6</h2><p>使用内容生成的方式清除浮动。</p>
<pre><code>.clearfix:after {
    content:&quot;&quot;;
    display:block;
    clear:both;
}
</code></pre><p>:after 选择器向选定的元素之后插入内容 </p>
<pre><code>content:&quot;&quot;; 生成内容为空
display: block; 生成的元素以块级元素显示,
clear:both; 清除前面元素浮动带来的影响
</code></pre><p>相对于空标签闭合浮动的方法，<br>优势：不破坏文档结构，没有副作用；<br>弊端：代码量多</p>
<h2 id="方法7"><a href="#方法7" class="headerlink" title="方法7"></a>方法7</h2><pre><code>.cf:before,.cf:after {
   content:&quot;&quot;;
   display:table;
}
.cf:after { clear:both; }
</code></pre><p>优势：不破坏文档结构，没有副作用；<br>弊端： 代码量多 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几种定位方式，以及CSS清除浮动的几种方法。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
</feed>
